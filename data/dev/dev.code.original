public void add ( double x , double y ) { data . add ( x ) ; data . add ( y ) ; minx = Math . min ( minx , x ) ; maxx = Math . max ( maxx , x ) ; miny = Math . min ( miny , y ) ; maxy = Math . max ( maxy , y ) ; }
public void handleTblBootstrapResOffButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SMDiscoveryBootstrapRefOffAddViewBean vb = ( SMDiscoveryBootstrapRefOffAddViewBean ) getViewBean ( SMDiscoveryBootstrapRefOffAddViewBean . class ) ; removePageSessionAttribute ( SMDiscoveryBootstrapRefOffAddViewBean . PROPERTY_ATTRIBUTE ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STRING , e . getMessage ( ) ) ; } }
public void handleTblBootstrapResOffButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; SMDiscoveryBootstrapRefOffAddViewBean vb = ( SMDiscoveryBootstrapRefOffAddViewBean ) getViewBean ( SMDiscoveryBootstrapRefOffAddViewBean . class ) ; removePageSessionAttribute ( SMDiscoveryBootstrapRefOffAddViewBean . PROPERTY_ATTRIBUTE ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STRING , e . getMessage ( ) ) ; } }
public static double volumeUnion ( SpatialComparable box1 , SpatialComparable box2 ) { final int dim = assertSameDimensionality ( box1 , box2 ) ; double volume = _NUM ; for ( int i = _NUM ; i < dim ; i ++ ) { final double min = Math . min ( box1 . getMin ( i ) , box2 . getMin ( i ) ) ; final double max = Math . max ( box1 . getMax ( i ) , box2 . getMax ( i ) ) ; volume *= ( max - min ) ; } return volume ; }
public void testSetDate_int_Date ( ) throws SQLException { Calendar cal = new GregorianCalendar ( _NUM , _NUM , _NUM ) ; Date [ ] dates = { new Date ( cal . getTimeInMillis ( ) ) , new Date ( Integer . MAX_VALUE ) , new Date ( _NUM ) } ; PreparedStatement ps = null ; PreparedStatement ps1 = null ; try { String query = STRING ; ps = conn . prepareStatement ( query ) ; for ( int i = _NUM ; i < dates . length ; i ++ ) { ps . setDate ( _NUM , dates [ i ] ) ; assertFalse ( ps . execute ( ) ) ; assertTrue ( ps . getUpdateCount ( ) > _NUM ) ; } try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { } String query1 = STRING ; ps1 = conn . prepareStatement ( query1 ) ; try { ps1 . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { assertEquals ( STRING , sqle . getMessage ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch ( SQLException ee ) { } } }
public void testSetDate_int_Date ( ) throws SQLException { Calendar cal = new GregorianCalendar ( _NUM , _NUM , _NUM ) ; Date [ ] dates = { new Date ( cal . getTimeInMillis ( ) ) , new Date ( Integer . MAX_VALUE ) , new Date ( _NUM ) } ; PreparedStatement ps = null ; PreparedStatement ps1 = null ; try { String query = STRING ; ps = conn . prepareStatement ( query ) ; for ( int i = _NUM ; i < dates . length ; i ++ ) { ps . setDate ( _NUM , dates [ i ] ) ; assertFalse ( ps . execute ( ) ) ; assertTrue ( ps . getUpdateCount ( ) > _NUM ) ; } try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { } String query1 = STRING ; ps1 = conn . prepareStatement ( query1 ) ; try { ps1 . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { assertEquals ( STRING , sqle . getMessage ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch ( SQLException ee ) { } } }
public void testSetDate_int_Date ( ) throws SQLException { Calendar cal = new GregorianCalendar ( _NUM , _NUM , _NUM ) ; Date [ ] dates = { new Date ( cal . getTimeInMillis ( ) ) , new Date ( Integer . MAX_VALUE ) , new Date ( _NUM ) } ; PreparedStatement ps = null ; PreparedStatement ps1 = null ; try { String query = STRING ; ps = conn . prepareStatement ( query ) ; for ( int i = _NUM ; i < dates . length ; i ++ ) { ps . setDate ( _NUM , dates [ i ] ) ; assertFalse ( ps . execute ( ) ) ; assertTrue ( ps . getUpdateCount ( ) > _NUM ) ; } try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { } String query1 = STRING ; ps1 = conn . prepareStatement ( query1 ) ; try { ps1 . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { assertEquals ( STRING , sqle . getMessage ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch ( SQLException ee ) { } } }
public void testSetDate_int_Date ( ) throws SQLException { Calendar cal = new GregorianCalendar ( _NUM , _NUM , _NUM ) ; Date [ ] dates = { new Date ( cal . getTimeInMillis ( ) ) , new Date ( Integer . MAX_VALUE ) , new Date ( _NUM ) } ; PreparedStatement ps = null ; PreparedStatement ps1 = null ; try { String query = STRING ; ps = conn . prepareStatement ( query ) ; for ( int i = _NUM ; i < dates . length ; i ++ ) { ps . setDate ( _NUM , dates [ i ] ) ; assertFalse ( ps . execute ( ) ) ; assertTrue ( ps . getUpdateCount ( ) > _NUM ) ; } try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { } String query1 = STRING ; ps1 = conn . prepareStatement ( query1 ) ; try { ps1 . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { assertEquals ( STRING , sqle . getMessage ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch ( SQLException ee ) { } } }
public void testSetDate_int_Date ( ) throws SQLException { Calendar cal = new GregorianCalendar ( _NUM , _NUM , _NUM ) ; Date [ ] dates = { new Date ( cal . getTimeInMillis ( ) ) , new Date ( Integer . MAX_VALUE ) , new Date ( _NUM ) } ; PreparedStatement ps = null ; PreparedStatement ps1 = null ; try { String query = STRING ; ps = conn . prepareStatement ( query ) ; for ( int i = _NUM ; i < dates . length ; i ++ ) { ps . setDate ( _NUM , dates [ i ] ) ; assertFalse ( ps . execute ( ) ) ; assertTrue ( ps . getUpdateCount ( ) > _NUM ) ; } try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( Exception sqle ) { } ps . close ( ) ; try { ps . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { } String query1 = STRING ; ps1 = conn . prepareStatement ( query1 ) ; try { ps1 . setDate ( _NUM , dates [ _NUM ] ) ; fail ( STRING ) ; } catch ( SQLException sqle ) { assertEquals ( STRING , sqle . getMessage ( ) ) ; } } finally { try { if ( ps != null ) ps . close ( ) ; if ( ps1 != null ) ps1 . close ( ) ; } catch ( SQLException ee ) { } } }
public boolean containsBafBody ( ) { Iterator < SootMethod > methodIt = methodIterator ( ) ; while ( methodIt . hasNext ( ) ) { SootMethod m = methodIt . next ( ) ; if ( m . hasActiveBody ( ) && m . getActiveBody ( ) instanceof soot . baf . BafBody ) { return _BOOL ; } } return _BOOL ; }
public boolean containsBafBody ( ) { Iterator < SootMethod > methodIt = methodIterator ( ) ; while ( methodIt . hasNext ( ) ) { SootMethod m = methodIt . next ( ) ; if ( m . hasActiveBody ( ) && m . getActiveBody ( ) instanceof soot . baf . BafBody ) { return _BOOL ; } } return _BOOL ; }
private Socket connect ( String host , String portString ) throws IOException { int port = _NUM ; Socket sock = null ; boolean DEBUG = Debug . debugging ( STRING ) ; try { port = Integer . parseInt ( portString , _NUM ) ; } catch ( NumberFormatException e ) { if ( DEBUG ) Debug . output ( STRING + host + STRING + portString ) ; throw new IOException ( STRING + portString ) ; } if ( DEBUG ) Debug . output ( STRING + host + STRING + port ) ; try { sock = new Socket ( host , port ) ; } catch ( IOException e ) { if ( sock != null ) sock . close ( ) ; if ( DEBUG ) { Debug . output ( STRING + host + STRING + port + STRING + e ) ; } throw e ; } return sock ; }
private Socket connect ( String host , String portString ) throws IOException { int port = _NUM ; Socket sock = null ; boolean DEBUG = Debug . debugging ( STRING ) ; try { port = Integer . parseInt ( portString , _NUM ) ; } catch ( NumberFormatException e ) { if ( DEBUG ) Debug . output ( STRING + host + STRING + portString ) ; throw new IOException ( STRING + portString ) ; } if ( DEBUG ) Debug . output ( STRING + host + STRING + port ) ; try { sock = new Socket ( host , port ) ; } catch ( IOException e ) { if ( sock != null ) sock . close ( ) ; if ( DEBUG ) { Debug . output ( STRING + host + STRING + port + STRING + e ) ; } throw e ; } return sock ; }
public void removeCancelListener ( ActionListener a ) { m_cancelBut . removeActionListener ( a ) ; }
public void addPrimer ( String moduleFilename , String extendedModuleName ) { tlaBuffer . append ( ResourceHelper . getExtendingModuleContent ( moduleFilename , extendedModuleName ) ) ; }
public void addPrimer ( String moduleFilename , String extendedModuleName ) { tlaBuffer . append ( ResourceHelper . getExtendingModuleContent ( moduleFilename , extendedModuleName ) ) ; }
protected void validateState ( State current ) { ValidationUtils . validateState ( current ) ; checkNotNull ( current . executionState , STRING ) ; checkIsPositiveNumber ( current . triggersSuccess , STRING ) ; checkIsPositiveNumber ( current . triggersError , STRING ) ; }
public static String findEditTable ( String tables ) { if ( ! StringUtils . isEmpty ( tables ) ) { int spacepos = tables . indexOf ( STRING ) ; int commapos = tables . indexOf ( STRING ) ; if ( spacepos > _NUM && ( spacepos < commapos || commapos < _NUM ) ) { return tables . substring ( _NUM , spacepos ) ; } else if ( commapos > _NUM && ( commapos < spacepos || spacepos < _NUM ) ) { return tables . substring ( _NUM , commapos ) ; } return tables ; } else { throw new IllegalStateException ( STRING ) ; } }
private void writeObject ( java . io . ObjectOutputStream oos ) throws java . io . IOException { synchronized ( principals ) { oos . defaultWriteObject ( ) ; } }
private void writeObject ( java . io . ObjectOutputStream oos ) throws java . io . IOException { synchronized ( principals ) { oos . defaultWriteObject ( ) ; } }
public void addQueryExecuteListener ( QueryExecuteListener l ) { m_QueryExecuteListeners . add ( l ) ; }
public static Request newStatusUpdateRequest ( Session session , String message , GraphPlace place , List < GraphUser > tags , Callback callback ) { List < String > tagIds = null ; if ( tags != null ) { tagIds = new ArrayList < String > ( tags . size ( ) ) ; for ( GraphUser tag : tags ) { tagIds . add ( tag . getId ( ) ) ; } } String placeId = place == null ? null : place . getId ( ) ; return newStatusUpdateRequest ( session , message , placeId , tagIds , callback ) ; }
public static Request newStatusUpdateRequest ( Session session , String message , GraphPlace place , List < GraphUser > tags , Callback callback ) { List < String > tagIds = null ; if ( tags != null ) { tagIds = new ArrayList < String > ( tags . size ( ) ) ; for ( GraphUser tag : tags ) { tagIds . add ( tag . getId ( ) ) ; } } String placeId = place == null ? null : place . getId ( ) ; return newStatusUpdateRequest ( session , message , placeId , tagIds , callback ) ; }
public static Request newStatusUpdateRequest ( Session session , String message , GraphPlace place , List < GraphUser > tags , Callback callback ) { List < String > tagIds = null ; if ( tags != null ) { tagIds = new ArrayList < String > ( tags . size ( ) ) ; for ( GraphUser tag : tags ) { tagIds . add ( tag . getId ( ) ) ; } } String placeId = place == null ? null : place . getId ( ) ; return newStatusUpdateRequest ( session , message , placeId , tagIds , callback ) ; }
public boolean equals ( Object object ) { if ( this == object ) { return _BOOL ; } else if ( object instanceof Namespace ) { Namespace that = ( Namespace ) object ; if ( hashCode ( ) == that . hashCode ( ) ) { return uri . equals ( that . getURI ( ) ) && prefix . equals ( that . getPrefix ( ) ) ; } } return _BOOL ; }
private static Path2D createTopTabShape ( int x , int y , int w , int h , double rTop , boolean addBottom ) { Path2D path = new Path2D . Double ( ) ; path . append ( new Line2D . Double ( x , y + h - _NUM , x , y + rTop ) , _BOOL ) ; QuadCurve2D curve = new QuadCurve2D . Double ( x , y + rTop , x , y , x + rTop , y ) ; path . append ( curve , _BOOL ) ; path . append ( new Line2D . Double ( x + rTop , y , x + w - rTop , y ) , _BOOL ) ; curve = new QuadCurve2D . Double ( x + w - rTop , y , x + w , y , x + w , y + rTop ) ; path . append ( curve , _BOOL ) ; path . append ( new Line2D . Double ( x + w , y + rTop , x + w , y + h ) , _BOOL ) ; if ( addBottom ) { path . append ( new Line2D . Double ( x + w , y + h - _NUM , x , y + h - _NUM ) , _BOOL ) ; } return path ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
void resize ( int newCapacity ) { Entry [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { threshold = Integer . MAX_VALUE ; return ; } Entry [ ] newTable = new Entry [ newCapacity ] ; transfer ( newTable ) ; table = newTable ; threshold = ( int ) ( newCapacity * loadFactor ) ; }
public static float parseFloat ( String s ) { if ( POSITIVE_INFINITY . equals ( s ) ) { return Float . POSITIVE_INFINITY ; } else if ( NEGATIVE_INFINITY . equals ( s ) ) { return Float . NEGATIVE_INFINITY ; } else if ( NaN . equals ( s ) ) { return Float . NaN ; } else { s = trimPlusSign ( s ) ; return Float . parseFloat ( s ) ; } }
public void fillPolygon ( Polygon p ) { g . fillPolygon ( p ) ; }
public void addServer ( ServerOpenssl server ) { _serverList . add ( server ) ; }
private boolean renderOutput ( Node node , InternalContextAdapter context , Writer writer ) throws IOException , MethodInvocationException , ResourceNotFoundException { String arg = STRING ; if ( node == null ) { rsvc . error ( STRING ) ; return _BOOL ; } Object value = node . value ( context ) ; if ( value == null ) { rsvc . error ( STRING ) ; return _BOOL ; } arg = value . toString ( ) ; Resource resource = null ; try { resource = rsvc . getContent ( arg , getInputEncoding ( context ) ) ; } catch ( ResourceNotFoundException rnfe ) { rsvc . error ( STRING + arg + STRING + context . getCurrentTemplateName ( ) + STRING + getLine ( ) + STRING + getColumn ( ) + STRING ) ; throw rnfe ; } catch ( Exception e ) { rsvc . error ( STRING + arg + STRING + context . getCurrentTemplateName ( ) + STRING + getLine ( ) + STRING + getColumn ( ) + STRING + e ) ; } if ( resource == null ) return _BOOL ; writer . write ( ( String ) resource . getData ( ) ) ; return _BOOL ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
@ SuppressWarnings ( STRING ) private Class validateClass ( ClientConfig cfg ) { Class clazz = null ; try { clazz = Class . forName ( cfg . getAccessRequestHandlerClassname ( ) ) ; } catch ( final ClassNotFoundException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } Object inst = null ; try { inst = InjectorHolder . getInstance ( clazz ) ; } catch ( ConfigurationException | ProvisionException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } AccessRequestHandler handler = null ; try { handler = ( AccessRequestHandler ) inst ; } catch ( final ClassCastException e ) { LOG . error ( STRING + cfg . getAccessRequestHandlerClassname ( ) + STRING + cfg . getName ( ) + STRING , e ) ; return null ; } return clazz ; }
public ZipEntry ( String name ) { if ( name == null ) { throw new NullPointerException ( ) ; } if ( name . length ( ) > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } this . name = name ; }
public void train ( Map CategoryValues , String sSuggestedCategory , String sFinalCategory ) { if ( CategoryValues == null ) CategoryValues = new HashMap ( ) ; if ( CategoryValues . size ( ) > _NUM ) vPreviousDecisions . add ( new DecisionSupport ( CategoryValues , sSuggestedCategory , sFinalCategory ) ) ; }
public void train ( Map CategoryValues , String sSuggestedCategory , String sFinalCategory ) { if ( CategoryValues == null ) CategoryValues = new HashMap ( ) ; if ( CategoryValues . size ( ) > _NUM ) vPreviousDecisions . add ( new DecisionSupport ( CategoryValues , sSuggestedCategory , sFinalCategory ) ) ; }
@ Override protected void forceInsertAttributeAt ( int position ) { int index = locateIndex ( position ) ; m_NumAttributes ++ ; if ( ( index >= _NUM ) && ( m_Indices [ index ] == position ) ) { int [ ] tempIndices = new int [ m_Indices . length + _NUM ] ; System . arraycopy ( m_Indices , _NUM , tempIndices , _NUM , index ) ; tempIndices [ index ] = position ; for ( int i = index ; i < m_Indices . length ; i ++ ) { tempIndices [ i + _NUM ] = m_Indices [ i ] + _NUM ; } m_Indices = tempIndices ; } else { int [ ] tempIndices = new int [ m_Indices . length + _NUM ] ; System . arraycopy ( m_Indices , _NUM , tempIndices , _NUM , index + _NUM ) ; tempIndices [ index + _NUM ] = position ; for ( int i = index + _NUM ; i < m_Indices . length ; i ++ ) { tempIndices [ i + _NUM ] = m_Indices [ i ] + _NUM ; } m_Indices = tempIndices ; } }
@ Override protected void forceInsertAttributeAt ( int position ) { int index = locateIndex ( position ) ; m_NumAttributes ++ ; if ( ( index >= _NUM ) && ( m_Indices [ index ] == position ) ) { int [ ] tempIndices = new int [ m_Indices . length + _NUM ] ; System . arraycopy ( m_Indices , _NUM , tempIndices , _NUM , index ) ; tempIndices [ index ] = position ; for ( int i = index ; i < m_Indices . length ; i ++ ) { tempIndices [ i + _NUM ] = m_Indices [ i ] + _NUM ; } m_Indices = tempIndices ; } else { int [ ] tempIndices = new int [ m_Indices . length + _NUM ] ; System . arraycopy ( m_Indices , _NUM , tempIndices , _NUM , index + _NUM ) ; tempIndices [ index + _NUM ] = position ; for ( int i = index + _NUM ; i < m_Indices . length ; i ++ ) { tempIndices [ i + _NUM ] = m_Indices [ i ] + _NUM ; } m_Indices = tempIndices ; } }
public static boolean canBeRandomized ( Class clazz ) { return ClassUtils . isPrimitiveOrWrapper ( clazz ) || clazz . equals ( String . class ) || clazz . equals ( IDiscordClient . class ) ; }
public void onStart ( String srcFile , String targetFile , long totalBytes ) ;
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STRING ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignore ) { } } return baos . toByteArray ( ) ; }
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STRING ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignore ) { } } return baos . toByteArray ( ) ; }
public void testDatabaseDriverPropertiesUserAndPasswordPropertyOverrideDSUserAndPassword ( ) { String driverPropertyString = STRING ; Properties props = new Properties ( ) ; props . setProperty ( DatasourcePropertySet . USERNAME , STRING ) ; props . setProperty ( DatasourcePropertySet . PASSWORD , STRING ) ; props . setProperty ( DatasourcePropertySet . CONNECTION_PROPERTIES , driverPropertyString ) ; DataSource ds = dataSourceConverter . fromProperties ( props ) ; assertEquals ( STRING , ds . getUsername ( ) ) ; assertEquals ( STRING , ds . getPassword ( ) ) ; }
public static String toString ( URL url , Charset encoding ) throws IOException { InputStream inputStream = url . openStream ( ) ; try { return toString ( inputStream , encoding ) ; } finally { inputStream . close ( ) ; } }
public static String toString ( URL url , Charset encoding ) throws IOException { InputStream inputStream = url . openStream ( ) ; try { return toString ( inputStream , encoding ) ; } finally { inputStream . close ( ) ; } }
boolean pageScroll ( int direction ) { int nextPage = - _NUM ; boolean down = _BOOL ; if ( direction == FOCUS_UP ) { nextPage = Math . max ( _NUM , mSelectedPosition - getChildCount ( ) - _NUM ) ; } else if ( direction == FOCUS_DOWN ) { nextPage = Math . min ( mItemCount - _NUM , mSelectedPosition + getChildCount ( ) - _NUM ) ; down = _BOOL ; } if ( nextPage >= _NUM ) { int position = lookForSelectablePosition ( nextPage , down ) ; if ( position >= _NUM ) { mLayoutMode = LAYOUT_SPECIFIC ; mSpecificLeft = getPaddingLeft ( ) + getHorizontalFadingEdgeLength ( ) ; if ( down && position > mItemCount - getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_RIGHT ; } if ( ! down && position < getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_LEFT ; } setSelectionInt ( position ) ; invokeOnItemScrollListener ( ) ; if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } return _BOOL ; } } return _BOOL ; }
boolean pageScroll ( int direction ) { int nextPage = - _NUM ; boolean down = _BOOL ; if ( direction == FOCUS_UP ) { nextPage = Math . max ( _NUM , mSelectedPosition - getChildCount ( ) - _NUM ) ; } else if ( direction == FOCUS_DOWN ) { nextPage = Math . min ( mItemCount - _NUM , mSelectedPosition + getChildCount ( ) - _NUM ) ; down = _BOOL ; } if ( nextPage >= _NUM ) { int position = lookForSelectablePosition ( nextPage , down ) ; if ( position >= _NUM ) { mLayoutMode = LAYOUT_SPECIFIC ; mSpecificLeft = getPaddingLeft ( ) + getHorizontalFadingEdgeLength ( ) ; if ( down && position > mItemCount - getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_RIGHT ; } if ( ! down && position < getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_LEFT ; } setSelectionInt ( position ) ; invokeOnItemScrollListener ( ) ; if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } return _BOOL ; } } return _BOOL ; }
boolean pageScroll ( int direction ) { int nextPage = - _NUM ; boolean down = _BOOL ; if ( direction == FOCUS_UP ) { nextPage = Math . max ( _NUM , mSelectedPosition - getChildCount ( ) - _NUM ) ; } else if ( direction == FOCUS_DOWN ) { nextPage = Math . min ( mItemCount - _NUM , mSelectedPosition + getChildCount ( ) - _NUM ) ; down = _BOOL ; } if ( nextPage >= _NUM ) { int position = lookForSelectablePosition ( nextPage , down ) ; if ( position >= _NUM ) { mLayoutMode = LAYOUT_SPECIFIC ; mSpecificLeft = getPaddingLeft ( ) + getHorizontalFadingEdgeLength ( ) ; if ( down && position > mItemCount - getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_RIGHT ; } if ( ! down && position < getChildCount ( ) ) { mLayoutMode = LAYOUT_FORCE_LEFT ; } setSelectionInt ( position ) ; invokeOnItemScrollListener ( ) ; if ( ! awakenScrollBars ( ) ) { invalidate ( ) ; } return _BOOL ; } } return _BOOL ; }
public boolean matches ( InventoryCrafting crafting , World world ) { final List < ItemStack > recipeList = new ArrayList < ItemStack > ( this . recipeItems ) ; for ( int i = _NUM ; i < _NUM ; ++ i ) { for ( int j = _NUM ; j < _NUM ; ++ j ) { final ItemStack actual = crafting . getStackInRowAndColumn ( j , i ) ; if ( actual != null ) { boolean flag = _BOOL ; final Iterator < ItemStack > iterator = recipeList . iterator ( ) ; while ( iterator . hasNext ( ) ) { final ItemStack expected = iterator . next ( ) ; if ( comparator . equals ( expected , actual ) ) { flag = _BOOL ; recipeList . remove ( expected ) ; break ; } } if ( ! flag ) { return _BOOL ; } } } } return recipeList . isEmpty ( ) ; }
public UpdateLogEntry addFile ( JsonValue file ) { files . add ( file ) ; return this ; }
public Analyzer add ( String name , NondominatedPopulation result ) { List < NondominatedPopulation > list = data . get ( name ) ; if ( list == null ) { list = new ArrayList < NondominatedPopulation > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public Analyzer add ( String name , NondominatedPopulation result ) { List < NondominatedPopulation > list = data . get ( name ) ; if ( list == null ) { list = new ArrayList < NondominatedPopulation > ( ) ; data . put ( name , list ) ; } list . add ( result ) ; return this ; }
public void adjustZoomFromMouseWheel ( int rot ) { Projection projection = getProjection ( ) ; if ( projection == null ) { return ; } setUserHasChangedScale ( _BOOL ) ; Point2D minutesPnt0 = projection . inverse ( _NUM , _NUM ) ; Point2D minutesPnt1 = projection . inverse ( _NUM , _NUM ) ; double minutesPerPixel = minutesPnt1 . getX ( ) - minutesPnt0 . getX ( ) ; double minSelectionWidthMinutes = minutesPerPixel * sliderPointHalfWidth * _NUM ; double selectionWidthPixels = selectionWidthMinutes / minutesPerPixel ; double multiplier = selectionWidthPixels / _NUM ; selectionWidthMinutes += rot * minutesPerPixel * multiplier ; if ( selectionWidthMinutes < minSelectionWidthMinutes ) { selectionWidthMinutes = minSelectionWidthMinutes ; } if ( selectionWidthMinutes > maxSelectionWidthMinutes ) { selectionWidthMinutes = maxSelectionWidthMinutes ; } updateTimeline ( ) ; doPrepare ( ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
@ Override public void addRelations ( Task task , Iterable < ObjectId > projectIds , String fieldName ) { List < Project > newProjectList = new LinkedList < > ( ) ; Iterable < Project > projectsToAdd = projectRepository . findAll ( projectIds , null ) ; projectsToAdd . forEach ( null ) ; try { if ( PropertyUtils . getProperty ( task , fieldName ) != null ) { Iterable < Project > projects = ( Iterable < Project > ) PropertyUtils . getProperty ( task , fieldName ) ; projects . forEach ( null ) ; } } catch ( Exception e ) { throw new RuntimeException ( e ) ; } try { PropertyUtils . setProperty ( task , fieldName , newProjectList ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } taskRepository . save ( task ) ; }
public synchronized byte [ ] toByteArray ( ) { int remaining = count ; if ( remaining == _NUM ) { return EMPTY_BYTE_ARRAY ; } byte newbuf [ ] = new byte [ remaining ] ; int pos = _NUM ; for ( byte [ ] buf : buffers ) { int c = Math . min ( buf . length , remaining ) ; System . arraycopy ( buf , _NUM , newbuf , pos , c ) ; pos += c ; remaining -= c ; if ( remaining == _NUM ) { break ; } } return newbuf ; }
public double calculateValue ( double log ) { return Math . pow ( this . base , log ) ; }
@ Override public void writeEntityRef ( String name ) throws XMLStreamException { throw new UnsupportedOperationException ( STRING ) ; }
@ Override public void writeEntityRef ( String name ) throws XMLStreamException { throw new UnsupportedOperationException ( STRING ) ; }
@ Override public void writeEntityRef ( String name ) throws XMLStreamException { throw new UnsupportedOperationException ( STRING ) ; }
@ Override public void writeEntityRef ( String name ) throws XMLStreamException { throw new UnsupportedOperationException ( STRING ) ; }
private DefaultMutableTreeNode iparent ( int AD_Client_ID , int M_Product_ID , int PP_Product_BOM_ID ) { DefaultMutableTreeNode parent = new DefaultMutableTreeNode ( Integer . toString ( M_Product_ID ) + STRING + Integer . toString ( PP_Product_BOM_ID ) ) ; String sql = STRING + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , m_trxName ) ; DB . setParameters ( pstmt , new Object [ ] { _BOOL , AD_Client_ID , M_Product_ID } ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { if ( rs . getRow ( ) > _NUM ) { tableproduct . clear ( ) ; tableproduct . put ( M_Product_ID , PP_Product_BOM_ID ) ; } DefaultMutableTreeNode bom = icomponent ( AD_Client_ID , rs . getInt ( _NUM ) , M_Product_ID , parent ) ; if ( bom != null ) { parent . add ( bom ) ; } } } catch ( SQLException e ) { throw new DBException ( e , sql ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } return parent ; }
public void flush ( ) { if ( ps != null ) { if ( lineBuffer . length ( ) != _NUM ) { flushLine ( _BOOL ) ; } ps . flush ( ) ; } }
@ SuppressLint ( STRING ) public static String saveMediaIntoDownloads ( Context context , File srcFile , String filename , String mimeType ) { String fullFilePath = saveFileInto ( srcFile , Environment . DIRECTORY_DOWNLOADS , filename ) ; if ( android . os . Build . VERSION . SDK_INT >= Build . VERSION_CODES . HONEYCOMB ) { if ( null != fullFilePath ) { DownloadManager downloadManager = ( DownloadManager ) context . getSystemService ( Context . DOWNLOAD_SERVICE ) ; try { File file = new File ( fullFilePath ) ; downloadManager . addCompletedDownload ( file . getName ( ) , file . getName ( ) , _BOOL , mimeType , file . getAbsolutePath ( ) , file . length ( ) , _BOOL ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } } } return fullFilePath ; }
public void calcWelzl ( FloatBuffer points ) { if ( center == null ) { center = new Vector3f ( ) ; } FloatBuffer buf = BufferUtils . createFloatBuffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurseMini ( buf , buf . limit ( ) / _NUM , _NUM , _NUM ) ; }
public void calcWelzl ( FloatBuffer points ) { if ( center == null ) { center = new Vector3f ( ) ; } FloatBuffer buf = BufferUtils . createFloatBuffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurseMini ( buf , buf . limit ( ) / _NUM , _NUM , _NUM ) ; }
public void calcWelzl ( FloatBuffer points ) { if ( center == null ) { center = new Vector3f ( ) ; } FloatBuffer buf = BufferUtils . createFloatBuffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurseMini ( buf , buf . limit ( ) / _NUM , _NUM , _NUM ) ; }
public void calcWelzl ( FloatBuffer points ) { if ( center == null ) { center = new Vector3f ( ) ; } FloatBuffer buf = BufferUtils . createFloatBuffer ( points . limit ( ) ) ; points . rewind ( ) ; buf . put ( points ) ; buf . flip ( ) ; recurseMini ( buf , buf . limit ( ) / _NUM , _NUM , _NUM ) ; }
static Type [ ] mapKeyAndValueTypes ( Type context , Class < ? > contextRawType ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type mapType = getSupertype ( context , contextRawType , Map . class ) ; if ( mapType instanceof ParameterizedType ) { ParameterizedType mapParameterizedType = ( ParameterizedType ) mapType ; return mapParameterizedType . getActualTypeArguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
static Type [ ] mapKeyAndValueTypes ( Type context , Class < ? > contextRawType ) { if ( context == Properties . class ) return new Type [ ] { String . class , String . class } ; Type mapType = getSupertype ( context , contextRawType , Map . class ) ; if ( mapType instanceof ParameterizedType ) { ParameterizedType mapParameterizedType = ( ParameterizedType ) mapType ; return mapParameterizedType . getActualTypeArguments ( ) ; } return new Type [ ] { Object . class , Object . class } ; }
public void addAddendum ( String word , String partOfSpeech , String [ ] phones ) { String pos = fixPartOfSpeech ( partOfSpeech ) ; if ( ! partsOfSpeech . contains ( pos ) ) { partsOfSpeech . add ( pos ) ; } addenda . put ( word + pos , phones ) ; }
public boolean equals ( Object object ) { if ( ! ( object instanceof ObjectInstance ) ) { return _BOOL ; } ObjectInstance val = ( ObjectInstance ) object ; if ( ! name . equals ( val . getObjectName ( ) ) ) return _BOOL ; if ( className == null ) return ( val . getClassName ( ) == null ) ; return className . equals ( val . getClassName ( ) ) ; }
public JPanel createLegendPanel ( ) { JPanel legendPanel = new JPanel ( ) ; legendPanel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; legendPanel . add ( getLegendPanel ( ) ) ; JPanel symbolTreePanel = getSymbolTree ( ) ; legendPanel . add ( symbolTreePanel ) ; return legendPanel ; }
@ PrePersist public void prePersist ( ) { lockTime = System . currentTimeMillis ( ) ; }
@ PrePersist public void prePersist ( ) { lockTime = System . currentTimeMillis ( ) ; }
protected void assertSenderConfig ( String config ) throws Exception { context = new ClassPathXmlApplicationContext ( config ) ; consumer = ( SpringConsumer ) context . getBean ( STRING ) ; assertTrue ( STRING , consumer != null ) ; consumer . start ( ) ; producer = ( SpringProducer ) context . getBean ( STRING ) ; assertTrue ( STRING , producer != null ) ; consumer . flushMessages ( ) ; producer . start ( ) ; consumer . waitForMessagesToArrive ( producer . getMessageCount ( ) ) ; List < Message > messages = consumer . flushMessages ( ) ; LOG . info ( STRING ) ; for ( Message message : messages ) { LOG . info ( STRING + message ) ; } assertEquals ( STRING , producer . getMessageCount ( ) , messages . size ( ) ) ; }
protected void assertSenderConfig ( String config ) throws Exception { context = new ClassPathXmlApplicationContext ( config ) ; consumer = ( SpringConsumer ) context . getBean ( STRING ) ; assertTrue ( STRING , consumer != null ) ; consumer . start ( ) ; producer = ( SpringProducer ) context . getBean ( STRING ) ; assertTrue ( STRING , producer != null ) ; consumer . flushMessages ( ) ; producer . start ( ) ; consumer . waitForMessagesToArrive ( producer . getMessageCount ( ) ) ; List < Message > messages = consumer . flushMessages ( ) ; LOG . info ( STRING ) ; for ( Message message : messages ) { LOG . info ( STRING + message ) ; } assertEquals ( STRING , producer . getMessageCount ( ) , messages . size ( ) ) ; }
public boolean shouldIgnoreForStats ( SootClass clz ) { return STATS_IGNORE_SOOTCLASSES . contains ( clz ) ; }
public void deleteObservers ( ) { observers . clear ( ) ; }
public void deleteObservers ( ) { observers . clear ( ) ; }
public void deleteObservers ( ) { observers . clear ( ) ; }
public void deleteObservers ( ) { observers . clear ( ) ; }
public void deleteObservers ( ) { observers . clear ( ) ; }
public static Map appendElementToMap ( String key , Set values , Map toMap ) { if ( ( key != null ) && ( values != null ) && ( ! values . isEmpty ( ) ) && ( toMap != null ) ) { Set previousValues = ( Set ) toMap . get ( key ) ; if ( ( previousValues != null ) && ( ! previousValues . isEmpty ( ) ) ) { previousValues . addAll ( values ) ; } else { toMap . put ( key , values ) ; } } return toMap ; }
public static byte [ ] hexToArray ( final String data ) throws ConversionException { try { return Hex . decodeHex ( data . toCharArray ( ) ) ; } catch ( DecoderException e ) { throw new ConversionException ( STRING , e ) ; } }
public static byte [ ] hexToArray ( final String data ) throws ConversionException { try { return Hex . decodeHex ( data . toCharArray ( ) ) ; } catch ( DecoderException e ) { throw new ConversionException ( STRING , e ) ; } }
private void addVNXFailedSubscription ( String storageSystemURI ) { if ( StringUtils . isNotEmpty ( storageSystemURI ) ) { FAILED_VNXFILE_SUBSCRIPTION . add ( storageSystemURI ) ; } }
private void addVNXFailedSubscription ( String storageSystemURI ) { if ( StringUtils . isNotEmpty ( storageSystemURI ) ) { FAILED_VNXFILE_SUBSCRIPTION . add ( storageSystemURI ) ; } }
private void addVNXFailedSubscription ( String storageSystemURI ) { if ( StringUtils . isNotEmpty ( storageSystemURI ) ) { FAILED_VNXFILE_SUBSCRIPTION . add ( storageSystemURI ) ; } }
static String escapeStringForASCII ( String s ) { StringBuilder out = new StringBuilder ( ) ; char [ ] cArray = s . toCharArray ( ) ; for ( int i = _NUM ; i < cArray . length ; i ++ ) { char c = cArray [ i ] ; if ( c > _NUM ) { out . append ( STRING ) ; String hex = Integer . toHexString ( c ) ; while ( hex . length ( ) < _NUM ) hex = STRING + hex ; out . append ( hex ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else { out . append ( c ) ; } } return out . toString ( ) ; }
static String escapeStringForASCII ( String s ) { StringBuilder out = new StringBuilder ( ) ; char [ ] cArray = s . toCharArray ( ) ; for ( int i = _NUM ; i < cArray . length ; i ++ ) { char c = cArray [ i ] ; if ( c > _NUM ) { out . append ( STRING ) ; String hex = Integer . toHexString ( c ) ; while ( hex . length ( ) < _NUM ) hex = STRING + hex ; out . append ( hex ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else if ( c == STRING ) { out . append ( STRING ) ; } else { out . append ( c ) ; } } return out . toString ( ) ; }
public static Map < Integer , String > generateMapOfValueNameInteger ( Class < ? > clazz ) { Map < Integer , String > valuesName = new HashMap < > ( ) ; try { for ( Field field : clazz . getFields ( ) ) { valuesName . put ( ( Integer ) field . get ( int . class ) , field . getName ( ) ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return valuesName ; }
public static Map < Integer , String > generateMapOfValueNameInteger ( Class < ? > clazz ) { Map < Integer , String > valuesName = new HashMap < > ( ) ; try { for ( Field field : clazz . getFields ( ) ) { valuesName . put ( ( Integer ) field . get ( int . class ) , field . getName ( ) ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return valuesName ; }
public static Map < Integer , String > generateMapOfValueNameInteger ( Class < ? > clazz ) { Map < Integer , String > valuesName = new HashMap < > ( ) ; try { for ( Field field : clazz . getFields ( ) ) { valuesName . put ( ( Integer ) field . get ( int . class ) , field . getName ( ) ) ; } } catch ( IllegalAccessException e ) { e . printStackTrace ( ) ; } return valuesName ; }
private JMXConnector connect ( String host , int port ) { try { if ( ! isNodeAvailable ( host ) ) { log . info ( STRING , host ) ; throw new IllegalStateException ( STRING ) ; } log . debug ( STRING , host , port ) ; String connectorAddress = String . format ( serviceUrl , host , port ) ; JMXServiceURL jmxUrl = new JMXServiceURL ( connectorAddress ) ; return JMXConnectorFactory . connect ( jmxUrl ) ; } catch ( MalformedURLException e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new IllegalStateException ( STRING ) ; } catch ( IOException e ) { log . error ( String . format ( STRING , host , port ) , e ) ; throw new IllegalStateException ( STRING + host ) ; } }
private static String stripWhitespace ( final String mosname ) { final StringBuffer sb = new StringBuffer ( ) ; final int size = mosname . length ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { final char ch = mosname . charAt ( i ) ; if ( ! Character . isWhitespace ( ch ) ) { sb . append ( ch ) ; } } return sb . toString ( ) ; }
private static String stripWhitespace ( final String mosname ) { final StringBuffer sb = new StringBuffer ( ) ; final int size = mosname . length ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { final char ch = mosname . charAt ( i ) ; if ( ! Character . isWhitespace ( ch ) ) { sb . append ( ch ) ; } } return sb . toString ( ) ; }
public void deleteSubGroupContainers ( Set groupContainers ) throws AMException , SSOException { Iterator iter = groupContainers . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupContainerDN = ( String ) iter . next ( ) ; AMGroupContainer groupContainer = new AMGroupContainerImpl ( token , groupContainerDN ) ; groupContainer . delete ( ) ; } }
public void deleteSubGroupContainers ( Set groupContainers ) throws AMException , SSOException { Iterator iter = groupContainers . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupContainerDN = ( String ) iter . next ( ) ; AMGroupContainer groupContainer = new AMGroupContainerImpl ( token , groupContainerDN ) ; groupContainer . delete ( ) ; } }
private UIComponent newInstance ( TreeNode n ) throws FacesException { if ( LOGGER . isLoggable ( Level . FINEST ) ) { LOGGER . log ( Level . FINEST , STRING , n . componentType ) ; } try { Class < ? > t = ( ( classMap != null ) ? classMap . get ( n . componentType ) : null ) ; if ( t == null ) { t = Util . loadClass ( n . componentType , n ) ; if ( t != null && classMap != null ) { classMap . put ( n . componentType , t ) ; } else { if ( ! isDevelopmentMode ) { throw new NullPointerException ( ) ; } } } assert ( t != null ) ; UIComponent c = ( UIComponent ) t . newInstance ( ) ; c . setId ( n . id ) ; return c ; } catch ( ClassNotFoundException | NullPointerException | InstantiationException | IllegalAccessException e ) { throw new FacesException ( e ) ; } }
private static int determineConsecutiveTextCount ( CharSequence msg , int startpos ) { int len = msg . length ( ) ; int idx = startpos ; while ( idx < len ) { char ch = msg . charAt ( idx ) ; int numericCount = _NUM ; while ( numericCount < _NUM && isDigit ( ch ) && idx < len ) { numericCount ++ ; idx ++ ; if ( idx < len ) { ch = msg . charAt ( idx ) ; } } if ( numericCount >= _NUM ) { return idx - startpos - numericCount ; } if ( numericCount > _NUM ) { continue ; } ch = msg . charAt ( idx ) ; if ( ! isText ( ch ) ) { break ; } idx ++ ; } return idx - startpos ; }
private static void showPreferenceWindow ( final GUIFactory currentGUI ) { properties = currentGUI . getProperties ( ) ; init ( currentGUI ) ; loadSettings ( ) ; borderPane . setLeft ( setupSideNavBar ( ) ) ; borderPane . setCenter ( getGeneralContent ( ) ) ; borderPane . setBottom ( setupBottomBar ( currentGUI ) ) ; preferenceDialog = new FXDialog ( null , Modality . APPLICATION_MODAL , borderPane , _NUM , _NUM ) ; preferenceDialog . setTitle ( Messages . getMessage ( STRING ) ) ; preferenceDialog . show ( ) ; }
private static byte [ ] generateSeed ( ) { try { ByteArrayOutputStream seedBuffer = new ByteArrayOutputStream ( ) ; DataOutputStream seedBufferOut = new DataOutputStream ( seedBuffer ) ; seedBufferOut . writeLong ( System . currentTimeMillis ( ) ) ; seedBufferOut . writeLong ( System . nanoTime ( ) ) ; seedBufferOut . write ( BUILD_FINGERPRINT_AND_DEVICE_SERIAL ) ; seedBufferOut . close ( ) ; return seedBuffer . toByteArray ( ) ; } catch ( IOException e ) { throw new SecurityException ( STRING , e ) ; } }
public < T > T param2PO ( Class < T > type , Object param , T po , User currentUser ) throws Exception { Long createdBy ; Long lastModifiedBy ; Field idField = type . getDeclaredField ( CommonsConstant . ID ) ; idField . setAccessible ( _BOOL ) ; Field createdByField = type . getDeclaredField ( CommonsConstant . CREATED_BY ) ; createdByField . setAccessible ( _BOOL ) ; Field lastModifiedByField = type . getDeclaredField ( CommonsConstant . LAST_MODIFIED_BY ) ; lastModifiedByField . setAccessible ( _BOOL ) ; Field lastModifiedDateField = type . getDeclaredField ( CommonsConstant . LAST_MODIFIED_DATE ) ; lastModifiedDateField . setAccessible ( _BOOL ) ; Date now = new Date ( ) ; if ( idField . get ( po ) == null ) { createdBy = currentUser . getId ( ) ; lastModifiedBy = createdBy ; } else { createdBy = ( Long ) createdByField . get ( po ) ; lastModifiedBy = currentUser . getId ( ) ; } BeanUtils . copyPropertiesIgnoreNull ( param , po ) ; createdByField . set ( po , createdBy ) ; lastModifiedByField . set ( po , lastModifiedBy ) ; lastModifiedDateField . set ( po , now ) ; return po ; }
public < T > T param2PO ( Class < T > type , Object param , T po , User currentUser ) throws Exception { Long createdBy ; Long lastModifiedBy ; Field idField = type . getDeclaredField ( CommonsConstant . ID ) ; idField . setAccessible ( _BOOL ) ; Field createdByField = type . getDeclaredField ( CommonsConstant . CREATED_BY ) ; createdByField . setAccessible ( _BOOL ) ; Field lastModifiedByField = type . getDeclaredField ( CommonsConstant . LAST_MODIFIED_BY ) ; lastModifiedByField . setAccessible ( _BOOL ) ; Field lastModifiedDateField = type . getDeclaredField ( CommonsConstant . LAST_MODIFIED_DATE ) ; lastModifiedDateField . setAccessible ( _BOOL ) ; Date now = new Date ( ) ; if ( idField . get ( po ) == null ) { createdBy = currentUser . getId ( ) ; lastModifiedBy = createdBy ; } else { createdBy = ( Long ) createdByField . get ( po ) ; lastModifiedBy = currentUser . getId ( ) ; } BeanUtils . copyPropertiesIgnoreNull ( param , po ) ; createdByField . set ( po , createdBy ) ; lastModifiedByField . set ( po , lastModifiedBy ) ; lastModifiedDateField . set ( po , now ) ; return po ; }
default long now ( TimeUnit unit ) { return unit . convert ( System . currentTimeMillis ( ) , TimeUnit . MILLISECONDS ) ; }
private void scheduleTimeoutRequestsTimer ( ) { PendingRequest nextRequest = getNextTimeoutingPendingRequest ( ) ; if ( nextRequest == null ) { cancelTimeoutPendingRequestTask ( ) ; } else { TimerTask task = timeoutPendingRequestsTask . get ( ) ; if ( task == null || task . scheduledExecutionTime ( ) > nextRequest . timeoutTime ) { cancelTimeoutPendingRequestTask ( ) ; task = TimerUtil . schedule ( timer , timeoutRun , executor , nextRequest . timeoutTime ) ; if ( ! timeoutPendingRequestsTask . compareAndSet ( null , task ) ) task . cancel ( ) ; } } }
private void scheduleTimeoutRequestsTimer ( ) { PendingRequest nextRequest = getNextTimeoutingPendingRequest ( ) ; if ( nextRequest == null ) { cancelTimeoutPendingRequestTask ( ) ; } else { TimerTask task = timeoutPendingRequestsTask . get ( ) ; if ( task == null || task . scheduledExecutionTime ( ) > nextRequest . timeoutTime ) { cancelTimeoutPendingRequestTask ( ) ; task = TimerUtil . schedule ( timer , timeoutRun , executor , nextRequest . timeoutTime ) ; if ( ! timeoutPendingRequestsTask . compareAndSet ( null , task ) ) task . cancel ( ) ; } } }
private final double preDistanceVM ( NumberVector v , SpatialComparable mbr , final int start , final int end ) { double agg = _NUM ; for ( int d = start ; d < end ; d ++ ) { final double value = v . doubleValue ( d ) , min = mbr . getMin ( d ) ; double delta = min - value ; if ( delta < _NUM ) { delta = value - mbr . getMax ( d ) ; } if ( delta > _NUM ) { agg += Math . pow ( delta , p ) ; } } return agg ; }
private final double preDistanceVM ( NumberVector v , SpatialComparable mbr , final int start , final int end ) { double agg = _NUM ; for ( int d = start ; d < end ; d ++ ) { final double value = v . doubleValue ( d ) , min = mbr . getMin ( d ) ; double delta = min - value ; if ( delta < _NUM ) { delta = value - mbr . getMax ( d ) ; } if ( delta > _NUM ) { agg += Math . pow ( delta , p ) ; } } return agg ; }
public void generatePartition ( Instances data ) throws Exception { if ( m_Classifier instanceof PartitionGenerator ) buildClassifier ( data ) ; else throw new Exception ( STRING + getClassifierSpec ( ) + STRING ) ; }
public void generatePartition ( Instances data ) throws Exception { if ( m_Classifier instanceof PartitionGenerator ) buildClassifier ( data ) ; else throw new Exception ( STRING + getClassifierSpec ( ) + STRING ) ; }
public void generatePartition ( Instances data ) throws Exception { if ( m_Classifier instanceof PartitionGenerator ) buildClassifier ( data ) ; else throw new Exception ( STRING + getClassifierSpec ( ) + STRING ) ; }
public static RotateBitmapResult rotateBitmapByExif ( Bitmap bitmap , Context context , Uri uri ) { try { File file = getFileFromUri ( context , uri ) ; if ( file . exists ( ) ) { ExifInterface ei = new ExifInterface ( file . getAbsolutePath ( ) ) ; return rotateBitmapByExif ( bitmap , ei ) ; } } catch ( Exception ignored ) { } return new RotateBitmapResult ( bitmap , _NUM ) ; }
public static RotateBitmapResult rotateBitmapByExif ( Bitmap bitmap , Context context , Uri uri ) { try { File file = getFileFromUri ( context , uri ) ; if ( file . exists ( ) ) { ExifInterface ei = new ExifInterface ( file . getAbsolutePath ( ) ) ; return rotateBitmapByExif ( bitmap , ei ) ; } } catch ( Exception ignored ) { } return new RotateBitmapResult ( bitmap , _NUM ) ; }
public void selectTab ( String groupKey ) { if ( groupKeysToTabIndexMap . containsKey ( groupKey ) ) { setSelectedIndex ( groupKeysToTabIndexMap . get ( groupKey ) ) ; } }
static boolean charEqualsIgnoreCase ( char c1 , char c2 ) { return c1 == c2 || Character . toUpperCase ( c1 ) == Character . toUpperCase ( c2 ) || Character . toLowerCase ( c1 ) == Character . toLowerCase ( c2 ) ; }
static boolean charEqualsIgnoreCase ( char c1 , char c2 ) { return c1 == c2 || Character . toUpperCase ( c1 ) == Character . toUpperCase ( c2 ) || Character . toLowerCase ( c1 ) == Character . toLowerCase ( c2 ) ; }
public void addDetailsLoadedListener ( @ NotNull Runnable runnable ) { myLoadingFinishedListeners . add ( runnable ) ; }
public void addDetailsLoadedListener ( @ NotNull Runnable runnable ) { myLoadingFinishedListeners . add ( runnable ) ; }
public static void writeAll ( OutputStream stream , Object [ ] o ) throws Exception { ObjectOutputStream oos ; int i ; if ( ! ( stream instanceof BufferedOutputStream ) ) { stream = new BufferedOutputStream ( stream ) ; } oos = new ObjectOutputStream ( stream ) ; for ( i = _NUM ; i < o . length ; i ++ ) { oos . writeObject ( o [ i ] ) ; } oos . flush ( ) ; oos . close ( ) ; }
@ Override public PackingPlan pack ( ) { Map < Integer , List < InstanceId > > ffdAllocation = getFFDAllocation ( ) ; Map < String , Long > ramMap = TopologyUtils . getComponentRamMapConfig ( topology ) ; Set < PackingPlan . ContainerPlan > containerPlans = PackingUtils . buildContainerPlans ( ffdAllocation , ramMap , this . defaultInstanceResources , this . paddingPercentage ) ; return new PackingPlan ( topology . getId ( ) , containerPlans ) ; }
public void addSeparator ( ) { mTableContents . add ( SEPARATOR ) ; }
public void verifyAnnotation ( String methodName , String annotationName ) throws Exception { Class clazz = Class . forName ( className ) ; Method method = clazz . getDeclaredMethod ( methodName ) ; Class annotationClazz = Class . forName ( annotationName ) ; java . lang . annotation . Annotation annotation = method . getAnnotation ( annotationClazz ) ; Assert . assertNotNull ( annotation ) ; }
public void verifyAnnotation ( String methodName , String annotationName ) throws Exception { Class clazz = Class . forName ( className ) ; Method method = clazz . getDeclaredMethod ( methodName ) ; Class annotationClazz = Class . forName ( annotationName ) ; java . lang . annotation . Annotation annotation = method . getAnnotation ( annotationClazz ) ; Assert . assertNotNull ( annotation ) ; }
public void writeHex ( Writer w ) throws IOException , MemoryFileAddressingFormatException { writeHex ( w , _NUM ) ; }
public void writeHex ( Writer w ) throws IOException , MemoryFileAddressingFormatException { writeHex ( w , _NUM ) ; }
public void writeHex ( Writer w ) throws IOException , MemoryFileAddressingFormatException { writeHex ( w , _NUM ) ; }
public void writeHeader ( ) throws IOException { FLVHeader flvHeader = new FLVHeader ( ) ; flvHeader . setFlagAudio ( _BOOL ) ; flvHeader . setFlagVideo ( _BOOL ) ; ByteBuffer header = ByteBuffer . allocate ( HEADER_LENGTH + _NUM ) ; flvHeader . write ( header ) ; file . setLength ( HEADER_LENGTH + _NUM ) ; if ( header . hasArray ( ) ) { log . debug ( STRING ) ; file . write ( header . array ( ) ) ; } else { log . debug ( STRING ) ; byte [ ] tmp = new byte [ HEADER_LENGTH + _NUM ] ; header . get ( tmp ) ; file . write ( tmp ) ; } bytesWritten = file . length ( ) ; header . clear ( ) ; }
public void addAdditionalSymbolClass ( FXGSymbolClass symbolClass ) { if ( additionalSymbolClasses == null ) additionalSymbolClasses = new ArrayList < FXGSymbolClass > ( ) ; additionalSymbolClasses . add ( symbolClass ) ; }
public void addAdditionalSymbolClass ( FXGSymbolClass symbolClass ) { if ( additionalSymbolClasses == null ) additionalSymbolClasses = new ArrayList < FXGSymbolClass > ( ) ; additionalSymbolClasses . add ( symbolClass ) ; }
public void addAdditionalSymbolClass ( FXGSymbolClass symbolClass ) { if ( additionalSymbolClasses == null ) additionalSymbolClasses = new ArrayList < FXGSymbolClass > ( ) ; additionalSymbolClasses . add ( symbolClass ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
public void addVetoableChangeListener ( String propertyName , VetoableChangeListener in_vcl ) { beanContextChildSupport . addVetoableChangeListener ( propertyName , in_vcl ) ; }
protected int mapDragOperationFromModifiers ( MouseEvent e ) { int mods = e . getModifiersEx ( ) ; int btns = mods & ButtonMask ; if ( ! ( btns == InputEvent . BUTTON1_DOWN_MASK || btns == InputEvent . BUTTON2_DOWN_MASK || btns == InputEvent . BUTTON3_DOWN_MASK ) ) { return DnDConstants . ACTION_NONE ; } return SunDragSourceContextPeer . convertModifiersToDropAction ( mods , getSourceActions ( ) ) ; }
public void removeGroup ( String group ) throws ObjectLacksException { assertContains ( group ) ; groups . remove ( group ) ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ _NUM ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + _NUM ] ; System . arraycopy ( srcAndRefPositions , _NUM , a , _NUM , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ _NUM ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + _NUM ] ; System . arraycopy ( srcAndRefPositions , _NUM , a , _NUM , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ _NUM ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + _NUM ] ; System . arraycopy ( srcAndRefPositions , _NUM , a , _NUM , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
private void addReference ( final int sourcePosition , final int referencePosition ) { if ( srcAndRefPositions == null ) { srcAndRefPositions = new int [ _NUM ] ; } if ( referenceCount >= srcAndRefPositions . length ) { int [ ] a = new int [ srcAndRefPositions . length + _NUM ] ; System . arraycopy ( srcAndRefPositions , _NUM , a , _NUM , srcAndRefPositions . length ) ; srcAndRefPositions = a ; } srcAndRefPositions [ referenceCount ++ ] = sourcePosition ; srcAndRefPositions [ referenceCount ++ ] = referencePosition ; }
public void processed ( String sourceId , String targetId , boolean linkExisted , String linkId , boolean linkCreated , Situation situation , ReconAction action ) { String id ; if ( phase == Phase . SOURCE ) { id = sourceId ; } else { id = targetId ; } parentStat . processed ( sourceId , targetId , linkExisted , linkId , linkCreated , situation , action ) ; if ( id != null ) { processedEntries . incrementAndGet ( ) ; if ( situation != null ) { List < String > situationIds = ids . get ( situation ) ; if ( situationIds != null ) { situationIds . add ( id ) ; } } } }
public void processed ( String sourceId , String targetId , boolean linkExisted , String linkId , boolean linkCreated , Situation situation , ReconAction action ) { String id ; if ( phase == Phase . SOURCE ) { id = sourceId ; } else { id = targetId ; } parentStat . processed ( sourceId , targetId , linkExisted , linkId , linkCreated , situation , action ) ; if ( id != null ) { processedEntries . incrementAndGet ( ) ; if ( situation != null ) { List < String > situationIds = ids . get ( situation ) ; if ( situationIds != null ) { situationIds . add ( id ) ; } } } }
private boolean openForWriting ( ) { File root = new File ( Properties . CTG_DIR ) ; if ( root . exists ( ) ) { if ( root . isDirectory ( ) ) { if ( ! root . canWrite ( ) ) { logger . error ( STRING + root . getAbsolutePath ( ) ) ; return _BOOL ; } } else { boolean deleted = root . delete ( ) ; if ( ! deleted ) { logger . error ( STRING + root + STRING ) ; return _BOOL ; } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . getAbsolutePath ( ) ) ; return _BOOL ; } } } } else { if ( ! root . mkdirs ( ) ) { logger . error ( STRING + root . getAbsolutePath ( ) ) ; return _BOOL ; } } File testsFolder = getBestTestFolder ( ) ; if ( ! testsFolder . exists ( ) ) { if ( ! testsFolder . mkdirs ( ) ) { logger . error ( STRING + testsFolder . getAbsolutePath ( ) ) ; return _BOOL ; } } File seedFolder = getSeedInFolder ( ) ; if ( ! seedFolder . exists ( ) ) { if ( ! seedFolder . mkdirs ( ) ) { logger . error ( STRING + seedFolder . getAbsolutePath ( ) ) ; } } return _BOOL ; }
public static void cleanupCache ( ) { for ( SoftReference < ReplaceableBitmapDrawable > reference : sImageCache . values ( ) ) { final ReplaceableBitmapDrawable drawable = reference . get ( ) ; if ( drawable != null ) drawable . setCallback ( null ) ; } }
public static void cleanupCache ( ) { for ( SoftReference < ReplaceableBitmapDrawable > reference : sImageCache . values ( ) ) { final ReplaceableBitmapDrawable drawable = reference . get ( ) ; if ( drawable != null ) drawable . setCallback ( null ) ; } }
private void handleHovering ( int x , int y ) { handleCellHover ( x , y ) ; if ( columnHeadersVisible ) { handleHoverOnColumnHeader ( x , y ) ; } }
private void handleHovering ( int x , int y ) { handleCellHover ( x , y ) ; if ( columnHeadersVisible ) { handleHoverOnColumnHeader ( x , y ) ; } }
private void handleHovering ( int x , int y ) { handleCellHover ( x , y ) ; if ( columnHeadersVisible ) { handleHoverOnColumnHeader ( x , y ) ; } }
private void handleHovering ( int x , int y ) { handleCellHover ( x , y ) ; if ( columnHeadersVisible ) { handleHoverOnColumnHeader ( x , y ) ; } }
private static byte [ ] bitmapToByte ( Bitmap b ) { if ( b == null ) { return null ; } ByteArrayOutputStream o = new ByteArrayOutputStream ( ) ; b . compress ( Bitmap . CompressFormat . PNG , _NUM , o ) ; return o . toByteArray ( ) ; }
private static byte [ ] bitmapToByte ( Bitmap b ) { if ( b == null ) { return null ; } ByteArrayOutputStream o = new ByteArrayOutputStream ( ) ; b . compress ( Bitmap . CompressFormat . PNG , _NUM , o ) ; return o . toByteArray ( ) ; }
public static String stripVersionFromRestName ( String restName ) { Preconditions . checkNotNull ( restName ) ; String version = extractDefaultMajorVersionFromRestName ( restName ) ; String [ ] segs = restName . split ( STRING ) ; if ( segs . length > _NUM ) { version = version + STRING ; } return restName . startsWith ( version ) ? restName . substring ( version . length ( ) ) : restName ; }
public static String stripVersionFromRestName ( String restName ) { Preconditions . checkNotNull ( restName ) ; String version = extractDefaultMajorVersionFromRestName ( restName ) ; String [ ] segs = restName . split ( STRING ) ; if ( segs . length > _NUM ) { version = version + STRING ; } return restName . startsWith ( version ) ? restName . substring ( version . length ( ) ) : restName ; }
public static String stripVersionFromRestName ( String restName ) { Preconditions . checkNotNull ( restName ) ; String version = extractDefaultMajorVersionFromRestName ( restName ) ; String [ ] segs = restName . split ( STRING ) ; if ( segs . length > _NUM ) { version = version + STRING ; } return restName . startsWith ( version ) ? restName . substring ( version . length ( ) ) : restName ; }
public static byte [ ] toUnsignedByteArray ( BigInteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . toByteArray ( ) ; if ( bb [ _NUM ] == _NUM ) { byte [ ] noZero = new byte [ bb . length - _NUM ] ; System . arraycopy ( bb , _NUM , noZero , _NUM , noZero . length ) ; return noZero ; } else { return bb ; } }
public static byte [ ] toUnsignedByteArray ( BigInteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . toByteArray ( ) ; if ( bb [ _NUM ] == _NUM ) { byte [ ] noZero = new byte [ bb . length - _NUM ] ; System . arraycopy ( bb , _NUM , noZero , _NUM , noZero . length ) ; return noZero ; } else { return bb ; } }
public static byte [ ] toUnsignedByteArray ( BigInteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . toByteArray ( ) ; if ( bb [ _NUM ] == _NUM ) { byte [ ] noZero = new byte [ bb . length - _NUM ] ; System . arraycopy ( bb , _NUM , noZero , _NUM , noZero . length ) ; return noZero ; } else { return bb ; } }
public static byte [ ] toUnsignedByteArray ( BigInteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . toByteArray ( ) ; if ( bb [ _NUM ] == _NUM ) { byte [ ] noZero = new byte [ bb . length - _NUM ] ; System . arraycopy ( bb , _NUM , noZero , _NUM , noZero . length ) ; return noZero ; } else { return bb ; } }
public static byte [ ] toUnsignedByteArray ( BigInteger bi ) { if ( bi == null ) { return null ; } byte [ ] bb = bi . toByteArray ( ) ; if ( bb [ _NUM ] == _NUM ) { byte [ ] noZero = new byte [ bb . length - _NUM ] ; System . arraycopy ( bb , _NUM , noZero , _NUM , noZero . length ) ; return noZero ; } else { return bb ; } }
public void onComplete ( final Consumer < OnComplete > fn ) { this . forXOf = fn ; if ( done ) { fn . accept ( buildOnComplete ( ) ) ; } }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; VolleyLog . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; VolleyLog . d ( STRING ) ; }
public static Bitmap makeRoundUserPicture ( Bitmap bitmap ) { if ( bitmap == null ) return null ; Bitmap output = Bitmap . createBitmap ( bitmap . getWidth ( ) , bitmap . getHeight ( ) , Config . ARGB_8888 ) ; Canvas canvas = new Canvas ( output ) ; final Paint paint = new Paint ( ) ; final Rect rect = new Rect ( _NUM , _NUM , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; canvas . drawARGB ( _NUM , _NUM , _NUM , _NUM ) ; paint . setAntiAlias ( _BOOL ) ; paint . setColor ( _NUM ) ; canvas . drawCircle ( bitmap . getWidth ( ) * _NUM , bitmap . getHeight ( ) * _NUM , bitmap . getWidth ( ) * _NUM , paint ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . SRC_IN ) ) ; canvas . drawBitmap ( bitmap , rect , rect , paint ) ; return output ; }
public static Bitmap makeRoundUserPicture ( Bitmap bitmap ) { if ( bitmap == null ) return null ; Bitmap output = Bitmap . createBitmap ( bitmap . getWidth ( ) , bitmap . getHeight ( ) , Config . ARGB_8888 ) ; Canvas canvas = new Canvas ( output ) ; final Paint paint = new Paint ( ) ; final Rect rect = new Rect ( _NUM , _NUM , bitmap . getWidth ( ) , bitmap . getHeight ( ) ) ; canvas . drawARGB ( _NUM , _NUM , _NUM , _NUM ) ; paint . setAntiAlias ( _BOOL ) ; paint . setColor ( _NUM ) ; canvas . drawCircle ( bitmap . getWidth ( ) * _NUM , bitmap . getHeight ( ) * _NUM , bitmap . getWidth ( ) * _NUM , paint ) ; paint . setXfermode ( new PorterDuffXfermode ( PorterDuff . Mode . SRC_IN ) ) ; canvas . drawBitmap ( bitmap , rect , rect , paint ) ; return output ; }
@ Override public int processImage ( String name , final int dataPointer , final PdfObject XObject ) throws PdfException { String key = null ; if ( ImageCommands . rejectSuperimposedImages ) { key = ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) ; } try { if ( System . getProperty ( STRING ) == null ) { processXImage ( name , name , key , XObject ) ; } } catch ( final Error e ) { LogWriter . writeLog ( STRING + e . getMessage ( ) ) ; parserOptions . imagesProcessedFully = _BOOL ; errorTracker . addPageFailureMessage ( STRING + e + STRING ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e ) ; parserOptions . imagesProcessedFully = _BOOL ; errorTracker . addPageFailureMessage ( STRING + e + STRING ) ; } return dataPointer ; }
@ Override public int processImage ( String name , final int dataPointer , final PdfObject XObject ) throws PdfException { String key = null ; if ( ImageCommands . rejectSuperimposedImages ) { key = ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) + STRING + ( ( int ) gs . CTM [ _NUM ] [ _NUM ] ) ; } try { if ( System . getProperty ( STRING ) == null ) { processXImage ( name , name , key , XObject ) ; } } catch ( final Error e ) { LogWriter . writeLog ( STRING + e . getMessage ( ) ) ; parserOptions . imagesProcessedFully = _BOOL ; errorTracker . addPageFailureMessage ( STRING + e + STRING ) ; } catch ( final Exception e ) { LogWriter . writeLog ( STRING + e ) ; parserOptions . imagesProcessedFully = _BOOL ; errorTracker . addPageFailureMessage ( STRING + e + STRING ) ; } return dataPointer ; }
protected void writeRaw ( final String text ) { writeIndent ( ) ; try { final int length = text != null ? text . length ( ) : NULL_TEXT . length ( ) ; _writer . write ( text ) ; column += length ; if ( text == null ) { return ; } boolean newLineSeen = _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { if ( text . charAt ( i ) == STRING ) { line ++ ; column = _NUM ; newLineSeen = _BOOL ; } else if ( newLineSeen ) { column ++ ; } } } catch ( IOException e ) { throw new UndeclaredThrowableException ( e ) ; } }
public static int previousClearBit ( long v , int start ) { if ( start < _NUM || start >= Long . SIZE ) { return - _NUM ; } long cur = ~ v & ( LONG_ALL_BITS > > > start ) ; if ( cur == _NUM ) { return - _NUM ; } return Long . SIZE - _NUM - Long . numberOfTrailingZeros ( cur ) ; }
public int hashCode ( ) { return alignment ^ leader ^ Math . round ( position ) ; }
public int hashCode ( ) { return alignment ^ leader ^ Math . round ( position ) ; }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
public void close ( ) throws IOException { if ( ! closed ) { try { if ( ! eof ) { exhaustInputStream ( this ) ; } } finally { eof = _BOOL ; closed = _BOOL ; } } }
private Image createPackedImage8 ( ) throws IOException { int size = input . readByte ( ) & _NUM ; if ( size == _NUM ) { size = _NUM ; } int [ ] palette = new int [ size ] ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . readInt ( ) ; } int width = input . readShort ( ) ; int height = input . readShort ( ) ; byte [ ] data = new byte [ width * height ] ; input . readFully ( data , _NUM , data . length ) ; return Image . createIndexed ( width , height , palette , data ) ; }
private void addSessionsRegistrationListener ( final ThirdPartyRegistrationListener listener ) { synchronized ( this ) { if ( ( null != listener ) && ( mThirdPartyRegistrationListeners . indexOf ( listener ) == - _NUM ) ) { mThirdPartyRegistrationListeners . add ( listener ) ; } } }
public void removeOperations ( Operation operation , Object token ) { if ( isRunning ) { if ( operationHandlerThreadHandler == null ) return ; operationHandlerThreadHandler . removeCallbacks ( new AndroidOperation ( this , operation ) , token ) ; } else { operationQueue . remove ( new AndroidOperation ( this , operation , AndroidOperation . Type . NORMAL , token , _NUM ) ) ; } }
public static String trim ( String s , boolean leading , boolean trailing , String sp ) { char space = ( sp == null || sp . length ( ) < _NUM ) ? STRING : sp . charAt ( _NUM ) ; if ( leading ) { int len = s . length ( ) , i = _NUM ; while ( i < len && s . charAt ( i ) == space ) { i ++ ; } s = ( i == _NUM ) ? s : s . substring ( i ) ; } if ( trailing ) { int endIndex = s . length ( ) - _NUM ; int i = endIndex ; while ( i >= _NUM && s . charAt ( i ) == space ) { i -- ; } s = i == endIndex ? s : s . substring ( _NUM , i + _NUM ) ; } return s ; }
public void mark ( int readAheadLimit ) throws IOException { if ( stream != null ) { stream . mark ( readAheadLimit ) ; } else { reader . mark ( readAheadLimit ) ; } }
public static double normalizeRadians ( double r ) { if ( r < _NUM && r >= - TWO_PI ) return r + TWO_PI ; if ( r >= TWO_PI && r < FOUR_PI ) return r - TWO_PI ; if ( r >= _NUM && r < TWO_PI ) return r ; r -= TWO_PI * Math . floor ( r * TWO_PI_INVERSE ) ; if ( r < _NUM ) r += TWO_PI ; return r ; }
@ Override public void performOnBackground ( final Runnable runnable ) { mLogger . logDebug ( STRING + mBackgroundExecutor . getActiveCount ( ) ) ; mBackgroundExecutor . execute ( runnable ) ; }
@ Override public void performOnBackground ( final Runnable runnable ) { mLogger . logDebug ( STRING + mBackgroundExecutor . getActiveCount ( ) ) ; mBackgroundExecutor . execute ( runnable ) ; }
private void loadMatrix ( final Matrix matrix , final File file ) throws IOException { final Iterator < String > lines = Util . readFileLineByLine ( file ) ; int row = _NUM ; while ( lines . hasNext ( ) ) { final String line = lines . next ( ) ; final String [ ] fields = line . split ( STRING ) ; for ( int i = _NUM ; i < fields . length ; i ++ ) { matrix . set ( row , i , Double . valueOf ( fields [ i ] ) ) ; } row ++ ; } }
public int hashCode ( ) { int hash = addrType . hashCode ( ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hashCode ( ) { int hash = addrType . hashCode ( ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hashCode ( ) { int hash = addrType . hashCode ( ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hashCode ( ) { int hash = addrType . hashCode ( ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public int hashCode ( ) { int hash = addrType . hashCode ( ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { hash += buf [ i ] ; } return hash ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public synchronized Object co_entry_pause ( int thisCoroutine ) throws java . lang . NoSuchMethodException { if ( ! m_activeIDs . get ( thisCoroutine ) ) throw new java . lang . NoSuchMethodException ( ) ; while ( m_nextCoroutine != thisCoroutine ) { try { wait ( ) ; } catch ( java . lang . InterruptedException e ) { } } return m_yield ; }
public void testInvokeAny4 ( ) throws Throwable { CountDownLatch latch = new CountDownLatch ( _NUM ) ; ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( latchAwaitingStringTask ( latch ) ) ; l . add ( null ) ; try { e . invokeAny ( l ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } latch . countDown ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void testInvokeAny4 ( ) throws Throwable { CountDownLatch latch = new CountDownLatch ( _NUM ) ; ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( latchAwaitingStringTask ( latch ) ) ; l . add ( null ) ; try { e . invokeAny ( l ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } latch . countDown ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void testInvokeAny4 ( ) throws Throwable { CountDownLatch latch = new CountDownLatch ( _NUM ) ; ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; List < Callable < String > > l = new ArrayList < Callable < String > > ( ) ; l . add ( latchAwaitingStringTask ( latch ) ) ; l . add ( null ) ; try { e . invokeAny ( l ) ; shouldThrow ( ) ; } catch ( NullPointerException success ) { } latch . countDown ( ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public synchronized T removeNextHatchedIfAvailable ( ) { T o = getNextHatchedIfAvailable ( ) ; if ( o == null ) return null ; orderList . removeFirst ( ) ; hatchMap . remove ( o ) ; notifyAll ( ) ; return o ; }
public synchronized T removeNextHatchedIfAvailable ( ) { T o = getNextHatchedIfAvailable ( ) ; if ( o == null ) return null ; orderList . removeFirst ( ) ; hatchMap . remove ( o ) ; notifyAll ( ) ; return o ; }
@ Inject private void init ( NodeRunnerDescriptorProvider descriptorProvider ) { if ( ! runnerRegistry . isRegistered ( NodeRunner . ID ) ) { runnerRegistry . register ( descriptorProvider . get ( ) ) ; } }
@ Inject private void init ( NodeRunnerDescriptorProvider descriptorProvider ) { if ( ! runnerRegistry . isRegistered ( NodeRunner . ID ) ) { runnerRegistry . register ( descriptorProvider . get ( ) ) ; } }
@ Inject private void init ( NodeRunnerDescriptorProvider descriptorProvider ) { if ( ! runnerRegistry . isRegistered ( NodeRunner . ID ) ) { runnerRegistry . register ( descriptorProvider . get ( ) ) ; } }
@ Override public void write ( String str , int off , int len ) { int newcount = count + len ; if ( newcount > buf . length ) { buf = Arrays . copyOf ( buf , Math . max ( buf . length << _NUM , newcount ) ) ; } str . getChars ( off , off + len , buf , count ) ; count = newcount ; }
private static void buildNameLine ( final INaviFunctionNode node , final ZyLabelContent content , final boolean showFunctionInformation ) { final INaviFunction function = node . getFunction ( ) ; String informationString = STRING ; if ( function . getBasicBlockCount ( ) > _NUM ) { final StringBuilder builder = new StringBuilder ( ) ; builder . append ( STRING ) ; builder . append ( function . getBasicBlockCount ( ) ) ; builder . append ( STRING ) ; if ( function . getBasicBlockCount ( ) > _NUM ) { builder . append ( STRING ) ; } if ( function . getEdgeCount ( ) > _NUM ) { builder . append ( STRING ) ; builder . append ( function . getEdgeCount ( ) ) ; builder . append ( STRING ) ; if ( function . getEdgeCount ( ) > _NUM ) { builder . append ( STRING ) ; } } builder . append ( STRING ) ; informationString = builder . toString ( ) ; } final ZyLineContent nameLine = new ZyLineContent ( function . getName ( ) + informationString , NORMAL_FONT , null ) ; content . addLineContent ( nameLine ) ; }
private int calculatedWeightedValue ( mxGraphAbstractHierarchyCell currentCell , Collection < mxGraphAbstractHierarchyCell > collection ) { int totalWeight = _NUM ; Iterator < mxGraphAbstractHierarchyCell > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { mxGraphAbstractHierarchyCell cell = iter . next ( ) ; if ( currentCell . isVertex ( ) && cell . isVertex ( ) ) { totalWeight ++ ; } else if ( currentCell . isEdge ( ) && cell . isEdge ( ) ) { totalWeight += _NUM ; } else { totalWeight += _NUM ; } } return totalWeight ; }
private int calculatedWeightedValue ( mxGraphAbstractHierarchyCell currentCell , Collection < mxGraphAbstractHierarchyCell > collection ) { int totalWeight = _NUM ; Iterator < mxGraphAbstractHierarchyCell > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { mxGraphAbstractHierarchyCell cell = iter . next ( ) ; if ( currentCell . isVertex ( ) && cell . isVertex ( ) ) { totalWeight ++ ; } else if ( currentCell . isEdge ( ) && cell . isEdge ( ) ) { totalWeight += _NUM ; } else { totalWeight += _NUM ; } } return totalWeight ; }
public void changedUpdate ( DocumentEvent e ) { m_ApplyButton . setEnabled ( isValidFormat ( ) ) ; }
private static final void waitForEditorToBeActive ( IEditorPart internalFileEditor , IWorkbenchPage page ) { long start = System . currentTimeMillis ( ) ; long end = start ; do { end = System . currentTimeMillis ( ) ; } while ( page . getActiveEditor ( ) != internalFileEditor && ( end - start ) < _NUM ) ; if ( page . getActiveEditor ( ) != internalFileEditor ) logger . warn ( STRING ) ; }
public static Properties readProperties ( Class clazz ) { return readProperties ( clazz . getName ( ) ) ; }
protected BackgroundTask ( long timeout , TimeUnit timeUnit ) { this . ownerFrame = null ; this . timeoutMilliseconds = timeUnit . toMillis ( timeout ) ; }
protected BackgroundTask ( long timeout , TimeUnit timeUnit ) { this . ownerFrame = null ; this . timeoutMilliseconds = timeUnit . toMillis ( timeout ) ; }
public void verifyBeanPropertyExist ( String propertyName ) throws Exception { Class clazz = Class . forName ( className ) ; String getterMethodName = generateGetterMethodName ( propertyName ) ; verifyMethodExist ( getterMethodName ) ; String setterMethodName = generateSetterMethodName ( propertyName ) ; verifyMethodExist ( setterMethodName ) ; }
public void verifyBeanPropertyExist ( String propertyName ) throws Exception { Class clazz = Class . forName ( className ) ; String getterMethodName = generateGetterMethodName ( propertyName ) ; verifyMethodExist ( getterMethodName ) ; String setterMethodName = generateSetterMethodName ( propertyName ) ; verifyMethodExist ( setterMethodName ) ; }
public void updateSuccessfulQueryTimestamp ( ) { createUserIfNull ( ) ; userEntity . setProperty ( STRING , System . currentTimeMillis ( ) ) ; service . put ( userEntity ) ; }
public static void clearTimeOfDay ( Calendar calendar ) { calendar . set ( Calendar . MILLISECOND , _NUM ) ; calendar . set ( Calendar . SECOND , _NUM ) ; calendar . set ( Calendar . MINUTE , _NUM ) ; calendar . set ( Calendar . HOUR_OF_DAY , _NUM ) ; }
public static HashProvider best ( HashParameters params ) { return best ( params , EnumSet . of ( HashSupport . STATEFUL ) ) ; }
public static HashProvider best ( HashParameters params ) { return best ( params , EnumSet . of ( HashSupport . STATEFUL ) ) ; }
public void testGetColorsByLevel ( ) { try { for ( String colorLevel : MaterialPalettes . NON_ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . ALL_COLOR_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { for ( String colorLevel : MaterialPalettes . ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . COLORS_WITH_ACCENT_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByName ( STRING ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByLevel ( null ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } }
public void testGetColorsByLevel ( ) { try { for ( String colorLevel : MaterialPalettes . NON_ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . ALL_COLOR_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { for ( String colorLevel : MaterialPalettes . ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . COLORS_WITH_ACCENT_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByName ( STRING ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByLevel ( null ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } }
public void testGetColorsByLevel ( ) { try { for ( String colorLevel : MaterialPalettes . NON_ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . ALL_COLOR_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { for ( String colorLevel : MaterialPalettes . ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . COLORS_WITH_ACCENT_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByName ( STRING ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByLevel ( null ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } }
public void testGetColorsByLevel ( ) { try { for ( String colorLevel : MaterialPalettes . NON_ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . ALL_COLOR_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { for ( String colorLevel : MaterialPalettes . ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . COLORS_WITH_ACCENT_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByName ( STRING ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByLevel ( null ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } }
public void testGetColorsByLevel ( ) { try { for ( String colorLevel : MaterialPalettes . NON_ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . ALL_COLOR_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { for ( String colorLevel : MaterialPalettes . ACCENT_COLOR_LEVELS ) { List < Integer > colors = MaterialPalettes . getColorsByLevel ( colorLevel ) ; assertEquals ( MaterialPalettes . COLORS_WITH_ACCENT_NAMES . length , colors . size ( ) ) ; } } catch ( IllegalAccessException iae ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByName ( STRING ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } try { List < Integer > colors = MaterialPalettes . getColorsByLevel ( null ) ; fail ( ) ; } catch ( IllegalArgumentException iae ) { } catch ( IllegalAccessException iae1 ) { fail ( ) ; } }
public void failoverCopy ( RPCopyRequestParams copyToFailoverTo ) throws RecoverPointException { String bookmarkName = copyToFailoverTo . getBookmarkName ( ) ; Date apitTime = copyToFailoverTo . getApitTime ( ) ; if ( bookmarkName != null ) { logger . info ( STRING + bookmarkName ) ; } else if ( apitTime != null ) { logger . info ( STRING + apitTime . toString ( ) ) ; } else { logger . info ( STRING ) ; } RecoverPointImageManagementUtils imageManager = new RecoverPointImageManagementUtils ( ) ; imageManager . enableCopyImage ( functionalAPI , copyToFailoverTo , _BOOL ) ; }
public double lengthToJava2D ( double length , Rectangle2D area , RectangleEdge edge ) { double zero = valueToJava2D ( _NUM , area , edge ) ; double l = valueToJava2D ( length , area , edge ) ; return Math . abs ( l - zero ) ; }
public double lengthToJava2D ( double length , Rectangle2D area , RectangleEdge edge ) { double zero = valueToJava2D ( _NUM , area , edge ) ; double l = valueToJava2D ( length , area , edge ) ; return Math . abs ( l - zero ) ; }
public static void o ( Zmat A ) { o ( A , Parameters . OutputFieldWidth , Parameters . OutputFracPlaces ) ; }
@ Override public Generator < ILineSegment > construct ( String [ ] args ) { return new GridGenerator ( Double . valueOf ( args [ _NUM ] ) , Double . valueOf ( args [ _NUM ] ) ) ; }
@ SkipValidation public DCBDisplayInfo prepareDisplayInfo ( ) { DCBDisplayInfo dcbDispInfo = new DCBDisplayInfo ( ) ; LOGGER . debug ( STRING ) ; List < String > reasonCategoryCodes = new ArrayList < String > ( ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_TAX ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_PENALTY ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_FINES ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_ADVANCE ) ; dcbDispInfo . setReasonCategoryCodes ( reasonCategoryCodes ) ; List < String > reasonList = new ArrayList < String > ( ) ; reasonList . addAll ( ORDERED_DEMAND_RSNS_LIST ) ; reasonList . remove ( PropertyTaxConstants . DEMANDRSN_CODE_ADVANCE ) ; dcbDispInfo . setReasonMasterCodes ( reasonList ) ; LOGGER . debug ( STRING + dcbDispInfo ) ; LOGGER . debug ( STRING + ( reasonList != null ? reasonList . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcbDispInfo ; }
@ SkipValidation public DCBDisplayInfo prepareDisplayInfo ( ) { DCBDisplayInfo dcbDispInfo = new DCBDisplayInfo ( ) ; LOGGER . debug ( STRING ) ; List < String > reasonCategoryCodes = new ArrayList < String > ( ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_TAX ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_PENALTY ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_FINES ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_ADVANCE ) ; dcbDispInfo . setReasonCategoryCodes ( reasonCategoryCodes ) ; List < String > reasonList = new ArrayList < String > ( ) ; reasonList . addAll ( ORDERED_DEMAND_RSNS_LIST ) ; reasonList . remove ( PropertyTaxConstants . DEMANDRSN_CODE_ADVANCE ) ; dcbDispInfo . setReasonMasterCodes ( reasonList ) ; LOGGER . debug ( STRING + dcbDispInfo ) ; LOGGER . debug ( STRING + ( reasonList != null ? reasonList . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcbDispInfo ; }
@ SkipValidation public DCBDisplayInfo prepareDisplayInfo ( ) { DCBDisplayInfo dcbDispInfo = new DCBDisplayInfo ( ) ; LOGGER . debug ( STRING ) ; List < String > reasonCategoryCodes = new ArrayList < String > ( ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_TAX ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_PENALTY ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_FINES ) ; reasonCategoryCodes . add ( PropertyTaxConstants . REASON_CATEGORY_CODE_ADVANCE ) ; dcbDispInfo . setReasonCategoryCodes ( reasonCategoryCodes ) ; List < String > reasonList = new ArrayList < String > ( ) ; reasonList . addAll ( ORDERED_DEMAND_RSNS_LIST ) ; reasonList . remove ( PropertyTaxConstants . DEMANDRSN_CODE_ADVANCE ) ; dcbDispInfo . setReasonMasterCodes ( reasonList ) ; LOGGER . debug ( STRING + dcbDispInfo ) ; LOGGER . debug ( STRING + ( reasonList != null ? reasonList . size ( ) : ZERO ) ) ; LOGGER . debug ( STRING ) ; return dcbDispInfo ; }
public PolynomialFunction add ( final PolynomialFunction p ) { final int lowLength = FastMath . min ( coefficients . length , p . coefficients . length ) ; final int highLength = FastMath . max ( coefficients . length , p . coefficients . length ) ; double [ ] newCoefficients = new double [ highLength ] ; for ( int i = _NUM ; i < lowLength ; ++ i ) { newCoefficients [ i ] = coefficients [ i ] + p . coefficients [ i ] ; } System . arraycopy ( ( coefficients . length < p . coefficients . length ) ? p . coefficients : coefficients , lowLength , newCoefficients , lowLength , highLength - lowLength ) ; return new PolynomialFunction ( newCoefficients ) ; }
public SimpleString [ ] split ( final char delim ) { List < SimpleString > all = null ; byte low = ( byte ) ( delim & _NUM ) ; byte high = ( byte ) ( delim > > _NUM & _NUM ) ; int lasPos = _NUM ; for ( int i = _NUM ; i < data . length ; i += _NUM ) { if ( data [ i ] == low && data [ i + _NUM ] == high ) { byte [ ] bytes = new byte [ i - lasPos ] ; System . arraycopy ( data , lasPos , bytes , _NUM , bytes . length ) ; lasPos = i + _NUM ; if ( all == null ) { all = new ArrayList < > ( _NUM ) ; } all . add ( new SimpleString ( bytes ) ) ; } } if ( all == null ) { return new SimpleString [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - lasPos ] ; System . arraycopy ( data , lasPos , bytes , _NUM , bytes . length ) ; all . add ( new SimpleString ( bytes ) ) ; SimpleString [ ] parts = new SimpleString [ all . size ( ) ] ; return all . toArray ( parts ) ; } }
public SimpleString [ ] split ( final char delim ) { List < SimpleString > all = null ; byte low = ( byte ) ( delim & _NUM ) ; byte high = ( byte ) ( delim > > _NUM & _NUM ) ; int lasPos = _NUM ; for ( int i = _NUM ; i < data . length ; i += _NUM ) { if ( data [ i ] == low && data [ i + _NUM ] == high ) { byte [ ] bytes = new byte [ i - lasPos ] ; System . arraycopy ( data , lasPos , bytes , _NUM , bytes . length ) ; lasPos = i + _NUM ; if ( all == null ) { all = new ArrayList < > ( _NUM ) ; } all . add ( new SimpleString ( bytes ) ) ; } } if ( all == null ) { return new SimpleString [ ] { this } ; } else { byte [ ] bytes = new byte [ data . length - lasPos ] ; System . arraycopy ( data , lasPos , bytes , _NUM , bytes . length ) ; all . add ( new SimpleString ( bytes ) ) ; SimpleString [ ] parts = new SimpleString [ all . size ( ) ] ; return all . toArray ( parts ) ; } }
public static List < String > fileList ( String directoryPath , boolean includeFullPath ) { List < String > fileList = new ArrayList < String > ( ) ; String dir = directoryPath . substring ( _NUM , directoryPath . lastIndexOf ( File . separator ) ) ; String pattern = StringUtils . substringAfterLast ( directoryPath , File . separator ) ; File directory = new File ( dir ) ; if ( directory . isDirectory ( ) ) { File [ ] files = directory . listFiles ( ) ; for ( int i = _NUM ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . isFile ( ) ) { String fileName = f . getName ( ) ; String fullPath = dir + File . separator + fileName ; if ( fileName . matches ( convertGlobToRegEx ( pattern ) ) ) { if ( includeFullPath ) { fileList . add ( fullPath ) ; } else { fileList . add ( fileName ) ; } } } } } return fileList ; }
public static List < String > fileList ( String directoryPath , boolean includeFullPath ) { List < String > fileList = new ArrayList < String > ( ) ; String dir = directoryPath . substring ( _NUM , directoryPath . lastIndexOf ( File . separator ) ) ; String pattern = StringUtils . substringAfterLast ( directoryPath , File . separator ) ; File directory = new File ( dir ) ; if ( directory . isDirectory ( ) ) { File [ ] files = directory . listFiles ( ) ; for ( int i = _NUM ; i < files . length ; i ++ ) { File f = files [ i ] ; if ( f . isFile ( ) ) { String fileName = f . getName ( ) ; String fullPath = dir + File . separator + fileName ; if ( fileName . matches ( convertGlobToRegEx ( pattern ) ) ) { if ( includeFullPath ) { fileList . add ( fullPath ) ; } else { fileList . add ( fileName ) ; } } } } } return fileList ; }
public SearchSourceBuilder aggregation ( AbstractAggregationBuilder aggregation ) { if ( aggregations == null ) { aggregations = new ArrayList < > ( ) ; } aggregations . add ( aggregation ) ; return this ; }
public static < E extends Identifiable > E findByPrimaryKey ( EntityManager em , BigInteger id , Class < E > type ) { requireArgument ( em != null , STRING ) ; requireArgument ( id != null && id . compareTo ( ZERO ) > _NUM , STRING ) ; requireArgument ( type != null , STRING ) ; TypedQuery < E > query = em . createNamedQuery ( STRING , type ) ; query . setHint ( STRING , STRING ) ; try { query . setParameter ( STRING , id ) ; query . setParameter ( STRING , _BOOL ) ; return query . getSingleResult ( ) ; } catch ( NoResultException ex ) { return null ; } }
public static < E extends Identifiable > E findByPrimaryKey ( EntityManager em , BigInteger id , Class < E > type ) { requireArgument ( em != null , STRING ) ; requireArgument ( id != null && id . compareTo ( ZERO ) > _NUM , STRING ) ; requireArgument ( type != null , STRING ) ; TypedQuery < E > query = em . createNamedQuery ( STRING , type ) ; query . setHint ( STRING , STRING ) ; try { query . setParameter ( STRING , id ) ; query . setParameter ( STRING , _BOOL ) ; return query . getSingleResult ( ) ; } catch ( NoResultException ex ) { return null ; } }
public void addElement ( AstNode element ) { assertNotNull ( element ) ; if ( elements == null ) elements = new ArrayList < AstNode > ( ) ; elements . add ( element ) ; element . setParent ( this ) ; }
public void addElement ( AstNode element ) { assertNotNull ( element ) ; if ( elements == null ) elements = new ArrayList < AstNode > ( ) ; elements . add ( element ) ; element . setParent ( this ) ; }
public long cstime ( ) { return Long . parseLong ( fields [ _NUM ] ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = _NUM ; while ( i < n ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = _NUM ; while ( i < n ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = _NUM ; while ( i < n ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int n = val . size ( ) ; int i = _NUM ; while ( i < n ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
protected void parseMemberName ( final String [ ] args ) { for ( String arg : args ) { if ( ! ( arg . startsWith ( OPTION_PREFIX ) || Command . isCommand ( arg ) ) ) { setMemberName ( arg ) ; break ; } } }
protected void parseMemberName ( final String [ ] args ) { for ( String arg : args ) { if ( ! ( arg . startsWith ( OPTION_PREFIX ) || Command . isCommand ( arg ) ) ) { setMemberName ( arg ) ; break ; } } }
protected void calcPositions ( ) { for ( int index = _NUM ; index < vertexArray . length ; index ++ ) { if ( isMoveable [ index ] ) { double deltaLength = Math . sqrt ( dispX [ index ] * dispX [ index ] + dispY [ index ] * dispY [ index ] ) ; if ( deltaLength < _NUM ) { deltaLength = _NUM ; } double newXDisp = dispX [ index ] / deltaLength * Math . min ( deltaLength , temperature ) ; double newYDisp = dispY [ index ] / deltaLength * Math . min ( deltaLength , temperature ) ; dispX [ index ] = _NUM ; dispY [ index ] = _NUM ; cellLocation [ index ] [ _NUM ] += newXDisp ; cellLocation [ index ] [ _NUM ] += newYDisp ; } } }
protected void calcPositions ( ) { for ( int index = _NUM ; index < vertexArray . length ; index ++ ) { if ( isMoveable [ index ] ) { double deltaLength = Math . sqrt ( dispX [ index ] * dispX [ index ] + dispY [ index ] * dispY [ index ] ) ; if ( deltaLength < _NUM ) { deltaLength = _NUM ; } double newXDisp = dispX [ index ] / deltaLength * Math . min ( deltaLength , temperature ) ; double newYDisp = dispY [ index ] / deltaLength * Math . min ( deltaLength , temperature ) ; dispX [ index ] = _NUM ; dispY [ index ] = _NUM ; cellLocation [ index ] [ _NUM ] += newXDisp ; cellLocation [ index ] [ _NUM ] += newYDisp ; } } }
public static Arguments parseArgs ( final String args ) { Map < String , String > parsed = new HashMap < > ( ) ; for ( String argPair : args . split ( STRING ) ) { String [ ] tokens = argPair . split ( STRING ) ; if ( tokens . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } parsed . put ( tokens [ _NUM ] , tokens [ _NUM ] ) ; } for ( String requiredArg : REQUIRED ) { if ( ! parsed . containsKey ( requiredArg ) ) { throw new IllegalArgumentException ( String . format ( STRING , requiredArg ) ) ; } } return new Arguments ( parsed ) ; }
public static Arguments parseArgs ( final String args ) { Map < String , String > parsed = new HashMap < > ( ) ; for ( String argPair : args . split ( STRING ) ) { String [ ] tokens = argPair . split ( STRING ) ; if ( tokens . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } parsed . put ( tokens [ _NUM ] , tokens [ _NUM ] ) ; } for ( String requiredArg : REQUIRED ) { if ( ! parsed . containsKey ( requiredArg ) ) { throw new IllegalArgumentException ( String . format ( STRING , requiredArg ) ) ; } } return new Arguments ( parsed ) ; }
public boolean unregisterClient ( UnregisterProfile profile , ServerConfig utils , Context context , APIResultCallBack apiResultCallback ) throws AndroidAgentException { StringBuilder endPoint = new StringBuilder ( ) ; endPoint . append ( utils . getAPIServerURL ( context ) ) ; endPoint . append ( Constants . DYNAMIC_CLIENT_REGISTER_ENDPOINT ) ; endPoint . append ( STRING + USER_ID + STRING + profile . getUserId ( ) ) ; endPoint . append ( STRING + CONSUMER_KEY + STRING + profile . getConsumerKey ( ) ) ; endPoint . append ( STRING + APPLICATION_NAME + STRING + profile . getApplicationName ( ) ) ; EndPointInfo endPointInfo = new EndPointInfo ( ) ; endPointInfo . setHttpMethod ( org . wso2 . emm . agent . proxy . utils . Constants . HTTP_METHODS . DELETE ) ; endPointInfo . setEndPoint ( endPoint . toString ( ) ) ; sendRequest ( endPointInfo , apiResultCallback , Constants . DYNAMIC_CLIENT_UNREGISTER_REQUEST_CODE ) ; return _BOOL ; }
private boolean peerExists ( String id ) { if ( id == null ) return _BOOL ; for ( Peer peer : peerList ) { if ( id . equals ( peer . getPeerId ( ) ) ) { return _BOOL ; } } return _BOOL ; }
public void testSetIssuersLjava_util_Collection ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STRING ) ; X500Principal iss2 = new X500Principal ( STRING ) ; X500Principal iss3 = new X500Principal ( STRING ) ; TestCRL crl1 = new TestCRL ( iss1 ) ; TestCRL crl2 = new TestCRL ( iss2 ) ; TestCRL crl3 = new TestCRL ( iss3 ) ; selector . setIssuers ( null ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; ArrayList < X500Principal > issuers = new ArrayList < X500Principal > ( _NUM ) ; issuers . add ( iss1 ) ; issuers . add ( iss2 ) ; selector . setIssuers ( issuers ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; assertFalse ( STRING , selector . match ( crl3 ) ) ; issuers . add ( iss3 ) ; assertFalse ( STRING + STRING , selector . match ( crl3 ) ) ; }
public void testSetIssuersLjava_util_Collection ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STRING ) ; X500Principal iss2 = new X500Principal ( STRING ) ; X500Principal iss3 = new X500Principal ( STRING ) ; TestCRL crl1 = new TestCRL ( iss1 ) ; TestCRL crl2 = new TestCRL ( iss2 ) ; TestCRL crl3 = new TestCRL ( iss3 ) ; selector . setIssuers ( null ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; ArrayList < X500Principal > issuers = new ArrayList < X500Principal > ( _NUM ) ; issuers . add ( iss1 ) ; issuers . add ( iss2 ) ; selector . setIssuers ( issuers ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; assertFalse ( STRING , selector . match ( crl3 ) ) ; issuers . add ( iss3 ) ; assertFalse ( STRING + STRING , selector . match ( crl3 ) ) ; }
public void testSetIssuersLjava_util_Collection ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STRING ) ; X500Principal iss2 = new X500Principal ( STRING ) ; X500Principal iss3 = new X500Principal ( STRING ) ; TestCRL crl1 = new TestCRL ( iss1 ) ; TestCRL crl2 = new TestCRL ( iss2 ) ; TestCRL crl3 = new TestCRL ( iss3 ) ; selector . setIssuers ( null ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; ArrayList < X500Principal > issuers = new ArrayList < X500Principal > ( _NUM ) ; issuers . add ( iss1 ) ; issuers . add ( iss2 ) ; selector . setIssuers ( issuers ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; assertFalse ( STRING , selector . match ( crl3 ) ) ; issuers . add ( iss3 ) ; assertFalse ( STRING + STRING , selector . match ( crl3 ) ) ; }
public void testSetIssuersLjava_util_Collection ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STRING ) ; X500Principal iss2 = new X500Principal ( STRING ) ; X500Principal iss3 = new X500Principal ( STRING ) ; TestCRL crl1 = new TestCRL ( iss1 ) ; TestCRL crl2 = new TestCRL ( iss2 ) ; TestCRL crl3 = new TestCRL ( iss3 ) ; selector . setIssuers ( null ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; ArrayList < X500Principal > issuers = new ArrayList < X500Principal > ( _NUM ) ; issuers . add ( iss1 ) ; issuers . add ( iss2 ) ; selector . setIssuers ( issuers ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; assertFalse ( STRING , selector . match ( crl3 ) ) ; issuers . add ( iss3 ) ; assertFalse ( STRING + STRING , selector . match ( crl3 ) ) ; }
public void testSetIssuersLjava_util_Collection ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; X500Principal iss1 = new X500Principal ( STRING ) ; X500Principal iss2 = new X500Principal ( STRING ) ; X500Principal iss3 = new X500Principal ( STRING ) ; TestCRL crl1 = new TestCRL ( iss1 ) ; TestCRL crl2 = new TestCRL ( iss2 ) ; TestCRL crl3 = new TestCRL ( iss3 ) ; selector . setIssuers ( null ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; ArrayList < X500Principal > issuers = new ArrayList < X500Principal > ( _NUM ) ; issuers . add ( iss1 ) ; issuers . add ( iss2 ) ; selector . setIssuers ( issuers ) ; assertTrue ( STRING , selector . match ( crl1 ) && selector . match ( crl2 ) ) ; assertFalse ( STRING , selector . match ( crl3 ) ) ; issuers . add ( iss3 ) ; assertFalse ( STRING + STRING , selector . match ( crl3 ) ) ; }
private String liveness ( ) { boolean isClosed = _BOOL ; try { if ( isClosed ( ) ) { isClosed = _BOOL ; } } catch ( SQLException s ) { isClosed = _BOOL ; } if ( isClosed ) { return STRING ; } return STRING ; }
public Type1Font ( String platname , Object nativeNames , boolean createdCopy ) throws FontFormatException { super ( platname , nativeNames ) ; fontRank = Font2D . TYPE1_RANK ; checkedNatives = _BOOL ; try { verify ( ) ; } catch ( Throwable t ) { if ( createdCopy ) { T1DisposerRecord ref = new T1DisposerRecord ( platname ) ; Disposer . addObjectRecord ( bufferRef , ref ) ; bufferRef = null ; } if ( t instanceof FontFormatException ) { throw ( FontFormatException ) t ; } else { throw new FontFormatException ( STRING ) ; } } }
public static Vector < String > find ( Class < ? > cls , String [ ] pkgnames ) { Vector < String > result ; int i ; HashSet < String > names ; result = new Vector < String > ( ) ; names = new HashSet < String > ( ) ; for ( i = _NUM ; i < pkgnames . length ; i ++ ) { names . addAll ( find ( cls , pkgnames [ i ] ) ) ; } result . addAll ( names ) ; Collections . sort ( result , new StringCompare ( ) ) ; return result ; }
public static Vector < String > find ( Class < ? > cls , String [ ] pkgnames ) { Vector < String > result ; int i ; HashSet < String > names ; result = new Vector < String > ( ) ; names = new HashSet < String > ( ) ; for ( i = _NUM ; i < pkgnames . length ; i ++ ) { names . addAll ( find ( cls , pkgnames [ i ] ) ) ; } result . addAll ( names ) ; Collections . sort ( result , new StringCompare ( ) ) ; return result ; }
private boolean canBeNarrowingPrimitiveConversion ( TypeMirror type ) { TypeMirror unboxedType = TypesUtils . isBoxedPrimitive ( type ) ? types . unboxedType ( type ) : type ; TypeKind unboxedKind = unboxedType . getKind ( ) ; return unboxedKind == TypeKind . BYTE || unboxedKind == TypeKind . SHORT || unboxedKind == TypeKind . CHAR ; }
private boolean canBeNarrowingPrimitiveConversion ( TypeMirror type ) { TypeMirror unboxedType = TypesUtils . isBoxedPrimitive ( type ) ? types . unboxedType ( type ) : type ; TypeKind unboxedKind = unboxedType . getKind ( ) ; return unboxedKind == TypeKind . BYTE || unboxedKind == TypeKind . SHORT || unboxedKind == TypeKind . CHAR ; }
public void markErrorLogin ( String clientIP ) { if ( isDisabled ( ) ) { return ; } if ( null != clientIP && ! clientIP . isEmpty ( ) ) { String zkPath = getZkPath ( clientIP ) ; InterProcessLock lock = null ; try { lock = _coordinator . getLock ( INVALID_LOGIN_CLEANER_LOCK ) ; lock . acquire ( ) ; _log . debug ( STRING ) ; InvalidLogins invLogins = ( InvalidLogins ) _distDataManager . getData ( zkPath , _BOOL ) ; if ( null == invLogins ) { _distDataManager . createNode ( zkPath , _BOOL ) ; invLogins = new InvalidLogins ( clientIP , getCurrentTimeInMins ( ) , _NUM ) ; _log . debug ( STRING , clientIP ) ; } else { invLogins . incrementErrorLoginCount ( ) ; } invLogins . setLastAccessTimeInLong ( getCurrentTimeInMins ( ) ) ; _log . debug ( STRING , clientIP ) ; _distDataManager . putData ( zkPath , invLogins ) ; } catch ( Exception ex ) { _log . error ( STRING , clientIP , ex ) ; } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception ex ) { _log . error ( STRING , ex ) ; } } } } else { _log . error ( STRING ) ; } return ; }
public void markErrorLogin ( String clientIP ) { if ( isDisabled ( ) ) { return ; } if ( null != clientIP && ! clientIP . isEmpty ( ) ) { String zkPath = getZkPath ( clientIP ) ; InterProcessLock lock = null ; try { lock = _coordinator . getLock ( INVALID_LOGIN_CLEANER_LOCK ) ; lock . acquire ( ) ; _log . debug ( STRING ) ; InvalidLogins invLogins = ( InvalidLogins ) _distDataManager . getData ( zkPath , _BOOL ) ; if ( null == invLogins ) { _distDataManager . createNode ( zkPath , _BOOL ) ; invLogins = new InvalidLogins ( clientIP , getCurrentTimeInMins ( ) , _NUM ) ; _log . debug ( STRING , clientIP ) ; } else { invLogins . incrementErrorLoginCount ( ) ; } invLogins . setLastAccessTimeInLong ( getCurrentTimeInMins ( ) ) ; _log . debug ( STRING , clientIP ) ; _distDataManager . putData ( zkPath , invLogins ) ; } catch ( Exception ex ) { _log . error ( STRING , clientIP , ex ) ; } finally { if ( lock != null ) { try { lock . release ( ) ; } catch ( Exception ex ) { _log . error ( STRING , ex ) ; } } } } else { _log . error ( STRING ) ; } return ; }
public static LngLat normalizeLngLat ( LngLat p1 ) { if ( p1 . longitude < Util . MIN_LON || p1 . longitude > Util . MAX_LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN_LON ) / Util . LON_PER_WORLD ) ; p1 . longitude -= wraps * Util . LON_PER_WORLD ; } return p1 ; }
public static LngLat normalizeLngLat ( LngLat p1 ) { if ( p1 . longitude < Util . MIN_LON || p1 . longitude > Util . MAX_LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN_LON ) / Util . LON_PER_WORLD ) ; p1 . longitude -= wraps * Util . LON_PER_WORLD ; } return p1 ; }
public static LngLat normalizeLngLat ( LngLat p1 ) { if ( p1 . longitude < Util . MIN_LON || p1 . longitude > Util . MAX_LON ) { int wraps = ( int ) Math . floor ( ( p1 . longitude - Util . MIN_LON ) / Util . LON_PER_WORLD ) ; p1 . longitude -= wraps * Util . LON_PER_WORLD ; } return p1 ; }
public static Object serializeClone ( final Object obj ) throws IOException , ClassNotFoundException { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; ByteArrayInputStream src = new ByteArrayInputStream ( memOut . toByteArray ( ) ) ; ObjectInputStream objIs = new ObjectInputStream ( src ) ; return objIs . readObject ( ) ; }
public static Object serializeClone ( final Object obj ) throws IOException , ClassNotFoundException { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; ByteArrayInputStream src = new ByteArrayInputStream ( memOut . toByteArray ( ) ) ; ObjectInputStream objIs = new ObjectInputStream ( src ) ; return objIs . readObject ( ) ; }
public static boolean deleteDirectorySubdirectories ( String rootDirectory ) { if ( ( rootDirectory == null ) ) { return _BOOL ; } boolean didSuccessfullyDeleteAllDirectories = _BOOL ; try { List < File > files = getListOfFilesInADirectory ( rootDirectory ) ; for ( File file : files ) { if ( file . isDirectory ( ) ) { boolean deleteSuccess = deleteDirectoryAndContents ( file ) ; if ( ! deleteSuccess ) { logger . debug ( STRING + file . getAbsolutePath ( ) ) ; didSuccessfullyDeleteAllDirectories = _BOOL ; } } } } catch ( Exception e ) { logger . debug ( e . toString ( ) + System . lineSeparator ( ) + StackTrace . getStringFromStackTrace ( e ) ) ; return _BOOL ; } return didSuccessfullyDeleteAllDirectories ; }
public void writeField ( final String name , final double value ) throws java . io . IOException { writeField ( name , Double . toString ( value ) ) ; }
private long startWait ( ) { return System . nanoTime ( ) ; }
private void initialize ( URI p_other ) { m_scheme = p_other . getScheme ( ) ; m_userinfo = p_other . getUserinfo ( ) ; m_host = p_other . getHost ( ) ; m_port = p_other . getPort ( ) ; m_path = p_other . getPath ( ) ; m_queryString = p_other . getQueryString ( ) ; m_fragment = p_other . getFragment ( ) ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
EdgeMap < Block > findLoops ( Deque < Block > code , Map < Block , Block > idom , SetMap < Block , Edge > pred ) { EdgeMap < Block > loops = new EdgeMap < Block > ( ) ; for ( Block b : code ) for ( Edge s : b . succ ( ) ) if ( isLoop ( s , idom ) ) { verboseStatus ( STRING + s ) ; Block h = s . to ; Set < Block > loop = loops . get ( h ) ; Set < Block > work = new TreeSet < Block > ( ) ; for ( Edge p : pred . get ( h ) ) { if ( isLoop ( p , idom ) && ! loop . contains ( p . from ) && p . from != h ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } while ( ! work . isEmpty ( ) ) { Block x = getBlock ( work ) ; for ( Edge p : pred . get ( x ) ) { if ( p . from != h && ! loop . contains ( p . from ) ) { loop . add ( p . from ) ; work . add ( p . from ) ; } } } } return loops ; }
public synchronized void insertAudio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , byte [ ] audio ) throws SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupAudio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setBytes ( _NUM , audio ) ; st . executeUpdate ( ) ; st . close ( ) ; }
public synchronized void insertAudio ( String inputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext , byte [ ] audio ) throws SQLException { if ( inputtype == null || locale == null || voice == null || inputtext == null ) { throw new NullPointerException ( STRING ) ; } if ( lookupAudio ( inputtype , locale , voice , outputparams , style , effects , inputtext ) != null ) { return ; } String query = STRING + inputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; st . setBytes ( _NUM , audio ) ; st . executeUpdate ( ) ; st . close ( ) ; }
private List < Entry > readFeed ( XmlPullParser parser ) throws XmlPullParserException , IOException , ParseException { List < Entry > entries = new ArrayList < > ( ) ; parser . require ( XmlPullParser . START_TAG , ns , STRING ) ; while ( parser . next ( ) != XmlPullParser . END_TAG ) { if ( parser . getEventType ( ) != XmlPullParser . START_TAG ) { continue ; } String name = parser . getName ( ) ; if ( name . equals ( STRING ) ) { entries . add ( readEntry ( parser ) ) ; } else { skip ( parser ) ; } } return entries ; }
public StemmedString ( CharSequence orig , String stemmed ) { strOrig = orig . toString ( ) ; strStemmed = stemmed ; }
protected static double calcSigmaFromMu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < _NUM ) { sigma = _NUM ; } return sigma ; }
protected static double calcSigmaFromMu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < _NUM ) { sigma = _NUM ; } return sigma ; }
protected static double calcSigmaFromMu ( double mu ) { double sigma = Math . sqrt ( mu ) ; if ( sigma < _NUM ) { sigma = _NUM ; } return sigma ; }
public IntervalCategoryToolTipGenerator ( ) { super ( DEFAULT_TOOL_TIP_FORMAT_STRING , NumberFormat . getInstance ( ) ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
public static String strip ( String s ) { return s . replaceAll ( STRING , STRING ) ; }
@ Override public void trim ( MemoryTrimType trimType ) { ArrayList < Entry < K , V > > oldEntries ; final double trimRatio = mCacheTrimStrategy . getTrimRatio ( trimType ) ; synchronized ( this ) { int targetCacheSize = ( int ) ( mCachedEntries . getSizeInBytes ( ) * ( _NUM - trimRatio ) ) ; int targetEvictionQueueSize = Math . max ( _NUM , targetCacheSize - getInUseSizeInBytes ( ) ) ; oldEntries = trimExclusivelyOwnedEntries ( Integer . MAX_VALUE , targetEvictionQueueSize ) ; makeOrphans ( oldEntries ) ; } maybeClose ( oldEntries ) ; maybeNotifyExclusiveEntryRemoval ( oldEntries ) ; maybeUpdateCacheParams ( ) ; maybeEvictEntries ( ) ; }
public BlockSwapper ( World world , EntityPlayer player , ItemStack truncator , BlockPos origCoords , int range , boolean leaves ) { this . world = world ; this . player = player ; this . truncator = truncator ; this . origin = origCoords ; this . range = range ; this . treatLeavesSpecial = leaves ; this . candidateQueue = new PriorityQueue < > ( ) ; this . completedCoords = new HashSet < > ( ) ; candidateQueue . offer ( new SwapCandidate ( this . origin , this . range ) ) ; }
public static double createDoubleSetting ( final Map < String , String > rawSettings , final String settingName , final double defaultValue ) { final String settingString = rawSettings . get ( settingName ) ; if ( settingString == null ) { return defaultValue ; } else { try { return Double . parseDouble ( settingString ) ; } catch ( final NumberFormatException exception ) { CUtilityFunctions . logException ( exception ) ; return defaultValue ; } } }
public List < LinearConstraint > normalizeConstraints ( Collection < LinearConstraint > originalConstraints ) { List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size ( ) ) ; for ( LinearConstraint constraint : originalConstraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }
public List < LinearConstraint > normalizeConstraints ( Collection < LinearConstraint > originalConstraints ) { List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size ( ) ) ; for ( LinearConstraint constraint : originalConstraints ) { normalized . add ( normalize ( constraint ) ) ; } return normalized ; }
private Parsed currentParsed ( ) { return parsed . get ( parsed . size ( ) - _NUM ) ; }
@ Override protected String extractKey ( final String name ) { final String key = unescape ( name . substring ( _NUM , name . length ( ) - _NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
@ Override protected String extractKey ( final String name ) { final String key = unescape ( name . substring ( _NUM , name . length ( ) - _NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
@ Override protected String extractKey ( final String name ) { final String key = unescape ( name . substring ( _NUM , name . length ( ) - _NUM ) ) ; return key . equals ( STRING ) ? null : key ; }
private void drawGuideLine ( @ NonNull Canvas canvas ) { float offset = ( float ) ( mRadius / Math . sqrt ( _NUM ) ) ; float topLeftPointX = mCenterPointX - offset ; float topLeftPointY = mCenterPointY - offset ; float topRightPointX = mCenterPointX + offset ; float bottomLeftPointY = mCenterPointY + offset ; canvas . drawLine ( topLeftPointX , topLeftPointY , topRightPointX , topLeftPointY , mGuideLinePaint ) ; canvas . drawLine ( mCenterPointX - mRadius , mCenterPointY , mCenterPointX + mRadius , mCenterPointY , mGuideLinePaint ) ; canvas . drawLine ( topLeftPointX , bottomLeftPointY , topRightPointX , bottomLeftPointY , mGuideLinePaint ) ; canvas . drawLine ( topLeftPointX , topLeftPointY , topLeftPointX , bottomLeftPointY , mGuideLinePaint ) ; canvas . drawLine ( mCenterPointX , mCenterPointY - mRadius , mCenterPointX , mCenterPointY + mRadius , mGuideLinePaint ) ; canvas . drawLine ( topRightPointX , topLeftPointY , topRightPointX , bottomLeftPointY , mGuideLinePaint ) ; }
public void writeTimerReport ( XMLWriter writer ) { writer . writeOpenTag ( STRING ) ; writer . writeOpenTag ( STRING , new Attribute . Default < String > ( STRING , STRING ) ) ; writer . writeIDref ( STRING , STRING ) ; writer . writeCloseTag ( STRING ) ; writer . writeCloseTag ( STRING ) ; }
@ Override default CompletableFuture < OptionalInt > maxInt ( final ToIntFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
public final static int readRawUntil ( final StringBuilder out , final String in , final int start , final char end ) { int pos = start ; while ( pos < in . length ( ) ) { final char ch = in . charAt ( pos ) ; if ( ch == end ) { break ; } out . append ( ch ) ; pos ++ ; } return ( pos == in . length ( ) ) ? - _NUM : pos ; }
public void handleTblSupportedContainerButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; WSPPServiceSupportedContainerAddViewBean vb = ( WSPPServiceSupportedContainerAddViewBean ) getViewBean ( WSPPServiceSupportedContainerAddViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STRING , e . getMessage ( ) ) ; forwardTo ( ) ; } }
public void handleTblSupportedContainerButtonAddRequest ( RequestInvocationEvent event ) throws ModelControlException { try { Map values = getValues ( ) ; onBeforeSaveProfile ( values ) ; setPageSessionAttribute ( PROPERTY_ATTRIBUTE , ( HashMap ) values ) ; WSPPServiceSupportedContainerAddViewBean vb = ( WSPPServiceSupportedContainerAddViewBean ) getViewBean ( WSPPServiceSupportedContainerAddViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; } catch ( AMConsoleException e ) { setInlineAlertMessage ( CCAlert . TYPE_ERROR , STRING , e . getMessage ( ) ) ; forwardTo ( ) ; } }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
public boolean init ( StepMetaInterface smi , StepDataInterface sdi ) { this . meta = ( ( SortKeyStepMeta ) smi ) ; this . data = ( ( SortKeyStepData ) sdi ) ; return super . init ( smi , sdi ) ; }
public static List < List < File > > findJavaFilesPerDirectory ( File parent , String ... dirNames ) { List < List < File > > filesPerDirectory = new ArrayList < > ( ) ; for ( String dirName : dirNames ) { File dir = new File ( parent , dirName ) ; if ( dir . isDirectory ( ) ) { filesPerDirectory . addAll ( findJavaTestFilesInDirectory ( dir ) ) ; } } return filesPerDirectory ; }
public static List < List < File > > findJavaFilesPerDirectory ( File parent , String ... dirNames ) { List < List < File > > filesPerDirectory = new ArrayList < > ( ) ; for ( String dirName : dirNames ) { File dir = new File ( parent , dirName ) ; if ( dir . isDirectory ( ) ) { filesPerDirectory . addAll ( findJavaTestFilesInDirectory ( dir ) ) ; } } return filesPerDirectory ; }
private HashMap < String , String > readConfig ( String configPath ) throws Exception { log . debug ( STRING + configPath ) ; File configFile = new File ( configPath ) ; if ( ! configFile . isFile ( ) ) return null ; ConfigReader reader = new ConfigReader ( ) ; reader . readConfig ( configPath ) ; return reader . getConfigMap ( ) ; }
public void fillDefaultValues ( ) { tfActivationProbability . setText ( Double . toString ( PROTOTYPE_RESPONDER . getActivationProbability ( ) ) ) ; tfResponseValue . setText ( Double . toString ( PROTOTYPE_RESPONDER . getActivationProbability ( ) ) ) ; }
public void fillDefaultValues ( ) { tfActivationProbability . setText ( Double . toString ( PROTOTYPE_RESPONDER . getActivationProbability ( ) ) ) ; tfResponseValue . setText ( Double . toString ( PROTOTYPE_RESPONDER . getActivationProbability ( ) ) ) ; }
protected Date compute ( double value ) { if ( Double . isNaN ( value ) ) { return null ; } long dateLong = ( long ) value ; Date date = new Date ( dateLong ) ; Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( date ) ; return cal . getTime ( ) ; }
public void roll ( int field , int value ) { boolean increment = value >= _NUM ; int count = increment ? value : - value ; for ( int i = _NUM ; i < count ; i ++ ) { roll ( field , increment ) ; } }
public SabresQuery ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . getSimpleName ( ) ; innerQueries = null ; }
public SabresQuery ( Class < T > clazz ) { this . clazz = clazz ; name = clazz . getSimpleName ( ) ; innerQueries = null ; }
private void drawAutoHit ( Graphics g , Coords hex ) { int baseX = ( hex . getX ( ) * ( hexSide [ zoom ] + hexSideBySin30 [ zoom ] ) ) + leftMargin + hexSide [ zoom ] ; int baseY = ( ( ( _NUM * hex . getY ( ) ) + _NUM + ( hex . getX ( ) % _NUM ) ) * hexSideByCos30 [ zoom ] ) + topMargin ; Color alt = g . getColor ( ) ; g . setColor ( Color . RED ) ; g . drawOval ( baseX - ( unitSize - _NUM ) , baseY - ( unitSize - _NUM ) , ( _NUM * unitSize ) - _NUM , ( _NUM * unitSize ) - _NUM ) ; g . drawLine ( baseX - unitSize - _NUM , baseY , ( baseX - unitSize ) + _NUM , baseY ) ; g . drawLine ( baseX + unitSize + _NUM , baseY , ( baseX + unitSize ) - _NUM , baseY ) ; g . drawLine ( baseX , baseY - unitSize - _NUM , baseX , ( baseY - unitSize ) + _NUM ) ; g . drawLine ( baseX , baseY + unitSize + _NUM , baseX , ( baseY + unitSize ) - _NUM ) ; g . setColor ( alt ) ; }
private void drawAutoHit ( Graphics g , Coords hex ) { int baseX = ( hex . getX ( ) * ( hexSide [ zoom ] + hexSideBySin30 [ zoom ] ) ) + leftMargin + hexSide [ zoom ] ; int baseY = ( ( ( _NUM * hex . getY ( ) ) + _NUM + ( hex . getX ( ) % _NUM ) ) * hexSideByCos30 [ zoom ] ) + topMargin ; Color alt = g . getColor ( ) ; g . setColor ( Color . RED ) ; g . drawOval ( baseX - ( unitSize - _NUM ) , baseY - ( unitSize - _NUM ) , ( _NUM * unitSize ) - _NUM , ( _NUM * unitSize ) - _NUM ) ; g . drawLine ( baseX - unitSize - _NUM , baseY , ( baseX - unitSize ) + _NUM , baseY ) ; g . drawLine ( baseX + unitSize + _NUM , baseY , ( baseX + unitSize ) - _NUM , baseY ) ; g . drawLine ( baseX , baseY - unitSize - _NUM , baseX , ( baseY - unitSize ) + _NUM ) ; g . drawLine ( baseX , baseY + unitSize + _NUM , baseX , ( baseY + unitSize ) - _NUM ) ; g . setColor ( alt ) ; }
private void addFacilityToHashMap ( ActivityFacilityImpl facility ) { Id < Link > facilityLink = getClosestLink ( facility ) ; assureHashMapInitializedForLink ( facilityLink ) ; ArrayList < ActivityFacilityImpl > list = linkFacilityMapping . get ( facilityLink ) ; list . add ( facility ) ; }
private void addFacilityToHashMap ( ActivityFacilityImpl facility ) { Id < Link > facilityLink = getClosestLink ( facility ) ; assureHashMapInitializedForLink ( facilityLink ) ; ArrayList < ActivityFacilityImpl > list = linkFacilityMapping . get ( facilityLink ) ; list . add ( facility ) ; }
public String toString ( ) { StringBuffer result = new StringBuffer ( ipAddress . toString ( ) ) ; result . append ( STRING ) ; result . append ( extendedNetworkPrefix ) ; return result . toString ( ) ; }
private boolean canAccess ( ) { if ( Binder . getCallingPid ( ) == Process . myPid ( ) ) { return _BOOL ; } else { return PreferencesUtils . getBoolean ( getContext ( ) , R . string . allow_access_key , PreferencesUtils . ALLOW_ACCESS_DEFAULT ) ; } }
private boolean canAccess ( ) { if ( Binder . getCallingPid ( ) == Process . myPid ( ) ) { return _BOOL ; } else { return PreferencesUtils . getBoolean ( getContext ( ) , R . string . allow_access_key , PreferencesUtils . ALLOW_ACCESS_DEFAULT ) ; } }
private static String fixImportStatement ( String importStatementOnDemand ) { if ( importStatementOnDemand . endsWith ( STRING ) ) { return importStatementOnDemand . substring ( _NUM , importStatementOnDemand . length ( ) - _NUM ) ; } else { boolean hasClassname = StringUtil . hasUpperCaseChar ( importStatementOnDemand ) ; if ( hasClassname ) { int pos = importStatementOnDemand . lastIndexOf ( STRING ) ; return importStatementOnDemand . substring ( _NUM , pos ) ; } else { return importStatementOnDemand ; } } }
private static String fixImportStatement ( String importStatementOnDemand ) { if ( importStatementOnDemand . endsWith ( STRING ) ) { return importStatementOnDemand . substring ( _NUM , importStatementOnDemand . length ( ) - _NUM ) ; } else { boolean hasClassname = StringUtil . hasUpperCaseChar ( importStatementOnDemand ) ; if ( hasClassname ) { int pos = importStatementOnDemand . lastIndexOf ( STRING ) ; return importStatementOnDemand . substring ( _NUM , pos ) ; } else { return importStatementOnDemand ; } } }
private static String fixImportStatement ( String importStatementOnDemand ) { if ( importStatementOnDemand . endsWith ( STRING ) ) { return importStatementOnDemand . substring ( _NUM , importStatementOnDemand . length ( ) - _NUM ) ; } else { boolean hasClassname = StringUtil . hasUpperCaseChar ( importStatementOnDemand ) ; if ( hasClassname ) { int pos = importStatementOnDemand . lastIndexOf ( STRING ) ; return importStatementOnDemand . substring ( _NUM , pos ) ; } else { return importStatementOnDemand ; } } }
public static boolean confirmAction ( String i18nKey , String propertyKey , Object ... arguments ) { String propValue = ParameterService . getParameterValue ( propertyKey ) ; if ( propValue != null ) { if ( propValue . equals ( VALUE_TRUE ) ) { return _BOOL ; } else if ( propValue . equals ( VALUE_FALSE ) ) { return _BOOL ; } } DecisionRememberingConfirmDialog d = new DecisionRememberingConfirmDialog ( i18nKey , propertyKey , DialogType . CONFIRM , arguments ) ; d . setVisible ( _BOOL ) ; return d . confirmed ; }
public static boolean confirmAction ( String i18nKey , String propertyKey , Object ... arguments ) { String propValue = ParameterService . getParameterValue ( propertyKey ) ; if ( propValue != null ) { if ( propValue . equals ( VALUE_TRUE ) ) { return _BOOL ; } else if ( propValue . equals ( VALUE_FALSE ) ) { return _BOOL ; } } DecisionRememberingConfirmDialog d = new DecisionRememberingConfirmDialog ( i18nKey , propertyKey , DialogType . CONFIRM , arguments ) ; d . setVisible ( _BOOL ) ; return d . confirmed ; }
public static boolean confirmAction ( String i18nKey , String propertyKey , Object ... arguments ) { String propValue = ParameterService . getParameterValue ( propertyKey ) ; if ( propValue != null ) { if ( propValue . equals ( VALUE_TRUE ) ) { return _BOOL ; } else if ( propValue . equals ( VALUE_FALSE ) ) { return _BOOL ; } } DecisionRememberingConfirmDialog d = new DecisionRememberingConfirmDialog ( i18nKey , propertyKey , DialogType . CONFIRM , arguments ) ; d . setVisible ( _BOOL ) ; return d . confirmed ; }
private boolean remove ( final int row , final int colIndex ) { boolean copied = _BOOL ; final int lastIndex = this . maxIndices [ row ] - _NUM ; if ( lastIndex > _NUM && lastIndex != colIndex ) { System . arraycopy ( this . cols [ row ] , colIndex + _NUM , this . cols [ row ] , colIndex , lastIndex - colIndex ) ; System . arraycopy ( this . values [ row ] , colIndex + _NUM , this . values [ row ] , colIndex , lastIndex - colIndex ) ; copied = _BOOL ; } if ( lastIndex >= _NUM ) { this . cols [ row ] [ lastIndex ] = _NUM ; this . values [ row ] [ lastIndex ] = _NUM ; } -- this . maxIndices [ row ] ; return copied ; }
private boolean remove ( final int row , final int colIndex ) { boolean copied = _BOOL ; final int lastIndex = this . maxIndices [ row ] - _NUM ; if ( lastIndex > _NUM && lastIndex != colIndex ) { System . arraycopy ( this . cols [ row ] , colIndex + _NUM , this . cols [ row ] , colIndex , lastIndex - colIndex ) ; System . arraycopy ( this . values [ row ] , colIndex + _NUM , this . values [ row ] , colIndex , lastIndex - colIndex ) ; copied = _BOOL ; } if ( lastIndex >= _NUM ) { this . cols [ row ] [ lastIndex ] = _NUM ; this . values [ row ] [ lastIndex ] = _NUM ; } -- this . maxIndices [ row ] ; return copied ; }
@ Override public double cos ( int step ) { step = Math . abs ( step ) % steps ; if ( step < costable . length ) { return costable [ step ] ; } if ( step > halfsteps ) { step = steps - step ; if ( step < costable . length ) { return costable [ step ] ; } } step = halfsteps - step ; return - costable [ step ] ; }
@ Override public double cos ( int step ) { step = Math . abs ( step ) % steps ; if ( step < costable . length ) { return costable [ step ] ; } if ( step > halfsteps ) { step = steps - step ; if ( step < costable . length ) { return costable [ step ] ; } } step = halfsteps - step ; return - costable [ step ] ; }
public void add ( EventBean theEvent ) { if ( theEvent == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( firstEvent == null ) { firstEvent = theEvent ; return ; } if ( additionalEvents == null ) { additionalEvents = new ArrayDeque < EventBean > ( ) ; } additionalEvents . add ( theEvent ) ; }
public void createROCPlotDialog ( ROCData data ) { ROCChartPlotter plotter = new ROCChartPlotter ( ) ; plotter . addROCData ( STRING , data ) ; JDialog dialog = new JDialog ( ) ; dialog . setTitle ( STRING ) ; dialog . add ( plotter ) ; dialog . setSize ( _NUM , _NUM ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setVisible ( _BOOL ) ; }
public void createROCPlotDialog ( ROCData data ) { ROCChartPlotter plotter = new ROCChartPlotter ( ) ; plotter . addROCData ( STRING , data ) ; JDialog dialog = new JDialog ( ) ; dialog . setTitle ( STRING ) ; dialog . add ( plotter ) ; dialog . setSize ( _NUM , _NUM ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setVisible ( _BOOL ) ; }
public void createROCPlotDialog ( ROCData data ) { ROCChartPlotter plotter = new ROCChartPlotter ( ) ; plotter . addROCData ( STRING , data ) ; JDialog dialog = new JDialog ( ) ; dialog . setTitle ( STRING ) ; dialog . add ( plotter ) ; dialog . setSize ( _NUM , _NUM ) ; dialog . setLocationRelativeTo ( null ) ; dialog . setVisible ( _BOOL ) ; }
@ Override public synchronized boolean add ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; return _BOOL ; }
@ Override public synchronized boolean add ( E object ) { if ( elementCount == elementData . length ) { growByOne ( ) ; } elementData [ elementCount ++ ] = object ; modCount ++ ; return _BOOL ; }
private void writeFlowPair ( FlowPair pair , Document document , Element parentElement ) { Element flowPair = document . createElement ( STRING ) ; parentElement . appendChild ( flowPair ) ; writeDomainSpec ( pair . getFirstDomain ( ) , document , flowPair ) ; writeDomainSpec ( pair . getSecondDomain ( ) , document , flowPair ) ; }
public String createRandomBytes ( int byteNum ) { byte [ ] secretBytes = new byte [ byteNum ] ; secureRandom . nextBytes ( secretBytes ) ; return Base64 . encode ( secretBytes ) ; }
public String createRandomBytes ( int byteNum ) { byte [ ] secretBytes = new byte [ byteNum ] ; secureRandom . nextBytes ( secretBytes ) ; return Base64 . encode ( secretBytes ) ; }
public void writeExif ( byte [ ] jpeg , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpeg == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; s = getExifWriterStream ( exifOutFileName ) ; s . write ( jpeg , _NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void writeExif ( byte [ ] jpeg , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpeg == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; s = getExifWriterStream ( exifOutFileName ) ; s . write ( jpeg , _NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void writeExif ( byte [ ] jpeg , String exifOutFileName ) throws FileNotFoundException , IOException { if ( jpeg == null || exifOutFileName == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = null ; s = getExifWriterStream ( exifOutFileName ) ; s . write ( jpeg , _NUM , jpeg . length ) ; s . flush ( ) ; s . close ( ) ; }
public void writeInt ( int value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeInt ( value ) ; }
public void testValueOfDoubleNeg ( ) { double a = - _NUM ; BigDecimal result = BigDecimal . valueOf ( a ) ; String res = STRING ; int resScale = _NUM ; assertEquals ( STRING , res , result . toString ( ) ) ; assertEquals ( STRING , resScale , result . scale ( ) ) ; }
private void walkParseTree ( List < SwiftBaseListener > listeners , TopLevelContext tree ) { ParseTreeWalker walker = new ParseTreeWalker ( ) ; listeners . forEach ( null ) ; }
public static byte checkRange ( Object value , Comparable < Object > minLimit , Comparable < Object > maxLimit ) { byte retVal = RC_WITHIN_RANGE ; if ( minLimit != null && minLimit . compareTo ( value ) > _NUM ) retVal |= RC_BELOW_RANGE ; if ( maxLimit != null && maxLimit . compareTo ( value ) < _NUM ) retVal |= RC_ABOVE_RANGE ; return ( retVal ) ; }
@ Override public String toString ( ) { synchronized ( lock ) { return buf . toString ( ) ; } }
public void insertUpdate ( DocumentEvent changes , Shape a , ViewFactory f ) { updateChildren ( changes , a ) ; Rectangle alloc = ( ( a != null ) && isAllocationValid ( ) ) ? getInsideAllocation ( a ) : null ; int pos = changes . getOffset ( ) ; View v = getViewAtPosition ( pos , alloc ) ; if ( v != null ) v . insertUpdate ( changes , alloc , f ) ; }
public void insertUpdate ( DocumentEvent changes , Shape a , ViewFactory f ) { updateChildren ( changes , a ) ; Rectangle alloc = ( ( a != null ) && isAllocationValid ( ) ) ? getInsideAllocation ( a ) : null ; int pos = changes . getOffset ( ) ; View v = getViewAtPosition ( pos , alloc ) ; if ( v != null ) v . insertUpdate ( changes , alloc , f ) ; }
public void insertUpdate ( DocumentEvent changes , Shape a , ViewFactory f ) { updateChildren ( changes , a ) ; Rectangle alloc = ( ( a != null ) && isAllocationValid ( ) ) ? getInsideAllocation ( a ) : null ; int pos = changes . getOffset ( ) ; View v = getViewAtPosition ( pos , alloc ) ; if ( v != null ) v . insertUpdate ( changes , alloc , f ) ; }
public void insertUpdate ( DocumentEvent changes , Shape a , ViewFactory f ) { updateChildren ( changes , a ) ; Rectangle alloc = ( ( a != null ) && isAllocationValid ( ) ) ? getInsideAllocation ( a ) : null ; int pos = changes . getOffset ( ) ; View v = getViewAtPosition ( pos , alloc ) ; if ( v != null ) v . insertUpdate ( changes , alloc , f ) ; }
private void removeCaboosesAndCarsWithFredAndSaveFinalDestination ( ) throws BuildFailedException { addLine ( _buildReport , SEVEN , BLANK_LINE ) ; addLine ( _buildReport , SEVEN , Bundle . getMessage ( STRING ) ) ; for ( _carIndex = _NUM ; _carIndex < _carList . size ( ) ; _carIndex ++ ) { Car car = _carList . get ( _carIndex ) ; if ( car . isCaboose ( ) || car . hasFred ( ) ) { addLine ( _buildReport , SEVEN , MessageFormat . format ( Bundle . getMessage ( STRING ) , new Object [ ] { car . toString ( ) , car . getTypeName ( ) , ( car . getLocationName ( ) + STRING + car . getTrackName ( ) ) } ) ) ; if ( car . getTrack ( ) == _departStageTrack ) { throw new BuildFailedException ( STRING ) ; } _carList . remove ( car ) ; _carIndex -- ; } car . setPreviousFinalDestination ( car . getFinalDestination ( ) ) ; car . setPreviousFinalDestinationTrack ( car . getFinalDestinationTrack ( ) ) ; car . setPreviousScheduleId ( car . getScheduleItemId ( ) ) ; } }
private void removeCaboosesAndCarsWithFredAndSaveFinalDestination ( ) throws BuildFailedException { addLine ( _buildReport , SEVEN , BLANK_LINE ) ; addLine ( _buildReport , SEVEN , Bundle . getMessage ( STRING ) ) ; for ( _carIndex = _NUM ; _carIndex < _carList . size ( ) ; _carIndex ++ ) { Car car = _carList . get ( _carIndex ) ; if ( car . isCaboose ( ) || car . hasFred ( ) ) { addLine ( _buildReport , SEVEN , MessageFormat . format ( Bundle . getMessage ( STRING ) , new Object [ ] { car . toString ( ) , car . getTypeName ( ) , ( car . getLocationName ( ) + STRING + car . getTrackName ( ) ) } ) ) ; if ( car . getTrack ( ) == _departStageTrack ) { throw new BuildFailedException ( STRING ) ; } _carList . remove ( car ) ; _carIndex -- ; } car . setPreviousFinalDestination ( car . getFinalDestination ( ) ) ; car . setPreviousFinalDestinationTrack ( car . getFinalDestinationTrack ( ) ) ; car . setPreviousScheduleId ( car . getScheduleItemId ( ) ) ; } }
private void removeCaboosesAndCarsWithFredAndSaveFinalDestination ( ) throws BuildFailedException { addLine ( _buildReport , SEVEN , BLANK_LINE ) ; addLine ( _buildReport , SEVEN , Bundle . getMessage ( STRING ) ) ; for ( _carIndex = _NUM ; _carIndex < _carList . size ( ) ; _carIndex ++ ) { Car car = _carList . get ( _carIndex ) ; if ( car . isCaboose ( ) || car . hasFred ( ) ) { addLine ( _buildReport , SEVEN , MessageFormat . format ( Bundle . getMessage ( STRING ) , new Object [ ] { car . toString ( ) , car . getTypeName ( ) , ( car . getLocationName ( ) + STRING + car . getTrackName ( ) ) } ) ) ; if ( car . getTrack ( ) == _departStageTrack ) { throw new BuildFailedException ( STRING ) ; } _carList . remove ( car ) ; _carIndex -- ; } car . setPreviousFinalDestination ( car . getFinalDestination ( ) ) ; car . setPreviousFinalDestinationTrack ( car . getFinalDestinationTrack ( ) ) ; car . setPreviousScheduleId ( car . getScheduleItemId ( ) ) ; } }
private boolean safeEquals ( Object o1 , Object o2 ) { if ( o1 == null && o2 == null ) return _BOOL ; if ( o1 == null ) return _BOOL ; if ( o2 == null ) return _BOOL ; return o1 . equals ( o2 ) ; }
public void reset ( ) { System . arraycopy ( COLOR_SCHEME . mDefaultColors , _NUM , mCurrentColors , _NUM , TextStyle . NUM_INDEXED_COLORS ) ; }
public void reset ( ) { System . arraycopy ( COLOR_SCHEME . mDefaultColors , _NUM , mCurrentColors , _NUM , TextStyle . NUM_INDEXED_COLORS ) ; }
protected Boolean compute ( double value ) { if ( Double . isNaN ( value ) ) { return _BOOL ; } else { return _BOOL ; } }
@ Override public void write ( byte [ ] buf , int offset , int length , boolean isEnd ) throws IOException { while ( length > _NUM ) { if ( _tail == null ) { addBuffer ( TempBuffer . create ( ) ) ; } else if ( _tail . buffer ( ) . length <= _tail . length ( ) ) { addBuffer ( TempBuffer . create ( ) ) ; } TempBuffer tail = _tail ; int sublen = Math . min ( length , tail . buffer ( ) . length - tail . length ( ) ) ; System . arraycopy ( buf , offset , tail . buffer ( ) , tail . length ( ) , sublen ) ; length -= sublen ; offset += sublen ; _tail . length ( _tail . length ( ) + sublen ) ; } }
public static boolean isWindowsNt4 ( ) { return osName . indexOf ( STRING ) > - _NUM && osVersion . equals ( STRING ) ; }
public static boolean isWindowsNt4 ( ) { return osName . indexOf ( STRING ) > - _NUM && osVersion . equals ( STRING ) ; }
private void computeDuration ( ) { duration = System . currentTimeMillis ( ) - start ; total_duration += duration ; }
public BloomFilter ( double falsePositiveProbability , int expectedNumberOfElements ) { this ( Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( _NUM ) ) ) / Math . log ( _NUM ) , expectedNumberOfElements , ( int ) Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( _NUM ) ) ) ) ; }
public BloomFilter ( double falsePositiveProbability , int expectedNumberOfElements ) { this ( Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( _NUM ) ) ) / Math . log ( _NUM ) , expectedNumberOfElements , ( int ) Math . ceil ( - ( Math . log ( falsePositiveProbability ) / Math . log ( _NUM ) ) ) ) ; }
public void exit ( ) { shuttingDown = _BOOL ; saveSettings ( _BOOL ) ; logAllViewerstats ( ) ; c . disconnect ( ) ; frankerFaceZ . disconnectWs ( ) ; pubsub . disconnect ( ) ; g . cleanUp ( ) ; chatLog . close ( ) ; System . exit ( _NUM ) ; }
private static byte [ ] readBytes ( final ClientReader inputStream , final int length ) throws IOException { final ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; final byte [ ] data = new byte [ length ] ; int read = _NUM ; while ( read < length ) { final int retval = inputStream . read ( data , _NUM , length - read ) ; baos . write ( data , _NUM , retval ) ; read += retval ; } return baos . toByteArray ( ) ; }
public void testMomentWithInvalidTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += createStartMomentXml ( STRING , STRING ) ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
public void testMomentWithInvalidTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += createStartMomentXml ( STRING , STRING ) ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
public void testMomentWithInvalidTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += createStartMomentXml ( STRING , STRING ) ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
private void addTaskToNPC ( final int idx ) { final String state = points . get ( idx ) ; final SpeakerNPC npc = npcs . get ( state ) ; npc . add ( ConversationStates . ATTENDING , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ATTENDING , null , new PaperChasePoint ( idx ) ) ; if ( NPC_IDLE . contains ( state ) ) { npc . add ( ConversationStates . ANY , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ANY , null , new PaperChasePoint ( idx ) ) ; } }
private void addTaskToNPC ( final int idx ) { final String state = points . get ( idx ) ; final SpeakerNPC npc = npcs . get ( state ) ; npc . add ( ConversationStates . ATTENDING , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ATTENDING , null , new PaperChasePoint ( idx ) ) ; if ( NPC_IDLE . contains ( state ) ) { npc . add ( ConversationStates . ANY , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ANY , null , new PaperChasePoint ( idx ) ) ; } }
private void addTaskToNPC ( final int idx ) { final String state = points . get ( idx ) ; final SpeakerNPC npc = npcs . get ( state ) ; npc . add ( ConversationStates . ATTENDING , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ATTENDING , null , new PaperChasePoint ( idx ) ) ; if ( NPC_IDLE . contains ( state ) ) { npc . add ( ConversationStates . ANY , Arrays . asList ( STRING , STRING , STRING ) , new SystemPropertyCondition ( STRING ) , ConversationStates . ANY , null , new PaperChasePoint ( idx ) ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private void insertCOMMarkerSegment ( COMMarkerSegment newGuy ) { int lastCOM = findMarkerSegmentPosition ( COMMarkerSegment . class , _BOOL ) ; boolean hasJFIF = ( findMarkerSegment ( JFIFMarkerSegment . class , _BOOL ) != null ) ; int firstAdobe = findMarkerSegmentPosition ( AdobeMarkerSegment . class , _BOOL ) ; if ( lastCOM != - _NUM ) { markerSequence . add ( lastCOM + _NUM , newGuy ) ; } else if ( hasJFIF ) { markerSequence . add ( _NUM , newGuy ) ; } else if ( firstAdobe != - _NUM ) { markerSequence . add ( firstAdobe + _NUM , newGuy ) ; } else { markerSequence . add ( _NUM , newGuy ) ; } }
private InputStreamReader createReader ( InputStream is , String encoding ) throws UnsupportedEncodingException { InputStreamReader r ; if ( encoding != null ) { r = new InputStreamReader ( is , encoding ) ; } else { r = new InputStreamReader ( is ) ; } return r ; }
protected ActionArgumentValue [ ] readArgumentValues ( NodeList nodeList , ActionArgument [ ] args ) throws ActionException { List < Node > nodes = getMatchingNodes ( nodeList , args ) ; ActionArgumentValue [ ] values = new ActionArgumentValue [ args . length ] ; for ( int i = _NUM ; i < args . length ; i ++ ) { ActionArgument arg = args [ i ] ; Node node = findActionArgumentNode ( nodes , arg ) ; if ( node == null ) { throw new ActionException ( ErrorCode . ARGUMENT_VALUE_INVALID , STRING + arg . getName ( ) + STRING ) ; } log . fine ( STRING + arg . getName ( ) ) ; String value = XMLUtil . getTextContent ( node ) ; values [ i ] = createValue ( arg , value ) ; } return values ; }
public synchronized void remove ( IAudioProvider provider ) { providers . remove ( provider ) ; }
public void sort ( ) { throwIfImmutable ( ) ; if ( ! sorted ) { Arrays . sort ( values , _NUM , size ) ; sorted = _BOOL ; } }
public void sort ( ) { throwIfImmutable ( ) ; if ( ! sorted ) { Arrays . sort ( values , _NUM , size ) ; sorted = _BOOL ; } }
public String ncgSummaryStr ( ) { if ( ncg . homeScore > ncg . awayScore ) { return ncg . homeTeam . name + STRING + ncg . homeTeam . wins + STRING + ncg . homeTeam . losses + STRING + STRING + ncg . awayTeam . name + STRING + ncg . awayTeam . wins + STRING + ncg . awayTeam . losses + STRING + ncg . homeScore + STRING + ncg . awayScore + STRING ; } else { return ncg . awayTeam . name + STRING + ncg . awayTeam . wins + STRING + ncg . awayTeam . losses + STRING + STRING + ncg . homeTeam . name + STRING + ncg . homeTeam . wins + STRING + ncg . homeTeam . losses + STRING + ncg . awayScore + STRING + ncg . homeScore + STRING ; } }
public String ncgSummaryStr ( ) { if ( ncg . homeScore > ncg . awayScore ) { return ncg . homeTeam . name + STRING + ncg . homeTeam . wins + STRING + ncg . homeTeam . losses + STRING + STRING + ncg . awayTeam . name + STRING + ncg . awayTeam . wins + STRING + ncg . awayTeam . losses + STRING + ncg . homeScore + STRING + ncg . awayScore + STRING ; } else { return ncg . awayTeam . name + STRING + ncg . awayTeam . wins + STRING + ncg . awayTeam . losses + STRING + STRING + ncg . homeTeam . name + STRING + ncg . homeTeam . wins + STRING + ncg . homeTeam . losses + STRING + ncg . awayScore + STRING + ncg . homeScore + STRING ; } }
public static StringBuffer replaceStrStr ( final StringBuffer string , final String oldPattern , final String newPattern ) { if ( ( string == null ) || ( oldPattern == null ) || oldPattern . equals ( STRING ) || ( newPattern == null ) ) { return string ; } final StringBuffer replaced = new StringBuffer ( ) ; int startIdx = _NUM ; int idxOld ; while ( ( idxOld = string . indexOf ( oldPattern , startIdx ) ) >= _NUM ) { replaced . append ( string . substring ( startIdx , idxOld ) ) ; replaced . append ( newPattern ) ; startIdx = idxOld + oldPattern . length ( ) ; } replaced . append ( string . substring ( startIdx ) ) ; return replaced ; }
public static StringBuffer replaceStrStr ( final StringBuffer string , final String oldPattern , final String newPattern ) { if ( ( string == null ) || ( oldPattern == null ) || oldPattern . equals ( STRING ) || ( newPattern == null ) ) { return string ; } final StringBuffer replaced = new StringBuffer ( ) ; int startIdx = _NUM ; int idxOld ; while ( ( idxOld = string . indexOf ( oldPattern , startIdx ) ) >= _NUM ) { replaced . append ( string . substring ( startIdx , idxOld ) ) ; replaced . append ( newPattern ) ; startIdx = idxOld + oldPattern . length ( ) ; } replaced . append ( string . substring ( startIdx ) ) ; return replaced ; }
public static StringBuffer replaceStrStr ( final StringBuffer string , final String oldPattern , final String newPattern ) { if ( ( string == null ) || ( oldPattern == null ) || oldPattern . equals ( STRING ) || ( newPattern == null ) ) { return string ; } final StringBuffer replaced = new StringBuffer ( ) ; int startIdx = _NUM ; int idxOld ; while ( ( idxOld = string . indexOf ( oldPattern , startIdx ) ) >= _NUM ) { replaced . append ( string . substring ( startIdx , idxOld ) ) ; replaced . append ( newPattern ) ; startIdx = idxOld + oldPattern . length ( ) ; } replaced . append ( string . substring ( startIdx ) ) ; return replaced ; }
public static StringBuffer replaceStrStr ( final StringBuffer string , final String oldPattern , final String newPattern ) { if ( ( string == null ) || ( oldPattern == null ) || oldPattern . equals ( STRING ) || ( newPattern == null ) ) { return string ; } final StringBuffer replaced = new StringBuffer ( ) ; int startIdx = _NUM ; int idxOld ; while ( ( idxOld = string . indexOf ( oldPattern , startIdx ) ) >= _NUM ) { replaced . append ( string . substring ( startIdx , idxOld ) ) ; replaced . append ( newPattern ) ; startIdx = idxOld + oldPattern . length ( ) ; } replaced . append ( string . substring ( startIdx ) ) ; return replaced ; }
public void applyPattern ( String pattern ) { this . pattern = pattern ; if ( patternTokens != null ) { patternTokens . clear ( ) ; patternTokens = null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public Timestamp recalculateEstimatedCompletionDate ( Long priority , Timestamp startDate ) { if ( exist ( ) ) { getProductionRunRoutingTasks ( ) ; if ( quantity == null ) getQuantity ( ) ; Timestamp endDate = null ; for ( Iterator < GenericValue > iter = productionRunRoutingTasks . iterator ( ) ; iter . hasNext ( ) ; ) { GenericValue routingTask = iter . next ( ) ; if ( priority . compareTo ( routingTask . getLong ( STRING ) ) <= _NUM ) { long totalTime = ProductionRun . getEstimatedTaskTime ( routingTask , quantity , dispatcher ) ; endDate = TechDataServices . addForward ( TechDataServices . getTechDataCalendar ( routingTask ) , startDate , totalTime ) ; routingTask . set ( STRING , startDate ) ; routingTask . set ( STRING , endDate ) ; startDate = endDate ; } } return endDate ; } else { return null ; } }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
public void close ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . close ( ) ; }
default Literal toLiteral ( final Object value ) { final ValueFactory vf = Defaults . VF ; if ( value instanceof Float ) { return vf . createLiteral ( ( Float ) value ) ; } else if ( value instanceof Double ) { return vf . createLiteral ( ( Double ) value ) ; } else if ( value instanceof Integer ) { return vf . createLiteral ( ( Integer ) value ) ; } else if ( value instanceof Long ) { return vf . createLiteral ( ( Long ) value ) ; } else if ( value instanceof Boolean ) { return vf . createLiteral ( ( Boolean ) value ) ; } else if ( value instanceof Short ) { return vf . createLiteral ( ( Short ) value ) ; } else if ( value instanceof Byte ) { return vf . createLiteral ( ( Byte ) value ) ; } else if ( value instanceof String ) { return vf . createLiteral ( ( String ) value ) ; } else { throw new IllegalArgumentException ( String . format ( STRING , value ) ) ; } }
public void addThumbnailChangeListener ( ThumbnailChangeListener listener ) { if ( ! mListeners . contains ( listener ) ) { mListeners . add ( listener ) ; } }
public Boolean checkIfProviderSupportsCompressionOperations ( StorageSystem storageSystem ) { String versionSubstring = null ; if ( storageSystem . checkIfVmax3 ( ) && storageSystem . getUsingSmis80 ( ) ) { try { StorageProvider storageProvider = _dbClient . queryObject ( StorageProvider . class , storageSystem . getActiveProviderURI ( ) ) ; String providerVersion = storageProvider . getVersionString ( ) ; versionSubstring = providerVersion . split ( STRING ) [ _NUM ] ; } catch ( Exception e ) { _log . error ( STRING , storageSystem . getLabel ( ) , storageSystem . getId ( ) ) ; return _BOOL ; } } if ( NullColumnValueGetter . isNullValue ( versionSubstring ) || ! ( Integer . parseInt ( versionSubstring ) > _NUM ) ) { String errMsg = String . format ( STRING , storageSystem . getSerialNumber ( ) ) ; _log . error ( errMsg ) ; return _BOOL ; } return _BOOL ; }
public Boolean checkIfProviderSupportsCompressionOperations ( StorageSystem storageSystem ) { String versionSubstring = null ; if ( storageSystem . checkIfVmax3 ( ) && storageSystem . getUsingSmis80 ( ) ) { try { StorageProvider storageProvider = _dbClient . queryObject ( StorageProvider . class , storageSystem . getActiveProviderURI ( ) ) ; String providerVersion = storageProvider . getVersionString ( ) ; versionSubstring = providerVersion . split ( STRING ) [ _NUM ] ; } catch ( Exception e ) { _log . error ( STRING , storageSystem . getLabel ( ) , storageSystem . getId ( ) ) ; return _BOOL ; } } if ( NullColumnValueGetter . isNullValue ( versionSubstring ) || ! ( Integer . parseInt ( versionSubstring ) > _NUM ) ) { String errMsg = String . format ( STRING , storageSystem . getSerialNumber ( ) ) ; _log . error ( errMsg ) ; return _BOOL ; } return _BOOL ; }
@ Override public String chooseServerAlias ( final String keyType , final Principal [ ] issuers , final Socket socket ) { if ( keyManager != null ) { return keyManager . chooseServerAlias ( keyType , issuers , socket ) ; } return null ; }
protected IMultiPoint nearest ( double [ ] rawTarget , double min [ ] ) { IMultiPoint result = null ; double d = shorter ( rawTarget , min [ _NUM ] ) ; if ( d >= _NUM && d < min [ _NUM ] ) { min [ _NUM ] = d ; result = point ; } double dp = Math . abs ( coord - rawTarget [ dimension - _NUM ] ) ; IMultiPoint newResult = null ; int numDblRec = _NUM ; if ( dp < min [ _NUM ] ) { if ( above != null ) { numDblRec ++ ; newResult = above . nearest ( rawTarget , min ) ; if ( newResult != null ) { result = newResult ; } } if ( below != null ) { numDblRec ++ ; newResult = below . nearest ( rawTarget , min ) ; if ( newResult != null ) { result = newResult ; } } if ( numDblRec == _NUM ) { numDoubleRecursions ++ ; } else if ( numDblRec == _NUM ) { numRecursions ++ ; } } else { numRecursions ++ ; if ( rawTarget [ dimension - _NUM ] < coord ) { if ( below != null ) { newResult = below . nearest ( rawTarget , min ) ; } } else { if ( above != null ) { newResult = above . nearest ( rawTarget , min ) ; } } if ( newResult != null ) { return newResult ; } } return result ; }
public static double max ( double [ ] a ) { double max = Double . NEGATIVE_INFINITY ; for ( int i = _NUM ; i < a . length ; i ++ ) { if ( Double . isNaN ( a [ i ] ) ) return Double . NaN ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
public static double max ( double [ ] a ) { double max = Double . NEGATIVE_INFINITY ; for ( int i = _NUM ; i < a . length ; i ++ ) { if ( Double . isNaN ( a [ i ] ) ) return Double . NaN ; if ( a [ i ] > max ) max = a [ i ] ; } return max ; }
@ Nullable public ECKey findKeyFromPubHash ( byte [ ] pubkeyHash ) { lock . lock ( ) ; try { for ( ECKey key : keychain ) { if ( Arrays . equals ( key . getPubKeyHash ( ) , pubkeyHash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public ECKey findKeyFromPubHash ( byte [ ] pubkeyHash ) { lock . lock ( ) ; try { for ( ECKey key : keychain ) { if ( Arrays . equals ( key . getPubKeyHash ( ) , pubkeyHash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public ECKey findKeyFromPubHash ( byte [ ] pubkeyHash ) { lock . lock ( ) ; try { for ( ECKey key : keychain ) { if ( Arrays . equals ( key . getPubKeyHash ( ) , pubkeyHash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public ECKey findKeyFromPubHash ( byte [ ] pubkeyHash ) { lock . lock ( ) ; try { for ( ECKey key : keychain ) { if ( Arrays . equals ( key . getPubKeyHash ( ) , pubkeyHash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Nullable public ECKey findKeyFromPubHash ( byte [ ] pubkeyHash ) { lock . lock ( ) ; try { for ( ECKey key : keychain ) { if ( Arrays . equals ( key . getPubKeyHash ( ) , pubkeyHash ) ) return key ; } return null ; } finally { lock . unlock ( ) ; } }
@ Override public void close ( ) throws IOException { while ( in != null ) { nextStream ( ) ; } e = null ; }
@ Override public void close ( ) throws IOException { while ( in != null ) { nextStream ( ) ; } e = null ; }
public static String fromGenericTag ( Tag tag ) { switch ( tag . getType ( ) ) { case BYTE : return fromTag ( ( ByteTag ) tag ) ; case BYTE_ARRAY : return fromTag ( ( ByteArrayTag ) tag ) ; case COMPOUND : return fromTag ( ( CompoundTag ) tag ) ; case DOUBLE : return fromTag ( ( DoubleTag ) tag ) ; case FLOAT : return fromTag ( ( FloatTag ) tag ) ; case INT : return fromTag ( ( IntTag ) tag ) ; case INT_ARRAY : return fromTag ( ( IntArrayTag ) tag ) ; case LIST : return fromTag ( ( ListTag ) tag ) ; case LONG : return fromTag ( ( LongTag ) tag ) ; case SHORT : return fromTag ( ( ShortTag ) tag ) ; case STRING : return fromTag ( ( StringTag ) tag ) ; } return null ; }
public static int chooseAtLeastForOnMeasure ( int minValue , int measureSpec ) { int specMode = MeasureSpec . getMode ( measureSpec ) ; int specSize = MeasureSpec . getSize ( measureSpec ) ; if ( specMode == MeasureSpec . EXACTLY || specMode == MeasureSpec . AT_MOST && minValue > specSize ) return specSize ; return minValue ; }
public void testAddAndSumMT ( ) throws Throwable { final int incs = _NUM ; final int nthreads = _NUM ; final ExecutorService pool = Executors . newCachedThreadPool ( ) ; LongAdder a = new LongAdder ( ) ; CyclicBarrier barrier = new CyclicBarrier ( nthreads + _NUM ) ; for ( int i = _NUM ; i < nthreads ; ++ i ) pool . execute ( new AdderTask ( a , barrier , incs ) ) ; barrier . await ( ) ; barrier . await ( ) ; long total = ( long ) nthreads * incs ; long sum = a . sum ( ) ; assertEquals ( sum , total ) ; pool . shutdown ( ) ; }
public void testAddAndSumMT ( ) throws Throwable { final int incs = _NUM ; final int nthreads = _NUM ; final ExecutorService pool = Executors . newCachedThreadPool ( ) ; LongAdder a = new LongAdder ( ) ; CyclicBarrier barrier = new CyclicBarrier ( nthreads + _NUM ) ; for ( int i = _NUM ; i < nthreads ; ++ i ) pool . execute ( new AdderTask ( a , barrier , incs ) ) ; barrier . await ( ) ; barrier . await ( ) ; long total = ( long ) nthreads * incs ; long sum = a . sum ( ) ; assertEquals ( sum , total ) ; pool . shutdown ( ) ; }
public void addUserMessageListener ( UserMessageListener userMessageListener ) { userMessageListeners . add ( userMessageListener ) ; }
private < T extends CWLResource > T lookForResource ( CWLResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > _NUM ? resources . get ( _NUM ) : null ; }
private < T extends CWLResource > T lookForResource ( CWLResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > _NUM ? resources . get ( _NUM ) : null ; }
public synchronized boolean hasAlert ( Alert alert ) { if ( alerts == null ) { return _BOOL ; } return alerts . contains ( alert ) ; }
public DataBuffer ( final byte [ ] buffer , final int offset , final int length ) { byteBuffer = ByteBuffer . wrap ( buffer ) ; byteBuffer . order ( ByteOrder . LITTLE_ENDIAN ) ; byteBuffer . position ( offset ) ; }
public synchronized NativeTcp registerIncomingTcpConnection ( String originAddr , int originPort , String destAddr , int destPort ) { EndPointInfo origin = new EndPointInfo ( originAddr , originPort , ConnectionType . TCP ) ; EndPointInfo dest = new EndPointInfo ( destAddr , destPort , ConnectionType . TCP ) ; Queue < NativeTcp > queue = incomingConnections . get ( dest ) ; if ( queue == null ) { queue = new ConcurrentLinkedQueue < > ( ) ; incomingConnections . put ( dest , queue ) ; } NativeTcp connection = new NativeTcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized NativeTcp registerIncomingTcpConnection ( String originAddr , int originPort , String destAddr , int destPort ) { EndPointInfo origin = new EndPointInfo ( originAddr , originPort , ConnectionType . TCP ) ; EndPointInfo dest = new EndPointInfo ( destAddr , destPort , ConnectionType . TCP ) ; Queue < NativeTcp > queue = incomingConnections . get ( dest ) ; if ( queue == null ) { queue = new ConcurrentLinkedQueue < > ( ) ; incomingConnections . put ( dest , queue ) ; } NativeTcp connection = new NativeTcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized NativeTcp registerIncomingTcpConnection ( String originAddr , int originPort , String destAddr , int destPort ) { EndPointInfo origin = new EndPointInfo ( originAddr , originPort , ConnectionType . TCP ) ; EndPointInfo dest = new EndPointInfo ( destAddr , destPort , ConnectionType . TCP ) ; Queue < NativeTcp > queue = incomingConnections . get ( dest ) ; if ( queue == null ) { queue = new ConcurrentLinkedQueue < > ( ) ; incomingConnections . put ( dest , queue ) ; } NativeTcp connection = new NativeTcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public synchronized NativeTcp registerIncomingTcpConnection ( String originAddr , int originPort , String destAddr , int destPort ) { EndPointInfo origin = new EndPointInfo ( originAddr , originPort , ConnectionType . TCP ) ; EndPointInfo dest = new EndPointInfo ( destAddr , destPort , ConnectionType . TCP ) ; Queue < NativeTcp > queue = incomingConnections . get ( dest ) ; if ( queue == null ) { queue = new ConcurrentLinkedQueue < > ( ) ; incomingConnections . put ( dest , queue ) ; } NativeTcp connection = new NativeTcp ( dest , origin ) ; queue . add ( connection ) ; return connection ; }
public void flush ( ) { writeDataBlock ( ) ; }
public PilotingRollData checkManeuver ( MoveStep step , EntityMovementType overallMoveType ) { PilotingRollData roll = getBasePilotingRoll ( overallMoveType ) ; if ( ( step == null ) || ( step . getType ( ) != MoveStepType . MANEUVER ) ) { roll . addModifier ( TargetRoll . CHECK_FALSE , STRING ) ; return roll ; } boolean sideSlipMod = ( this instanceof ConvFighter ) && isVSTOL ( ) ; roll . append ( new PilotingRollData ( getId ( ) , ManeuverType . getMod ( step . getManeuverType ( ) , sideSlipMod ) , ManeuverType . getTypeName ( step . getManeuverType ( ) ) + STRING ) ) ; return roll ; }
public PilotingRollData checkManeuver ( MoveStep step , EntityMovementType overallMoveType ) { PilotingRollData roll = getBasePilotingRoll ( overallMoveType ) ; if ( ( step == null ) || ( step . getType ( ) != MoveStepType . MANEUVER ) ) { roll . addModifier ( TargetRoll . CHECK_FALSE , STRING ) ; return roll ; } boolean sideSlipMod = ( this instanceof ConvFighter ) && isVSTOL ( ) ; roll . append ( new PilotingRollData ( getId ( ) , ManeuverType . getMod ( step . getManeuverType ( ) , sideSlipMod ) , ManeuverType . getTypeName ( step . getManeuverType ( ) ) + STRING ) ) ; return roll ; }
private void sortUnitsToMove ( final List < Unit > units , final Route route ) { if ( units == null || units . isEmpty ( ) ) { return ; } else if ( route == null ) { final Exception nullRouteError = ( new IllegalArgumentException ( STRING ) ) ; ClientLogger . logQuietly ( STRING , nullRouteError ) ; } final Comparator < Unit > unitComparator ; if ( route . isUnload ( ) && Match . someMatch ( units , Matches . UnitIsLand ) ) { unitComparator = UnitComparator . getUnloadableUnitsComparator ( units , route , getUnitOwner ( units ) ) ; } else { unitComparator = UnitComparator . getMovableUnitsComparator ( units , route ) ; } Collections . sort ( units , unitComparator ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public Object [ ] toArray ( ) { return al . toArray ( ) ; }
public void writeToFile ( String fileName ) throws IOException { write ( new FileOutputStream ( fileName ) ) ; }
public void stop ( ) { mCancel = _BOOL ; if ( mRunning . compareAndSet ( _BOOL , _BOOL ) ) { if ( mSampleDispatcherTask != null ) { mThreadPoolManager . cancel ( mSampleDispatcherTask ) ; mSampleDispatcherTask = null ; mFilledBuffers . clear ( ) ; } } }
public static File writeTmpFile ( final String prefix , final String suffix , final boolean deleteOnExit , final List < String > args ) throws IOException { final File tmpFile = File . createTempFile ( prefix , suffix ) ; if ( deleteOnExit ) { tmpFile . deleteOnExit ( ) ; } writeFile ( tmpFile , args ) ; return tmpFile ; }
@ SuppressWarnings ( STRING ) protected Object readResolve ( ) throws ObjectStreamException { try { Class messageClass = Class . forName ( messageClassName ) ; Method newBuilder = messageClass . getMethod ( STRING ) ; MessageLite . Builder builder = ( MessageLite . Builder ) newBuilder . invoke ( null ) ; builder . mergeFrom ( asBytes ) ; return builder . buildPartial ( ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( STRING , e . getCause ( ) ) ; } catch ( InvalidProtocolBufferException e ) { throw new RuntimeException ( STRING , e ) ; } }
@ SuppressWarnings ( STRING ) protected Object readResolve ( ) throws ObjectStreamException { try { Class messageClass = Class . forName ( messageClassName ) ; Method newBuilder = messageClass . getMethod ( STRING ) ; MessageLite . Builder builder = ( MessageLite . Builder ) newBuilder . invoke ( null ) ; builder . mergeFrom ( asBytes ) ; return builder . buildPartial ( ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( IllegalAccessException e ) { throw new RuntimeException ( STRING , e ) ; } catch ( InvocationTargetException e ) { throw new RuntimeException ( STRING , e . getCause ( ) ) ; } catch ( InvalidProtocolBufferException e ) { throw new RuntimeException ( STRING , e ) ; } }
public void switchSetup ( ) { int retVal ; retVal = m_SetupFileChooser . showOpenDialog ( this ) ; if ( retVal != JFileChooser . APPROVE_OPTION ) { return ; } m_DbUtils . initialize ( m_SetupFileChooser . getSelectedFile ( ) ) ; m_URL = m_DbUtils . getDatabaseURL ( ) ; m_User = m_DbUtils . getUsername ( ) ; m_Password = m_DbUtils . getPassword ( ) ; m_TextURL . setText ( m_URL ) ; }
public void switchSetup ( ) { int retVal ; retVal = m_SetupFileChooser . showOpenDialog ( this ) ; if ( retVal != JFileChooser . APPROVE_OPTION ) { return ; } m_DbUtils . initialize ( m_SetupFileChooser . getSelectedFile ( ) ) ; m_URL = m_DbUtils . getDatabaseURL ( ) ; m_User = m_DbUtils . getUsername ( ) ; m_Password = m_DbUtils . getPassword ( ) ; m_TextURL . setText ( m_URL ) ; }
public boolean hasSingleElement ( ) { return mSelectedWidgets . size ( ) == _NUM ; }
public boolean hasSingleElement ( ) { return mSelectedWidgets . size ( ) == _NUM ; }
public void add ( char [ ] keyword , byte id ) { int key = getStringMapKey ( keyword ) ; loop : for ( char ch : keyword ) { if ( ! Character . isLetterOrDigit ( ch ) ) { for ( int j = _NUM ; j < noWordSep . length ( ) ; j ++ ) { if ( noWordSep . charAt ( j ) == ch ) continue loop ; } noWordSep . append ( ch ) ; } } map [ key ] = new Keyword ( keyword , id , map [ key ] ) ; }
@ Override public void write ( byte [ ] buffer , int offset , int length ) throws IOException { _crc = Crc64 . generate ( _crc , buffer , offset , length ) ; _next . write ( buffer , offset , length ) ; }
@ Override protected void addToFrontier ( Node node ) { if ( ! explored . contains ( node . getState ( ) ) ) { frontier . add ( node ) ; updateMetrics ( frontier . size ( ) ) ; } }
@ Override protected void addToFrontier ( Node node ) { if ( ! explored . contains ( node . getState ( ) ) ) { frontier . add ( node ) ; updateMetrics ( frontier . size ( ) ) ; } }
@ Override protected void addToFrontier ( Node node ) { if ( ! explored . contains ( node . getState ( ) ) ) { frontier . add ( node ) ; updateMetrics ( frontier . size ( ) ) ; } }
public String canonicalize ( String simpleURL ) { String resultURL = simpleURL ; if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( ! hasProtocolName ( simpleURL ) ) { if ( isSimpleHostName ( simpleURL ) ) { simpleURL = STRING + simpleURL + STRING ; } resultURL = STRING + simpleURL ; } return resultURL ; }
public String canonicalize ( String simpleURL ) { String resultURL = simpleURL ; if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( ! hasProtocolName ( simpleURL ) ) { if ( isSimpleHostName ( simpleURL ) ) { simpleURL = STRING + simpleURL + STRING ; } resultURL = STRING + simpleURL ; } return resultURL ; }
public String canonicalize ( String simpleURL ) { String resultURL = simpleURL ; if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( simpleURL . startsWith ( STRING ) ) { resultURL = STRING + simpleURL ; } else if ( ! hasProtocolName ( simpleURL ) ) { if ( isSimpleHostName ( simpleURL ) ) { simpleURL = STRING + simpleURL + STRING ; } resultURL = STRING + simpleURL ; } return resultURL ; }
static public String normalizeWWN ( String wwn ) { String result = wwn ; if ( wwn != null && ! wwn . isEmpty ( ) ) { result = wwn . replaceAll ( STRING , STRING ) ; result = result . toUpperCase ( ) ; } return result ; }
static public String normalizeWWN ( String wwn ) { String result = wwn ; if ( wwn != null && ! wwn . isEmpty ( ) ) { result = wwn . replaceAll ( STRING , STRING ) ; result = result . toUpperCase ( ) ; } return result ; }
private void writeDomainPair ( DomPair pair , Document document , Element parentElement ) { Element domPair = document . createElement ( STRING ) ; parentElement . appendChild ( domPair ) ; writeDomainSpec ( pair . getFirstDomain ( ) , document , domPair ) ; writeDomainSpec ( pair . getSecondDomain ( ) , document , domPair ) ; }
public static Bitmap loadBitmapWithBackouts ( Context context , Uri sourceUri , int sampleSize ) { boolean noBitmap = _BOOL ; int num_tries = _NUM ; if ( sampleSize <= _NUM ) { sampleSize = _NUM ; } Bitmap bmap = null ; while ( noBitmap ) { try { bmap = loadDownsampledBitmap ( context , sourceUri , sampleSize ) ; noBitmap = _BOOL ; } catch ( java . lang . OutOfMemoryError e ) { if ( ++ num_tries >= BITMAP_LOAD_BACKOUT_ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sampleSize *= _NUM ; } } return bmap ; }
public static Bitmap loadBitmapWithBackouts ( Context context , Uri sourceUri , int sampleSize ) { boolean noBitmap = _BOOL ; int num_tries = _NUM ; if ( sampleSize <= _NUM ) { sampleSize = _NUM ; } Bitmap bmap = null ; while ( noBitmap ) { try { bmap = loadDownsampledBitmap ( context , sourceUri , sampleSize ) ; noBitmap = _BOOL ; } catch ( java . lang . OutOfMemoryError e ) { if ( ++ num_tries >= BITMAP_LOAD_BACKOUT_ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sampleSize *= _NUM ; } } return bmap ; }
public static Bitmap loadBitmapWithBackouts ( Context context , Uri sourceUri , int sampleSize ) { boolean noBitmap = _BOOL ; int num_tries = _NUM ; if ( sampleSize <= _NUM ) { sampleSize = _NUM ; } Bitmap bmap = null ; while ( noBitmap ) { try { bmap = loadDownsampledBitmap ( context , sourceUri , sampleSize ) ; noBitmap = _BOOL ; } catch ( java . lang . OutOfMemoryError e ) { if ( ++ num_tries >= BITMAP_LOAD_BACKOUT_ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sampleSize *= _NUM ; } } return bmap ; }
public static Bitmap loadBitmapWithBackouts ( Context context , Uri sourceUri , int sampleSize ) { boolean noBitmap = _BOOL ; int num_tries = _NUM ; if ( sampleSize <= _NUM ) { sampleSize = _NUM ; } Bitmap bmap = null ; while ( noBitmap ) { try { bmap = loadDownsampledBitmap ( context , sourceUri , sampleSize ) ; noBitmap = _BOOL ; } catch ( java . lang . OutOfMemoryError e ) { if ( ++ num_tries >= BITMAP_LOAD_BACKOUT_ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sampleSize *= _NUM ; } } return bmap ; }
public static Bitmap loadBitmapWithBackouts ( Context context , Uri sourceUri , int sampleSize ) { boolean noBitmap = _BOOL ; int num_tries = _NUM ; if ( sampleSize <= _NUM ) { sampleSize = _NUM ; } Bitmap bmap = null ; while ( noBitmap ) { try { bmap = loadDownsampledBitmap ( context , sourceUri , sampleSize ) ; noBitmap = _BOOL ; } catch ( java . lang . OutOfMemoryError e ) { if ( ++ num_tries >= BITMAP_LOAD_BACKOUT_ATTEMPTS ) { throw e ; } bmap = null ; System . gc ( ) ; sampleSize *= _NUM ; } } return bmap ; }
private static void learn ( ) { int listSize = learningQueue . size ( ) ; LOG . info ( STRING + listSize ) ; for ( int i = _NUM ; i < listSize ; i ++ ) { Instance inst = learningQueue . poll ( ) ; if ( inst != null ) learner . trainOnInstance ( inst ) ; } }
private void handleServerURLChange ( String newServerURL ) { this . coordinatorServerURL = newServerURL ; log . info ( STRING + newServerURL ) ; }
private void handleServerURLChange ( String newServerURL ) { this . coordinatorServerURL = newServerURL ; log . info ( STRING + newServerURL ) ; }
private void handleServerURLChange ( String newServerURL ) { this . coordinatorServerURL = newServerURL ; log . info ( STRING + newServerURL ) ; }
public void receive ( float newSample ) { mBuffer . set ( mBufferPointer , newSample ) ; mBufferPointer ++ ; if ( mBufferPointer >= mBufferSize ) { mBufferPointer = _NUM ; } float accumulator = _NUM ; accumulator += mCoefficients [ mCenterCoefficient ] * mBuffer . get ( mIndexMap [ mBufferPointer ] [ mCenterCoefficientMapIndex ] ) ; for ( int x = _NUM ; x < mCenterCoefficientMapIndex ; x += _NUM ) { accumulator += mCoefficients [ x ] * ( mBuffer . get ( mIndexMap [ mBufferPointer ] [ x ] ) + mBuffer . get ( mIndexMap [ mBufferPointer ] [ x + _NUM ] ) ) ; } if ( mListener != null ) { mListener . receive ( ( float ) ( accumulator * mGain ) ) ; } }
public void receive ( float newSample ) { mBuffer . set ( mBufferPointer , newSample ) ; mBufferPointer ++ ; if ( mBufferPointer >= mBufferSize ) { mBufferPointer = _NUM ; } float accumulator = _NUM ; accumulator += mCoefficients [ mCenterCoefficient ] * mBuffer . get ( mIndexMap [ mBufferPointer ] [ mCenterCoefficientMapIndex ] ) ; for ( int x = _NUM ; x < mCenterCoefficientMapIndex ; x += _NUM ) { accumulator += mCoefficients [ x ] * ( mBuffer . get ( mIndexMap [ mBufferPointer ] [ x ] ) + mBuffer . get ( mIndexMap [ mBufferPointer ] [ x + _NUM ] ) ) ; } if ( mListener != null ) { mListener . receive ( ( float ) ( accumulator * mGain ) ) ; } }
public void subtractAmount ( final String amount ) { subtractAmount ( Integer . parseInt ( amount ) ) ; }
public void subtractAmount ( final String amount ) { subtractAmount ( Integer . parseInt ( amount ) ) ; }
public static final void printCurrentThreadCpuTime ( ) { printThreadCpuTime ( Thread . currentThread ( ) ) ; }
public static final void printCurrentThreadCpuTime ( ) { printThreadCpuTime ( Thread . currentThread ( ) ) ; }
public static final void printCurrentThreadCpuTime ( ) { printThreadCpuTime ( Thread . currentThread ( ) ) ; }
public void add ( final T object ) { mObjects . add ( object ) ; notifyItemInserted ( getItemCount ( ) - _NUM ) ; }
public void add ( final T object ) { mObjects . add ( object ) ; notifyItemInserted ( getItemCount ( ) - _NUM ) ; }
@ Override public RequestMethodsRequestCondition combine ( RequestMethodsRequestCondition other ) { Set < RequestMethod > set = new LinkedHashSet < > ( this . methods ) ; set . addAll ( other . methods ) ; return new RequestMethodsRequestCondition ( set ) ; }
@ Override public synchronized void addDataSourceListener ( DataSourceListener dsl ) { m_dataSourceListeners . addElement ( dsl ) ; if ( m_format != null ) { DataSetEvent e = new DataSetEvent ( this , m_format ) ; dsl . acceptDataSet ( e ) ; } }
public IntegerConstant addInteger ( int value ) { IntegerConstant entry = getIntegerByValue ( value ) ; if ( entry != null ) return entry ; entry = new IntegerConstant ( this , _entries . size ( ) , value ) ; addConstant ( entry ) ; return entry ; }
private static int rail ( int val ) { return val > _NUM ? _NUM : val ; }
private static int rail ( int val ) { return val > _NUM ? _NUM : val ; }
private static int rail ( int val ) { return val > _NUM ? _NUM : val ; }
private static int rail ( int val ) { return val > _NUM ? _NUM : val ; }
private static int rail ( int val ) { return val > _NUM ? _NUM : val ; }
public static void splitFilePath ( String sourcePath , List < String > partitionsFiles , String separator ) { if ( StringUtils . isNotEmpty ( sourcePath ) ) { String [ ] files = sourcePath . split ( separator ) ; for ( String file : files ) { partitionsFiles . add ( file ) ; } } }
public Lucene70Codec ( Mode mode ) { super ( STRING ) ; this . storedFieldsFormat = new Lucene50StoredFieldsFormat ( Objects . requireNonNull ( mode ) ) ; }
public Lucene70Codec ( Mode mode ) { super ( STRING ) ; this . storedFieldsFormat = new Lucene50StoredFieldsFormat ( Objects . requireNonNull ( mode ) ) ; }
protected void reorderAppDeploymentsAfterConfigurationVersion ( Element domain ) { List < Element > appDeployments = xmlTool . selectElementsMatchingXPath ( STRING , domain ) ; for ( Element appDeployment : appDeployments ) { domain . removeChild ( appDeployment ) ; } Element configurationVersion = xmlTool . selectElementMatchingXPath ( STRING , domain ) ; Node before = null ; NodeList children = domain . getChildNodes ( ) ; for ( int i = _NUM ; i < children . getLength ( ) ; i ++ ) { if ( configurationVersion . equals ( children . item ( i ) ) && i < children . getLength ( ) - _NUM ) { before = children . item ( i + _NUM ) ; } } if ( before != null ) { for ( Element appDeployment : appDeployments ) { domain . insertBefore ( appDeployment , before ) ; } } else { for ( Element appDeployment : appDeployments ) { domain . appendChild ( appDeployment ) ; } } }
protected void reorderAppDeploymentsAfterConfigurationVersion ( Element domain ) { List < Element > appDeployments = xmlTool . selectElementsMatchingXPath ( STRING , domain ) ; for ( Element appDeployment : appDeployments ) { domain . removeChild ( appDeployment ) ; } Element configurationVersion = xmlTool . selectElementMatchingXPath ( STRING , domain ) ; Node before = null ; NodeList children = domain . getChildNodes ( ) ; for ( int i = _NUM ; i < children . getLength ( ) ; i ++ ) { if ( configurationVersion . equals ( children . item ( i ) ) && i < children . getLength ( ) - _NUM ) { before = children . item ( i + _NUM ) ; } } if ( before != null ) { for ( Element appDeployment : appDeployments ) { domain . insertBefore ( appDeployment , before ) ; } } else { for ( Element appDeployment : appDeployments ) { domain . appendChild ( appDeployment ) ; } } }
protected void reorderAppDeploymentsAfterConfigurationVersion ( Element domain ) { List < Element > appDeployments = xmlTool . selectElementsMatchingXPath ( STRING , domain ) ; for ( Element appDeployment : appDeployments ) { domain . removeChild ( appDeployment ) ; } Element configurationVersion = xmlTool . selectElementMatchingXPath ( STRING , domain ) ; Node before = null ; NodeList children = domain . getChildNodes ( ) ; for ( int i = _NUM ; i < children . getLength ( ) ; i ++ ) { if ( configurationVersion . equals ( children . item ( i ) ) && i < children . getLength ( ) - _NUM ) { before = children . item ( i + _NUM ) ; } } if ( before != null ) { for ( Element appDeployment : appDeployments ) { domain . insertBefore ( appDeployment , before ) ; } } else { for ( Element appDeployment : appDeployments ) { domain . appendChild ( appDeployment ) ; } } }
protected void reorderAppDeploymentsAfterConfigurationVersion ( Element domain ) { List < Element > appDeployments = xmlTool . selectElementsMatchingXPath ( STRING , domain ) ; for ( Element appDeployment : appDeployments ) { domain . removeChild ( appDeployment ) ; } Element configurationVersion = xmlTool . selectElementMatchingXPath ( STRING , domain ) ; Node before = null ; NodeList children = domain . getChildNodes ( ) ; for ( int i = _NUM ; i < children . getLength ( ) ; i ++ ) { if ( configurationVersion . equals ( children . item ( i ) ) && i < children . getLength ( ) - _NUM ) { before = children . item ( i + _NUM ) ; } } if ( before != null ) { for ( Element appDeployment : appDeployments ) { domain . insertBefore ( appDeployment , before ) ; } } else { for ( Element appDeployment : appDeployments ) { domain . appendChild ( appDeployment ) ; } } }
public synchronized void zoom ( final Point2D p , double scale ) { m_itransform . transform ( p , m_tmpPoint ) ; zoomAbs ( m_tmpPoint , scale ) ; }
public synchronized void zoom ( final Point2D p , double scale ) { m_itransform . transform ( p , m_tmpPoint ) ; zoomAbs ( m_tmpPoint , scale ) ; }
public boolean closeConnection ( ) throws SQLException { if ( connection == null ) { return _BOOL ; } connection . close ( ) ; connection = null ; return _BOOL ; }
public void stop ( ) { running = _BOOL ; }
public int numSquares1 ( int n ) { while ( n % _NUM == _NUM ) n /= _NUM ; if ( n % _NUM == _NUM ) return _NUM ; for ( int a = _NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return _NUM + ( a > _NUM ? _NUM : _NUM ) ; } } return _NUM ; }
public int numSquares1 ( int n ) { while ( n % _NUM == _NUM ) n /= _NUM ; if ( n % _NUM == _NUM ) return _NUM ; for ( int a = _NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return _NUM + ( a > _NUM ? _NUM : _NUM ) ; } } return _NUM ; }
public int numSquares1 ( int n ) { while ( n % _NUM == _NUM ) n /= _NUM ; if ( n % _NUM == _NUM ) return _NUM ; for ( int a = _NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return _NUM + ( a > _NUM ? _NUM : _NUM ) ; } } return _NUM ; }
public int numSquares1 ( int n ) { while ( n % _NUM == _NUM ) n /= _NUM ; if ( n % _NUM == _NUM ) return _NUM ; for ( int a = _NUM ; a * a <= n ; a ++ ) { int b = ( int ) Math . sqrt ( n - a * a ) ; if ( a * a + b * b == n ) { return _NUM + ( a > _NUM ? _NUM : _NUM ) ; } } return _NUM ; }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + url + STRING + databaseIdentifier + STRING + currentQuota + STRING + totalUsedQuota + STRING ) ; } long totalUnusedQuota = mGlobalLimit - totalUsedQuota - mAppCacheMaxSize ; if ( totalUnusedQuota <= _NUM ) { if ( totalUsedQuota > _NUM ) { scheduleOutOfSpaceNotification ( ) ; } quotaUpdater . updateQuota ( currentQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING ) ; } return ; } long newOriginQuota = currentQuota ; if ( newOriginQuota == _NUM ) { if ( totalUnusedQuota >= estimatedSize ) { newOriginQuota = estimatedSize ; } else { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + STRING + STRING + estimatedSize + STRING + totalUnusedQuota ) ; } newOriginQuota = _NUM ; } } else { long quotaIncrease = estimatedSize == _NUM ? Math . min ( QUOTA_INCREASE_STEP , totalUnusedQuota ) : estimatedSize ; newOriginQuota += quotaIncrease ; if ( quotaIncrease > totalUnusedQuota ) { newOriginQuota = currentQuota ; } } quotaUpdater . updateQuota ( newOriginQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + newOriginQuota ) ; } }
public void onExceededDatabaseQuota ( String url , String databaseIdentifier , long currentQuota , long estimatedSize , long totalUsedQuota , WebStorage . QuotaUpdater quotaUpdater ) { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + url + STRING + databaseIdentifier + STRING + currentQuota + STRING + totalUsedQuota + STRING ) ; } long totalUnusedQuota = mGlobalLimit - totalUsedQuota - mAppCacheMaxSize ; if ( totalUnusedQuota <= _NUM ) { if ( totalUsedQuota > _NUM ) { scheduleOutOfSpaceNotification ( ) ; } quotaUpdater . updateQuota ( currentQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING ) ; } return ; } long newOriginQuota = currentQuota ; if ( newOriginQuota == _NUM ) { if ( totalUnusedQuota >= estimatedSize ) { newOriginQuota = estimatedSize ; } else { if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + STRING + STRING + estimatedSize + STRING + totalUnusedQuota ) ; } newOriginQuota = _NUM ; } } else { long quotaIncrease = estimatedSize == _NUM ? Math . min ( QUOTA_INCREASE_STEP , totalUnusedQuota ) : estimatedSize ; newOriginQuota += quotaIncrease ; if ( quotaIncrease > totalUnusedQuota ) { newOriginQuota = currentQuota ; } } quotaUpdater . updateQuota ( newOriginQuota ) ; if ( LOGV_ENABLED ) { Log . v ( LOGTAG , STRING + newOriginQuota ) ; } }
private static int arrayIndex ( int i ) { return ( i > > SHIFT_PER_WORD ) ; }
private static int arrayIndex ( int i ) { return ( i > > SHIFT_PER_WORD ) ; }
public boolean cancelTransfer ( String username , String submissionID ) { if ( cancelUpload ( username , submissionID ) ) return _BOOL ; return cancelDownload ( username , submissionID ) ; }
public void merge ( Rectangle other ) { int oldX2 = getX2 ( ) ; int oldY2 = getY2 ( ) ; setX ( Math . min ( getX ( ) , other . getX ( ) ) ) ; setY ( Math . min ( getY ( ) , other . getY ( ) ) ) ; setWidth ( Math . max ( oldX2 , other . getX2 ( ) ) - getX ( ) ) ; setHeight ( Math . max ( oldY2 , other . getY2 ( ) ) - getY ( ) ) ; }
public void addAllListeners ( PropertyChangeListener listener , Object newObject , Set updateSet ) { addListeners ( listener , newObject , updateSet ) ; if ( ( children != null ) && ( children . length > _NUM ) ) { try { Object newValue = null ; if ( newObject != null ) { updateSet . add ( newObject ) ; newValue = extractNewValue ( newObject ) ; } for ( BindPath child : children ) { child . addAllListeners ( listener , newValue , updateSet ) ; } } catch ( Exception e ) { e . printStackTrace ( System . out ) ; } } }
public void addAllListeners ( PropertyChangeListener listener , Object newObject , Set updateSet ) { addListeners ( listener , newObject , updateSet ) ; if ( ( children != null ) && ( children . length > _NUM ) ) { try { Object newValue = null ; if ( newObject != null ) { updateSet . add ( newObject ) ; newValue = extractNewValue ( newObject ) ; } for ( BindPath child : children ) { child . addAllListeners ( listener , newValue , updateSet ) ; } } catch ( Exception e ) { e . printStackTrace ( System . out ) ; } } }
protected final void initStatistics ( String who , String [ ] headerLines ) throws AdeException { setStatsFilePath ( ) ; if ( statsFilePath == null ) { throw new AdeInternalException ( STRING ) ; } appendStatString ( SPACER ) ; appendStatString ( String . format ( STRING , currentTimeStamp ( ) , who ) ) ; appendStatString ( SPACER ) ; for ( int i = _NUM ; i < headerLines . length ; i ++ ) { appendStatString ( headerLines [ i ] ) ; } appendStatString ( SPACER ) ; }
protected final void initStatistics ( String who , String [ ] headerLines ) throws AdeException { setStatsFilePath ( ) ; if ( statsFilePath == null ) { throw new AdeInternalException ( STRING ) ; } appendStatString ( SPACER ) ; appendStatString ( String . format ( STRING , currentTimeStamp ( ) , who ) ) ; appendStatString ( SPACER ) ; for ( int i = _NUM ; i < headerLines . length ; i ++ ) { appendStatString ( headerLines [ i ] ) ; } appendStatString ( SPACER ) ; }
public boolean isNumericallyIdentical ( final Plane p ) { if ( Math . abs ( this . y * p . z - this . z * p . y ) >= MINIMUM_RESOLUTION ) return _BOOL ; if ( Math . abs ( this . z * p . x - this . x * p . z ) >= MINIMUM_RESOLUTION ) return _BOOL ; if ( Math . abs ( this . x * p . y - this . y * p . x ) >= MINIMUM_RESOLUTION ) return _BOOL ; final double denom = _NUM / ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return evaluateIsZero ( - p . x * p . D * denom , - p . y * p . D * denom , - p . z * p . D * denom ) ; }
public boolean isNumericallyIdentical ( final Plane p ) { if ( Math . abs ( this . y * p . z - this . z * p . y ) >= MINIMUM_RESOLUTION ) return _BOOL ; if ( Math . abs ( this . z * p . x - this . x * p . z ) >= MINIMUM_RESOLUTION ) return _BOOL ; if ( Math . abs ( this . x * p . y - this . y * p . x ) >= MINIMUM_RESOLUTION ) return _BOOL ; final double denom = _NUM / ( p . x * p . x + p . y * p . y + p . z * p . z ) ; return evaluateIsZero ( - p . x * p . D * denom , - p . y * p . D * denom , - p . z * p . D * denom ) ; }
public void removeValueFromDomain ( Variable var , Object value ) { Domain currDomain = getDomain ( var ) ; List < Object > values = new ArrayList < Object > ( currDomain . size ( ) ) ; for ( Object v : currDomain ) if ( ! v . equals ( value ) ) values . add ( v ) ; setDomain ( var , new Domain ( values ) ) ; }
public void removeValueFromDomain ( Variable var , Object value ) { Domain currDomain = getDomain ( var ) ; List < Object > values = new ArrayList < Object > ( currDomain . size ( ) ) ; for ( Object v : currDomain ) if ( ! v . equals ( value ) ) values . add ( v ) ; setDomain ( var , new Domain ( values ) ) ; }
public void removeValueFromDomain ( Variable var , Object value ) { Domain currDomain = getDomain ( var ) ; List < Object > values = new ArrayList < Object > ( currDomain . size ( ) ) ; for ( Object v : currDomain ) if ( ! v . equals ( value ) ) values . add ( v ) ; setDomain ( var , new Domain ( values ) ) ; }
protected PostgresMessages readMessage ( boolean hasType ) throws IOException { PostgresMessages type ; int code = - _NUM ; if ( hasType ) { try { beforeIdle ( ) ; while ( _BOOL ) { try { code = dataInput . read ( ) ; } catch ( SocketTimeoutException ex ) { idle ( ) ; continue ; } if ( ! PostgresMessages . readTypeCorrect ( code ) ) { throw new IOException ( STRING + ( char ) code ) ; } type = PostgresMessages . messageType ( code ) ; break ; } } finally { afterIdle ( ) ; } } else { type = PostgresMessages . STARTUP_MESSAGE_TYPE ; code = _NUM ; } if ( code < _NUM ) return PostgresMessages . EOF_TYPE ; recvTap . in ( ) ; try { int count = _NUM ; if ( code > _NUM ) count ++ ; int len = dataInput . readInt ( ) ; if ( ( len < _NUM ) || ( len > type . maxSize ( ) ) ) throw new IOException ( String . format ( STRING , len ) ) ; count += len ; len -= _NUM ; try { rawMessageInput = new byte [ len ] ; dataInput . readFully ( rawMessageInput , _NUM , len ) ; messageInput = new DataInputStream ( new ByteArrayInputStream ( rawMessageInput ) ) ; } catch ( OutOfMemoryError ex ) { throw new IOException ( String . format ( STRING , len ) ) ; } bytesRead ( count ) ; return type ; } finally { recvTap . out ( ) ; } }
@ Override public int hashCode ( ) { int myPosition = position ; int hash = _NUM ; while ( myPosition < limit ) { hash = hash + Float . floatToIntBits ( get ( myPosition ++ ) ) ; } return hash ; }
@ Override public int hashCode ( ) { int myPosition = position ; int hash = _NUM ; while ( myPosition < limit ) { hash = hash + Float . floatToIntBits ( get ( myPosition ++ ) ) ; } return hash ; }
@ Override public int hashCode ( ) { int myPosition = position ; int hash = _NUM ; while ( myPosition < limit ) { hash = hash + Float . floatToIntBits ( get ( myPosition ++ ) ) ; } return hash ; }
@ Override public int hashCode ( ) { int myPosition = position ; int hash = _NUM ; while ( myPosition < limit ) { hash = hash + Float . floatToIntBits ( get ( myPosition ++ ) ) ; } return hash ; }
public static double computeNewPriority_sigmoidFractionOfFriends ( double priority , int sharedFriends , int myFriends ) { double trustMultiplier = sigmoid ( sharedFriends / ( double ) myFriends , _NUM , _NUM ) ; trustMultiplier = trustMultiplier + getGaussian ( MEAN , VAR ) ; trustMultiplier = Math . min ( trustMultiplier , _NUM ) ; trustMultiplier = Math . max ( trustMultiplier , _NUM ) ; if ( sharedFriends == _NUM ) { trustMultiplier = EPSILON_TRUST ; } return priority * trustMultiplier ; }
public static double computeNewPriority_sigmoidFractionOfFriends ( double priority , int sharedFriends , int myFriends ) { double trustMultiplier = sigmoid ( sharedFriends / ( double ) myFriends , _NUM , _NUM ) ; trustMultiplier = trustMultiplier + getGaussian ( MEAN , VAR ) ; trustMultiplier = Math . min ( trustMultiplier , _NUM ) ; trustMultiplier = Math . max ( trustMultiplier , _NUM ) ; if ( sharedFriends == _NUM ) { trustMultiplier = EPSILON_TRUST ; } return priority * trustMultiplier ; }
public void addBuilderSet ( Builder builer ) { relations . addAll ( builer . relations ) ; }
public void addBuilderSet ( Builder builer ) { relations . addAll ( builer . relations ) ; }
@ PostConstruct public void init ( ) { LOGGER . trace ( STRING ) ; clusterCache . acquireWriteLockOnKey ( LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY ) ; try { if ( ! clusterCache . hasKey ( LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY ) ) { clusterCache . put ( LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY , _BOOL ) ; clusterCache . put ( LAST_ALIVE_TIMER_CHECK_LONG , Long . valueOf ( _NUM ) ) ; } } finally { clusterCache . releaseWriteLockOnKey ( LAST_ALIVE_TIMER_CHECK_INITIALISATION_KEY ) ; } LOGGER . trace ( STRING ) ; }
public static void simulateRPU ( LogicCircuit lc , GateLibrary gate_library , Args options ) { ArrayList < Gate > logic_and_output_gates = new ArrayList < Gate > ( ) ; logic_and_output_gates . addAll ( lc . get_logic_gates ( ) ) ; logic_and_output_gates . addAll ( lc . get_output_gates ( ) ) ; for ( Gate gate : logic_and_output_gates ) { gate . set_unvisited ( _BOOL ) ; } for ( Gate gate : logic_and_output_gates ) { Evaluate . simulateRPU ( gate , gate_library , options ) ; } }
public static void simulateRPU ( LogicCircuit lc , GateLibrary gate_library , Args options ) { ArrayList < Gate > logic_and_output_gates = new ArrayList < Gate > ( ) ; logic_and_output_gates . addAll ( lc . get_logic_gates ( ) ) ; logic_and_output_gates . addAll ( lc . get_output_gates ( ) ) ; for ( Gate gate : logic_and_output_gates ) { gate . set_unvisited ( _BOOL ) ; } for ( Gate gate : logic_and_output_gates ) { Evaluate . simulateRPU ( gate , gate_library , options ) ; } }
public static int putByteBuffer ( byte [ ] bytes , int offset , ByteBuffer buf ) { int len = buf . remaining ( ) ; buf . get ( bytes , offset , len ) ; return offset + len ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public void addAttribute ( GoogleBaseAttributeId attributeId , GmAttribute . Importance importance ) { if ( attributeIds . contains ( attributeId ) ) { throw new IllegalArgumentException ( STRING + STRING + attributeId ) ; } attributes . add ( new GmAttribute ( attributeId , importance ) ) ; attributeIds . add ( attributeId ) ; }
public StandardXYZToolTipGenerator ( ) { this ( DEFAULT_TOOL_TIP_FORMAT , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) ) ; }
public StandardXYZToolTipGenerator ( ) { this ( DEFAULT_TOOL_TIP_FORMAT , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) ) ; }
public StandardXYZToolTipGenerator ( ) { this ( DEFAULT_TOOL_TIP_FORMAT , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) , NumberFormat . getNumberInstance ( ) ) ; }
WebSession createNewSession ( String hostAddr ) { String newId ; do { newId = generateSessionId ( ) ; } while ( sessions . get ( newId ) != null ) ; WebSession session = new WebSession ( this ) ; session . lastAccess = System . currentTimeMillis ( ) ; session . put ( STRING , newId ) ; session . put ( STRING , hostAddr ) ; session . put ( STRING , DEFAULT_LANGUAGE ) ; session . put ( STRING , STRING ) ; session . put ( STRING , STRING ) ; sessions . put ( newId , session ) ; readTranslations ( session , DEFAULT_LANGUAGE ) ; return getSession ( newId ) ; }
private void createWorkbookJXL ( ) throws BiffException , IOException { File file = getFile ( ) ; WorkbookSettings workbookSettings = new WorkbookSettings ( ) ; if ( encoding != null ) { workbookSettings . setEncoding ( encoding . name ( ) ) ; } workbookJXL = Workbook . getWorkbook ( file , workbookSettings ) ; }
private void commitCommentNote ( String reviewCommitHash , ReviewComment comment ) { try ( GitNoteWriter < ReviewComment > writer = GitNoteWriter . createNoteWriter ( reviewCommitHash , repo , author , COMMENTS_REF ) ) { comment . setTimestamp ( System . currentTimeMillis ( ) / _NUM ) ; comment . setAuthor ( author . getEmailAddress ( ) ) ; List < ReviewComment > comments = new ArrayList < ReviewComment > ( ) ; comments . add ( comment ) ; writer . create ( STRING + reviewCommitHash , comments ) ; } }
private void commitCommentNote ( String reviewCommitHash , ReviewComment comment ) { try ( GitNoteWriter < ReviewComment > writer = GitNoteWriter . createNoteWriter ( reviewCommitHash , repo , author , COMMENTS_REF ) ) { comment . setTimestamp ( System . currentTimeMillis ( ) / _NUM ) ; comment . setAuthor ( author . getEmailAddress ( ) ) ; List < ReviewComment > comments = new ArrayList < ReviewComment > ( ) ; comments . add ( comment ) ; writer . create ( STRING + reviewCommitHash , comments ) ; } }
public DomainEditorKit ( ) { xmlViewFactory = new XmlViewFactory ( ) ; }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public GenericTableHandler ( JsonValue tableConfig , String dbSchemaName , JsonValue queriesConfig , JsonValue commandsConfig , int maxBatchSize , SQLExceptionHandler sqlExceptionHandler ) { cfg = GenericTableConfig . parse ( tableConfig ) ; this . mainTableName = cfg . mainTableName ; this . propTableName = cfg . propertiesTableName ; this . dbSchemaName = dbSchemaName ; if ( maxBatchSize < _NUM ) { this . maxBatchSize = _NUM ; } else { this . maxBatchSize = maxBatchSize ; } if ( sqlExceptionHandler == null ) { this . sqlExceptionHandler = new DefaultSQLExceptionHandler ( ) ; } else { this . sqlExceptionHandler = sqlExceptionHandler ; } queries = new TableQueries ( this , mainTableName , propTableName , dbSchemaName , getSearchableLength ( ) , new GenericQueryResultMapper ( ) ) ; queryMap = Collections . unmodifiableMap ( initializeQueryMap ( ) ) ; queries . setConfiguredQueries ( queriesConfig , commandsConfig , queryMap ) ; enableBatching = ( this . maxBatchSize > _NUM ) ; if ( enableBatching ) { logger . info ( STRING , this . maxBatchSize ) ; } else { logger . info ( STRING ) ; } }
public double norm ( ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
private List < Solution > normalize ( Population population ) { List < Solution > result = new ArrayList < Solution > ( ) ; double [ ] min = new double [ problem . getNumberOfObjectives ( ) ] ; double [ ] max = new double [ problem . getNumberOfObjectives ( ) ] ; Arrays . fill ( min , Double . POSITIVE_INFINITY ) ; Arrays . fill ( max , Double . NEGATIVE_INFINITY ) ; for ( Solution solution : population ) { for ( int i = _NUM ; i < problem . getNumberOfObjectives ( ) ; i ++ ) { min [ i ] = Math . min ( min [ i ] , solution . getObjective ( i ) ) ; max [ i ] = Math . max ( max [ i ] , solution . getObjective ( i ) ) ; } } for ( Solution solution : population ) { Solution newSolution = solution . copy ( ) ; for ( int i = _NUM ; i < problem . getNumberOfObjectives ( ) ; i ++ ) { newSolution . setObjective ( i , ( max [ i ] - ( newSolution . getObjective ( i ) - min [ i ] ) + offset ) / ( max [ i ] - min [ i ] ) ) ; } result . add ( newSolution ) ; } return result ; }
private static Object run ( String expr , Map < String , Object > variables ) { StellarProcessor processor = new StellarProcessor ( ) ; Object ret = processor . parse ( expr , null , StellarFunctions . FUNCTION_RESOLVER ( ) , Context . EMPTY_CONTEXT ( ) ) ; byte [ ] raw = SerDeUtils . toBytes ( ret ) ; Object actual = SerDeUtils . fromBytes ( raw , Object . class ) ; if ( ret instanceof StatisticsProvider ) { StatisticsProvider left = ( StatisticsProvider ) ret ; StatisticsProvider right = ( StatisticsProvider ) actual ; tolerantAssertEquals ( null , left , right ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; tolerantAssertEquals ( null , left , right , _NUM ) ; for ( double d = _NUM ; d < _NUM ; d += _NUM ) { final double pctile = d ; tolerantAssertEquals ( null , left , right , _NUM ) ; } } return ret ; }
public PropertyXMLBuilder ( ServiceSchema serviceSchema , AMModel model , Set attributeSchemas ) throws SMSException , SSOException { this . model = model ; this . serviceName = serviceSchema . getServiceName ( ) ; getServiceResourceBundle ( serviceSchema ) ; if ( serviceBundle != null ) { mapTypeToAttributeSchema = new HashMap ( attributeSchemas . size ( ) * _NUM ) ; mapTypeToAttributeSchema . put ( NULL_TYPE , attributeSchemas ) ; } }
public PropertyXMLBuilder ( ServiceSchema serviceSchema , AMModel model , Set attributeSchemas ) throws SMSException , SSOException { this . model = model ; this . serviceName = serviceSchema . getServiceName ( ) ; getServiceResourceBundle ( serviceSchema ) ; if ( serviceBundle != null ) { mapTypeToAttributeSchema = new HashMap ( attributeSchemas . size ( ) * _NUM ) ; mapTypeToAttributeSchema . put ( NULL_TYPE , attributeSchemas ) ; } }
private void basicInvalidate ( final EntryEventImpl event , boolean invokeCallbacks ) throws EntryNotFoundException { basicInvalidate ( event , invokeCallbacks , _BOOL ) ; }
private HTTPSProperties createPermissiveHTTPSProperties ( ) throws Exception { SSLContext sc = null ; sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustingTrustManager , new SecureRandom ( ) ) ; return new HTTPSProperties ( trustingHostVerifier , sc ) ; }
private HTTPSProperties createPermissiveHTTPSProperties ( ) throws Exception { SSLContext sc = null ; sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustingTrustManager , new SecureRandom ( ) ) ; return new HTTPSProperties ( trustingHostVerifier , sc ) ; }
private HTTPSProperties createPermissiveHTTPSProperties ( ) throws Exception { SSLContext sc = null ; sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustingTrustManager , new SecureRandom ( ) ) ; return new HTTPSProperties ( trustingHostVerifier , sc ) ; }
private HTTPSProperties createPermissiveHTTPSProperties ( ) throws Exception { SSLContext sc = null ; sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustingTrustManager , new SecureRandom ( ) ) ; return new HTTPSProperties ( trustingHostVerifier , sc ) ; }
private HTTPSProperties createPermissiveHTTPSProperties ( ) throws Exception { SSLContext sc = null ; sc = SSLContext . getInstance ( STRING ) ; sc . init ( null , trustingTrustManager , new SecureRandom ( ) ) ; return new HTTPSProperties ( trustingHostVerifier , sc ) ; }
protected void expandCapacity ( ) { String [ ] newArray = new String [ array . length << _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , index ) ; array = newArray ; }
private float [ ] [ ] doPolarFillCorrection ( float [ ] xpoints , float [ ] ypoints , int y1 ) { float [ ] [ ] ret = new float [ _NUM ] [ ] ; int len = xpoints . length ; float [ ] alt_xpts = new float [ len + _NUM ] ; float [ ] alt_ypts = new float [ len + _NUM ] ; System . arraycopy ( xpoints , _NUM , alt_xpts , _NUM , len ) ; System . arraycopy ( ypoints , _NUM , alt_ypts , _NUM , len ) ; alt_xpts [ len ] = alt_xpts [ len - _NUM ] ; alt_xpts [ len + _NUM ] = alt_xpts [ _NUM ] ; alt_ypts [ len ] = y1 ; alt_ypts [ len + _NUM ] = alt_ypts [ len ] ; ret [ _NUM ] = alt_xpts ; ret [ _NUM ] = alt_ypts ; return ret ; }
public long count ( ) { return count . get ( ) ; }
public DriverTask expandVolume ( StorageVolume storageVolume , long newCapacity ) { DriverTask task = new DellSCDriverTask ( STRING ) ; try { StorageCenterAPI api = connectionManager . getConnection ( storageVolume . getStorageSystemId ( ) ) ; ScVolume scVol = api . expandVolume ( storageVolume . getNativeId ( ) , SizeUtil . byteToMeg ( newCapacity ) ) ; storageVolume . setProvisionedCapacity ( SizeUtil . sizeStrToBytes ( scVol . configuredSize ) ) ; task . setStatus ( TaskStatus . READY ) ; LOG . info ( STRING , scVol . name ) ; } catch ( DellSCDriverException | StorageCenterAPIException dex ) { String error = String . format ( STRING , storageVolume . getDisplayName ( ) , dex ) ; LOG . error ( error ) ; task . setMessage ( error ) ; task . setStatus ( TaskStatus . FAILED ) ; } return task ; }
public static SequencesReader createSequencesReader ( final SequenceDataSource source ) throws IOException { final List < byte [ ] > data = new ArrayList < > ( ) ; final List < String > labels = new ArrayList < > ( ) ; final List < Long > counts = new ArrayList < > ( ) ; int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; while ( source . nextSequence ( ) ) { final byte [ ] b = new byte [ source . currentLength ( ) ] ; System . arraycopy ( source . sequenceData ( ) , _NUM , b , _NUM , source . currentLength ( ) ) ; data . add ( b ) ; labels . add ( source . name ( ) ) ; counts . add ( ( long ) source . currentLength ( ) ) ; min = Math . min ( min , source . currentLength ( ) ) ; max = Math . max ( max , source . currentLength ( ) ) ; } final byte [ ] [ ] dataArray = data . toArray ( new byte [ data . size ( ) ] [ ] ) ; final String [ ] labelsArray = labels . toArray ( new String [ labels . size ( ) ] ) ; return new CompressedMemorySequencesReader ( dataArray , labelsArray , ArrayUtils . asLongArray ( counts ) , min , max , source . type ( ) ) ; }
public static String javaEscape ( String s ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; default : sb . append ( c ) ; } } return sb . toString ( ) ; }
public Statement isNotNull ( ) { statement . append ( STRING ) ; return this ; }
public void addOption ( String name , String value ) { if ( options == null ) options = new LinkedList < ReplOption > ( ) ; options . add ( new ReplOption ( name , value ) ) ; }
public void addOption ( String name , String value ) { if ( options == null ) options = new LinkedList < ReplOption > ( ) ; options . add ( new ReplOption ( name , value ) ) ; }
public void addOption ( String name , String value ) { if ( options == null ) options = new LinkedList < ReplOption > ( ) ; options . add ( new ReplOption ( name , value ) ) ; }
protected void uncheck ( ) { checkmark . setAttribute ( SVGConstants . SVG_STYLE_ATTRIBUTE , SVGConstants . CSS_DISPLAY_PROPERTY + STRING + SVGConstants . CSS_NONE_VALUE ) ; checked = _BOOL ; fireSwitchEvent ( new ChangeEvent ( SVGCheckbox . this ) ) ; }
protected void uncheck ( ) { checkmark . setAttribute ( SVGConstants . SVG_STYLE_ATTRIBUTE , SVGConstants . CSS_DISPLAY_PROPERTY + STRING + SVGConstants . CSS_NONE_VALUE ) ; checked = _BOOL ; fireSwitchEvent ( new ChangeEvent ( SVGCheckbox . this ) ) ; }
public SolrConfig ( ) throws ParserConfigurationException , IOException , SAXException { this ( ( SolrResourceLoader ) null , DEFAULT_CONF_FILE , null ) ; }
protected String format ( Object o ) { return o . toString ( ) ; }
protected String format ( Object o ) { return o . toString ( ) ; }
public void register ( GridCacheTtlManager mgr ) { synchronized ( mux ) { if ( cleanupWorker == null ) startCleanupWorker ( ) ; mgrs . add ( mgr ) ; } }
public void alias ( final String name , final Class < ? > type , final Class < ? > defaultImplementation ) { alias ( name , type ) ; addDefaultImplementation ( defaultImplementation , type ) ; }
public void alias ( final String name , final Class < ? > type , final Class < ? > defaultImplementation ) { alias ( name , type ) ; addDefaultImplementation ( defaultImplementation , type ) ; }
@ Override public void fillOval ( int x , int y , int width , int height ) { setStateToLocal ( ) ; m_printstream . println ( xTransform ( xScale ( x ) ) + STRING + yTransform ( yScale ( y ) ) + STRING + xScale ( width ) + STRING + yScale ( height ) + STRING ) ; }
public void addMechDisplayListener ( MechDisplayListener listener ) { eventListeners . add ( listener ) ; }
public void addMechDisplayListener ( MechDisplayListener listener ) { eventListeners . add ( listener ) ; }
public void addMechDisplayListener ( MechDisplayListener listener ) { eventListeners . add ( listener ) ; }
private void populateTimeFields ( ) { leftStore . setTimeFields ( timeFieldStr . split ( STRING ) [ _NUM ] ) ; rightStore . setTimeFields ( timeFieldStr . split ( STRING ) [ _NUM ] ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Rule ) ) { return _BOOL ; } Rule other = ( Rule ) o ; if ( getLHS ( ) != other . getLHS ( ) ) { return _BOOL ; } if ( ! Arrays . equals ( getFrench ( ) , other . getFrench ( ) ) ) { return _BOOL ; } return Arrays . equals ( target , other . getEnglish ( ) ) ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Rule ) ) { return _BOOL ; } Rule other = ( Rule ) o ; if ( getLHS ( ) != other . getLHS ( ) ) { return _BOOL ; } if ( ! Arrays . equals ( getFrench ( ) , other . getFrench ( ) ) ) { return _BOOL ; } return Arrays . equals ( target , other . getEnglish ( ) ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public void testLocalInstances_deterministic ( ) { MatsimRandom . reset ( ) ; Random local1a = MatsimRandom . getLocalInstance ( ) ; Random local1b = MatsimRandom . getLocalInstance ( ) ; MatsimRandom . reset ( ) ; Random local2a = MatsimRandom . getLocalInstance ( ) ; Random local2b = MatsimRandom . getLocalInstance ( ) ; assertEqualRandomNumberGenerators ( local1a , local2a ) ; assertEqualRandomNumberGenerators ( local1b , local2b ) ; }
public void testLocalInstances_deterministic ( ) { MatsimRandom . reset ( ) ; Random local1a = MatsimRandom . getLocalInstance ( ) ; Random local1b = MatsimRandom . getLocalInstance ( ) ; MatsimRandom . reset ( ) ; Random local2a = MatsimRandom . getLocalInstance ( ) ; Random local2b = MatsimRandom . getLocalInstance ( ) ; assertEqualRandomNumberGenerators ( local1a , local2a ) ; assertEqualRandomNumberGenerators ( local1b , local2b ) ; }
public void testLocalInstances_deterministic ( ) { MatsimRandom . reset ( ) ; Random local1a = MatsimRandom . getLocalInstance ( ) ; Random local1b = MatsimRandom . getLocalInstance ( ) ; MatsimRandom . reset ( ) ; Random local2a = MatsimRandom . getLocalInstance ( ) ; Random local2b = MatsimRandom . getLocalInstance ( ) ; assertEqualRandomNumberGenerators ( local1a , local2a ) ; assertEqualRandomNumberGenerators ( local1b , local2b ) ; }
public void load ( FileLocation loc , String defaultEnc ) throws IOException { this . loc = loc ; if ( loc . isLocal ( ) && ! loc . isLocalAndExists ( ) ) { this . charSet = defaultEnc != null ? defaultEnc : getDefaultEncoding ( ) ; return ; } UnicodeReader ur = new UnicodeReader ( loc . getInputStream ( ) , defaultEnc ) ; charSet = ur . getEncoding ( ) ; Document doc = getDocument ( ) ; doc . removeDocumentListener ( this ) ; BufferedReader r = new BufferedReader ( ur ) ; try { read ( r , null ) ; } finally { doc . addDocumentListener ( this ) ; r . close ( ) ; } }
public void startAutoScroll ( String increment ) { this . autoScrolling = _BOOL ; this . autoScrollIncrement = increment ; }
public void startAutoScroll ( String increment ) { this . autoScrolling = _BOOL ; this . autoScrollIncrement = increment ; }
public void addTerminationScript ( String pathname ) { _terminationScripts . add ( pathname ) ; setDirtyAndFirePropertyChange ( STRING , pathname , null ) ; }
public void addTerminationScript ( String pathname ) { _terminationScripts . add ( pathname ) ; setDirtyAndFirePropertyChange ( STRING , pathname , null ) ; }
public static Literal parseLiteral ( String nTriplesLiteral , ValueFactory valueFactory ) throws IllegalArgumentException { if ( nTriplesLiteral . startsWith ( STRING ) ) { int endLabelIdx = findEndOfLabel ( nTriplesLiteral ) ; if ( endLabelIdx != - _NUM ) { int startLangIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; int startDtIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; if ( startLangIdx != - _NUM && startDtIdx != - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } String label = nTriplesLiteral . substring ( _NUM , endLabelIdx ) ; label = unescapeString ( label ) ; if ( startLangIdx != - _NUM ) { String language = nTriplesLiteral . substring ( startLangIdx + _NUM ) ; return valueFactory . createLiteral ( label , language ) ; } else if ( startDtIdx != - _NUM ) { String datatype = nTriplesLiteral . substring ( startDtIdx + _NUM ) ; IRI dtURI = parseURI ( datatype , valueFactory ) ; return valueFactory . createLiteral ( label , dtURI ) ; } else { return valueFactory . createLiteral ( label ) ; } } } throw new IllegalArgumentException ( STRING + nTriplesLiteral ) ; }
public static Literal parseLiteral ( String nTriplesLiteral , ValueFactory valueFactory ) throws IllegalArgumentException { if ( nTriplesLiteral . startsWith ( STRING ) ) { int endLabelIdx = findEndOfLabel ( nTriplesLiteral ) ; if ( endLabelIdx != - _NUM ) { int startLangIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; int startDtIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; if ( startLangIdx != - _NUM && startDtIdx != - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } String label = nTriplesLiteral . substring ( _NUM , endLabelIdx ) ; label = unescapeString ( label ) ; if ( startLangIdx != - _NUM ) { String language = nTriplesLiteral . substring ( startLangIdx + _NUM ) ; return valueFactory . createLiteral ( label , language ) ; } else if ( startDtIdx != - _NUM ) { String datatype = nTriplesLiteral . substring ( startDtIdx + _NUM ) ; IRI dtURI = parseURI ( datatype , valueFactory ) ; return valueFactory . createLiteral ( label , dtURI ) ; } else { return valueFactory . createLiteral ( label ) ; } } } throw new IllegalArgumentException ( STRING + nTriplesLiteral ) ; }
public static Literal parseLiteral ( String nTriplesLiteral , ValueFactory valueFactory ) throws IllegalArgumentException { if ( nTriplesLiteral . startsWith ( STRING ) ) { int endLabelIdx = findEndOfLabel ( nTriplesLiteral ) ; if ( endLabelIdx != - _NUM ) { int startLangIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; int startDtIdx = nTriplesLiteral . indexOf ( STRING , endLabelIdx ) ; if ( startLangIdx != - _NUM && startDtIdx != - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } String label = nTriplesLiteral . substring ( _NUM , endLabelIdx ) ; label = unescapeString ( label ) ; if ( startLangIdx != - _NUM ) { String language = nTriplesLiteral . substring ( startLangIdx + _NUM ) ; return valueFactory . createLiteral ( label , language ) ; } else if ( startDtIdx != - _NUM ) { String datatype = nTriplesLiteral . substring ( startDtIdx + _NUM ) ; IRI dtURI = parseURI ( datatype , valueFactory ) ; return valueFactory . createLiteral ( label , dtURI ) ; } else { return valueFactory . createLiteral ( label ) ; } } } throw new IllegalArgumentException ( STRING + nTriplesLiteral ) ; }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private void printToHost ( String host , int port , byte [ ] cmds ) throws IOException { log . debug ( STRING , host , port ) ; try ( Socket socket = new Socket ( host , port ) ; DataOutputStream out = new DataOutputStream ( socket . getOutputStream ( ) ) ) { out . write ( cmds ) ; } }
private View findCurrentCenterView ( ) { float centerX = getWidth ( ) / _NUM ; float viewHalfWidth = settings . getViewWidthPx ( ) / _NUM ; View nearestToCenterView = null ; int nearestDeltaX = _NUM ; View item ; int centerXView ; for ( int count = getChildCount ( ) , i = _NUM ; i < count ; i ++ ) { item = getChildAt ( i ) ; centerXView = ( int ) ( getDecoratedLeft ( item ) + viewHalfWidth ) ; if ( nearestToCenterView == null || Math . abs ( nearestDeltaX ) > Math . abs ( centerX - centerXView ) ) { nearestToCenterView = item ; nearestDeltaX = ( int ) ( centerX - centerXView ) ; } } return nearestToCenterView ; }
private View findCurrentCenterView ( ) { float centerX = getWidth ( ) / _NUM ; float viewHalfWidth = settings . getViewWidthPx ( ) / _NUM ; View nearestToCenterView = null ; int nearestDeltaX = _NUM ; View item ; int centerXView ; for ( int count = getChildCount ( ) , i = _NUM ; i < count ; i ++ ) { item = getChildAt ( i ) ; centerXView = ( int ) ( getDecoratedLeft ( item ) + viewHalfWidth ) ; if ( nearestToCenterView == null || Math . abs ( nearestDeltaX ) > Math . abs ( centerX - centerXView ) ) { nearestToCenterView = item ; nearestDeltaX = ( int ) ( centerX - centerXView ) ; } } return nearestToCenterView ; }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( bayesIm == null ) { throw new NullPointerException ( ) ; } }
@ Override protected Change configureCacheObject ( SubEquipment subEquipment , Properties properties ) { SubEquipmentCacheObject subEquipmentCacheObject = ( SubEquipmentCacheObject ) subEquipment ; EquipmentConfigurationUpdate update = setCommonProperties ( subEquipment , properties ) ; String tmpStr = properties . getProperty ( STRING ) ; if ( tmpStr == null ) { tmpStr = properties . getProperty ( STRING ) ; } if ( tmpStr != null ) { try { subEquipmentCacheObject . setParentId ( Long . valueOf ( tmpStr ) ) ; } catch ( NumberFormatException e ) { throw new ConfigurationException ( ConfigurationException . INVALID_PARAMETER_VALUE , STRING + tmpStr ) ; } } return update ; }
public ActivationGroupImpl ( ActivationGroupID id , MarshalledObject < ? > data ) throws RemoteException { super ( id ) ; groupID = id ; unexportObject ( this , _BOOL ) ; RMIServerSocketFactory ssf = new ServerSocketFactoryImpl ( ) ; UnicastRemoteObject . exportObject ( this , _NUM , null , ssf ) ; if ( System . getSecurityManager ( ) == null ) { try { System . setSecurityManager ( new SecurityManager ( ) ) ; } catch ( Exception e ) { throw new RemoteException ( STRING , e ) ; } } }
private static String unescapePathComponent ( String name ) { return name . replaceAll ( STRING , STRING ) ; }
private static String unescapePathComponent ( String name ) { return name . replaceAll ( STRING , STRING ) ; }
private static String unescapePathComponent ( String name ) { return name . replaceAll ( STRING , STRING ) ; }
private static String unescapePathComponent ( String name ) { return name . replaceAll ( STRING , STRING ) ; }
private static String unescapePathComponent ( String name ) { return name . replaceAll ( STRING , STRING ) ; }
public void tableChanged ( TableModelEvent e ) { initializeSortIndices ( ) ; if ( isSorted ( ) ) sort ( m_SortColumn , m_SortAscending ) ; fireTableChanged ( e ) ; }
public void tableChanged ( TableModelEvent e ) { initializeSortIndices ( ) ; if ( isSorted ( ) ) sort ( m_SortColumn , m_SortAscending ) ; fireTableChanged ( e ) ; }
public void tableChanged ( TableModelEvent e ) { initializeSortIndices ( ) ; if ( isSorted ( ) ) sort ( m_SortColumn , m_SortAscending ) ; fireTableChanged ( e ) ; }
private void addMinimizedSection ( Composite parent , FormToolkit toolkit , String sectionTitle , int numColums ) { Section section = toolkit . createSection ( parent , ExpandableComposite . TITLE_BAR | ExpandableComposite . TWISTIE ) ; section . setText ( sectionTitle ) ; section . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , _BOOL , _BOOL ) ) ; Composite sectionComposite = toolkit . createComposite ( section ) ; GridLayout gridLayout = new GridLayout ( numColums , _BOOL ) ; gridLayout . marginLeft = _NUM ; gridLayout . marginTop = _NUM ; sectionComposite . setLayout ( gridLayout ) ; section . setClient ( sectionComposite ) ; if ( ! minimizedSections . containsKey ( sectionTitle ) ) { minimizedSections . put ( sectionTitle , sectionComposite ) ; } }
private void addMinimizedSection ( Composite parent , FormToolkit toolkit , String sectionTitle , int numColums ) { Section section = toolkit . createSection ( parent , ExpandableComposite . TITLE_BAR | ExpandableComposite . TWISTIE ) ; section . setText ( sectionTitle ) ; section . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , _BOOL , _BOOL ) ) ; Composite sectionComposite = toolkit . createComposite ( section ) ; GridLayout gridLayout = new GridLayout ( numColums , _BOOL ) ; gridLayout . marginLeft = _NUM ; gridLayout . marginTop = _NUM ; sectionComposite . setLayout ( gridLayout ) ; section . setClient ( sectionComposite ) ; if ( ! minimizedSections . containsKey ( sectionTitle ) ) { minimizedSections . put ( sectionTitle , sectionComposite ) ; } }
private void addMinimizedSection ( Composite parent , FormToolkit toolkit , String sectionTitle , int numColums ) { Section section = toolkit . createSection ( parent , ExpandableComposite . TITLE_BAR | ExpandableComposite . TWISTIE ) ; section . setText ( sectionTitle ) ; section . setLayoutData ( new GridData ( SWT . FILL , SWT . FILL , _BOOL , _BOOL ) ) ; Composite sectionComposite = toolkit . createComposite ( section ) ; GridLayout gridLayout = new GridLayout ( numColums , _BOOL ) ; gridLayout . marginLeft = _NUM ; gridLayout . marginTop = _NUM ; sectionComposite . setLayout ( gridLayout ) ; section . setClient ( sectionComposite ) ; if ( ! minimizedSections . containsKey ( sectionTitle ) ) { minimizedSections . put ( sectionTitle , sectionComposite ) ; } }
public void addUI ( Component component , int buffer , int width , int height ) { if ( fieldPanel != null ) { int lastX = - _NUM ; for ( Component c : fieldPanel . getComponents ( ) ) { int x = c . getX ( ) + c . getWidth ( ) ; if ( x > lastX ) { lastX = x ; } } component . setBounds ( lastX + buffer , _NUM , width , height ) ; fieldPanel . add ( component ) ; } }
private void calcCoordinates ( final float x , final float [ ] [ ] Trm , float charSpacing ) { final float [ ] [ ] trm = new float [ _NUM ] [ _NUM ] ; for ( int xx = _NUM ; xx < _NUM ; xx ++ ) { System . arraycopy ( Trm [ xx ] , _NUM , trm [ xx ] , _NUM , _NUM ) ; } x1 = x ; x2 = trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; if ( glyphData . isHorizontal ( ) ) { if ( trm [ _NUM ] [ _NUM ] < _NUM ) { x1 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; x2 = trm [ _NUM ] [ _NUM ] ; } else if ( trm [ _NUM ] [ _NUM ] > _NUM ) { x1 = x ; x2 = trm [ _NUM ] [ _NUM ] ; } } else if ( trm [ _NUM ] [ _NUM ] > _NUM ) { x1 = trm [ _NUM ] [ _NUM ] ; x2 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; } else if ( trm [ _NUM ] [ _NUM ] < _NUM ) { x2 = trm [ _NUM ] [ _NUM ] ; x1 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; } }
private void calcCoordinates ( final float x , final float [ ] [ ] Trm , float charSpacing ) { final float [ ] [ ] trm = new float [ _NUM ] [ _NUM ] ; for ( int xx = _NUM ; xx < _NUM ; xx ++ ) { System . arraycopy ( Trm [ xx ] , _NUM , trm [ xx ] , _NUM , _NUM ) ; } x1 = x ; x2 = trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; if ( glyphData . isHorizontal ( ) ) { if ( trm [ _NUM ] [ _NUM ] < _NUM ) { x1 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; x2 = trm [ _NUM ] [ _NUM ] ; } else if ( trm [ _NUM ] [ _NUM ] > _NUM ) { x1 = x ; x2 = trm [ _NUM ] [ _NUM ] ; } } else if ( trm [ _NUM ] [ _NUM ] > _NUM ) { x1 = trm [ _NUM ] [ _NUM ] ; x2 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; } else if ( trm [ _NUM ] [ _NUM ] < _NUM ) { x2 = trm [ _NUM ] [ _NUM ] ; x1 = x + trm [ _NUM ] [ _NUM ] - ( charSpacing * trm [ _NUM ] [ _NUM ] ) ; } }
private static void analyzeNewStringSetContainsOldStringSetValues ( StringSet a , StringSet b , String name , HashMap < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . hasNext ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT_NULL , name ) ; changes . put ( key , change ) ; } }
private static void analyzeNewStringSetContainsOldStringSetValues ( StringSet a , StringSet b , String name , HashMap < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . hasNext ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT_NULL , name ) ; changes . put ( key , change ) ; } }
private static void analyzeNewStringSetContainsOldStringSetValues ( StringSet a , StringSet b , String name , HashMap < String , Change > changes ) { if ( a != null ) { Iterator < String > iter = a . iterator ( ) ; while ( iter . hasNext ( ) ) { String val = iter . next ( ) ; if ( b != null && b . contains ( val ) ) { continue ; } String key = name + STRING + val ; Change change = new Change ( key , val , null , name ) ; changes . put ( key , change ) ; } } else if ( a == null && b != null ) { String key = name ; Change change = new Change ( key , null , NOT_NULL , name ) ; changes . put ( key , change ) ; } }
public void add ( final PositionChangeListener listener ) { listeners . add ( listener ) ; }
public int addOutput ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; outputContext . add ( DEFAULT_OUTPUT_CONTEXT ) ; return index ; }
public int addOutput ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; outputContext . add ( DEFAULT_OUTPUT_CONTEXT ) ; return index ; }
public int addOutput ( ) { int index = outputs . size ( ) ; outputs . add ( Functions . discard ( ) ) ; outputContext . add ( DEFAULT_OUTPUT_CONTEXT ) ; return index ; }
public void clearAccountDisabledState ( ) { operations . add ( PasswordPolicyStateOperationType . CLEAR_ACCOUNT_DISABLED_STATE ) ; }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int qValue = quantize ( value ) ; for ( int i = _NUM ; i <= qValue ; i ++ ) { int hash = hashNgram ( ngram , _NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int qValue = quantize ( value ) ; for ( int i = _NUM ; i <= qValue ; i ++ ) { int hash = hashNgram ( ngram , _NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int qValue = quantize ( value ) ; for ( int i = _NUM ; i <= qValue ; i ++ ) { int hash = hashNgram ( ngram , _NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
private void add ( int [ ] ngram , long value , long [ ] [ ] funcs ) { if ( ngram == null ) return ; int qValue = quantize ( value ) ; for ( int i = _NUM ; i <= qValue ; i ++ ) { int hash = hashNgram ( ngram , _NUM , ngram . length , i ) ; bf . add ( hash , funcs ) ; } }
public < T extends Enum < T > > T consumeEnum ( String name , boolean required , Class < T > enumClass , T defaultValue ) throws ParseException { String value = consume ( name , required ) ; if ( value == null ) { return defaultValue ; } try { return Enum . valueOf ( enumClass , value . toUpperCase ( ) ) ; } catch ( IllegalArgumentException e ) { ParseException pe = new ParseException ( CoreErrorDomain . ERR . invalidAttributeValue , e ) ; pe . setInternalReason ( STRING + name + STRING ) ; throw pe ; } }
public void stop ( ) { duration += System . currentTimeMillis ( ) - start ; }
public static String clearEvent ( HttpServletRequest request , HttpServletResponse response ) { String errMsg = STRING ; Locale locale = UtilHttp . getLocale ( request ) ; Security security = ( Security ) request . getAttribute ( STRING ) ; if ( ! security . hasPermission ( STRING , request . getSession ( ) ) ) { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } String name = request . getParameter ( STRING ) ; if ( name == null ) { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } UtilCache < ? , ? > utilCache = UtilCache . findCache ( name ) ; if ( utilCache != null ) { utilCache . clear ( ) ; errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , UtilMisc . toMap ( STRING , name ) , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; } else { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , UtilMisc . toMap ( STRING , name ) , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } return STRING ; }
public static String clearEvent ( HttpServletRequest request , HttpServletResponse response ) { String errMsg = STRING ; Locale locale = UtilHttp . getLocale ( request ) ; Security security = ( Security ) request . getAttribute ( STRING ) ; if ( ! security . hasPermission ( STRING , request . getSession ( ) ) ) { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } String name = request . getParameter ( STRING ) ; if ( name == null ) { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } UtilCache < ? , ? > utilCache = UtilCache . findCache ( name ) ; if ( utilCache != null ) { utilCache . clear ( ) ; errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , UtilMisc . toMap ( STRING , name ) , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; } else { errMsg = UtilProperties . getMessage ( UtilCacheEvents . err_resource , STRING , UtilMisc . toMap ( STRING , name ) , locale ) + STRING ; request . setAttribute ( STRING , errMsg ) ; return STRING ; } return STRING ; }
public String assignProviderAudioSocket ( AbstractProviderConnection connection ) { String socket = connection . getAudioSocketName ( ) ; if ( socket == null ) { socket = STRING + connection . getProviderName ( ) + STRING + System . currentTimeMillis ( ) ; if ( connection . createAudioSocket ( mNativeHub , socket ) ) { Log . i ( TAG , STRING + connection . getProviderName ( ) ) ; } else { Log . w ( TAG , STRING + connection . getProviderName ( ) ) ; } } return socket ; }
public void circle ( double x , double y , double r ) { if ( r < _NUM ) throw new IllegalArgumentException ( STRING ) ; double xs = scaleX ( x ) ; double ys = scaleY ( y ) ; double ws = factorX ( _NUM * r ) ; double hs = factorY ( _NUM * r ) ; if ( ws <= _NUM && hs <= _NUM ) pixel ( x , y ) ; else offscreen . draw ( new Ellipse2D . Double ( xs - ws / _NUM , ys - hs / _NUM , ws , hs ) ) ; draw ( ) ; }
public void refresh ( CloudObject [ ] objects , CloudResponse < Integer > response ) { refreshImpl ( objects , response ) ; }
public void refresh ( CloudObject [ ] objects , CloudResponse < Integer > response ) { refreshImpl ( objects , response ) ; }
public void refresh ( CloudObject [ ] objects , CloudResponse < Integer > response ) { refreshImpl ( objects , response ) ; }
public static void sendWakeOnLan ( @ NonNull String ipStr , @ NonNull String macStr , int port , int timeoutMillis , int packets ) throws IOException , IllegalArgumentException { if ( ipStr == null ) throw new IllegalArgumentException ( STRING ) ; if ( macStr == null ) throw new IllegalArgumentException ( STRING ) ; if ( port <= _NUM || port > _NUM ) throw new IllegalArgumentException ( STRING + port ) ; if ( packets <= _NUM ) throw new IllegalArgumentException ( STRING + packets ) ; byte [ ] macBytes = getMacBytes ( macStr ) ; byte [ ] bytes = new byte [ _NUM + _NUM * macBytes . length ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { bytes [ i ] = ( byte ) _NUM ; } for ( int i = _NUM ; i < bytes . length ; i += macBytes . length ) { System . arraycopy ( macBytes , _NUM , bytes , i , macBytes . length ) ; } InetAddress address = InetAddress . getByName ( ipStr ) ; DatagramPacket packet = new DatagramPacket ( bytes , bytes . length , address , port ) ; for ( int i = _NUM ; i < packets ; i ++ ) { DatagramSocket socket = new DatagramSocket ( ) ; socket . setSoTimeout ( timeoutMillis ) ; socket . send ( packet ) ; socket . close ( ) ; } }
public static void sortFields ( FieldBinding [ ] sortedFields , int left , int right ) { Arrays . sort ( sortedFields , left , right , FIELD_COMPARATOR ) ; }
public static void sortFields ( FieldBinding [ ] sortedFields , int left , int right ) { Arrays . sort ( sortedFields , left , right , FIELD_COMPARATOR ) ; }
protected void writeNonHTMLAttributes ( AttributeSet attr ) throws IOException { String style = STRING ; String separator = STRING ; if ( inFontTag ( ) && fontAttributes . isEqual ( attr ) ) { return ; } boolean first = _BOOL ; Color color = ( Color ) attr . getAttribute ( StyleConstants . Foreground ) ; if ( color != null ) { style += STRING + css . styleConstantsValueToCSSValue ( ( StyleConstants ) StyleConstants . Foreground , color ) ; first = _BOOL ; } Integer size = ( Integer ) attr . getAttribute ( StyleConstants . FontSize ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . intValue ( ) + STRING ; first = _BOOL ; } String family = ( String ) attr . getAttribute ( StyleConstants . FontFamily ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = _BOOL ; } if ( style . length ( ) > _NUM ) { if ( fontMask != _NUM ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; } startSpanTag ( style ) ; fontAttributes = attr ; } else if ( fontAttributes != null ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; endSpanTag ( ) ; } }
protected void writeNonHTMLAttributes ( AttributeSet attr ) throws IOException { String style = STRING ; String separator = STRING ; if ( inFontTag ( ) && fontAttributes . isEqual ( attr ) ) { return ; } boolean first = _BOOL ; Color color = ( Color ) attr . getAttribute ( StyleConstants . Foreground ) ; if ( color != null ) { style += STRING + css . styleConstantsValueToCSSValue ( ( StyleConstants ) StyleConstants . Foreground , color ) ; first = _BOOL ; } Integer size = ( Integer ) attr . getAttribute ( StyleConstants . FontSize ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . intValue ( ) + STRING ; first = _BOOL ; } String family = ( String ) attr . getAttribute ( StyleConstants . FontFamily ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = _BOOL ; } if ( style . length ( ) > _NUM ) { if ( fontMask != _NUM ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; } startSpanTag ( style ) ; fontAttributes = attr ; } else if ( fontAttributes != null ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; endSpanTag ( ) ; } }
protected void writeNonHTMLAttributes ( AttributeSet attr ) throws IOException { String style = STRING ; String separator = STRING ; if ( inFontTag ( ) && fontAttributes . isEqual ( attr ) ) { return ; } boolean first = _BOOL ; Color color = ( Color ) attr . getAttribute ( StyleConstants . Foreground ) ; if ( color != null ) { style += STRING + css . styleConstantsValueToCSSValue ( ( StyleConstants ) StyleConstants . Foreground , color ) ; first = _BOOL ; } Integer size = ( Integer ) attr . getAttribute ( StyleConstants . FontSize ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . intValue ( ) + STRING ; first = _BOOL ; } String family = ( String ) attr . getAttribute ( StyleConstants . FontFamily ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = _BOOL ; } if ( style . length ( ) > _NUM ) { if ( fontMask != _NUM ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; } startSpanTag ( style ) ; fontAttributes = attr ; } else if ( fontAttributes != null ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; endSpanTag ( ) ; } }
protected void writeNonHTMLAttributes ( AttributeSet attr ) throws IOException { String style = STRING ; String separator = STRING ; if ( inFontTag ( ) && fontAttributes . isEqual ( attr ) ) { return ; } boolean first = _BOOL ; Color color = ( Color ) attr . getAttribute ( StyleConstants . Foreground ) ; if ( color != null ) { style += STRING + css . styleConstantsValueToCSSValue ( ( StyleConstants ) StyleConstants . Foreground , color ) ; first = _BOOL ; } Integer size = ( Integer ) attr . getAttribute ( StyleConstants . FontSize ) ; if ( size != null ) { if ( ! first ) { style += separator ; } style += STRING + size . intValue ( ) + STRING ; first = _BOOL ; } String family = ( String ) attr . getAttribute ( StyleConstants . FontFamily ) ; if ( family != null ) { if ( ! first ) { style += separator ; } style += STRING + family ; first = _BOOL ; } if ( style . length ( ) > _NUM ) { if ( fontMask != _NUM ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; } startSpanTag ( style ) ; fontAttributes = attr ; } else if ( fontAttributes != null ) { writeEndMask ( fontMask ) ; fontMask = _NUM ; endSpanTag ( ) ; } }
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
protected abstract boolean resolveRequest ( ClusterState state , Request request , ActionListener < Response > listener ) ;
public void addTotalResultCountCookie ( WorkbenchRequest req , HttpServletResponse resp , int value ) { addCookie ( req , resp , STRING , String . valueOf ( value ) ) ; }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public void initDiskCache ( ) { synchronized ( mDiskCacheLock ) { if ( mDiskLruCache == null || mDiskLruCache . isClosed ( ) ) { File diskCacheDir = mCacheParams . diskCacheDir ; if ( mCacheParams . diskCacheEnabled && diskCacheDir != null ) { if ( ! diskCacheDir . exists ( ) ) { diskCacheDir . mkdirs ( ) ; } if ( getUsableSpace ( diskCacheDir ) > mCacheParams . diskCacheSize ) { try { mDiskLruCache = DiskLruCache . open ( diskCacheDir , _NUM , _NUM , mCacheParams . diskCacheSize ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( final IOException e ) { mCacheParams . diskCacheDir = null ; Log . e ( TAG , STRING + e ) ; } } } } mDiskCacheStarting = _BOOL ; mDiskCacheLock . notifyAll ( ) ; } }
public static JsonObject httpGet ( CloseableHttpClient httpClient , URI uri ) throws ClientProtocolException , IOException , IllegalStateException , HttpException { HttpGet httpGet = new HttpGet ( uri ) ; try ( CloseableHttpResponse response = httpClient . execute ( httpGet ) ) { return UtilityFunctions . parseHTTPResponse ( response , uri . toString ( ) ) ; } catch ( ClientProtocolException e ) { throw e ; } }
public DateParser ( ) { this ( DateFormat . getDateInstance ( DateFormat . SHORT ) ) ; }
public synchronized void draw ( final Graphics2D gfx , final float x , final float y ) { if ( ! isEmpty ( ) ) { m_textLayout . draw ( gfx , x , y ) ; for ( final CHighlighting highlighting : new ArrayList < CHighlighting > ( m_highlighting ) ) { final double bpX = ( x + highlighting . getStart ( ) ) - _NUM ; final double bpY = ( y - m_charHeight ) + _NUM ; final double bpW = highlighting . getEnd ( ) + _NUM ; final double bpH = m_charHeight - _NUM ; drawHighlighting ( gfx , bpX , bpY , bpW , bpH , highlighting . getColor ( ) ) ; } } }
public static OSType calculateOS ( ) { String osName = System . getProperty ( STRING ) ; osName = osName . toLowerCase ( Locale . ENGLISH ) ; if ( osName . startsWith ( STRING ) ) { return OSType . APPLE ; } if ( osName . startsWith ( STRING ) ) { return OSType . WINDOWS ; } if ( osName . startsWith ( STRING ) ) { return OSType . LINUX ; } if ( osName . startsWith ( STRING ) ) { return OSType . SUN ; } return OSType . UNKNOWN ; }
public Set createAssignableDynamicGroups ( Set groupNames ) throws AMException , SSOException { Iterator iter = groupNames . iterator ( ) ; Set groups = new HashSet ( ) ; while ( iter . hasNext ( ) ) { String groupDN = AMNamingAttrManager . getNamingAttr ( GROUP ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entryDN ; AMAssignableDynamicGroupImpl groupImpl = new AMAssignableDynamicGroupImpl ( token , groupDN ) ; groupImpl . create ( ) ; groups . add ( groupImpl ) ; } return groups ; }
public Set createAssignableDynamicGroups ( Set groupNames ) throws AMException , SSOException { Iterator iter = groupNames . iterator ( ) ; Set groups = new HashSet ( ) ; while ( iter . hasNext ( ) ) { String groupDN = AMNamingAttrManager . getNamingAttr ( GROUP ) + STRING + ( ( String ) iter . next ( ) ) + STRING + entryDN ; AMAssignableDynamicGroupImpl groupImpl = new AMAssignableDynamicGroupImpl ( token , groupDN ) ; groupImpl . create ( ) ; groups . add ( groupImpl ) ; } return groups ; }
public static String JQ ( String request ) throws Exception { int queryStartPos = request . indexOf ( STRING ) ; String query ; String path ; if ( - _NUM == queryStartPos ) { query = STRING ; path = request ; } else { query = request . substring ( queryStartPos + _NUM ) ; path = request . substring ( _NUM , queryStartPos ) ; } query = setParam ( query , STRING , STRING ) ; request = path + STRING + setParam ( query , STRING , STRING ) ; String response ; boolean failed = _BOOL ; try { response = restTestHarness . query ( request ) ; failed = _BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }
public static String JQ ( String request ) throws Exception { int queryStartPos = request . indexOf ( STRING ) ; String query ; String path ; if ( - _NUM == queryStartPos ) { query = STRING ; path = request ; } else { query = request . substring ( queryStartPos + _NUM ) ; path = request . substring ( _NUM , queryStartPos ) ; } query = setParam ( query , STRING , STRING ) ; request = path + STRING + setParam ( query , STRING , STRING ) ; String response ; boolean failed = _BOOL ; try { response = restTestHarness . query ( request ) ; failed = _BOOL ; } finally { if ( failed ) { log . error ( STRING + request ) ; } } return response ; }
public NoDuplicateValueGlobalConstraint ( AbstractParameter < ? , ? > ... parameters ) { this . parameters = Arrays . asList ( parameters ) ; }
public void sendShieldFrame ( ShieldFrame frame , boolean waitIfInACallback ) { if ( frame == null ) throw new NullPointerException ( STRING ) ; if ( ! isConnected ( ) ) { onError ( OneSheeldError . DEVICE_NOT_CONNECTED ) ; return ; } else if ( isUpdatingFirmware ( ) ) { onError ( OneSheeldError . FIRMWARE_UPDATE_IN_PROGRESS ) ; return ; } if ( ! waitIfInACallback ) { sendFrame ( frame ) ; return ; } boolean inACallback ; synchronized ( arduinoCallbacksLock ) { inACallback = isInACallback ; } if ( inACallback ) { queuedFrames . add ( frame ) ; } else { if ( queuedFrames . isEmpty ( ) ) { sendFrame ( frame ) ; } else { queuedFrames . add ( frame ) ; } } }
public FontSizer ( FontSizer source ) { restore ( source ) ; }
@ Before public void initializeTestDirectories ( ) { logger . debug ( STRING ) ; String testId = testIdWatcher . getTestId ( ) ; File baseDir = getBaseDir ( ) ; File resourcesDir = new File ( baseDir , TEST_RESOURCES_DIR ) ; sourceTestDir = new File ( resourcesDir , testId ) ; targetTestDir = new File ( baseDir , TEST_RESOURCES_TARGET_DIR + testId ) ; logger . debug ( STRING ) ; try { FileUtils . deleteDirectory ( targetTestDir ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING + targetTestDir . getAbsolutePath ( ) , e ) ; } targetTestDir . mkdirs ( ) ; }
@ Before public void initializeTestDirectories ( ) { logger . debug ( STRING ) ; String testId = testIdWatcher . getTestId ( ) ; File baseDir = getBaseDir ( ) ; File resourcesDir = new File ( baseDir , TEST_RESOURCES_DIR ) ; sourceTestDir = new File ( resourcesDir , testId ) ; targetTestDir = new File ( baseDir , TEST_RESOURCES_TARGET_DIR + testId ) ; logger . debug ( STRING ) ; try { FileUtils . deleteDirectory ( targetTestDir ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING + targetTestDir . getAbsolutePath ( ) , e ) ; } targetTestDir . mkdirs ( ) ; }
@ Before public void initializeTestDirectories ( ) { logger . debug ( STRING ) ; String testId = testIdWatcher . getTestId ( ) ; File baseDir = getBaseDir ( ) ; File resourcesDir = new File ( baseDir , TEST_RESOURCES_DIR ) ; sourceTestDir = new File ( resourcesDir , testId ) ; targetTestDir = new File ( baseDir , TEST_RESOURCES_TARGET_DIR + testId ) ; logger . debug ( STRING ) ; try { FileUtils . deleteDirectory ( targetTestDir ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING + targetTestDir . getAbsolutePath ( ) , e ) ; } targetTestDir . mkdirs ( ) ; }
@ Before public void initializeTestDirectories ( ) { logger . debug ( STRING ) ; String testId = testIdWatcher . getTestId ( ) ; File baseDir = getBaseDir ( ) ; File resourcesDir = new File ( baseDir , TEST_RESOURCES_DIR ) ; sourceTestDir = new File ( resourcesDir , testId ) ; targetTestDir = new File ( baseDir , TEST_RESOURCES_TARGET_DIR + testId ) ; logger . debug ( STRING ) ; try { FileUtils . deleteDirectory ( targetTestDir ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING + targetTestDir . getAbsolutePath ( ) , e ) ; } targetTestDir . mkdirs ( ) ; }
public static String createTempFile ( final String ... lines ) throws Exception { final File f = File . createTempFile ( STRING , STRING ) ; f . deleteOnExit ( ) ; try ( final FileWriter w = new FileWriter ( f ) ) { for ( final String s : lines ) { w . write ( s + System . getProperty ( STRING ) ) ; } } return f . getAbsolutePath ( ) ; }
public static String createTempFile ( final String ... lines ) throws Exception { final File f = File . createTempFile ( STRING , STRING ) ; f . deleteOnExit ( ) ; try ( final FileWriter w = new FileWriter ( f ) ) { for ( final String s : lines ) { w . write ( s + System . getProperty ( STRING ) ) ; } } return f . getAbsolutePath ( ) ; }
public static byte [ ] createNonce ( int bytes ) { LOGGER . debug ( STRING , bytes ) ; byte [ ] nonce = new byte [ bytes ] ; random . nextBytes ( nonce ) ; return nonce ; }
public void resetFPSCalculations ( ) { firstSystemTime = SystemClock . elapsedRealtime ( ) ; timeToUpdate = firstSystemTime + _NUM ; numberOfFrames = _NUM ; }
public void resetFPSCalculations ( ) { firstSystemTime = SystemClock . elapsedRealtime ( ) ; timeToUpdate = firstSystemTime + _NUM ; numberOfFrames = _NUM ; }
public void resetFPSCalculations ( ) { firstSystemTime = SystemClock . elapsedRealtime ( ) ; timeToUpdate = firstSystemTime + _NUM ; numberOfFrames = _NUM ; }
public void removeRestrictionList ( Node n ) { while ( ! nodeCausingRestriction . empty ( ) && nodeCausingRestriction . peek ( ) == n ) { neighbourLists . pop ( ) ; nodeCausingRestriction . pop ( ) ; } }
private boolean isMemberMXBeanFound ( final Collection < ObjectName > objectNames ) { return ! ( objectNames == null || objectNames . isEmpty ( ) ) ; }
private boolean isMemberMXBeanFound ( final Collection < ObjectName > objectNames ) { return ! ( objectNames == null || objectNames . isEmpty ( ) ) ; }
public void addRangeAxisConfig ( RangeAxisConfig rangeAxis ) { addRangeAxisConfig ( rangeAxisConfigs . size ( ) , rangeAxis ) ; }
public void stop ( ) { synchronized ( this ) { mStopped = _BOOL ; if ( mListenerThread == null ) { return ; } } mListenerThread . interrupt ( ) ; try { if ( mServerSocket != null ) { mServerSocket . close ( ) ; } } catch ( IOException e ) { } }
public void stop ( ) { synchronized ( this ) { mStopped = _BOOL ; if ( mListenerThread == null ) { return ; } } mListenerThread . interrupt ( ) ; try { if ( mServerSocket != null ) { mServerSocket . close ( ) ; } } catch ( IOException e ) { } }
private static int determineType ( byte [ ] bytes ) { int offset = _NUM ; if ( bytes . length >= _NUM && ( bytes [ _NUM ] & _NUM ) == _NUM && ( bytes [ _NUM ] & _NUM ) == _NUM && ( bytes [ _NUM ] & _NUM ) == _NUM ) { offset += _NUM ; } while ( offset < bytes . length && bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING || bytes [ offset ] == STRING ) { offset ++ ; } return determineType ( new String ( bytes , offset , Math . min ( _NUM , bytes . length - offset ) ) ) ; }
@ SafeVarargs public static < T > Supplier < T > randomlySelect ( T first , T ... additional ) { if ( additional == null || additional . length == _NUM ) return null ; Random rng = new Random ( System . currentTimeMillis ( ) ) ; int max = additional . length + _NUM ; return null ; }
@ SafeVarargs public static < T > Supplier < T > randomlySelect ( T first , T ... additional ) { if ( additional == null || additional . length == _NUM ) return null ; Random rng = new Random ( System . currentTimeMillis ( ) ) ; int max = additional . length + _NUM ; return null ; }
@ SafeVarargs public static < T > Supplier < T > randomlySelect ( T first , T ... additional ) { if ( additional == null || additional . length == _NUM ) return null ; Random rng = new Random ( System . currentTimeMillis ( ) ) ; int max = additional . length + _NUM ; return null ; }
@ SafeVarargs public static < T > Supplier < T > randomlySelect ( T first , T ... additional ) { if ( additional == null || additional . length == _NUM ) return null ; Random rng = new Random ( System . currentTimeMillis ( ) ) ; int max = additional . length + _NUM ; return null ; }
@ SafeVarargs public static < T > Supplier < T > randomlySelect ( T first , T ... additional ) { if ( additional == null || additional . length == _NUM ) return null ; Random rng = new Random ( System . currentTimeMillis ( ) ) ; int max = additional . length + _NUM ; return null ; }
public ContentProposalAdapter ( Control control , IControlContentAdapter controlContentAdapter , IContentProposalProvider proposalProvider , KeyStroke keyStroke , char [ ] autoActivationCharacters ) { super ( ) ; Assert . isNotNull ( control ) ; Assert . isNotNull ( controlContentAdapter ) ; this . control = control ; this . controlContentAdapter = controlContentAdapter ; this . proposalProvider = proposalProvider ; this . triggerKeyStroke = keyStroke ; if ( autoActivationCharacters != null ) { this . autoActivateString = new String ( autoActivationCharacters ) ; } addControlListener ( control ) ; }
public ContentProposalAdapter ( Control control , IControlContentAdapter controlContentAdapter , IContentProposalProvider proposalProvider , KeyStroke keyStroke , char [ ] autoActivationCharacters ) { super ( ) ; Assert . isNotNull ( control ) ; Assert . isNotNull ( controlContentAdapter ) ; this . control = control ; this . controlContentAdapter = controlContentAdapter ; this . proposalProvider = proposalProvider ; this . triggerKeyStroke = keyStroke ; if ( autoActivationCharacters != null ) { this . autoActivateString = new String ( autoActivationCharacters ) ; } addControlListener ( control ) ; }
public ContentProposalAdapter ( Control control , IControlContentAdapter controlContentAdapter , IContentProposalProvider proposalProvider , KeyStroke keyStroke , char [ ] autoActivationCharacters ) { super ( ) ; Assert . isNotNull ( control ) ; Assert . isNotNull ( controlContentAdapter ) ; this . control = control ; this . controlContentAdapter = controlContentAdapter ; this . proposalProvider = proposalProvider ; this . triggerKeyStroke = keyStroke ; if ( autoActivationCharacters != null ) { this . autoActivateString = new String ( autoActivationCharacters ) ; } addControlListener ( control ) ; }
public static MimeType fromFileName ( final String fileName ) { final String inLowerCaseName = fileName . toLowerCase ( ) ; final String fileExtension = getFileExtension ( inLowerCaseName ) ; final MimeType mimeType = fileExtensions . get ( fileExtension ) ; if ( mimeType != null ) { return mimeType ; } return BINARY ; }
@ VisibleForTesting protected static void updateBootDiskCapacity ( List < AttachedDiskCreateSpec > disks , ImageEntity image , List < Throwable > warnings ) throws InvalidVmDisksSpecException , InvalidImageStateException { for ( AttachedDiskCreateSpec disk : disks ) { if ( disk . isBootDisk ( ) ) { if ( image . getSize ( ) == null ) { throw new InvalidImageStateException ( STRING + image . getId ( ) + STRING ) ; } if ( disk . getCapacityGb ( ) != null ) { warnings . add ( new InvalidVmDisksSpecException ( STRING ) ) ; } disk . setCapacityGb ( ( int ) ( image . getSize ( ) / GB_TO_BYTE_CONVERSION_RATIO ) ) ; return ; } } throw new InvalidVmDisksSpecException ( STRING ) ; }
@ VisibleForTesting protected static void updateBootDiskCapacity ( List < AttachedDiskCreateSpec > disks , ImageEntity image , List < Throwable > warnings ) throws InvalidVmDisksSpecException , InvalidImageStateException { for ( AttachedDiskCreateSpec disk : disks ) { if ( disk . isBootDisk ( ) ) { if ( image . getSize ( ) == null ) { throw new InvalidImageStateException ( STRING + image . getId ( ) + STRING ) ; } if ( disk . getCapacityGb ( ) != null ) { warnings . add ( new InvalidVmDisksSpecException ( STRING ) ) ; } disk . setCapacityGb ( ( int ) ( image . getSize ( ) / GB_TO_BYTE_CONVERSION_RATIO ) ) ; return ; } } throw new InvalidVmDisksSpecException ( STRING ) ; }
@ VisibleForTesting protected static void updateBootDiskCapacity ( List < AttachedDiskCreateSpec > disks , ImageEntity image , List < Throwable > warnings ) throws InvalidVmDisksSpecException , InvalidImageStateException { for ( AttachedDiskCreateSpec disk : disks ) { if ( disk . isBootDisk ( ) ) { if ( image . getSize ( ) == null ) { throw new InvalidImageStateException ( STRING + image . getId ( ) + STRING ) ; } if ( disk . getCapacityGb ( ) != null ) { warnings . add ( new InvalidVmDisksSpecException ( STRING ) ) ; } disk . setCapacityGb ( ( int ) ( image . getSize ( ) / GB_TO_BYTE_CONVERSION_RATIO ) ) ; return ; } } throw new InvalidVmDisksSpecException ( STRING ) ; }
@ Override public Enumeration < String > enumerateRequests ( ) { Vector < String > newVector = new Vector < String > ( _NUM ) ; if ( m_evaluateThread != null ) { newVector . addElement ( STRING ) ; } return newVector . elements ( ) ; }
public ResourcesPoet addTypedArray ( String name , @ NotNull List < String > values ) { Element element = document . createElement ( STRING ) ; element . setAttribute ( STRING , name ) ; for ( String value : values ) { Element valueElement = document . createElement ( STRING ) ; valueElement . appendChild ( document . createTextNode ( value ) ) ; element . appendChild ( valueElement ) ; } resourceElement . appendChild ( element ) ; return this ; }
protected SnmpCachedData updateCachedDatas ( Object userData ) { final String [ ] path = JvmRuntimeImpl . getBootClassPath ( userData ) ; final long time = System . currentTimeMillis ( ) ; final int len = path . length ; SnmpOid indexes [ ] = new SnmpOid [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { indexes [ i ] = new SnmpOid ( i + _NUM ) ; } return new SnmpCachedData ( time , indexes , path ) ; }
protected SnmpCachedData updateCachedDatas ( Object userData ) { final String [ ] path = JvmRuntimeImpl . getBootClassPath ( userData ) ; final long time = System . currentTimeMillis ( ) ; final int len = path . length ; SnmpOid indexes [ ] = new SnmpOid [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { indexes [ i ] = new SnmpOid ( i + _NUM ) ; } return new SnmpCachedData ( time , indexes , path ) ; }
private Optional < IcicleRedisResponse > executeLuaScript ( final Redis redis , final long batchSize ) { List < String > args = Arrays . asList ( String . valueOf ( MAX_SEQUENCE ) , String . valueOf ( MIN_LOGICAL_SHARD_ID ) , String . valueOf ( MAX_LOGICAL_SHARD_ID ) , String . valueOf ( batchSize ) ) ; return redis . evalLuaScript ( luaScriptSha , args ) ; }
private Optional < IcicleRedisResponse > executeLuaScript ( final Redis redis , final long batchSize ) { List < String > args = Arrays . asList ( String . valueOf ( MAX_SEQUENCE ) , String . valueOf ( MIN_LOGICAL_SHARD_ID ) , String . valueOf ( MAX_LOGICAL_SHARD_ID ) , String . valueOf ( batchSize ) ) ; return redis . evalLuaScript ( luaScriptSha , args ) ; }
public void removeIgnoredView ( View v ) { mIgnoredViews . remove ( v ) ; }
@ Override public void renderFormsOntoG2InHeadless ( final Object raw , final int pageIndex , final Map componentsToIgnore , final FormFactory formFactory ) { if ( formsOrdered == null || formsOrdered [ pageIndex ] == null ) { return ; } this . componentsToIgnore = componentsToIgnore ; FormObject formObject ; final boolean isPrinting = formFactory != null ; final Graphics2D g2 = ( Graphics2D ) raw ; final AffineTransform defaultAf = g2 . getTransform ( ) ; final AffineTransform aff = g2 . getTransform ( ) ; aff . scale ( _NUM , _NUM ) ; g2 . setTransform ( aff ) ; for ( final FormObject nextVal : formsOrdered [ pageIndex ] ) { if ( nextVal != null ) { formObject = nextVal ; final boolean [ ] flags = formObject . getCharacteristics ( ) ; if ( ( ( flags [ _NUM ] || ( isPrinting && ! flags [ _NUM ] ) ) ) ) { continue ; } renderComponent ( g2 , formObject , isPrinting ) ; } } g2 . setTransform ( defaultAf ) ; }
public static byte [ ] [ ] split ( final byte [ ] bytes , final int splitIndex ) { if ( splitIndex < _NUM || bytes . length < splitIndex ) { throw new IllegalArgumentException ( STRING ) ; } final byte [ ] lhs = new byte [ splitIndex ] ; final byte [ ] rhs = new byte [ bytes . length - splitIndex ] ; System . arraycopy ( bytes , _NUM , lhs , _NUM , lhs . length ) ; System . arraycopy ( bytes , splitIndex , rhs , _NUM , rhs . length ) ; return new byte [ ] [ ] { lhs , rhs } ; }
public static byte [ ] [ ] split ( final byte [ ] bytes , final int splitIndex ) { if ( splitIndex < _NUM || bytes . length < splitIndex ) { throw new IllegalArgumentException ( STRING ) ; } final byte [ ] lhs = new byte [ splitIndex ] ; final byte [ ] rhs = new byte [ bytes . length - splitIndex ] ; System . arraycopy ( bytes , _NUM , lhs , _NUM , lhs . length ) ; System . arraycopy ( bytes , splitIndex , rhs , _NUM , rhs . length ) ; return new byte [ ] [ ] { lhs , rhs } ; }
public final void init ( final String current_key ) { key = current_key + System . currentTimeMillis ( ) ; final File f = new File ( temp_dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
public final void init ( final String current_key ) { key = current_key + System . currentTimeMillis ( ) ; final File f = new File ( temp_dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
public final void init ( final String current_key ) { key = current_key + System . currentTimeMillis ( ) ; final File f = new File ( temp_dir ) ; if ( ! f . exists ( ) ) { f . mkdirs ( ) ; } }
private void updateVersion ( ) { prop . put ( STRING + oldVersion , STRING ) ; prop . put ( STRING + newVersion , STRING ) ; prop . put ( STRING + oldVersion , newVersion ) ; }
private void ensureSize ( ) { if ( children == EMPTY_CHILDREN ) { children = new FPNode [ _NUM ] ; return ; } int newsize = children . length == _NUM ? INITIAL_SIZE : ( children . length << _NUM ) ; children = Arrays . copyOf ( children , newsize ) ; }
private void ensureSize ( ) { if ( children == EMPTY_CHILDREN ) { children = new FPNode [ _NUM ] ; return ; } int newsize = children . length == _NUM ? INITIAL_SIZE : ( children . length << _NUM ) ; children = Arrays . copyOf ( children , newsize ) ; }
public < T > T toNova ( Object nativeObject ) { Objects . requireNonNull ( nativeObject ) ; NativeConverter converter = findConverter ( nativeConverters , nativeObject ) ; if ( converter == null ) { throw new NativeException ( STRING + nativeObject + STRING + nativeObject . getClass ( ) + STRING ) ; } return ( T ) converter . toNova ( nativeObject ) ; }
public < T > T toNova ( Object nativeObject ) { Objects . requireNonNull ( nativeObject ) ; NativeConverter converter = findConverter ( nativeConverters , nativeObject ) ; if ( converter == null ) { throw new NativeException ( STRING + nativeObject + STRING + nativeObject . getClass ( ) + STRING ) ; } return ( T ) converter . toNova ( nativeObject ) ; }
public < T > T toNova ( Object nativeObject ) { Objects . requireNonNull ( nativeObject ) ; NativeConverter converter = findConverter ( nativeConverters , nativeObject ) ; if ( converter == null ) { throw new NativeException ( STRING + nativeObject + STRING + nativeObject . getClass ( ) + STRING ) ; } return ( T ) converter . toNova ( nativeObject ) ; }
private static void addToBG ( AbstractButton button , Container cont , ButtonGroup bg ) { bg . add ( button ) ; cont . add ( button ) ; }
private void computeImplicitForwardDependencesUse ( Register r , DepGraphNode destNode ) { DepGraphNode sourceNode = getDepGraphNode ( r ) ; if ( sourceNode != null ) { for ( Enumeration < Register > e = GenericPhysicalDefUse . enumerate ( GenericPhysicalDefUse . getMaskTSPDefs ( ) , ir ) ; e . hasMoreElements ( ) ; ) { Register r2 = e . nextElement ( ) ; if ( r == r2 ) { sourceNode . insertOutEdge ( destNode , REG_MAY_DEF ) ; return ; } } sourceNode . insertOutEdge ( destNode , REG_TRUE ) ; } }
public boolean addRow ( TableEntry entry ) { try { int row = list . size ( ) ; list . add ( entry ) ; fireTableRowsInserted ( row , row ) ; } catch ( Exception e ) { return _BOOL ; } return _BOOL ; }
public void readData ( DataInput din ) throws IOException { reference = din . readUnsignedShort ( ) ; andMask = din . readUnsignedShort ( ) ; orMask = din . readUnsignedShort ( ) ; }
public void readData ( DataInput din ) throws IOException { reference = din . readUnsignedShort ( ) ; andMask = din . readUnsignedShort ( ) ; orMask = din . readUnsignedShort ( ) ; }
public DNetscapeCaRevocationUrl ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
private static String eliminateSpaces ( final String ¢ ) { return Essence . of ( ¢ ) ; }
public static String report ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Tap tap : dispatchesCopy ( ) ) { int length = sb . length ( ) ; tap . appendReport ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW_LINE ) ; } } String result = sb . toString ( ) ; LOG . debug ( STRING + NEW_LINE + NEW_LINE + result + NEW_LINE ) ; return result ; }
public static String report ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Tap tap : dispatchesCopy ( ) ) { int length = sb . length ( ) ; tap . appendReport ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW_LINE ) ; } } String result = sb . toString ( ) ; LOG . debug ( STRING + NEW_LINE + NEW_LINE + result + NEW_LINE ) ; return result ; }
public static String report ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Tap tap : dispatchesCopy ( ) ) { int length = sb . length ( ) ; tap . appendReport ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW_LINE ) ; } } String result = sb . toString ( ) ; LOG . debug ( STRING + NEW_LINE + NEW_LINE + result + NEW_LINE ) ; return result ; }
public static String report ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( Tap tap : dispatchesCopy ( ) ) { int length = sb . length ( ) ; tap . appendReport ( null , sb ) ; if ( sb . length ( ) > length ) { sb . append ( NEW_LINE ) ; } } String result = sb . toString ( ) ; LOG . debug ( STRING + NEW_LINE + NEW_LINE + result + NEW_LINE ) ; return result ; }
@ Step ( STRING ) public static void assertElementIsVisibleAfter ( AugmentedFunctions driver , By by , int timeoutInSeconds ) { Preconditions . checkNotNull ( driver ) ; Preconditions . checkNotNull ( by ) ; try { driver . findElementsVisibleAfter ( by , timeoutInSeconds ) ; } catch ( TimeoutException e ) { throw new AssertionError ( String . format ( STRING , by , timeoutInSeconds ) , e ) ; } }
@ Step ( STRING ) public static void assertElementIsVisibleAfter ( AugmentedFunctions driver , By by , int timeoutInSeconds ) { Preconditions . checkNotNull ( driver ) ; Preconditions . checkNotNull ( by ) ; try { driver . findElementsVisibleAfter ( by , timeoutInSeconds ) ; } catch ( TimeoutException e ) { throw new AssertionError ( String . format ( STRING , by , timeoutInSeconds ) , e ) ; } }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + _NUM ] ; System . arraycopy ( key , _NUM , tmp , _NUM , keylen ) ; return tmp ; }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + _NUM ] ; System . arraycopy ( key , _NUM , tmp , _NUM , keylen ) ; return tmp ; }
public final static byte [ ] successor ( final byte [ ] key ) { final int keylen = key . length ; final byte [ ] tmp = new byte [ keylen + _NUM ] ; System . arraycopy ( key , _NUM , tmp , _NUM , keylen ) ; return tmp ; }
@ Inline public static void toUTF8 ( String s , ByteBuffer b ) { int result_index = _NUM ; for ( int i = _NUM , n = s . length ( ) ; i < n ; ++ i ) { char c = s . charAt ( i ) ; if ( ( ( ! WRITE_PSEUDO_UTF8 ) || ( c >= _NUM ) ) && ( c <= _NUM ) ) { b . put ( ( byte ) c ) ; } else if ( c > _NUM ) { b . put ( ( byte ) ( _NUM | ( byte ) ( c > > _NUM ) ) ) ; b . put ( ( byte ) ( _NUM | ( ( c & _NUM ) > > _NUM ) ) ) ; b . put ( ( byte ) ( _NUM | ( c & _NUM ) ) ) ; } else { b . put ( ( byte ) ( _NUM | ( byte ) ( c > > _NUM ) ) ) ; b . put ( ( byte ) ( _NUM | ( c & _NUM ) ) ) ; } } }
private void updateDesign ( DataSetDesign dataSetDesign , IConnection conn , String queryText ) throws OdaException { IQuery query = conn . newQuery ( null ) ; query . prepare ( queryText ) ; query . setProperty ( Query . PROP_SETUP_QUERY_TEXT , getSetupQueryText ( ) ) ; try { IResultSetMetaData md = query . getMetaData ( ) ; updateResultSetDesign ( md , dataSetDesign ) ; } catch ( OdaException e ) { dataSetDesign . setResultSets ( null ) ; e . printStackTrace ( ) ; } try { IParameterMetaData paramMd = query . getParameterMetaData ( ) ; updateParameterDesign ( paramMd , dataSetDesign ) ; } catch ( OdaException ex ) { dataSetDesign . setParameters ( null ) ; ex . printStackTrace ( ) ; } }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public static DBHandler acquireDB ( ) throws GBException { try { if ( dbLock . tryLock ( _NUM , TimeUnit . SECONDS ) ) { return lockHandler ; } } catch ( InterruptedException ex ) { Log . i ( TAG , STRING ) ; } throw new GBException ( STRING ) ; }
public String moveBack ( ) { Check . isTrue ( currentIndex > _NUM , STRING ) ; currentIndex -- ; return history . get ( currentIndex ) ; }
public String moveBack ( ) { Check . isTrue ( currentIndex > _NUM , STRING ) ; currentIndex -- ; return history . get ( currentIndex ) ; }
public void close ( ) { assertNotNull ( client ) ; client . setConnectionStatus ( ConnectionChangeEvent . Status . DISCONNECTED ) ; if ( inputThread != null ) inputThread . end ( ) ; if ( heartbeatThread != null ) heartbeatThread . end ( ) ; if ( outputExecutor != null ) outputExecutor . shutdownNow ( ) ; try { if ( channel != null ) channel . close ( ) ; if ( socket != null ) socket . close ( ) ; } catch ( Exception e ) { } }
private void generateChunksForSchema ( String schemaName ) { try { if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + schemaName ) ; ArrayList < Table > tablesFromSchema = connection . getTables ( schemaName , _BOOL , _BOOL ) ; if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + tablesFromSchema ) ; if ( tablesFromSchema != null && tablesFromSchema . size ( ) > _NUM ) { for ( Table table : tablesFromSchema ) { generateChunksForTable ( table , - _NUM , null ) ; } } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
public String leaveDTD ( ) throws IOException { if ( _writer == _dtdWriter ) { flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
public String leaveDTD ( ) throws IOException { if ( _writer == _dtdWriter ) { flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
public String leaveDTD ( ) throws IOException { if ( _writer == _dtdWriter ) { flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
public String leaveDTD ( ) throws IOException { if ( _writer == _dtdWriter ) { flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
public String leaveDTD ( ) throws IOException { if ( _writer == _dtdWriter ) { flushLine ( _BOOL ) ; _writer = _docWriter ; return _dtdWriter . toString ( ) ; } return null ; }
private LocusInfo createNextUncoveredLocusInfo ( final Locus stopBeforeLocus ) { while ( lastReferenceSequence <= stopBeforeLocus . getSequenceIndex ( ) && lastReferenceSequence <= referenceSequenceMask . getMaxSequenceIndex ( ) ) { if ( lastReferenceSequence == stopBeforeLocus . getSequenceIndex ( ) && lastPosition + _NUM >= stopBeforeLocus . getPosition ( ) ) { return null ; } final int nextbit = referenceSequenceMask . nextPosition ( lastReferenceSequence , lastPosition ) ; if ( nextbit == - _NUM ) { if ( lastReferenceSequence == stopBeforeLocus . getSequenceIndex ( ) ) { lastPosition = stopBeforeLocus . getPosition ( ) ; return null ; } lastReferenceSequence ++ ; lastPosition = _NUM ; } else if ( lastReferenceSequence < stopBeforeLocus . getSequenceIndex ( ) || nextbit < stopBeforeLocus . getPosition ( ) ) { lastPosition = nextbit ; return new LocusInfo ( getReferenceSequence ( lastReferenceSequence ) , lastPosition ) ; } else if ( nextbit >= stopBeforeLocus . getPosition ( ) ) { return null ; } } return null ; }
public static void stopMostRecentTimer ( ) { try { stopTiming ( RLOG . get ( ) . mostRecentTimer . name ) ; } catch ( NullPointerException ignored ) { LOG . warn ( STRING ) ; } }
public static void wait ( Object lock , long timeout ) { try { synchronized ( lock ) { lock . wait ( timeout ) ; } } catch ( InterruptedException e ) { } }
public static < E > List < E > asList ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > result = new ArrayList < E > ( ) ; for ( E e : iterable ) { result . add ( e ) ; } return result ; }
public static < E > List < E > asList ( Iterable < E > iterable ) { if ( iterable instanceof List ) { return ( List < E > ) iterable ; } List < E > result = new ArrayList < E > ( ) ; for ( E e : iterable ) { result . add ( e ) ; } return result ; }
@ Override public String nextString ( ) { return Integer . toString ( nextInt ( ) ) ; }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public static int hex ( String hex ) { if ( hex . charAt ( _NUM ) == HEX_PREFIX ) hex = hex . substring ( _NUM ) ; if ( hex . length ( ) > _NUM ) { int rgb = Integer . parseInt ( hex . substring ( _NUM ) , _NUM ) ; int alpha = Integer . parseInt ( hex . substring ( _NUM , _NUM ) , _NUM ) ; return ColorLib . setAlpha ( rgb , alpha ) ; } else { return setAlpha ( Integer . parseInt ( hex , _NUM ) , _NUM ) ; } }
public CodePosition addPositionChoice ( int index , String entry , String prefix , Properties props ) { CodeScheme cs = ( CodeScheme ) super . addPositionChoice ( index , entry , prefix , props ) ; prefix = PropUtils . getScopedPropertyPrefix ( prefix ) + entry + STRING ; String next = props . getProperty ( prefix + NextProperty ) ; if ( next != null ) { String nextClassName = props . getProperty ( next + STRING ) ; if ( nextClassName != null ) { CodePosition cp = ( CodePosition ) ComponentFactory . create ( nextClassName ) ; if ( DEBUG ) { Debug . output ( STRING + next + STRING + nextClassName ) ; } if ( cp != null ) { cs . nextPosition = cp ; cp . parsePositions ( next , props ) ; } } else { if ( DEBUG ) { Debug . output ( STRING + next + STRING + nextClassName ) ; } } } cs . defaultSymbolCode = props . getProperty ( prefix + DefaultSymbolCodeProperty ) ; cs . hierarchyAddition = props . getProperty ( prefix + HierarchyCodeAdditionProperty , STRING ) ; return cs ; }
protected void loadHistory ( ) { int size ; int i ; String cmd ; size = Integer . parseInt ( PROPERTIES . getProperty ( STRING , STRING ) ) ; m_CommandHistory . clear ( ) ; for ( i = _NUM ; i < size ; i ++ ) { cmd = PROPERTIES . getProperty ( STRING + i , STRING ) ; if ( cmd . length ( ) != _NUM ) { m_CommandHistory . add ( cmd ) ; } else { break ; } } m_HistoryPos = m_CommandHistory . size ( ) ; }
protected int executePrepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQLException { int bindNo = _NUM ; PreparedStatement statement = null ; int affectedRows = _NUM ; try { statement = dbConn . prepareStatement ( SQL ) ; for ( Column c : columns ) { setColumnValue ( statement , bindNo , c ) ; bindNo ++ ; } affectedRows = statement . executeUpdate ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - _NUM ) table . setStatement ( type , statement ) ; return affectedRows ; }
protected int executePrepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQLException { int bindNo = _NUM ; PreparedStatement statement = null ; int affectedRows = _NUM ; try { statement = dbConn . prepareStatement ( SQL ) ; for ( Column c : columns ) { setColumnValue ( statement , bindNo , c ) ; bindNo ++ ; } affectedRows = statement . executeUpdate ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - _NUM ) table . setStatement ( type , statement ) ; return affectedRows ; }
protected int executePrepare ( Table table , List < Column > columns , String SQL , boolean keep , int type ) throws SQLException { int bindNo = _NUM ; PreparedStatement statement = null ; int affectedRows = _NUM ; try { statement = dbConn . prepareStatement ( SQL ) ; for ( Column c : columns ) { setColumnValue ( statement , bindNo , c ) ; bindNo ++ ; } affectedRows = statement . executeUpdate ( ) ; } finally { if ( statement != null && ! keep ) { statement . close ( ) ; statement = null ; } } if ( keep && type > - _NUM ) table . setStatement ( type , statement ) ; return affectedRows ; }
public final void flushBatch ( ) throws SQLException { if ( m_ps != null && m_batchCount > _NUM ) { m_ps . executeBatch ( ) ; m_batchCount = _NUM ; } }
public final void flushBatch ( ) throws SQLException { if ( m_ps != null && m_batchCount > _NUM ) { m_ps . executeBatch ( ) ; m_batchCount = _NUM ; } }
public final void flushBatch ( ) throws SQLException { if ( m_ps != null && m_batchCount > _NUM ) { m_ps . executeBatch ( ) ; m_batchCount = _NUM ; } }
protected static DNSTaskStarter newDNSTaskStarter ( JmDNSImpl jmDNSImpl ) { DNSTaskStarter instance = null ; ClassDelegate delegate = _databaseClassDelegate . get ( ) ; if ( delegate != null ) { instance = delegate . newDNSTaskStarter ( jmDNSImpl ) ; } return ( instance != null ? instance : new DNSTaskStarterImpl ( jmDNSImpl ) ) ; }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
public void substituteHeader ( int state , String header ) throws AuthLoginException { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + state + STRING + header ) ; } if ( state > stateLength ) { throw new AuthLoginException ( bundleName , STRING , new Object [ ] { new Integer ( state ) } ) ; } Callback [ ] ext = getCallback ( state ) ; if ( ext . length <= _NUM ) { throw new AuthLoginException ( bundleName , STRING , null ) ; } if ( ( header != null ) && ( header . length ( ) != _NUM ) ) { PagePropertiesCallback pc = ( PagePropertiesCallback ) ( ( Callback [ ] ) internal . get ( state - _NUM ) ) [ _NUM ] ; pc . setHeader ( header ) ; } }
private void decrementCopyFieldTargetCount ( SchemaField dest ) { Integer count = copyFieldTargetCounts . get ( dest ) ; assert count != null ; if ( count <= _NUM ) { copyFieldTargetCounts . remove ( dest ) ; } else { copyFieldTargetCounts . put ( dest , count - _NUM ) ; } }
private void decrementCopyFieldTargetCount ( SchemaField dest ) { Integer count = copyFieldTargetCounts . get ( dest ) ; assert count != null ; if ( count <= _NUM ) { copyFieldTargetCounts . remove ( dest ) ; } else { copyFieldTargetCounts . put ( dest , count - _NUM ) ; } }
public void test_emptyJournal ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal newJournal = f . get ( ) ; try { newJournal . destroy ( ) ; } finally { fail ( STRING + IllegalArgumentException . class ) ; } } catch ( IllegalArgumentException ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void test_emptyJournal ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal newJournal = f . get ( ) ; try { newJournal . destroy ( ) ; } finally { fail ( STRING + IllegalArgumentException . class ) ; } } catch ( IllegalArgumentException ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void test_emptyJournal ( ) throws IOException , InterruptedException , ExecutionException { final File out = File . createTempFile ( getName ( ) , Options . JNL ) ; try { final Journal src = getStore ( getProperties ( ) ) ; try { try { final Future < Journal > f = src . compact ( out ) ; final Journal newJournal = f . get ( ) ; try { newJournal . destroy ( ) ; } finally { fail ( STRING + IllegalArgumentException . class ) ; } } catch ( IllegalArgumentException ex ) { log . info ( STRING + ex ) ; } } finally { src . destroy ( ) ; } } finally { out . delete ( ) ; } }
public void addSslPort ( String newSslPort ) { String newSslPorts = StringUtils . addToList ( newSslPort , getSslPorts ( ) , _NUM ) ; setSslPorts ( newSslPorts ) ; }
public void addSslPort ( String newSslPort ) { String newSslPorts = StringUtils . addToList ( newSslPort , getSslPorts ( ) , _NUM ) ; setSslPorts ( newSslPorts ) ; }
public static boolean isSecurityManagerEnabled ( ) { return System . getSecurityManager ( ) != null ; }
private void captureDifferentString ( String oldString , String newString , Map < String , String > map , String appName ) { Reject . ifNull ( appName ) ; Reject . ifNull ( map ) ; if ( oldString == null ? newString != null : ! oldString . equals ( newString ) ) { map . put ( appName , newString ) ; } }
public void push ( final double value ) { long bits = Double . doubleToLongBits ( value ) ; if ( bits == _NUM || bits == _NUM ) { mv . visitInsn ( Opcodes . DCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Double ( value ) ) ; } }
public void push ( final double value ) { long bits = Double . doubleToLongBits ( value ) ; if ( bits == _NUM || bits == _NUM ) { mv . visitInsn ( Opcodes . DCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Double ( value ) ) ; } }
public void push ( final double value ) { long bits = Double . doubleToLongBits ( value ) ; if ( bits == _NUM || bits == _NUM ) { mv . visitInsn ( Opcodes . DCONST_0 + ( int ) value ) ; } else { mv . visitLdcInsn ( new Double ( value ) ) ; } }
protected void fillSampleDatabase ( Connection conn ) throws SQLException { info ( STRING ) ; PreparedStatement orgStmt = conn . prepareStatement ( STRING ) ; for ( int i = _NUM ; i < ORGANIZATION_CNT ; i ++ ) { orgStmt . setInt ( _NUM , i ) ; orgStmt . setString ( _NUM , STRING + i ) ; orgStmt . setString ( _NUM , STRING + i % _NUM ) ; orgStmt . addBatch ( ) ; } orgStmt . executeBatch ( ) ; U . closeQuiet ( orgStmt ) ; conn . commit ( ) ; PreparedStatement prnStmt = conn . prepareStatement ( STRING ) ; Random rnd = new Random ( ) ; for ( int i = _NUM ; i < PERSON_CNT ; i ++ ) { prnStmt . setInt ( _NUM , i ) ; prnStmt . setInt ( _NUM , i % _NUM ) ; prnStmt . setDate ( _NUM , Date . valueOf ( String . format ( STRING , _NUM + rnd . nextInt ( _NUM ) , _NUM + rnd . nextInt ( _NUM ) , _NUM + rnd . nextInt ( _NUM ) ) ) ) ; prnStmt . setString ( _NUM , STRING + i ) ; prnStmt . addBatch ( ) ; } prnStmt . executeBatch ( ) ; conn . commit ( ) ; U . closeQuiet ( prnStmt ) ; info ( STRING ) ; }
public void actionPerformed ( ActionEvent ae ) { String cmd = ae . getActionCommand ( ) ; if ( cmd == TimerStatus . TIMER_FORWARD ) { timeHandler . setClockDirection ( _NUM ) ; timeHandler . startClock ( ) ; } else if ( cmd == TimerStatus . TIMER_BACKWARD ) { timeHandler . setClockDirection ( - _NUM ) ; timeHandler . startClock ( ) ; } else if ( cmd == TimerStatus . TIMER_STEP_BACKWARD ) { timeHandler . stepBackward ( ) ; } else if ( cmd == TimerStatus . TIMER_STEP_FORWARD ) { timeHandler . stepForward ( ) ; } else if ( cmd == TimerStatus . TIMER_STOPPED ) { timeHandler . stopClock ( ) ; } }
public void actionPerformed ( ActionEvent ae ) { String cmd = ae . getActionCommand ( ) ; if ( cmd == TimerStatus . TIMER_FORWARD ) { timeHandler . setClockDirection ( _NUM ) ; timeHandler . startClock ( ) ; } else if ( cmd == TimerStatus . TIMER_BACKWARD ) { timeHandler . setClockDirection ( - _NUM ) ; timeHandler . startClock ( ) ; } else if ( cmd == TimerStatus . TIMER_STEP_BACKWARD ) { timeHandler . stepBackward ( ) ; } else if ( cmd == TimerStatus . TIMER_STEP_FORWARD ) { timeHandler . stepForward ( ) ; } else if ( cmd == TimerStatus . TIMER_STOPPED ) { timeHandler . stopClock ( ) ; } }
private double toDouble ( IXMLElement elem , String value ) throws IOException { return toDouble ( elem , value , _NUM , Double . MIN_VALUE , Double . MAX_VALUE ) ; }
public static byte [ ] bitmapToByte ( Bitmap b ) { if ( b == null ) { return null ; } ByteArrayOutputStream o = new ByteArrayOutputStream ( ) ; b . compress ( Bitmap . CompressFormat . PNG , _NUM , o ) ; return o . toByteArray ( ) ; }
public static byte [ ] bitmapToByte ( Bitmap b ) { if ( b == null ) { return null ; } ByteArrayOutputStream o = new ByteArrayOutputStream ( ) ; b . compress ( Bitmap . CompressFormat . PNG , _NUM , o ) ; return o . toByteArray ( ) ; }
public Process ( final File file , final ProgressListener progressListener ) throws IOException , XMLException { this . processLocation = new FileProcessLocation ( file ) ; initContext ( ) ; Reader in = null ; try { in = new InputStreamReader ( new FileInputStream ( file ) , STRING ) ; readProcess ( in , progressListener ) ; } catch ( IOException e ) { throw e ; } finally { if ( in != null ) { in . close ( ) ; } } }
private void updateStatus ( ) { String statusText ; if ( ! game . isTerminal ( currState ) ) { String toMove = ( String ) game . getPlayer ( currState ) ; statusText = STRING + toMove ; statusBar . setForeground ( toMove . equals ( STRING ) ? Color . RED : Color . YELLOW ) ; } else { String winner = null ; for ( int i = _NUM ; i < _NUM ; i ++ ) if ( game . getUtility ( currState , game . getPlayers ( ) [ i ] ) == _NUM ) winner = game . getPlayers ( ) [ i ] ; if ( winner != null ) statusText = STRING + winner + STRING ; else statusText = STRING ; statusBar . setForeground ( Color . WHITE ) ; } if ( searchMetrics != null ) statusText += STRING + searchMetrics ; statusBar . setText ( statusText ) ; }
public String toString ( ) { String result = m_ParamChar + STRING + m_Lower + STRING ; switch ( ( int ) ( m_Lower - m_Upper + _NUM ) ) { case _NUM : result += STRING ; break ; case _NUM : result += STRING ; break ; default : result += m_Upper ; break ; } result += STRING + m_Steps ; if ( m_RoundParam ) { result += STRING ; } return result ; }
public static boolean expressionIsTrue ( double leftSide , Operator operator , double rightSide ) { final String expression = leftSide + operator . getMathematicalOperator ( ) + rightSide ; return expressionIsTrue ( expression ) ; }
public void testMergeOneServletIntoEmptyDocument ( ) throws Exception { String srcXml = STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; }
public void sign ( AuthSuccess authSuccess ) throws ServerException , AssociationException { String handle = authSuccess . getHandle ( ) ; Association assoc = _sharedAssociations . load ( handle ) ; if ( assoc == null ) assoc = _privateAssociations . load ( handle ) ; if ( assoc == null ) throw new ServerException ( STRING + handle ) ; authSuccess . setSignature ( assoc . sign ( authSuccess . getSignedText ( ) ) ) ; }
public void sign ( AuthSuccess authSuccess ) throws ServerException , AssociationException { String handle = authSuccess . getHandle ( ) ; Association assoc = _sharedAssociations . load ( handle ) ; if ( assoc == null ) assoc = _privateAssociations . load ( handle ) ; if ( assoc == null ) throw new ServerException ( STRING + handle ) ; authSuccess . setSignature ( assoc . sign ( authSuccess . getSignedText ( ) ) ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { GetField gf = s . readFields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( getURLStreamHandler ( protocol ) == null ) { throw new IOException ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - _NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hashCode = gf . get ( STRING , - _NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > _NUM ) || port != - _NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - _NUM ) ? host : host + STRING + port ; } tempState = new UrlDeserializedState ( protocol , host , port , authority , file , ref , hashCode ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { GetField gf = s . readFields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( getURLStreamHandler ( protocol ) == null ) { throw new IOException ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - _NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hashCode = gf . get ( STRING , - _NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > _NUM ) || port != - _NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - _NUM ) ? host : host + STRING + port ; } tempState = new UrlDeserializedState ( protocol , host , port , authority , file , ref , hashCode ) ; }
private synchronized void readObject ( java . io . ObjectInputStream s ) throws IOException , ClassNotFoundException { GetField gf = s . readFields ( ) ; String protocol = ( String ) gf . get ( STRING , null ) ; if ( getURLStreamHandler ( protocol ) == null ) { throw new IOException ( STRING + protocol ) ; } String host = ( String ) gf . get ( STRING , null ) ; int port = gf . get ( STRING , - _NUM ) ; String authority = ( String ) gf . get ( STRING , null ) ; String file = ( String ) gf . get ( STRING , null ) ; String ref = ( String ) gf . get ( STRING , null ) ; int hashCode = gf . get ( STRING , - _NUM ) ; if ( authority == null && ( ( host != null && host . length ( ) > _NUM ) || port != - _NUM ) ) { if ( host == null ) host = STRING ; authority = ( port == - _NUM ) ? host : host + STRING + port ; } tempState = new UrlDeserializedState ( protocol , host , port , authority , file , ref , hashCode ) ; }
public static String removeQuotationMarksIfNeeded ( String str ) { if ( str . startsWith ( STRING ) && str . endsWith ( STRING ) ) return str . substring ( _NUM , str . length ( ) - _NUM ) ; return str ; }
public static String removeQuotationMarksIfNeeded ( String str ) { if ( str . startsWith ( STRING ) && str . endsWith ( STRING ) ) return str . substring ( _NUM , str . length ( ) - _NUM ) ; return str ; }
private static String padLeft ( String s , int minLength ) { return String . format ( STRING + minLength + STRING , s ) ; }
private static String padLeft ( String s , int minLength ) { return String . format ( STRING + minLength + STRING , s ) ; }
@ Override boolean equals ( Object obj ) ;
@ Override boolean equals ( Object obj ) ;
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > actionBarAutoHideSensitivity ) { deltaY = actionBarAutoHideSensitivity ; } else if ( deltaY < - actionBarAutoHideSensitivity ) { deltaY = - actionBarAutoHideSensitivity ; } if ( Math . signum ( deltaY ) * Math . signum ( actionBarAutoHideSignal ) < _NUM ) { actionBarAutoHideSignal = deltaY ; } else { actionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < actionBarAutoHideMinY || ( actionBarAutoHideSignal <= - actionBarAutoHideSensitivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > actionBarAutoHideSensitivity ) { deltaY = actionBarAutoHideSensitivity ; } else if ( deltaY < - actionBarAutoHideSensitivity ) { deltaY = - actionBarAutoHideSensitivity ; } if ( Math . signum ( deltaY ) * Math . signum ( actionBarAutoHideSignal ) < _NUM ) { actionBarAutoHideSignal = deltaY ; } else { actionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < actionBarAutoHideMinY || ( actionBarAutoHideSignal <= - actionBarAutoHideSensitivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > actionBarAutoHideSensitivity ) { deltaY = actionBarAutoHideSensitivity ; } else if ( deltaY < - actionBarAutoHideSensitivity ) { deltaY = - actionBarAutoHideSensitivity ; } if ( Math . signum ( deltaY ) * Math . signum ( actionBarAutoHideSignal ) < _NUM ) { actionBarAutoHideSignal = deltaY ; } else { actionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < actionBarAutoHideMinY || ( actionBarAutoHideSignal <= - actionBarAutoHideSensitivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > actionBarAutoHideSensitivity ) { deltaY = actionBarAutoHideSensitivity ; } else if ( deltaY < - actionBarAutoHideSensitivity ) { deltaY = - actionBarAutoHideSensitivity ; } if ( Math . signum ( deltaY ) * Math . signum ( actionBarAutoHideSignal ) < _NUM ) { actionBarAutoHideSignal = deltaY ; } else { actionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < actionBarAutoHideMinY || ( actionBarAutoHideSignal <= - actionBarAutoHideSensitivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
private void onMainContentScrolled ( int currentY , int deltaY ) { if ( deltaY > actionBarAutoHideSensitivity ) { deltaY = actionBarAutoHideSensitivity ; } else if ( deltaY < - actionBarAutoHideSensitivity ) { deltaY = - actionBarAutoHideSensitivity ; } if ( Math . signum ( deltaY ) * Math . signum ( actionBarAutoHideSignal ) < _NUM ) { actionBarAutoHideSignal = deltaY ; } else { actionBarAutoHideSignal += deltaY ; } boolean shouldShow = currentY < actionBarAutoHideMinY || ( actionBarAutoHideSignal <= - actionBarAutoHideSensitivity ) ; autoShowOrHideActionBar ( shouldShow ) ; }
@ SuppressWarnings ( STRING ) public RhythmOverlay inflateOverlay ( String configString ) { List < String > configStrings = Arrays . asList ( configString . split ( STRING ) ) ; return inflateOverlayInternal ( configStrings , Collections . EMPTY_MAP , _NUM ) ; }
@ SuppressWarnings ( STRING ) public RhythmOverlay inflateOverlay ( String configString ) { List < String > configStrings = Arrays . asList ( configString . split ( STRING ) ) ; return inflateOverlayInternal ( configStrings , Collections . EMPTY_MAP , _NUM ) ; }
private List < File > findDuplicateFiles ( List < File > files ) { HashSet < File > sourceFileSet = new HashSet < > ( ) ; List < File > duplicateFiles = new ArrayList < > ( ) ; for ( File file : files ) { if ( ! sourceFileSet . contains ( file ) ) { sourceFileSet . add ( file ) ; } else { duplicateFiles . add ( file ) ; } } return duplicateFiles ; }
private List < File > findDuplicateFiles ( List < File > files ) { HashSet < File > sourceFileSet = new HashSet < > ( ) ; List < File > duplicateFiles = new ArrayList < > ( ) ; for ( File file : files ) { if ( ! sourceFileSet . contains ( file ) ) { sourceFileSet . add ( file ) ; } else { duplicateFiles . add ( file ) ; } } return duplicateFiles ; }
private void addNodesSF ( Collection < MPPOrderNode > list , int PP_Order_Node_ID , int AD_Client_ID ) { final MPPOrderNode node = getNode ( PP_Order_Node_ID , AD_Client_ID ) ; if ( node != null ) { if ( ! list . contains ( node ) ) { list . add ( node ) ; } ArrayList < Integer > nextNodes = new ArrayList < Integer > ( ) ; for ( MPPOrderNodeNext next : node . getTransitions ( AD_Client_ID ) ) { final MPPOrderNode child = getNode ( next . getPP_Order_Next_ID ( ) , AD_Client_ID ) ; if ( child != null ) { if ( ! list . contains ( child ) ) { list . add ( child ) ; nextNodes . add ( next . getPP_Order_Next_ID ( ) ) ; } else { log . saveError ( STRING , STRING + node + STRING + child ) ; } } } for ( int pp_Order_Next_ID : nextNodes ) { addNodesSF ( list , pp_Order_Next_ID , AD_Client_ID ) ; } } }
private void addNodesSF ( Collection < MPPOrderNode > list , int PP_Order_Node_ID , int AD_Client_ID ) { final MPPOrderNode node = getNode ( PP_Order_Node_ID , AD_Client_ID ) ; if ( node != null ) { if ( ! list . contains ( node ) ) { list . add ( node ) ; } ArrayList < Integer > nextNodes = new ArrayList < Integer > ( ) ; for ( MPPOrderNodeNext next : node . getTransitions ( AD_Client_ID ) ) { final MPPOrderNode child = getNode ( next . getPP_Order_Next_ID ( ) , AD_Client_ID ) ; if ( child != null ) { if ( ! list . contains ( child ) ) { list . add ( child ) ; nextNodes . add ( next . getPP_Order_Next_ID ( ) ) ; } else { log . saveError ( STRING , STRING + node + STRING + child ) ; } } } for ( int pp_Order_Next_ID : nextNodes ) { addNodesSF ( list , pp_Order_Next_ID , AD_Client_ID ) ; } } }
void visitAndTransform ( TemplateElement [ ] elementBuffer , TemplateTransformModel transform , Map args ) throws TemplateException , IOException { try { Writer tw = transform . getWriter ( out , args ) ; if ( tw == null ) tw = EMPTY_BODY_WRITER ; TransformControl tc = tw instanceof TransformControl ? ( TransformControl ) tw : null ; Writer prevOut = out ; out = tw ; try { if ( tc == null || tc . onStart ( ) != TransformControl . SKIP_BODY ) { do { visit ( elementBuffer ) ; } while ( tc != null && tc . afterBody ( ) == TransformControl . REPEAT_EVALUATION ) ; } } catch ( Throwable t ) { try { if ( tc != null ) { tc . onError ( t ) ; } else { throw t ; } } catch ( TemplateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( RuntimeException e ) { throw e ; } catch ( Error e ) { throw e ; } catch ( Throwable e ) { throw new UndeclaredThrowableException ( e ) ; } } finally { out = prevOut ; tw . close ( ) ; } } catch ( TemplateException te ) { handleTemplateException ( te ) ; } }
public void addUpdateListener ( PreferenceUpdateListener listener ) { updateListeners . add ( listener ) ; }
public void addUpdateListener ( PreferenceUpdateListener listener ) { updateListeners . add ( listener ) ; }
public void addUpdateListener ( PreferenceUpdateListener listener ) { updateListeners . add ( listener ) ; }
protected Paint createHorizontalGradient ( Shape s , FourColors colors ) { Rectangle2D bounds = s . getBounds2D ( ) ; float x = ( float ) bounds . getX ( ) ; float y = ( float ) bounds . getY ( ) ; float w = ( float ) bounds . getWidth ( ) ; float h = ( float ) bounds . getHeight ( ) ; return createGradient ( x , ( _NUM * h ) + y , x + w , ( _NUM * h ) + y , new float [ ] { _NUM , _NUM , _NUM , _NUM } , new Color [ ] { colors . top , colors . upperMid , colors . lowerMid , colors . bottom } ) ; }
public void addAttachment ( URI url ) { if ( url == null ) return ; if ( m_attachments == null ) m_attachments = new ArrayList < Object > ( ) ; m_attachments . add ( url ) ; }
private Map < Member , String [ ] > inspectClass ( Class < ? > clazz ) { InputStream is = clazz . getResourceAsStream ( ClassUtils . getClassFileName ( clazz ) ) ; if ( is == null ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO_DEBUG_INFO_MAP ; } try { ClassReader classReader = new ClassReader ( is ) ; Map < Member , String [ ] > map = new ConcurrentHashMap < Member , String [ ] > ( ) ; classReader . accept ( new ParameterNameDiscoveringVisitor ( clazz , map ) , _BOOL ) ; return map ; } catch ( IOException ex ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IOException ex ) { } } return NO_DEBUG_INFO_MAP ; }
private Map < Member , String [ ] > inspectClass ( Class < ? > clazz ) { InputStream is = clazz . getResourceAsStream ( ClassUtils . getClassFileName ( clazz ) ) ; if ( is == null ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO_DEBUG_INFO_MAP ; } try { ClassReader classReader = new ClassReader ( is ) ; Map < Member , String [ ] > map = new ConcurrentHashMap < Member , String [ ] > ( ) ; classReader . accept ( new ParameterNameDiscoveringVisitor ( clazz , map ) , _BOOL ) ; return map ; } catch ( IOException ex ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IOException ex ) { } } return NO_DEBUG_INFO_MAP ; }
private Map < Member , String [ ] > inspectClass ( Class < ? > clazz ) { InputStream is = clazz . getResourceAsStream ( ClassUtils . getClassFileName ( clazz ) ) ; if ( is == null ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO_DEBUG_INFO_MAP ; } try { ClassReader classReader = new ClassReader ( is ) ; Map < Member , String [ ] > map = new ConcurrentHashMap < Member , String [ ] > ( ) ; classReader . accept ( new ParameterNameDiscoveringVisitor ( clazz , map ) , _BOOL ) ; return map ; } catch ( IOException ex ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IOException ex ) { } } return NO_DEBUG_INFO_MAP ; }
private Map < Member , String [ ] > inspectClass ( Class < ? > clazz ) { InputStream is = clazz . getResourceAsStream ( ClassUtils . getClassFileName ( clazz ) ) ; if ( is == null ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING ) ; } return NO_DEBUG_INFO_MAP ; } try { ClassReader classReader = new ClassReader ( is ) ; Map < Member , String [ ] > map = new ConcurrentHashMap < Member , String [ ] > ( ) ; classReader . accept ( new ParameterNameDiscoveringVisitor ( clazz , map ) , _BOOL ) ; return map ; } catch ( IOException ex ) { if ( LOGGER . isDebugEnabled ( ) ) { LOGGER . debug ( STRING + clazz + STRING , ex ) ; } } finally { try { is . close ( ) ; } catch ( IOException ex ) { } } return NO_DEBUG_INFO_MAP ; }
public static String addQueryParam ( String path , String key , String value ) { return path + ( path . contains ( STRING ) ? STRING : STRING ) + key + STRING + value ; }
public static String addQueryParam ( String path , String key , String value ) { return path + ( path . contains ( STRING ) ? STRING : STRING ) + key + STRING + value ; }
public void addFile ( File file ) { addEntry ( file . getPath ( ) ) ; }
public void addFile ( File file ) { addEntry ( file . getPath ( ) ) ; }
public void addFile ( File file ) { addEntry ( file . getPath ( ) ) ; }
public void clearOnPageChangeListeners ( ) { if ( mOnPageChangeListeners != null ) { mOnPageChangeListeners . clear ( ) ; } }
public IDirectableViewer addViewer ( IDirectableViewer viewer ) { if ( viewer instanceof MainViewer ) this . viewer = ( MainViewer ) viewer ; viewers . add ( viewer ) ; directorListeners . add ( viewer ) ; ProjectManager . projectWindowChanged ( this , viewer , _BOOL ) ; return viewer ; }
protected void enqueueUIOperation ( UIOperation operation ) { mOperations . add ( operation ) ; }
protected void enqueueUIOperation ( UIOperation operation ) { mOperations . add ( operation ) ; }
protected void enqueueUIOperation ( UIOperation operation ) { mOperations . add ( operation ) ; }
protected void enqueueUIOperation ( UIOperation operation ) { mOperations . add ( operation ) ; }
protected void enqueueUIOperation ( UIOperation operation ) { mOperations . add ( operation ) ; }
public GitConflictException ( String message ) { super ( message ) ; }
public HierarchicalClassLabel ( String name , Pattern regex , String separator ) { super ( ) ; this . separatorPattern = regex ; this . separatorString = separator ; String [ ] levelwiseStrings = separatorPattern . split ( name ) ; this . levelwiseNames = new Comparable < ? > [ levelwiseStrings . length ] ; for ( int i = _NUM ; i < levelwiseStrings . length ; i ++ ) { try { levelwiseNames [ i ] = Integer . valueOf ( levelwiseStrings [ i ] ) ; } catch ( NumberFormatException e ) { levelwiseNames [ i ] = levelwiseStrings [ i ] ; } } }
public HierarchicalClassLabel ( String name , Pattern regex , String separator ) { super ( ) ; this . separatorPattern = regex ; this . separatorString = separator ; String [ ] levelwiseStrings = separatorPattern . split ( name ) ; this . levelwiseNames = new Comparable < ? > [ levelwiseStrings . length ] ; for ( int i = _NUM ; i < levelwiseStrings . length ; i ++ ) { try { levelwiseNames [ i ] = Integer . valueOf ( levelwiseStrings [ i ] ) ; } catch ( NumberFormatException e ) { levelwiseNames [ i ] = levelwiseStrings [ i ] ; } } }
public HierarchicalClassLabel ( String name , Pattern regex , String separator ) { super ( ) ; this . separatorPattern = regex ; this . separatorString = separator ; String [ ] levelwiseStrings = separatorPattern . split ( name ) ; this . levelwiseNames = new Comparable < ? > [ levelwiseStrings . length ] ; for ( int i = _NUM ; i < levelwiseStrings . length ; i ++ ) { try { levelwiseNames [ i ] = Integer . valueOf ( levelwiseStrings [ i ] ) ; } catch ( NumberFormatException e ) { levelwiseNames [ i ] = levelwiseStrings [ i ] ; } } }
public HierarchicalClassLabel ( String name , Pattern regex , String separator ) { super ( ) ; this . separatorPattern = regex ; this . separatorString = separator ; String [ ] levelwiseStrings = separatorPattern . split ( name ) ; this . levelwiseNames = new Comparable < ? > [ levelwiseStrings . length ] ; for ( int i = _NUM ; i < levelwiseStrings . length ; i ++ ) { try { levelwiseNames [ i ] = Integer . valueOf ( levelwiseStrings [ i ] ) ; } catch ( NumberFormatException e ) { levelwiseNames [ i ] = levelwiseStrings [ i ] ; } } }
public static boolean isInputStreamGZIPCompressed ( final PushbackInputStream inputStream ) throws IOException { if ( inputStream == null ) return _BOOL ; byte [ ] signature = new byte [ _NUM ] ; int count = _NUM ; try { while ( count < _NUM ) { int readCount = inputStream . read ( signature , count , _NUM - count ) ; if ( readCount < _NUM ) return _BOOL ; count = count + readCount ; } } finally { inputStream . unread ( signature , _NUM , count ) ; } int streamHeader = ( ( int ) signature [ _NUM ] & _NUM ) | ( ( signature [ _NUM ] << _NUM ) & _NUM ) ; return GZIPInputStream . GZIP_MAGIC == streamHeader ; }
public void rotatedLootPot ( World world , Random rand , int x , int y , int z , int offsetX , int offsetY , int offsetZ , int rotation , int min , int max , int chance ) { x -= width / _NUM ; z -= depth / _NUM ; if ( rand . nextInt ( chance ) == _NUM ) return ; switch ( rotation ) { case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetX , y + offsetY , z + offsetZ ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetZ , y + offsetY , z + depth - offsetX - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetX - _NUM , y + offsetY , z + depth - offsetZ - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetZ - _NUM , y + offsetY , z + offsetX ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; } }
public void rotatedLootPot ( World world , Random rand , int x , int y , int z , int offsetX , int offsetY , int offsetZ , int rotation , int min , int max , int chance ) { x -= width / _NUM ; z -= depth / _NUM ; if ( rand . nextInt ( chance ) == _NUM ) return ; switch ( rotation ) { case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetX , y + offsetY , z + offsetZ ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetZ , y + offsetY , z + depth - offsetX - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetX - _NUM , y + offsetY , z + depth - offsetZ - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetZ - _NUM , y + offsetY , z + offsetX ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; } }
public void rotatedLootPot ( World world , Random rand , int x , int y , int z , int offsetX , int offsetY , int offsetZ , int rotation , int min , int max , int chance ) { x -= width / _NUM ; z -= depth / _NUM ; if ( rand . nextInt ( chance ) == _NUM ) return ; switch ( rotation ) { case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetX , y + offsetY , z + offsetZ ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + offsetZ , y + offsetY , z + depth - offsetX - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetX - _NUM , y + offsetY , z + depth - offsetZ - _NUM ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; case _NUM : generateLootPot ( world , rand , new BlockPos ( x + width - offsetZ - _NUM , y + offsetY , z + offsetX ) , min , max , LootTableRegistry . DUNGEON_POT_LOOT ) ; break ; } }
public static boolean hasVisibleChildren ( ActionGroup group , PresentationFactory factory , ActionManager actionManager , PerspectiveManager perspectiveManager ) { ActionEvent event = new ActionEvent ( factory . getPresentation ( group ) , actionManager , perspectiveManager ) ; for ( Action anAction : group . getChildren ( event ) ) { if ( anAction == null ) { Log . error ( Utils . class , STRING + group + STRING + factory . getPresentation ( group ) ) ; continue ; } if ( anAction instanceof Separator ) { continue ; } final Presentation presentation = factory . getPresentation ( anAction ) ; anAction . update ( new ActionEvent ( presentation , actionManager , perspectiveManager ) ) ; if ( anAction instanceof ActionGroup ) { ActionGroup childGroup = ( ActionGroup ) anAction ; if ( childGroup . isPopup ( ) ) { if ( ! presentation . isVisible ( ) ) { continue ; } } if ( hasVisibleChildren ( childGroup , factory , actionManager , perspectiveManager ) ) { return _BOOL ; } } else if ( presentation . isVisible ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean hasVisibleChildren ( ActionGroup group , PresentationFactory factory , ActionManager actionManager , PerspectiveManager perspectiveManager ) { ActionEvent event = new ActionEvent ( factory . getPresentation ( group ) , actionManager , perspectiveManager ) ; for ( Action anAction : group . getChildren ( event ) ) { if ( anAction == null ) { Log . error ( Utils . class , STRING + group + STRING + factory . getPresentation ( group ) ) ; continue ; } if ( anAction instanceof Separator ) { continue ; } final Presentation presentation = factory . getPresentation ( anAction ) ; anAction . update ( new ActionEvent ( presentation , actionManager , perspectiveManager ) ) ; if ( anAction instanceof ActionGroup ) { ActionGroup childGroup = ( ActionGroup ) anAction ; if ( childGroup . isPopup ( ) ) { if ( ! presentation . isVisible ( ) ) { continue ; } } if ( hasVisibleChildren ( childGroup , factory , actionManager , perspectiveManager ) ) { return _BOOL ; } } else if ( presentation . isVisible ( ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public synchronized void addTrainingSetListener ( TrainingSetListener tsl ) { m_trainingListeners . addElement ( tsl ) ; }
public void executeStatement ( String statement ) throws SQLException , NoConnectionException { if ( connection != null ) { Statement st = connection . createStatement ( ) ; st . execute ( statement ) ; } else throw new NoConnectionException ( ) ; }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( VERSION ) ) { version = V1 ; } else { throw new IOException ( STRING + STRING ) ; } }
public void add ( DimensionalNode dn ) { if ( inProgress ) { throw new ConcurrentModificationException ( STRING ) ; } nodes . add ( dn ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
public DatepickerCombo ( final Composite parent , final int style ) { this ( parent , style , DateFormat . getDateTimeInstance ( ) ) ; }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
private void checkForMissedScans ( ) { DateTime now = now ( ) ; for ( ScheduledDailyScanUpload scheduledScan : _scheduledScans ) { DateTime startCheckInterval = now . minusMinutes ( _NUM ) ; Interval missedInterval = new Interval ( startCheckInterval , now ) ; DateTime scheduledTime = scheduledScan . getNextExecutionTimeAfter ( startCheckInterval ) ; if ( missedInterval . contains ( scheduledTime ) ) { _log . info ( STRING , scheduledTime ) ; try { startScheduledScan ( scheduledScan , scheduledTime ) ; } catch ( RepeatScanException e ) { _log . info ( STRING , scheduledTime ) ; } catch ( ScanExecutionTimeException e ) { _log . info ( STRING , scheduledTime ) ; } } } }
protected void createGrid ( ) { grid . clear ( ) ; for ( int r = _NUM ; r <= rows ; ++ r ) { grid . add ( new LineSegment ( leftMargin , graphHeight - ( bottomMargin + r * pixelsPerYTic ) , leftMargin + width , graphHeight - ( bottomMargin + r * pixelsPerYTic ) ) ) ; } for ( int c = _NUM ; c <= cols ; ++ c ) { grid . add ( new LineSegment ( leftMargin + c * pixelsPerXTic , graphHeight - bottomMargin , leftMargin + c * pixelsPerXTic , graphHeight - ( bottomMargin + height ) ) ) ; } }
private String createFileName ( ) { String fileName = url . getPath ( ) ; if ( fileName . startsWith ( STRING ) ) { fileName = fileName . substring ( _NUM ) ; } else if ( fileName . startsWith ( STRING ) ) { fileName = fileName . substring ( _NUM ) ; } return fileName ; }
protected void requestStreamInfo ( String stream ) { String url = STRING + stream ; if ( attemptRequest ( url , stream ) ) { TwitchApiRequest request = new TwitchApiRequest ( this , RequestType . STREAM , url ) ; executor . execute ( request ) ; } }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public int add ( T dl , int row ) { _list . add ( row , dl ) ; fireTableRowsInserted ( row , row ) ; return row ; }
public AllocLocationModel ( SourceLocationTag line , IAllocNode node ) { this ( line . getClz ( ) , line . getLine ( ) , node ) ; }
protected List < Position > asPositionList ( LatLon ... locations ) { List < Position > positions = new ArrayList < Position > ( locations . length ) ; for ( LatLon loc : locations ) { positions . add ( new Position ( loc , _NUM ) ) ; } return positions ; }
public synchronized void removeDiscoveryListener ( DiscoveryListener l ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } int index = listeners . indexOf ( l ) ; if ( index != - _NUM ) listeners . remove ( index ) ; }
public synchronized void removeDiscoveryListener ( DiscoveryListener l ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } int index = listeners . indexOf ( l ) ; if ( index != - _NUM ) listeners . remove ( index ) ; }
public synchronized void removeDiscoveryListener ( DiscoveryListener l ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } int index = listeners . indexOf ( l ) ; if ( index != - _NUM ) listeners . remove ( index ) ; }
public synchronized void removeDiscoveryListener ( DiscoveryListener l ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } int index = listeners . indexOf ( l ) ; if ( index != - _NUM ) listeners . remove ( index ) ; }
public synchronized void removeDiscoveryListener ( DiscoveryListener l ) { if ( terminated ) { throw new IllegalStateException ( STRING ) ; } int index = listeners . indexOf ( l ) ; if ( index != - _NUM ) listeners . remove ( index ) ; }
private String stackTraceStr ( final Throwable error ) { if ( error == null ) { return STRING ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; error . printStackTrace ( pw ) ; pw . close ( ) ; return sw . toString ( ) ; }
private String stackTraceStr ( final Throwable error ) { if ( error == null ) { return STRING ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; error . printStackTrace ( pw ) ; pw . close ( ) ; return sw . toString ( ) ; }
private String stackTraceStr ( final Throwable error ) { if ( error == null ) { return STRING ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; error . printStackTrace ( pw ) ; pw . close ( ) ; return sw . toString ( ) ; }
private String stackTraceStr ( final Throwable error ) { if ( error == null ) { return STRING ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; error . printStackTrace ( pw ) ; pw . close ( ) ; return sw . toString ( ) ; }
private String stackTraceStr ( final Throwable error ) { if ( error == null ) { return STRING ; } StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; error . printStackTrace ( pw ) ; pw . close ( ) ; return sw . toString ( ) ; }
public Test findTest ( List < String > suiteNames , String testClassName , String testName , boolean insertIfMissing ) { if ( suiteNames . size ( ) <= _NUM ) { TestCase testCase = getTestCase ( testClassName ) ; return testCase . findTest ( testName , insertIfMissing ) ; } else { String rootName = suiteNames . remove ( _NUM ) ; TestSuite suite = getTestSuite ( rootName ) ; return suite . findTest ( suiteNames , testClassName , testName , insertIfMissing ) ; } }
@ Override public void visit ( Mapping m , int line , int col , int nextLine , int nextCol ) throws IOException { if ( previousLine != line ) { previousColumn = _NUM ; } if ( line != nextLine || col != nextCol ) { if ( line < maxLine ) { if ( previousLine == line ) { out . append ( STRING ) ; } writeEntry ( m , col ) ; previousLine = line ; previousColumn = col ; } else { Preconditions . checkState ( m == null ) ; } } for ( int i = line ; i <= nextLine && i < maxLine ; i ++ ) { if ( i == nextLine ) { break ; } closeLine ( _BOOL ) ; openLine ( _BOOL ) ; } }
public boolean cancel ( boolean force ) throws UnexecutedInvokeException { if ( future == null ) { throw new UnexecutedInvokeException ( this ) ; } return cancel ( _BOOL ) ; }
public boolean cancel ( boolean force ) throws UnexecutedInvokeException { if ( future == null ) { throw new UnexecutedInvokeException ( this ) ; } return cancel ( _BOOL ) ; }
public boolean cancel ( boolean force ) throws UnexecutedInvokeException { if ( future == null ) { throw new UnexecutedInvokeException ( this ) ; } return cancel ( _BOOL ) ; }
public boolean cancel ( boolean force ) throws UnexecutedInvokeException { if ( future == null ) { throw new UnexecutedInvokeException ( this ) ; } return cancel ( _BOOL ) ; }
private PlatformJob nextClosureJob ( PlatformAbstractTask task , BinaryRawReaderEx reader ) { return platformCtx . createClosureJob ( task , reader . readLong ( ) , reader . readObjectDetached ( ) ) ; }
public void addDataRow ( DataRow dataRow ) { dataRow . trim ( ) ; dataList . add ( dataRow ) ; dataRow . ensureNumberOfColumns ( columns ) ; }
public void addDataRow ( DataRow dataRow ) { dataRow . trim ( ) ; dataList . add ( dataRow ) ; dataRow . ensureNumberOfColumns ( columns ) ; }
public void addHostkeys ( char [ ] knownHostsData ) throws IOException { initialize ( knownHostsData ) ; }
public void addHostkeys ( char [ ] knownHostsData ) throws IOException { initialize ( knownHostsData ) ; }
private int ensureHeightGridAligned ( int height ) { float gridOverhang = height % FOUR_DIP ; if ( gridOverhang != _NUM ) { extraBottomPadding = ( int ) ( FOUR_DIP - Math . ceil ( gridOverhang ) ) ; } return extraBottomPadding ; }
boolean addComplement ( OwlClass c ) { return complementaryClasses . add ( c ) ; }
public void writeServer ( String server ) throws IOException { writeHeader ( HttpWriter . SERVER , server ) ; }
private int compareDate ( Date v1 , Date v2 ) { return v1 . compareTo ( v2 ) * - _NUM ; }
private int compareDate ( Date v1 , Date v2 ) { return v1 . compareTo ( v2 ) * - _NUM ; }
private int compareDate ( Date v1 , Date v2 ) { return v1 . compareTo ( v2 ) * - _NUM ; }
private int compareDate ( Date v1 , Date v2 ) { return v1 . compareTo ( v2 ) * - _NUM ; }
void queryReadResult ( PreparedStatement prep ) throws SQLException { ResultSet rs = prep . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; while ( rs . next ( ) ) { for ( int i = _NUM ; i < columnCount ; i ++ ) { rs . getString ( i + _NUM ) ; } } }
void queryReadResult ( PreparedStatement prep ) throws SQLException { ResultSet rs = prep . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; int columnCount = meta . getColumnCount ( ) ; while ( rs . next ( ) ) { for ( int i = _NUM ; i < columnCount ; i ++ ) { rs . getString ( i + _NUM ) ; } } }
public SmsConsoleServiceConfig ( ) { Document doc = parseDocument ( CONFIG_FILENAME ) ; configServices ( doc ) ; hiddenServices = Collections . unmodifiableSet ( services . get ( HIDDEN_SERVICES ) ) ; }
public SmsConsoleServiceConfig ( ) { Document doc = parseDocument ( CONFIG_FILENAME ) ; configServices ( doc ) ; hiddenServices = Collections . unmodifiableSet ( services . get ( HIDDEN_SERVICES ) ) ; }
public SmsConsoleServiceConfig ( ) { Document doc = parseDocument ( CONFIG_FILENAME ) ; configServices ( doc ) ; hiddenServices = Collections . unmodifiableSet ( services . get ( HIDDEN_SERVICES ) ) ; }
protected abstract String readOptionalStringImpl ( final String label ) ;
long parseBytes ( String freeSpace , String path ) throws IOException { try { long bytes = Long . parseLong ( freeSpace ) ; if ( bytes < _NUM ) { throw new IOException ( STRING + DF + STRING + STRING + path + STRING ) ; } return bytes ; } catch ( NumberFormatException ex ) { throw new IOExceptionWithCause ( STRING + DF + STRING + STRING + path + STRING , ex ) ; } }
private List < Map < String , Object > > typeParameters ( List < TypeParameter > tpl , Declaration from ) { if ( tpl != null && ! tpl . isEmpty ( ) ) { List < Map < String , Object > > l = new ArrayList < > ( tpl . size ( ) ) ; for ( TypeParameter tp : tpl ) { l . add ( typeParameterMap ( tp , from ) ) ; } return l ; } return null ; }
public static boolean isClassLiteralPossible ( ClassNode classNode ) { return Modifier . isPublic ( classNode . getModifiers ( ) ) ; }
public static boolean isClassLiteralPossible ( ClassNode classNode ) { return Modifier . isPublic ( classNode . getModifiers ( ) ) ; }
private String parseString ( final String s , final char separator , final AtomicReference < String > value ) { final StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int separatorIndex = - _NUM ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == separator && i + _NUM < s . length ( ) && s . charAt ( i + _NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . charAt ( i ) == separator ) { separatorIndex = i ; break ; } sb . append ( s . charAt ( i ) ) ; } value . set ( sb . toString ( ) ) ; if ( separatorIndex != - _NUM && separatorIndex != s . length ( ) - _NUM ) { return s . substring ( separatorIndex + _NUM ) ; } else { return STRING ; } }
private String parseString ( final String s , final char separator , final AtomicReference < String > value ) { final StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int separatorIndex = - _NUM ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == separator && i + _NUM < s . length ( ) && s . charAt ( i + _NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . charAt ( i ) == separator ) { separatorIndex = i ; break ; } sb . append ( s . charAt ( i ) ) ; } value . set ( sb . toString ( ) ) ; if ( separatorIndex != - _NUM && separatorIndex != s . length ( ) - _NUM ) { return s . substring ( separatorIndex + _NUM ) ; } else { return STRING ; } }
private String parseString ( final String s , final char separator , final AtomicReference < String > value ) { final StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int separatorIndex = - _NUM ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == separator && i + _NUM < s . length ( ) && s . charAt ( i + _NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . charAt ( i ) == separator ) { separatorIndex = i ; break ; } sb . append ( s . charAt ( i ) ) ; } value . set ( sb . toString ( ) ) ; if ( separatorIndex != - _NUM && separatorIndex != s . length ( ) - _NUM ) { return s . substring ( separatorIndex + _NUM ) ; } else { return STRING ; } }
private String parseString ( final String s , final char separator , final AtomicReference < String > value ) { final StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int separatorIndex = - _NUM ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == separator && i + _NUM < s . length ( ) && s . charAt ( i + _NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . charAt ( i ) == separator ) { separatorIndex = i ; break ; } sb . append ( s . charAt ( i ) ) ; } value . set ( sb . toString ( ) ) ; if ( separatorIndex != - _NUM && separatorIndex != s . length ( ) - _NUM ) { return s . substring ( separatorIndex + _NUM ) ; } else { return STRING ; } }
private String parseString ( final String s , final char separator , final AtomicReference < String > value ) { final StringBuilder sb = new StringBuilder ( s . length ( ) ) ; int separatorIndex = - _NUM ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == separator && i + _NUM < s . length ( ) && s . charAt ( i + _NUM ) == separator ) { sb . append ( separator ) ; i ++ ; continue ; } if ( s . charAt ( i ) == separator ) { separatorIndex = i ; break ; } sb . append ( s . charAt ( i ) ) ; } value . set ( sb . toString ( ) ) ; if ( separatorIndex != - _NUM && separatorIndex != s . length ( ) - _NUM ) { return s . substring ( separatorIndex + _NUM ) ; } else { return STRING ; } }
private void updateLastRefreshTime ( ) { this . lastRefreshTime = System . currentTimeMillis ( ) ; LOGGER . debug ( STRING , lastRefreshTime ) ; }
private void updateLastRefreshTime ( ) { this . lastRefreshTime = System . currentTimeMillis ( ) ; LOGGER . debug ( STRING , lastRefreshTime ) ; }
public Vector rotateXY ( final double angle ) { return rotateXY ( Math . sin ( angle ) , Math . cos ( angle ) ) ; }
public static String toString ( int value ) { return Integer . toString ( value ) ; }
private double calculateSingleTraitLikelihood ( ContrastedTraitNode contrastNode ) { SimpleTree contrastTree = new SimpleTree ( contrastNode ) ; double s2 = _NUM ; double sssContrast = _NUM ; double slogCV = _NUM ; for ( int i = _NUM ; i < contrastTree . getInternalNodeCount ( ) ; i ++ ) { ContrastedTraitNode ctNode = ( ContrastedTraitNode ) contrastTree . getInternalNode ( i ) ; double contrast = ctNode . getTraitContrasts ( ) [ _NUM ] ; double cv = ctNode . getContrastVariance ( ) ; sssContrast += ( contrast * contrast ) / cv ; slogCV += Math . log ( cv ) ; if ( ctNode . isRoot ( ) ) { slogCV += Math . log ( ctNode . getNodeVariance ( ) ) ; } } double tl = _NUM ; for ( int i = _NUM ; i < contrastTree . getNodeCount ( ) ; i ++ ) { NodeRef node = contrastTree . getNode ( i ) ; if ( ! contrastTree . isRoot ( node ) ) { tl += contrastTree . getBranchLength ( node ) ; } } s2 = sssContrast / contrastTree . getInternalNodeCount ( ) ; int n = contrastTree . getInternalNodeCount ( ) + _NUM ; double logL = n * Math . log ( _NUM * Math . PI * s2 ) ; logL += slogCV ; logL += sssContrast / s2 ; logL = - logL / _NUM ; return logL ; }
@ SuppressWarnings ( STRING ) public static void addExtraEncoding ( String name , IExtraEncoding enc ) { synchronized ( extraEncodings ) { extraEncodings . put ( name . toLowerCase ( ) , enc ) ; } }
public void shuffle ( Random rand ) { for ( int i = _pos ; i -- > _NUM ; ) { swap ( i , rand . nextInt ( i ) ) ; } }
public void shuffle ( Random rand ) { for ( int i = _pos ; i -- > _NUM ; ) { swap ( i , rand . nextInt ( i ) ) ; } }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public Set < String > hasRevisions ( Collection < Change > candidates ) { UpdateBuilder b = new UpdateBuilder ( getRevisions ) ; StringBuilder values = new StringBuilder ( ) ; for ( Change entry : candidates ) { values . append ( STRING + uris . entity ( ) + entry . entityId ( ) + STRING + entry . revision ( ) + STRING ) ; } b . bind ( STRING , values . toString ( ) ) ; b . bindUri ( STRING , SchemaDotOrg . VERSION ) ; return resultToSet ( query ( b . toString ( ) ) , STRING ) ; }
public long cardinality ( ) { switch ( type ) { case EMPTY : return _NUM ; case EXPLICIT : return explicitStorage . size ( ) ; case SPARSE : return ( long ) Math . ceil ( sparseProbabilisticAlgorithmCardinality ( ) ) ; case FULL : return ( long ) Math . ceil ( fullProbabilisticAlgorithmCardinality ( ) ) ; default : throw new RuntimeException ( STRING + type ) ; } }
private static int limitedLevenshtein ( final String str1 , final String str2 , int idx1 , int idx2 , final int limit ) { while ( _BOOL ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charAt ( idx1 ) != str2 . charAt ( idx2 ) ) { if ( limit < _NUM ) { return _NUM ; } else { return _NUM + bestLimLev ( str1 , str2 , idx1 , idx2 , limit - _NUM ) ; } } ++ idx1 ; ++ idx2 ; } }
private static int limitedLevenshtein ( final String str1 , final String str2 , int idx1 , int idx2 , final int limit ) { while ( _BOOL ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charAt ( idx1 ) != str2 . charAt ( idx2 ) ) { if ( limit < _NUM ) { return _NUM ; } else { return _NUM + bestLimLev ( str1 , str2 , idx1 , idx2 , limit - _NUM ) ; } } ++ idx1 ; ++ idx2 ; } }
private static int limitedLevenshtein ( final String str1 , final String str2 , int idx1 , int idx2 , final int limit ) { while ( _BOOL ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charAt ( idx1 ) != str2 . charAt ( idx2 ) ) { if ( limit < _NUM ) { return _NUM ; } else { return _NUM + bestLimLev ( str1 , str2 , idx1 , idx2 , limit - _NUM ) ; } } ++ idx1 ; ++ idx2 ; } }
private static int limitedLevenshtein ( final String str1 , final String str2 , int idx1 , int idx2 , final int limit ) { while ( _BOOL ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charAt ( idx1 ) != str2 . charAt ( idx2 ) ) { if ( limit < _NUM ) { return _NUM ; } else { return _NUM + bestLimLev ( str1 , str2 , idx1 , idx2 , limit - _NUM ) ; } } ++ idx1 ; ++ idx2 ; } }
private static int limitedLevenshtein ( final String str1 , final String str2 , int idx1 , int idx2 , final int limit ) { while ( _BOOL ) { if ( idx1 == str1 . length ( ) ) { return str2 . length ( ) - idx2 ; } else if ( idx2 == str2 . length ( ) ) { return str1 . length ( ) - idx1 ; } else if ( str1 . charAt ( idx1 ) != str2 . charAt ( idx2 ) ) { if ( limit < _NUM ) { return _NUM ; } else { return _NUM + bestLimLev ( str1 , str2 , idx1 , idx2 , limit - _NUM ) ; } } ++ idx1 ; ++ idx2 ; } }
private Tuple < Message , Connection > tryOtherMessages ( ) { List < Tuple < Message , Connection > > messages = new ArrayList < Tuple < Message , Connection > > ( ) ; Collection < Message > msgCollection = getMessageCollection ( ) ; for ( Connection con : getConnections ( ) ) { DTNHost other = con . getOtherNode ( getHost ( ) ) ; ProphetV2Router othRouter = ( ProphetV2Router ) other . getRouter ( ) ; if ( othRouter . isTransferring ( ) ) { continue ; } for ( Message m : msgCollection ) { if ( othRouter . hasMessage ( m . getId ( ) ) ) { continue ; } if ( ( othRouter . getPredFor ( m . getTo ( ) ) >= getPredFor ( m . getTo ( ) ) ) ) { messages . add ( new Tuple < Message , Connection > ( m , con ) ) ; } } } if ( messages . size ( ) == _NUM ) { return null ; } Collections . sort ( messages , new TupleComparator ( ) ) ; return tryMessagesForConnected ( messages ) ; }
public static void putObject ( final ByteBuffer buffer , Serializable o ) { try ( ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ) { try ( ObjectOutput oout = new ObjectOutputStream ( bos ) ) { oout . writeObject ( o ) ; byte [ ] laneBytes = bos . toByteArray ( ) ; buffer . putInt ( laneBytes . length ) ; for ( int i = _NUM ; i < laneBytes . length ; i ++ ) { buffer . put ( laneBytes [ i ] ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static void putObject ( final ByteBuffer buffer , Serializable o ) { try ( ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ) { try ( ObjectOutput oout = new ObjectOutputStream ( bos ) ) { oout . writeObject ( o ) ; byte [ ] laneBytes = bos . toByteArray ( ) ; buffer . putInt ( laneBytes . length ) ; for ( int i = _NUM ; i < laneBytes . length ; i ++ ) { buffer . put ( laneBytes [ i ] ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static void putObject ( final ByteBuffer buffer , Serializable o ) { try ( ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ) { try ( ObjectOutput oout = new ObjectOutputStream ( bos ) ) { oout . writeObject ( o ) ; byte [ ] laneBytes = bos . toByteArray ( ) ; buffer . putInt ( laneBytes . length ) ; for ( int i = _NUM ; i < laneBytes . length ; i ++ ) { buffer . put ( laneBytes [ i ] ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public String renameEntry ( SSOToken token , int objectType , String entryDN , String newName , boolean deleteOldName ) throws AMException { String newDN = super . renameEntry ( token , objectType , entryDN , newName , deleteOldName ) ; String oldDN = LDAPUtils . formatToRFC ( entryDN ) ; CacheBlock cb = ( CacheBlock ) sdkCache . remove ( oldDN ) ; newDN = LDAPUtils . formatToRFC ( newDN ) ; sdkCache . put ( newDN , cb ) ; return newDN ; }
public TvShowUpdateDatasourceTask ( String datasource ) { super ( BUNDLE . getString ( STRING ) + STRING + datasource + STRING ) ; tvShowList = TvShowList . getInstance ( ) ; dataSources = new ArrayList < > ( _NUM ) ; dataSources . add ( datasource ) ; }
public TvShowUpdateDatasourceTask ( String datasource ) { super ( BUNDLE . getString ( STRING ) + STRING + datasource + STRING ) ; tvShowList = TvShowList . getInstance ( ) ; dataSources = new ArrayList < > ( _NUM ) ; dataSources . add ( datasource ) ; }
public void copyResource ( String resourceName , File destFile , FilterChain filterChain , String encoding ) throws IOException { copyResource ( resourceName , destFile . getPath ( ) , defaultFileHandler , filterChain , encoding ) ; }
protected Set convertListToSet ( List list ) { Set s = new HashSet ( ) ; Iterator it = list . iterator ( ) ; while ( it . hasNext ( ) ) { s . add ( it . next ( ) ) ; } return s ; }
protected Set convertListToSet ( List list ) { Set s = new HashSet ( ) ; Iterator it = list . iterator ( ) ; while ( it . hasNext ( ) ) { s . add ( it . next ( ) ) ; } return s ; }
public SiteMonitor ( String [ ] urlList ) { siteUrlList = urlList ; }
public int position ( ) { return buff . position ( ) ; }
public JRakLibClient ( Logger logger , String serverIP , int serverPort ) { if ( serverPort < _NUM || serverPort > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } this . logger = logger ; this . serverEndpoint = new InetSocketAddress ( serverIP , serverPort ) ; externalQueue = new LinkedList < > ( ) ; internalQueue = new LinkedList < > ( ) ; start ( ) ; }
void removeRipple ( Ripple ripple ) { final Ripple [ ] ripples = mExitingRipples ; final int count = mExitingRipplesCount ; final int index = getRippleIndex ( ripple ) ; if ( index >= _NUM ) { System . arraycopy ( ripples , index + _NUM , ripples , index , count - ( index + _NUM ) ) ; ripples [ count - _NUM ] = null ; mExitingRipplesCount -- ; invalidateSelf ( ) ; } }
public final ParallelFlux < T > doAfterTerminate ( Runnable afterTerminate ) { Objects . requireNonNull ( afterTerminate , STRING ) ; return doOnSignal ( this , null , null , null , null , afterTerminate , null , null , null ) ; }
protected static int readFully ( Reader reader , char [ ] buf , int length ) throws IOException { int numCharsRead = _NUM ; while ( numCharsRead < length ) { int count = reader . read ( buf , numCharsRead , length - numCharsRead ) ; if ( count < _NUM ) { break ; } numCharsRead += count ; } return numCharsRead ; }
public static String convertToTitle ( int n ) { if ( n <= _NUM ) return STRING ; StringBuilder title = new StringBuilder ( ) ; while ( n > _NUM ) { n -- ; int r = n % _NUM ; title . insert ( _NUM , ( char ) ( STRING + r ) ) ; n = n / _NUM ; } return title . toString ( ) ; }
public static String convertToTitle ( int n ) { if ( n <= _NUM ) return STRING ; StringBuilder title = new StringBuilder ( ) ; while ( n > _NUM ) { n -- ; int r = n % _NUM ; title . insert ( _NUM , ( char ) ( STRING + r ) ) ; n = n / _NUM ; } return title . toString ( ) ; }
public static String convertToTitle ( int n ) { if ( n <= _NUM ) return STRING ; StringBuilder title = new StringBuilder ( ) ; while ( n > _NUM ) { n -- ; int r = n % _NUM ; title . insert ( _NUM , ( char ) ( STRING + r ) ) ; n = n / _NUM ; } return title . toString ( ) ; }
private String constructISCSINamesQuery ( String systemId , List < HostStorageDomain > hsdList , String model ) { Map < String , Object > attributeMap = new HashMap < String , Object > ( ) ; StorageArray array = new StorageArray ( systemId ) ; Add addOp = new Add ( HDSConstants . ISCSI_NAME_FOR_HSD_TARGET ) ; attributeMap . put ( HDSConstants . STORAGEARRAY , array ) ; attributeMap . put ( HDSConstants . ADD , addOp ) ; attributeMap . put ( HDSConstants . MODEL , model ) ; attributeMap . put ( HDSConstants . HOSTGROUP_LIST , hsdList ) ; String addWWNQuery = InputXMLGenerationClient . getInputXMLString ( HDSConstants . BATCH_ADD_WWN_TO_HSD_OP , attributeMap , HDSConstants . HITACHI_INPUT_XML_CONTEXT_FILE , HDSConstants . HITACHI_SMOOKS_CONFIG_FILE ) ; return addWWNQuery ; }
private String constructISCSINamesQuery ( String systemId , List < HostStorageDomain > hsdList , String model ) { Map < String , Object > attributeMap = new HashMap < String , Object > ( ) ; StorageArray array = new StorageArray ( systemId ) ; Add addOp = new Add ( HDSConstants . ISCSI_NAME_FOR_HSD_TARGET ) ; attributeMap . put ( HDSConstants . STORAGEARRAY , array ) ; attributeMap . put ( HDSConstants . ADD , addOp ) ; attributeMap . put ( HDSConstants . MODEL , model ) ; attributeMap . put ( HDSConstants . HOSTGROUP_LIST , hsdList ) ; String addWWNQuery = InputXMLGenerationClient . getInputXMLString ( HDSConstants . BATCH_ADD_WWN_TO_HSD_OP , attributeMap , HDSConstants . HITACHI_INPUT_XML_CONTEXT_FILE , HDSConstants . HITACHI_SMOOKS_CONFIG_FILE ) ; return addWWNQuery ; }
public void testWeaklyConsistentIteration ( ) { final LinkedBlockingQueue q = new LinkedBlockingQueue ( _NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . hasNext ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assertEquals ( _NUM , q . size ( ) ) ; }
public void testWeaklyConsistentIteration ( ) { final LinkedBlockingQueue q = new LinkedBlockingQueue ( _NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . hasNext ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assertEquals ( _NUM , q . size ( ) ) ; }
public void testWeaklyConsistentIteration ( ) { final LinkedBlockingQueue q = new LinkedBlockingQueue ( _NUM ) ; q . add ( one ) ; q . add ( two ) ; q . add ( three ) ; for ( Iterator it = q . iterator ( ) ; it . hasNext ( ) ; ) { q . remove ( ) ; it . next ( ) ; } assertEquals ( _NUM , q . size ( ) ) ; }
@ Override public void layerMoved ( final MapLayerListEvent event ) { redrawBaseImage = _BOOL ; if ( ! isDisposed ( ) ) redraw ( ) ; }
public static Color disable ( Color color ) { int alpha = color . getAlpha ( ) ; alpha /= _NUM ; return new Color ( ( color . getRGB ( ) & _NUM ) | ( alpha << _NUM ) , _BOOL ) ; }
public void testFindSpringActiveDirectory ( ) { LdapProxy proxy = getLdapAD ( ) ; List result = null ; try { result = proxy . find ( getLdapSearchVO ( STRING , LdapConstants . NO_SEARCH_LIMIT , null , null , null , LdapScopeConstants . SCOPE_SUBTREE ) ) ; } catch ( Exception e ) { } assertNotNull ( result ) ; assertEquals ( _NUM , result . size ( ) ) ; }
protected void assertViewHasText ( int viewId , String text ) { String viewText = textOfView ( viewId ) ; at ( STRING + viewText + STRING + text , viewText . contains ( text ) ) ; }
public static String stripUrl ( String url ) { if ( url == null ) return null ; Matcher m = STRIP_URL_PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( _NUM ) ; } else { return url ; } }
public static String stripUrl ( String url ) { if ( url == null ) return null ; Matcher m = STRIP_URL_PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( _NUM ) ; } else { return url ; } }
public static String stripUrl ( String url ) { if ( url == null ) return null ; Matcher m = STRIP_URL_PATTERN . matcher ( url ) ; if ( m . matches ( ) ) { return m . group ( _NUM ) ; } else { return url ; } }
protected void processPingRequest ( SimEvent ev ) { InfoPacket pkt = ( InfoPacket ) ev . getData ( ) ; pkt . setTag ( CloudSimTags . INFOPKT_RETURN ) ; pkt . setDestId ( pkt . getSrcId ( ) ) ; sendNow ( pkt . getSrcId ( ) , CloudSimTags . INFOPKT_RETURN , pkt ) ; }
public boolean isPureJAASModulePresent ( final String configName , final Configuration configuration ) throws AuthLoginException { if ( enforceJAASThread ) { return _BOOL ; } if ( null == configuration ) { return _BOOL ; } final AppConfigurationEntry [ ] entries = configuration . getAppConfigurationEntry ( configName ) ; if ( entries == null ) { throw new AuthLoginException ( STRING , AMAuthErrorCode . AUTH_CONFIG_NOT_FOUND , null ) ; } for ( AppConfigurationEntry entry : entries ) { String className = entry . getLoginModuleName ( ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + className ) ; } if ( isPureJAASModule ( className ) ) { return _BOOL ; } else if ( ! isISModule ( className ) ) { categoriseModuleClassFromClassname ( className ) ; if ( isPureJAASModule ( className ) ) { return _BOOL ; } } } return _BOOL ; }
public boolean isPureJAASModulePresent ( final String configName , final Configuration configuration ) throws AuthLoginException { if ( enforceJAASThread ) { return _BOOL ; } if ( null == configuration ) { return _BOOL ; } final AppConfigurationEntry [ ] entries = configuration . getAppConfigurationEntry ( configName ) ; if ( entries == null ) { throw new AuthLoginException ( STRING , AMAuthErrorCode . AUTH_CONFIG_NOT_FOUND , null ) ; } for ( AppConfigurationEntry entry : entries ) { String className = entry . getLoginModuleName ( ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + className ) ; } if ( isPureJAASModule ( className ) ) { return _BOOL ; } else if ( ! isISModule ( className ) ) { categoriseModuleClassFromClassname ( className ) ; if ( isPureJAASModule ( className ) ) { return _BOOL ; } } } return _BOOL ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
@ Ignore ( STRING ) @ Test public void testConcurrentEventsOnEmptyRegion ( ) { versionTestConcurrentEventsOnEmptyRegion ( ) ; }
public Matrix3 ( Matrix3 matrix ) { if ( matrix == null ) { throw new IllegalArgumentException ( Logger . logMessage ( Logger . ERROR , STRING , STRING , STRING ) ) ; } System . arraycopy ( matrix . m , _NUM , this . m , _NUM , _NUM ) ; }
public ParameterTypeFile ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; setOptional ( optional ) ; this . extensions = extensions ; }
public ParameterTypeFile ( String key , String description , boolean optional , String [ ] extensions ) { super ( key , description , null ) ; setOptional ( optional ) ; this . extensions = extensions ; }
public void writeTo ( byte [ ] bytes , int offset ) throws IOException { flush ( ) ; final long end = file . length ; long pos = _NUM ; int buffer = _NUM ; int bytesUpto = offset ; while ( pos < end ) { int length = BUFFER_SIZE ; long nextPos = pos + length ; if ( nextPos > end ) { length = ( int ) ( end - pos ) ; } System . arraycopy ( file . getBuffer ( buffer ++ ) , _NUM , bytes , bytesUpto , length ) ; bytesUpto += length ; pos = nextPos ; } }
public void addSelectionListener ( ExplorerSelectionListener listener ) { selectionListeners . add ( listener ) ; }
public void addSelectionListener ( ExplorerSelectionListener listener ) { selectionListeners . add ( listener ) ; }
public void addSelectionListener ( ExplorerSelectionListener listener ) { selectionListeners . add ( listener ) ; }
private void updateNextClock ( final PseudoTCPBase tcp , final Object lock ) { try { long now = PseudoTCPBase . now ( ) ; synchronized ( tcp ) { tcp . notifyClock ( now ) ; } long interval ; synchronized ( tcp ) { interval = tcp . getNextClock ( PseudoTCPBase . now ( ) ) ; } if ( logger . isLoggable ( Level . FINEST ) ) { logger . log ( Level . FINEST , tcp . debugName + STRING + interval ) ; } if ( interval < _NUM ) { if ( interval == - _NUM ) { interval = _NUM ; } else { return ; } } synchronized ( lock ) { lock . wait ( interval ) ; } } catch ( InterruptedException ex ) { } }
public ECIESKeyEncapsulation ( DerivationFunction kdf , SecureRandom rnd ) { this . kdf = kdf ; this . rnd = rnd ; this . CofactorMode = _BOOL ; this . OldCofactorMode = _BOOL ; this . SingleHashMode = _BOOL ; }
@ Deprecated public void addPrefixNSMapping ( String prefix , String nsURI ) { if ( nsURI . length ( ) == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( prefix . length ( ) == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( prefix . equals ( NO_NS_PREFIX ) ) { throw new IllegalArgumentException ( STRING + prefix + STRING ) ; } if ( prefixToNamespaceURILookup . containsKey ( prefix ) ) { throw new IllegalArgumentException ( STRING + prefix + STRING ) ; } if ( namespaceURIToPrefixLookup . containsKey ( nsURI ) ) { throw new IllegalArgumentException ( STRING + nsURI + STRING ) ; } if ( prefix . equals ( DEFAULT_NAMESPACE_PREFIX ) ) { this . defaultNS = nsURI ; } else { prefixToNamespaceURILookup . put ( prefix , nsURI ) ; namespaceURIToPrefixLookup . put ( nsURI , prefix ) ; } }
public static Optional < String > packageName ( String longName ) { if ( longName . contains ( STRING ) ) { return Optional . of ( longName . substring ( _NUM , longName . lastIndexOf ( STRING ) ) ) ; } else { return Optional . empty ( ) ; } }
@ Override public void afterAuthorizeSuccess ( OAuth2Request o2request , Request request , Response response ) { Series < CookieSetting > cookiesSetInThisResponse = response . getCookieSettings ( ) ; CookieSetting loginHintCookieSetting = cookiesSetInThisResponse . getFirst ( LOGIN_HINT_COOKIE ) ; if ( loginHintCookieSetting != null && loginHintCookieSetting . getMaxAge ( ) != _NUM ) { cookiesSetInThisResponse . removeFirst ( LOGIN_HINT_COOKIE ) ; } removeCookie ( request , response ) ; }
@ Override public void afterAuthorizeSuccess ( OAuth2Request o2request , Request request , Response response ) { Series < CookieSetting > cookiesSetInThisResponse = response . getCookieSettings ( ) ; CookieSetting loginHintCookieSetting = cookiesSetInThisResponse . getFirst ( LOGIN_HINT_COOKIE ) ; if ( loginHintCookieSetting != null && loginHintCookieSetting . getMaxAge ( ) != _NUM ) { cookiesSetInThisResponse . removeFirst ( LOGIN_HINT_COOKIE ) ; } removeCookie ( request , response ) ; }
@ Override public void afterAuthorizeSuccess ( OAuth2Request o2request , Request request , Response response ) { Series < CookieSetting > cookiesSetInThisResponse = response . getCookieSettings ( ) ; CookieSetting loginHintCookieSetting = cookiesSetInThisResponse . getFirst ( LOGIN_HINT_COOKIE ) ; if ( loginHintCookieSetting != null && loginHintCookieSetting . getMaxAge ( ) != _NUM ) { cookiesSetInThisResponse . removeFirst ( LOGIN_HINT_COOKIE ) ; } removeCookie ( request , response ) ; }
@ Override public void afterAuthorizeSuccess ( OAuth2Request o2request , Request request , Response response ) { Series < CookieSetting > cookiesSetInThisResponse = response . getCookieSettings ( ) ; CookieSetting loginHintCookieSetting = cookiesSetInThisResponse . getFirst ( LOGIN_HINT_COOKIE ) ; if ( loginHintCookieSetting != null && loginHintCookieSetting . getMaxAge ( ) != _NUM ) { cookiesSetInThisResponse . removeFirst ( LOGIN_HINT_COOKIE ) ; } removeCookie ( request , response ) ; }
private float overScrollUp ( int deltaY , int range ) { deltaY = Math . max ( deltaY , _NUM ) ; float currentTopAmount = getCurrentOverScrollAmount ( _BOOL ) ; float newTopAmount = currentTopAmount - deltaY ; if ( currentTopAmount > _NUM ) { setOverScrollAmount ( newTopAmount , _BOOL , _BOOL ) ; } float scrollAmount = newTopAmount < _NUM ? - newTopAmount : _NUM ; float newScrollY = mOwnScrollY + scrollAmount ; if ( newScrollY > range ) { if ( ! mExpandedInThisMotion ) { float currentBottomPixels = getCurrentOverScrolledPixels ( _BOOL ) ; setOverScrolledPixels ( currentBottomPixels + newScrollY - range , _BOOL , _BOOL ) ; } mOwnScrollY = range ; scrollAmount = _NUM ; } return scrollAmount ; }
public void service ( Mail mail ) { try { log ( mail . getName ( ) + STRING ) ; MimeMessage message = mail . getMessage ( ) ; HashSet < NameValuePair > pairs = getNameValuePairs ( message ) ; log ( mail . getName ( ) + STRING + pairs . size ( ) + STRING ) ; String result = httpPost ( pairs ) ; if ( passThrough ) { addHeader ( mail , _BOOL , result ) ; } else { mail . setState ( Mail . GHOST ) ; } } catch ( javax . mail . MessagingException me ) { log ( me . getMessage ( ) ) ; addHeader ( mail , _BOOL , me . getMessage ( ) ) ; } catch ( IOException e ) { log ( e . getMessage ( ) ) ; addHeader ( mail , _BOOL , e . getMessage ( ) ) ; } }
public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; }
public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; }
public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; }
public void addExtensionNamespace ( String uri , ExtensionHandler extNS ) { m_extensionFunctionNamespaces . put ( uri , extNS ) ; }
public ComponentManager ( Collection < Sequence > generalSeeds ) { Set < Sequence > seedSet = new LinkedHashSet < > ( generalSeeds . size ( ) ) ; seedSet . addAll ( generalSeeds ) ; this . gralSeeds = Collections . unmodifiableSet ( seedSet ) ; gralComponents = new SequenceCollection ( seedSet ) ; }
public void recordState ( DialogueState state , String name ) { if ( frame != null ) { stateMonitorTab . recordState ( state , name ) ; } }
public void recordState ( DialogueState state , String name ) { if ( frame != null ) { stateMonitorTab . recordState ( state , name ) ; } }
public void recordState ( DialogueState state , String name ) { if ( frame != null ) { stateMonitorTab . recordState ( state , name ) ; } }
private void update ( Tuple input ) { JSONObject message = ( JSONObject ) input . getValueByField ( STRING ) ; try { Map < String , String > expressions = profileConfig . getUpdate ( ) ; expressions . forEach ( null ) ; } catch ( ParseException e ) { String msg = format ( STRING , e . getMessage ( ) , measurement . getProfileName ( ) , measurement . getEntity ( ) ) ; throw new ParseException ( msg , e ) ; } }
private static int globalErrorHandler ( long display , long event_ptr ) { if ( noisyAwtHandler ) { XlibWrapper . PrintXErrorEvent ( display , event_ptr ) ; } XErrorEvent event = new XErrorEvent ( event_ptr ) ; saved_error = event ; try { if ( current_error_handler != null ) { return current_error_handler . handleError ( display , event ) ; } else { return SAVED_XERROR_HANDLER ( display , event ) ; } } catch ( Throwable z ) { log . fine ( STRING , z ) ; } return _NUM ; }
protected void parseAndAdd ( List list , String line ) { try { StringTokenizer tokenizer = new StringTokenizer ( line , STRING ) ; String feature = tokenizer . nextToken ( ) ; float start = Float . parseFloat ( tokenizer . nextToken ( ) ) ; float mid = Float . parseFloat ( tokenizer . nextToken ( ) ) ; float end = Float . parseFloat ( tokenizer . nextToken ( ) ) ; String type = tokenizer . nextToken ( ) ; if ( type . equals ( STRING ) ) { type = null ; } list . add ( new F0ModelTerm ( feature , start , mid , end , type ) ) ; } catch ( NoSuchElementException nsee ) { throw new Error ( STRING + nsee . getMessage ( ) ) ; } catch ( NumberFormatException nfe ) { throw new Error ( STRING + nfe . getMessage ( ) ) ; } }
public void union ( Clip c ) { if ( status == INVALID ) return ; if ( status == EMPTY ) { setClip ( c ) ; status = INUSE ; return ; } clip [ _NUM ] = Math . min ( clip [ _NUM ] , c . clip [ _NUM ] ) ; clip [ _NUM ] = Math . min ( clip [ _NUM ] , c . clip [ _NUM ] ) ; clip [ _NUM ] = Math . max ( clip [ _NUM ] , c . clip [ _NUM ] ) ; clip [ _NUM ] = Math . max ( clip [ _NUM ] , c . clip [ _NUM ] ) ; }
public boolean isEquivalent ( Transaction transaction ) { return mId . equals ( transaction . mId ) ; }
@ Override public void write ( byte b [ ] ) throws IOException { for ( OutputStream stream : outs ) stream . write ( b ) ; }
private File calcParentTree ( ) { File parentTree = treeFile . getParentFile ( ) ; if ( null == parentTree ) { return null ; } if ( treeFile . isAbsolute ( ) && ( null == parentTree . getParentFile ( ) ) ) { return null ; } return parentTree ; }
private File calcParentTree ( ) { File parentTree = treeFile . getParentFile ( ) ; if ( null == parentTree ) { return null ; } if ( treeFile . isAbsolute ( ) && ( null == parentTree . getParentFile ( ) ) ) { return null ; } return parentTree ; }
private File calcParentTree ( ) { File parentTree = treeFile . getParentFile ( ) ; if ( null == parentTree ) { return null ; } if ( treeFile . isAbsolute ( ) && ( null == parentTree . getParentFile ( ) ) ) { return null ; } return parentTree ; }
private File calcParentTree ( ) { File parentTree = treeFile . getParentFile ( ) ; if ( null == parentTree ) { return null ; } if ( treeFile . isAbsolute ( ) && ( null == parentTree . getParentFile ( ) ) ) { return null ; } return parentTree ; }
private File calcParentTree ( ) { File parentTree = treeFile . getParentFile ( ) ; if ( null == parentTree ) { return null ; } if ( treeFile . isAbsolute ( ) && ( null == parentTree . getParentFile ( ) ) ) { return null ; } return parentTree ; }
void parse ( ) throws IOException { while ( _BOOL ) { final String line = mIn . readLine ( ) ; if ( line == null ) { break ; } final String msg = line ( line ) ; if ( msg != null ) { error ( STRING + line + LS + msg ) ; } } end ( ) ; }
public static String quote ( String input ) { if ( input . contains ( STRING ) ) { return STRING + input + STRING ; } else { return input ; } }
public static String quote ( String input ) { if ( input . contains ( STRING ) ) { return STRING + input + STRING ; } else { return input ; } }
private List < Constraint < ? > > buildQuery ( PathCondition pc , int conditionIndex ) { PathCondition negatedPathCondition = pc . negate ( conditionIndex ) ; List < Constraint < ? > > query = negatedPathCondition . getConstraints ( ) ; List < Constraint < ? > > simplified_query = reduce ( query ) ; return simplified_query ; }
public RandomFilter ( final double minimumValue , final double maximumValue ) { if ( minimumValue > maximumValue ) { throw new IllegalArgumentException ( STRING ) ; } this . minimumValue = minimumValue ; this . maximumValue = maximumValue ; difference = Math . abs ( this . maximumValue - this . minimumValue ) ; random = new Random ( ) ; }
public static boolean isFileExist ( String filePath , FileType fileType , boolean performFileCheck ) throws IOException { filePath = filePath . replace ( STRING , STRING ) ; switch ( fileType ) { case HDFS : case VIEWFS : Path path = new Path ( filePath ) ; FileSystem fs = path . getFileSystem ( configuration ) ; if ( performFileCheck ) { return fs . exists ( path ) && fs . isFile ( path ) ; } else { return fs . exists ( path ) ; } case LOCAL : default : File defaultFile = new File ( filePath ) ; if ( performFileCheck ) { return defaultFile . exists ( ) && defaultFile . isFile ( ) ; } else { return defaultFile . exists ( ) ; } } }
public TSink < String > sendString ( TStream < String > stream ) { Objects . requireNonNull ( stream , STRING ) ; return sendText ( stream , null ) ; }
public TSink < String > sendString ( TStream < String > stream ) { Objects . requireNonNull ( stream , STRING ) ; return sendText ( stream , null ) ; }
public void unbindTree ( Container ui ) { int componentCount = ui . getComponentCount ( ) ; for ( int iter = _NUM ; iter < componentCount ; iter ++ ) { Component c = ui . getComponentAt ( iter ) ; if ( c instanceof Container ) { unbindTree ( ( Container ) c ) ; continue ; } String bind = c . getCloudBoundProperty ( ) ; if ( bind != null && bind . length ( ) > _NUM ) { String attributeName = c . getCloudDestinationProperty ( ) ; if ( attributeName != null ) { unbindProperty ( c , bind ) ; } } } }
public boolean showNoticeInServerWindow ( ) { return preferences . getBoolean ( resources . getString ( R . string . key_notice_server_window ) , Boolean . parseBoolean ( resources . getString ( R . string . default_notice_server_window ) ) ) ; }
public boolean showNoticeInServerWindow ( ) { return preferences . getBoolean ( resources . getString ( R . string . key_notice_server_window ) , Boolean . parseBoolean ( resources . getString ( R . string . default_notice_server_window ) ) ) ; }
protected DocWriter createWriter ( final MBasicTable table , final Document document , final OutputStream out ) throws DocumentException { final PdfWriter writer = PdfWriter . getInstance ( document , out ) ; if ( table . getName ( ) != null ) { final HeaderFooter header = new HeaderFooter ( new Phrase ( table . getName ( ) ) , _BOOL ) ; header . setAlignment ( Element . ALIGN_LEFT ) ; header . setBorder ( Rectangle . NO_BORDER ) ; document . setHeader ( header ) ; document . addTitle ( table . getName ( ) ) ; } writer . setPageEvent ( new AdvancedPageNumberEvents ( ) ) ; return writer ; }
protected DocWriter createWriter ( final MBasicTable table , final Document document , final OutputStream out ) throws DocumentException { final PdfWriter writer = PdfWriter . getInstance ( document , out ) ; if ( table . getName ( ) != null ) { final HeaderFooter header = new HeaderFooter ( new Phrase ( table . getName ( ) ) , _BOOL ) ; header . setAlignment ( Element . ALIGN_LEFT ) ; header . setBorder ( Rectangle . NO_BORDER ) ; document . setHeader ( header ) ; document . addTitle ( table . getName ( ) ) ; } writer . setPageEvent ( new AdvancedPageNumberEvents ( ) ) ; return writer ; }
protected DocWriter createWriter ( final MBasicTable table , final Document document , final OutputStream out ) throws DocumentException { final PdfWriter writer = PdfWriter . getInstance ( document , out ) ; if ( table . getName ( ) != null ) { final HeaderFooter header = new HeaderFooter ( new Phrase ( table . getName ( ) ) , _BOOL ) ; header . setAlignment ( Element . ALIGN_LEFT ) ; header . setBorder ( Rectangle . NO_BORDER ) ; document . setHeader ( header ) ; document . addTitle ( table . getName ( ) ) ; } writer . setPageEvent ( new AdvancedPageNumberEvents ( ) ) ; return writer ; }
private static void stoppingAnimation ( Thread me ) { final FetcherInfo info = FetcherInfo . getFetcherInfo ( ) ; synchronized ( info . waitList ) { int index = - _NUM ; for ( int i = _NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= _NUM ) { info . fetchers [ index ] = me ; info . numFetchers ++ ; me . setName ( STRING + index ) ; return ; } } }
private static void stoppingAnimation ( Thread me ) { final FetcherInfo info = FetcherInfo . getFetcherInfo ( ) ; synchronized ( info . waitList ) { int index = - _NUM ; for ( int i = _NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= _NUM ) { info . fetchers [ index ] = me ; info . numFetchers ++ ; me . setName ( STRING + index ) ; return ; } } }
private static void stoppingAnimation ( Thread me ) { final FetcherInfo info = FetcherInfo . getFetcherInfo ( ) ; synchronized ( info . waitList ) { int index = - _NUM ; for ( int i = _NUM ; i < info . fetchers . length ; i ++ ) { if ( info . fetchers [ i ] == me ) { return ; } if ( info . fetchers [ i ] == null ) { index = i ; } } if ( index >= _NUM ) { info . fetchers [ index ] = me ; info . numFetchers ++ ; me . setName ( STRING + index ) ; return ; } } }
public static DoubleVector rchisq ( int n , double ncp , Random random ) { DoubleVector v = new DoubleVector ( n ) ; double mean = Math . sqrt ( ncp ) ; double x ; for ( int i = _NUM ; i < n ; i ++ ) { x = random . nextGaussian ( ) + mean ; v . set ( i , x * x ) ; } return v ; }
@ Override public ServiceHost start ( ) throws Throwable { super . start ( ) ; startDefaultCoreServicesSynchronously ( ) ; super . startService ( new RootNamespaceService ( ) ) ; super . startService ( new SampleServiceWithSharedCustomUi ( ) ) ; super . startService ( new SampleFactoryServiceWithCustomUi ( ) ) ; super . startFactory ( new SampleSimpleEchoService ( ) ) ; super . startFactory ( new SamplePreviousEchoService ( ) ) ; super . startFactory ( new ExampleService ( ) ) ; super . startFactory ( new ExampleTaskService ( ) ) ; super . startService ( new UiService ( ) ) ; startSwaggerDescriptorService ( ) ; return this ; }
@ Override public ServiceHost start ( ) throws Throwable { super . start ( ) ; startDefaultCoreServicesSynchronously ( ) ; super . startService ( new RootNamespaceService ( ) ) ; super . startService ( new SampleServiceWithSharedCustomUi ( ) ) ; super . startService ( new SampleFactoryServiceWithCustomUi ( ) ) ; super . startFactory ( new SampleSimpleEchoService ( ) ) ; super . startFactory ( new SamplePreviousEchoService ( ) ) ; super . startFactory ( new ExampleService ( ) ) ; super . startFactory ( new ExampleTaskService ( ) ) ; super . startService ( new UiService ( ) ) ; startSwaggerDescriptorService ( ) ; return this ; }
protected void read ( long offset , byte [ ] b ) throws IOException { rafile . seek ( offset ) ; if ( rafile . read ( b ) != b . length ) { throw new IOException ( STRING + getPath ( ) ) ; } }
public Schedule newSchedule ( String name ) { Schedule schedule = getScheduleByName ( name ) ; if ( schedule == null ) { _id ++ ; schedule = new Schedule ( Integer . toString ( _id ) , name ) ; Integer oldSize = Integer . valueOf ( _scheduleHashTable . size ( ) ) ; _scheduleHashTable . put ( schedule . getId ( ) , schedule ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _scheduleHashTable . size ( ) ) ) ; } return schedule ; }
public Schedule newSchedule ( String name ) { Schedule schedule = getScheduleByName ( name ) ; if ( schedule == null ) { _id ++ ; schedule = new Schedule ( Integer . toString ( _id ) , name ) ; Integer oldSize = Integer . valueOf ( _scheduleHashTable . size ( ) ) ; _scheduleHashTable . put ( schedule . getId ( ) , schedule ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _scheduleHashTable . size ( ) ) ) ; } return schedule ; }
public boolean acceptFilenameIdentical ( String fileName ) { return acceptIdentical ( null , fileName ) ; }
public boolean acceptFilenameIdentical ( String fileName ) { return acceptIdentical ( null , fileName ) ; }
public boolean acceptFilenameIdentical ( String fileName ) { return acceptIdentical ( null , fileName ) ; }
public Container addChild ( @ NonNull DisplayObject DisplayObject ) { if ( mFps != DEFAULT_FPS ) { DisplayObject . setUp ( mFps ) ; } mDisplayList . add ( DisplayObject ) ; return this ; }
private static int javaScriptUnescapeHelper ( String s , int i , StringBuilder sb ) { if ( i >= s . length ( ) ) { throw new IllegalArgumentException ( STRING + s + STRING ) ; } char c = s . charAt ( i ++ ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; case STRING : String hexCode ; try { hexCode = s . substring ( i , i + _NUM ) ; } catch ( IndexOutOfBoundsException ioobe ) { throw new IllegalArgumentException ( STRING + s . substring ( i ) + STRING + i + STRING + s + STRING ) ; } int unicodeValue ; try { unicodeValue = Integer . parseInt ( hexCode , _NUM ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( STRING + hexCode + STRING + i + STRING + s + STRING ) ; } sb . append ( ( char ) unicodeValue ) ; i += _NUM ; break ; default : throw new IllegalArgumentException ( STRING + c + STRING + i + STRING + s + STRING ) ; } return i ; }
private static int javaScriptUnescapeHelper ( String s , int i , StringBuilder sb ) { if ( i >= s . length ( ) ) { throw new IllegalArgumentException ( STRING + s + STRING ) ; } char c = s . charAt ( i ++ ) ; switch ( c ) { case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : sb . append ( STRING ) ; break ; case STRING : case STRING : case STRING : case STRING : sb . append ( c ) ; break ; case STRING : String hexCode ; try { hexCode = s . substring ( i , i + _NUM ) ; } catch ( IndexOutOfBoundsException ioobe ) { throw new IllegalArgumentException ( STRING + s . substring ( i ) + STRING + i + STRING + s + STRING ) ; } int unicodeValue ; try { unicodeValue = Integer . parseInt ( hexCode , _NUM ) ; } catch ( NumberFormatException nfe ) { throw new IllegalArgumentException ( STRING + hexCode + STRING + i + STRING + s + STRING ) ; } sb . append ( ( char ) unicodeValue ) ; i += _NUM ; break ; default : throw new IllegalArgumentException ( STRING + c + STRING + i + STRING + s + STRING ) ; } return i ; }
public void load ( InputStream is , boolean doSubstitutions ) throws IOException { Properties props = new Properties ( ) ; props . load ( is ) ; if ( doSubstitutions ) substituteSystemValues ( props ) ; load ( props ) ; props = null ; }
public void load ( InputStream is , boolean doSubstitutions ) throws IOException { Properties props = new Properties ( ) ; props . load ( is ) ; if ( doSubstitutions ) substituteSystemValues ( props ) ; load ( props ) ; props = null ; }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX_VALUE ) ; } catch ( InterruptedException iex ) { } }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX_VALUE ) ; } catch ( InterruptedException iex ) { } }
public static void sleep ( ) { try { Thread . sleep ( Long . MAX_VALUE ) ; } catch ( InterruptedException iex ) { } }
LocationCollection enableBreak ( SourceFile f , int line , int isolateId ) throws NotConnectedException { LocationCollection col = new LocationCollection ( ) ; boolean singleSwfBreakpoint = m_fileInfo . isSwfFilterOn ( ) ; SwfInfo swf = m_fileInfo . getSwfFilter ( ) ; if ( singleSwfBreakpoint ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { SwfInfo [ ] swfs = m_fileInfo . getSwfs ( isolateId ) ; for ( SwfInfo swf1 : swfs ) { swf = swf1 ; if ( swf != null ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
LocationCollection enableBreak ( SourceFile f , int line , int isolateId ) throws NotConnectedException { LocationCollection col = new LocationCollection ( ) ; boolean singleSwfBreakpoint = m_fileInfo . isSwfFilterOn ( ) ; SwfInfo swf = m_fileInfo . getSwfFilter ( ) ; if ( singleSwfBreakpoint ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { SwfInfo [ ] swfs = m_fileInfo . getSwfs ( isolateId ) ; for ( SwfInfo swf1 : swfs ) { swf = swf1 ; if ( swf != null ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
LocationCollection enableBreak ( SourceFile f , int line , int isolateId ) throws NotConnectedException { LocationCollection col = new LocationCollection ( ) ; boolean singleSwfBreakpoint = m_fileInfo . isSwfFilterOn ( ) ; SwfInfo swf = m_fileInfo . getSwfFilter ( ) ; if ( singleSwfBreakpoint ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { SwfInfo [ ] swfs = m_fileInfo . getSwfs ( isolateId ) ; for ( SwfInfo swf1 : swfs ) { swf = swf1 ; if ( swf != null ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
LocationCollection enableBreak ( SourceFile f , int line , int isolateId ) throws NotConnectedException { LocationCollection col = new LocationCollection ( ) ; boolean singleSwfBreakpoint = m_fileInfo . isSwfFilterOn ( ) ; SwfInfo swf = m_fileInfo . getSwfFilter ( ) ; if ( singleSwfBreakpoint ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { SwfInfo [ ] swfs = m_fileInfo . getSwfs ( isolateId ) ; for ( SwfInfo swf1 : swfs ) { swf = swf1 ; if ( swf != null ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
LocationCollection enableBreak ( SourceFile f , int line , int isolateId ) throws NotConnectedException { LocationCollection col = new LocationCollection ( ) ; boolean singleSwfBreakpoint = m_fileInfo . isSwfFilterOn ( ) ; SwfInfo swf = m_fileInfo . getSwfFilter ( ) ; if ( singleSwfBreakpoint ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( ( swf == null ) ? STRING : swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } col . add ( l ) ; } else { SwfInfo [ ] swfs = m_fileInfo . getSwfs ( isolateId ) ; for ( SwfInfo swf1 : swfs ) { swf = swf1 ; if ( swf != null ) { Location l = null ; try { l = findAndEnableBreak ( swf , f , line ) ; } catch ( InProgressException e ) { if ( Trace . error ) Trace . trace ( ( swf . getUrl ( ) ) + STRING + f . getName ( ) + STRING + line + STRING ) ; } if ( l != null ) col . add ( l ) ; } } } return col ; }
public AuthPropertiesModelImpl ( HttpServletRequest req , Map map ) { super ( req , map ) ; currentRealm = ( String ) map . get ( AMAdminConstants . CURRENT_REALM ) ; if ( currentRealm == null ) { currentRealm = STRING ; } }
private static void add2 ( Collection < String > src , String line ) { src . add ( TAB2 + line ) ; }
public byte [ ] toByteArray ( ) { byte b [ ] = new byte [ _NUM ] ; ByteBuffer bb = ByteBuffer . wrap ( b ) ; bb . putInt ( _time ) ; bb . putInt ( _machine ) ; bb . putInt ( _inc ) ; return b ; }
public char read ( ) { if ( pos >= length ) { throw new StringIndexOutOfBoundsException ( ) ; } return source . charAt ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new StringIndexOutOfBoundsException ( ) ; } return source . charAt ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new StringIndexOutOfBoundsException ( ) ; } return source . charAt ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new StringIndexOutOfBoundsException ( ) ; } return source . charAt ( pos ++ ) ; }
public char read ( ) { if ( pos >= length ) { throw new StringIndexOutOfBoundsException ( ) ; } return source . charAt ( pos ++ ) ; }
public static boolean isCallerValid ( String className ) { if ( ! checkCaller ) { return ( _BOOL ) ; } String parentClass = getParentClass ( className ) ; for ( int i = _NUM ; i < VALID_PACKAGES . length ; i ++ ) { if ( parentClass . startsWith ( VALID_PACKAGES [ i ] ) ) { return ( _BOOL ) ; } } for ( int i = _NUM ; i < VALID_CLASSES . length ; i ++ ) { if ( parentClass . equals ( VALID_CLASSES [ i ] ) ) { return ( _BOOL ) ; } } return ( _BOOL ) ; }
public static boolean isCallerValid ( String className ) { if ( ! checkCaller ) { return ( _BOOL ) ; } String parentClass = getParentClass ( className ) ; for ( int i = _NUM ; i < VALID_PACKAGES . length ; i ++ ) { if ( parentClass . startsWith ( VALID_PACKAGES [ i ] ) ) { return ( _BOOL ) ; } } for ( int i = _NUM ; i < VALID_CLASSES . length ; i ++ ) { if ( parentClass . equals ( VALID_CLASSES [ i ] ) ) { return ( _BOOL ) ; } } return ( _BOOL ) ; }
public static boolean isCallerValid ( String className ) { if ( ! checkCaller ) { return ( _BOOL ) ; } String parentClass = getParentClass ( className ) ; for ( int i = _NUM ; i < VALID_PACKAGES . length ; i ++ ) { if ( parentClass . startsWith ( VALID_PACKAGES [ i ] ) ) { return ( _BOOL ) ; } } for ( int i = _NUM ; i < VALID_CLASSES . length ; i ++ ) { if ( parentClass . equals ( VALID_CLASSES [ i ] ) ) { return ( _BOOL ) ; } } return ( _BOOL ) ; }
public static boolean isCallerValid ( String className ) { if ( ! checkCaller ) { return ( _BOOL ) ; } String parentClass = getParentClass ( className ) ; for ( int i = _NUM ; i < VALID_PACKAGES . length ; i ++ ) { if ( parentClass . startsWith ( VALID_PACKAGES [ i ] ) ) { return ( _BOOL ) ; } } for ( int i = _NUM ; i < VALID_CLASSES . length ; i ++ ) { if ( parentClass . equals ( VALID_CLASSES [ i ] ) ) { return ( _BOOL ) ; } } return ( _BOOL ) ; }
public void testCase6 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = - _NUM ; int bSign = _NUM ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
private Object readNewLongString ( boolean unshared ) throws IOException { long length = input . readLong ( ) ; Object result = input . decodeUTF ( ( int ) length ) ; if ( enableResolve ) { result = resolveObject ( result ) ; } registerObjectRead ( result , nextHandle ( ) , unshared ) ; return result ; }
@ Override public AudioInputStream synthesiseOneSection ( String festivalUtt , Voice voice ) throws IOException { writeRelationFiles ( festivalUtt ) ; File audioFile = new File ( festivalDir . getPath ( ) + File . separator + STRING ) ; String festivalVoiceCmd = STRING + voice . getName ( ) + STRING ; AudioInputStream sound = festivalSynthesise ( audioFile , festivalVoiceCmd ) ; return sound ; }
public String writeDataFile ( ) throws DataFileException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; writeDataFile ( bos ) ; String outString = bos . toString ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( IOException e ) { Debug . logWarning ( e , module ) ; } return outString ; }
public String writeDataFile ( ) throws DataFileException { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; writeDataFile ( bos ) ; String outString = bos . toString ( ) ; try { if ( bos != null ) bos . close ( ) ; } catch ( IOException e ) { Debug . logWarning ( e , module ) ; } return outString ; }
@ SafeVarargs public final Token < TokenType > expect ( TokenType ... expected ) throws SimpleParserException { if ( hasType ( expected ) ) return this ; throw new SimpleParserException ( line , column , STRING + Arrays . toString ( expected ) + STRING + toString ( ) ) ; }
@ SafeVarargs public final Token < TokenType > expect ( TokenType ... expected ) throws SimpleParserException { if ( hasType ( expected ) ) return this ; throw new SimpleParserException ( line , column , STRING + Arrays . toString ( expected ) + STRING + toString ( ) ) ; }
public boolean authenticate ( final OddCallback < AuthToken > callback ) { synchronized ( syncLock ) { if ( isExpired ( ) ) { return _BOOL ; } if ( ! authenticating ) { authenticating = _BOOL ; timer = new Timer ( ) ; TimerTask task = getPollTask ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; TimerTask expiredTask = getExpiredTask ( callback ) ; timer . schedule ( expiredTask , expirationDate ) ; } return _BOOL ; } }
public boolean authenticate ( final OddCallback < AuthToken > callback ) { synchronized ( syncLock ) { if ( isExpired ( ) ) { return _BOOL ; } if ( ! authenticating ) { authenticating = _BOOL ; timer = new Timer ( ) ; TimerTask task = getPollTask ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; TimerTask expiredTask = getExpiredTask ( callback ) ; timer . schedule ( expiredTask , expirationDate ) ; } return _BOOL ; } }
public boolean authenticate ( final OddCallback < AuthToken > callback ) { synchronized ( syncLock ) { if ( isExpired ( ) ) { return _BOOL ; } if ( ! authenticating ) { authenticating = _BOOL ; timer = new Timer ( ) ; TimerTask task = getPollTask ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; TimerTask expiredTask = getExpiredTask ( callback ) ; timer . schedule ( expiredTask , expirationDate ) ; } return _BOOL ; } }
public boolean authenticate ( final OddCallback < AuthToken > callback ) { synchronized ( syncLock ) { if ( isExpired ( ) ) { return _BOOL ; } if ( ! authenticating ) { authenticating = _BOOL ; timer = new Timer ( ) ; TimerTask task = getPollTask ( callback ) ; timer . schedule ( task , new Date ( ) , interval ) ; TimerTask expiredTask = getExpiredTask ( callback ) ; timer . schedule ( expiredTask , expirationDate ) ; } return _BOOL ; } }
public static int convertToColorInt ( String argb ) throws NumberFormatException { if ( argb . startsWith ( STRING ) ) { argb = argb . replace ( STRING , STRING ) ; } int alpha = - _NUM , red = - _NUM , green = - _NUM , blue = - _NUM ; if ( argb . length ( ) == _NUM ) { alpha = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; red = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; green = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; blue = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; } else if ( argb . length ( ) == _NUM ) { alpha = _NUM ; red = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; green = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; blue = Integer . parseInt ( argb . substring ( _NUM , _NUM ) , _NUM ) ; } return Color . argb ( alpha , red , green , blue ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . getInstance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY_OF_MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . getInstance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY_OF_MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public static String timestamp ( ) { Calendar calendar = Calendar . getInstance ( ) ; return STRING + calendar . get ( Calendar . YEAR ) + calendar . get ( Calendar . MONTH ) + calendar . get ( Calendar . DAY_OF_MONTH ) + calendar . get ( Calendar . HOUR ) + calendar . get ( Calendar . MINUTE ) + calendar . get ( Calendar . SECOND ) ; }
public double localScore ( int i ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i ) ; } return sum / scores . size ( ) ; }
public double localScore ( int i ) { double sum = _NUM ; for ( BDeuScore score : scores ) { sum += score . localScore ( i ) ; } return sum / scores . size ( ) ; }
protected boolean isRelevant ( String term ) { return term . length ( ) >= _NUM && matches ( characterPattern , term ) ; }
protected boolean isRelevant ( String term ) { return term . length ( ) >= _NUM && matches ( characterPattern , term ) ; }
protected boolean isRelevant ( String term ) { return term . length ( ) >= _NUM && matches ( characterPattern , term ) ; }
public void putString ( String s ) { ensureCapacity ( ( s . length ( ) * _NUM ) + _NUM ) ; System . arraycopy ( s . getBytes ( ) , _NUM , this . byteBuffer , this . position , s . length ( ) ) ; this . position += s . length ( ) ; this . byteBuffer [ this . position ++ ] = _NUM ; }
protected void selectPreviousPossibleValue ( ) { int si = listBox . getSelectedIndex ( ) ; if ( si > _NUM ) { listBox . setSelectedIndex ( si - _NUM ) ; listBox . ensureIndexIsVisible ( si - _NUM ) ; } }
protected void selectPreviousPossibleValue ( ) { int si = listBox . getSelectedIndex ( ) ; if ( si > _NUM ) { listBox . setSelectedIndex ( si - _NUM ) ; listBox . ensureIndexIsVisible ( si - _NUM ) ; } }
protected void selectPreviousPossibleValue ( ) { int si = listBox . getSelectedIndex ( ) ; if ( si > _NUM ) { listBox . setSelectedIndex ( si - _NUM ) ; listBox . ensureIndexIsVisible ( si - _NUM ) ; } }
protected void selectPreviousPossibleValue ( ) { int si = listBox . getSelectedIndex ( ) ; if ( si > _NUM ) { listBox . setSelectedIndex ( si - _NUM ) ; listBox . ensureIndexIsVisible ( si - _NUM ) ; } }
private void makeMultiTraversal ( ) { Optional < String > roleA = roletypes . get ( _NUM ) ; String playerA = roleplayers . get ( _NUM ) ; Optional < String > roleB = roletypes . get ( _NUM ) ; String playerB = roleplayers . get ( _NUM ) ; multiTraversal = MultiTraversal . create ( new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerA , playerB ) , new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerB , playerA ) ) ; }
private void makeMultiTraversal ( ) { Optional < String > roleA = roletypes . get ( _NUM ) ; String playerA = roleplayers . get ( _NUM ) ; Optional < String > roleB = roletypes . get ( _NUM ) ; String playerB = roleplayers . get ( _NUM ) ; multiTraversal = MultiTraversal . create ( new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerA , playerB ) , new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerB , playerA ) ) ; }
private void makeMultiTraversal ( ) { Optional < String > roleA = roletypes . get ( _NUM ) ; String playerA = roleplayers . get ( _NUM ) ; Optional < String > roleB = roletypes . get ( _NUM ) ; String playerB = roleplayers . get ( _NUM ) ; multiTraversal = MultiTraversal . create ( new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerA , playerB ) , new FragmentImpl ( null , FragmentPriority . EDGE_RELATION , playerB , playerA ) ) ; }
private static void addJdbcFields ( Document doc , Node parent , String name , Collection < PojoField > fields ) { if ( ! fields . isEmpty ( ) ) { Element prop = addProperty ( doc , parent , name , null ) ; Element list = addElement ( doc , prop , STRING ) ; for ( PojoField field : fields ) { Element item = addBean ( doc , list , JdbcTypeField . class ) ; Element dbType = addProperty ( doc , item , STRING , null ) ; addElement ( doc , dbType , STRING , STRING , STRING + field . dbTypeName ( ) ) ; addProperty ( doc , item , STRING , field . dbName ( ) ) ; addProperty ( doc , item , STRING , field . javaTypeName ( ) ) ; addProperty ( doc , item , STRING , field . javaName ( ) ) ; } } }
public String generateUniqueName ( String name , boolean addName ) { while ( mUsedNames . containsKey ( name . toLowerCase ( ) ) ) { Matcher matcher = mRegEx . matcher ( name ) ; if ( matcher . matches ( ) ) { name = matcher . group ( _NUM ) + ( Integer . parseInt ( matcher . group ( _NUM ) ) + _NUM ) ; } else { name = name + STRING ; } } if ( addName ) { mUsedNames . put ( name . toLowerCase ( ) , STRING ) ; notifyChanged ( ) ; } return name . toLowerCase ( ) ; }
protected void computeParameters ( ) { if ( m_SumOfWeights > _NUM ) { m_Mean = m_SumOfValues / m_SumOfWeights ; double stdDev = Math . sqrt ( Math . abs ( m_SumOfValuesSq - m_Mean * m_SumOfValues ) / m_SumOfWeights ) ; if ( stdDev > _NUM ) { m_StandardDev = Math . max ( m_Precision / ( _NUM * _NUM ) , stdDev ) ; } } }
final public MutableString toUpperCase ( ) { int n = length ( ) ; final char [ ] a = array ; while ( n -- != _NUM ) a [ n ] = Character . toUpperCase ( a [ n ] ) ; changed ( ) ; return this ; }
public void addActionListener ( ActionListener newListener ) { m_listeners . add ( newListener ) ; }
private void markerWithColoredIcon ( GoogleMap googleMap , LatLng latLng , String publicId , String hexColor ) { MarkerOptions options = new MarkerOptions ( ) ; options . position ( latLng ) ; int color = Color . parseColor ( hexColor ) ; float [ ] hsv = new float [ _NUM ] ; Color . colorToHSV ( color , hsv ) ; float hue = hsv [ _NUM ] ; options . icon ( BitmapDescriptorFactory . defaultMarker ( hue ) ) ; Marker marker = googleMap . addMarker ( options ) ; publicMarkerIds . put ( marker . getId ( ) , publicId ) ; }
private void markerWithColoredIcon ( GoogleMap googleMap , LatLng latLng , String publicId , String hexColor ) { MarkerOptions options = new MarkerOptions ( ) ; options . position ( latLng ) ; int color = Color . parseColor ( hexColor ) ; float [ ] hsv = new float [ _NUM ] ; Color . colorToHSV ( color , hsv ) ; float hue = hsv [ _NUM ] ; options . icon ( BitmapDescriptorFactory . defaultMarker ( hue ) ) ; Marker marker = googleMap . addMarker ( options ) ; publicMarkerIds . put ( marker . getId ( ) , publicId ) ; }
public DefaultHeatMapDataset ( int xSamples , int ySamples , double minX , double maxX , double minY , double maxY ) { if ( xSamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ySamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minX ) || Double . isNaN ( minX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxX ) || Double . isNaN ( maxX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minY ) || Double . isNaN ( minY ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxY ) || Double . isNaN ( maxY ) ) { throw new IllegalArgumentException ( STRING ) ; } this . xSamples = xSamples ; this . ySamples = ySamples ; this . minX = minX ; this . maxX = maxX ; this . minY = minY ; this . maxY = maxY ; this . zValues = new double [ xSamples ] [ ] ; for ( int x = _NUM ; x < xSamples ; x ++ ) { this . zValues [ x ] = new double [ ySamples ] ; } }
public DefaultHeatMapDataset ( int xSamples , int ySamples , double minX , double maxX , double minY , double maxY ) { if ( xSamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ySamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minX ) || Double . isNaN ( minX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxX ) || Double . isNaN ( maxX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minY ) || Double . isNaN ( minY ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxY ) || Double . isNaN ( maxY ) ) { throw new IllegalArgumentException ( STRING ) ; } this . xSamples = xSamples ; this . ySamples = ySamples ; this . minX = minX ; this . maxX = maxX ; this . minY = minY ; this . maxY = maxY ; this . zValues = new double [ xSamples ] [ ] ; for ( int x = _NUM ; x < xSamples ; x ++ ) { this . zValues [ x ] = new double [ ySamples ] ; } }
public DefaultHeatMapDataset ( int xSamples , int ySamples , double minX , double maxX , double minY , double maxY ) { if ( xSamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ySamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minX ) || Double . isNaN ( minX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxX ) || Double . isNaN ( maxX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minY ) || Double . isNaN ( minY ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxY ) || Double . isNaN ( maxY ) ) { throw new IllegalArgumentException ( STRING ) ; } this . xSamples = xSamples ; this . ySamples = ySamples ; this . minX = minX ; this . maxX = maxX ; this . minY = minY ; this . maxY = maxY ; this . zValues = new double [ xSamples ] [ ] ; for ( int x = _NUM ; x < xSamples ; x ++ ) { this . zValues [ x ] = new double [ ySamples ] ; } }
public DefaultHeatMapDataset ( int xSamples , int ySamples , double minX , double maxX , double minY , double maxY ) { if ( xSamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( ySamples < _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minX ) || Double . isNaN ( minX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxX ) || Double . isNaN ( maxX ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( minY ) || Double . isNaN ( minY ) ) { throw new IllegalArgumentException ( STRING ) ; } if ( Double . isInfinite ( maxY ) || Double . isNaN ( maxY ) ) { throw new IllegalArgumentException ( STRING ) ; } this . xSamples = xSamples ; this . ySamples = ySamples ; this . minX = minX ; this . maxX = maxX ; this . minY = minY ; this . maxY = maxY ; this . zValues = new double [ xSamples ] [ ] ; for ( int x = _NUM ; x < xSamples ; x ++ ) { this . zValues [ x ] = new double [ ySamples ] ; } }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
private synchronized void addLock ( FileLock lock ) throws OverlappingFileLockException { long lockEnd = lock . position ( ) + lock . size ( ) ; for ( FileLock existingLock : locks ) { if ( existingLock . position ( ) > lockEnd ) { break ; } if ( existingLock . overlaps ( lock . position ( ) , lock . size ( ) ) ) { throw new OverlappingFileLockException ( ) ; } } locks . add ( lock ) ; }
void releaseObject ( long object , boolean dissociate ) { if ( dissociate ) { try { portDissociate ( port , PORT_SOURCE_FILE , object ) ; } catch ( UnixException x ) { } } long name = unsafe . getAddress ( object + OFFSET_FO_NAME ) ; unsafe . freeMemory ( name ) ; unsafe . freeMemory ( object ) ; }
public static String subString ( String string , int beginIndex , int length ) { if ( string == null ) { return null ; } final int endIndex = beginIndex + length ; if ( beginIndex >= string . length ( ) ) { return EMPTY ; } if ( endIndex > string . length ( ) ) { return string . substring ( beginIndex , string . length ( ) ) ; } return string . substring ( beginIndex , endIndex ) ; }
public static int copy ( InputStream in , OutputStream out ) throws IOException { Assert . notNull ( in , STRING ) ; Assert . notNull ( out , STRING ) ; int byteCount = _NUM ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead = - _NUM ; while ( ( bytesRead = in . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , bytesRead ) ; byteCount += bytesRead ; } out . flush ( ) ; return byteCount ; }
public static int copy ( InputStream in , OutputStream out ) throws IOException { Assert . notNull ( in , STRING ) ; Assert . notNull ( out , STRING ) ; int byteCount = _NUM ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead = - _NUM ; while ( ( bytesRead = in . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , bytesRead ) ; byteCount += bytesRead ; } out . flush ( ) ; return byteCount ; }
public static int copy ( InputStream in , OutputStream out ) throws IOException { Assert . notNull ( in , STRING ) ; Assert . notNull ( out , STRING ) ; int byteCount = _NUM ; byte [ ] buffer = new byte [ BUFFER_SIZE ] ; int bytesRead = - _NUM ; while ( ( bytesRead = in . read ( buffer ) ) != - _NUM ) { out . write ( buffer , _NUM , bytesRead ) ; byteCount += bytesRead ; } out . flush ( ) ; return byteCount ; }
public Host createHost ( String name , File appBase ) { return new Host ( invoke ( embeddedCreateHost , name , appBase . getAbsolutePath ( ) ) ) ; }
protected String checkHeap ( ) { if ( comparator == null ) { for ( int i = _NUM ; i < size ; i ++ ) { final int parent = ( i - _NUM ) > > > _NUM ; @ SuppressWarnings ( STRING ) Comparable < Object > po = ( Comparable < Object > ) queue [ parent ] ; if ( po . compareTo ( queue [ i ] ) > _NUM ) { return STRING + parent + STRING + queue [ parent ] + STRING + i + STRING + queue [ i ] ; } } } else { for ( int i = _NUM ; i < size ; i ++ ) { final int parent = ( i - _NUM ) > > > _NUM ; if ( comparator . compare ( queue [ parent ] , queue [ i ] ) > _NUM ) { return STRING + parent + STRING + queue [ parent ] + STRING + i + STRING + queue [ i ] ; } } } return null ; }
@ Override public void run ( ) { try { handleAlarm ( ) ; } catch ( Throwable e ) { log . log ( Level . WARNING , e . toString ( ) , e ) ; } finally { _isRunning = _BOOL ; _runningAlarmCount . decrementAndGet ( ) ; } }
public Builder addInCollectionItemClause ( String collectionFieldName , Collection < String > itemNames ) { String collectionItemFieldName = QuerySpecification . buildCollectionItemName ( collectionFieldName ) ; return addInClause ( collectionItemFieldName , itemNames ) ; }
public Builder addInCollectionItemClause ( String collectionFieldName , Collection < String > itemNames ) { String collectionItemFieldName = QuerySpecification . buildCollectionItemName ( collectionFieldName ) ; return addInClause ( collectionItemFieldName , itemNames ) ; }
public Set < Long > keySet ( ) { HashSet < Long > set = new HashSet < Long > ( ) ; for ( Segment < V > s : segments ) { set . addAll ( s . keySet ( ) ) ; } return set ; }
public static void stop ( String [ ] args ) { LOG . info ( STRING ) ; System . exit ( _NUM ) ; }
public static void toString ( Iterator < ? > iter , String separator , StringBuilder sb ) { while ( iter . hasNext ( ) ) { sb . append ( iter . next ( ) ) ; if ( iter . hasNext ( ) ) { sb . append ( separator ) ; } } }
public boolean isBufferResultSetToLocalTemp ( ) { return bufferResultSetToLocalTemp ; }
public boolean isBufferResultSetToLocalTemp ( ) { return bufferResultSetToLocalTemp ; }
protected void createUserDictSettings ( PreferenceGroup userDictGroup ) { final Activity activity = getActivity ( ) ; userDictGroup . removeAll ( ) ; final TreeSet < String > localeList = UserDictionaryList . getUserDictionaryLocalesSet ( activity ) ; if ( localeList . isEmpty ( ) ) { userDictGroup . addPreference ( createUserDictionaryPreference ( null , activity ) ) ; } else { for ( String locale : localeList ) { userDictGroup . addPreference ( createUserDictionaryPreference ( locale , activity ) ) ; } } }
protected void createUserDictSettings ( PreferenceGroup userDictGroup ) { final Activity activity = getActivity ( ) ; userDictGroup . removeAll ( ) ; final TreeSet < String > localeList = UserDictionaryList . getUserDictionaryLocalesSet ( activity ) ; if ( localeList . isEmpty ( ) ) { userDictGroup . addPreference ( createUserDictionaryPreference ( null , activity ) ) ; } else { for ( String locale : localeList ) { userDictGroup . addPreference ( createUserDictionaryPreference ( locale , activity ) ) ; } } }
protected void createUserDictSettings ( PreferenceGroup userDictGroup ) { final Activity activity = getActivity ( ) ; userDictGroup . removeAll ( ) ; final TreeSet < String > localeList = UserDictionaryList . getUserDictionaryLocalesSet ( activity ) ; if ( localeList . isEmpty ( ) ) { userDictGroup . addPreference ( createUserDictionaryPreference ( null , activity ) ) ; } else { for ( String locale : localeList ) { userDictGroup . addPreference ( createUserDictionaryPreference ( locale , activity ) ) ; } } }
private static boolean addToEvaluator ( ArrayDeque < FilterValueSetParam > remainingParameters , FilterHandle filterCallback , EventEvaluator eventEvaluator , ArrayDeque < EventTypeIndexBuilderIndexLookupablePair > treePathInfo , FilterServiceGranularLockFactory lockFactory ) { if ( eventEvaluator instanceof FilterHandleSetNode ) { FilterHandleSetNode node = ( FilterHandleSetNode ) eventEvaluator ; addToNode ( remainingParameters , filterCallback , node , treePathInfo , lockFactory ) ; return _BOOL ; } FilterParamIndexBase nextIndex = ( FilterParamIndexBase ) eventEvaluator ; FilterValueSetParam parameter = IndexHelper . findParameter ( remainingParameters , nextIndex ) ; if ( parameter != null ) { remainingParameters . remove ( parameter ) ; treePathInfo . add ( new EventTypeIndexBuilderIndexLookupablePair ( nextIndex , parameter . getFilterForValue ( ) ) ) ; addToIndex ( remainingParameters , filterCallback , nextIndex , parameter . getFilterForValue ( ) , treePathInfo , lockFactory ) ; return _BOOL ; } return _BOOL ; }
public Cookie ( final String domain , final String name , final String value , final String path , final int maxAge , final boolean secure ) { this ( domain , name , value , path , null , secure ) ; if ( maxAge < - _NUM ) { throw new IllegalArgumentException ( STRING + Integer . toString ( maxAge ) ) ; } if ( maxAge >= _NUM ) { setExpiryDate ( new Date ( System . currentTimeMillis ( ) + maxAge * _NUM ) ) ; } }
public List < JsonObject > executeParametrizedStatement ( String statement , List < String > parameterNames , List < Object > parameterValues ) { JsonObject namedParams = JsonObject . create ( ) ; for ( int param = _NUM ; param < parameterNames . size ( ) ; param ++ ) { namedParams . put ( parameterNames . get ( param ) , parameterValues . get ( param ) ) ; } ParameterizedN1qlQuery query = N1qlQuery . parameterized ( statement , namedParams ) ; return executeQuery ( query ) ; }
public static String grepMinusV ( String val , String pattern ) { return grepInner ( val , pattern , _BOOL ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; if ( policy == null ) { throw new InvalidObjectException ( STRING ) ; } if ( classpath == null ) { throw new InvalidObjectException ( STRING ) ; } if ( log == null ) { throw new InvalidObjectException ( STRING ) ; } if ( serverOptions == null ) { throw new InvalidObjectException ( STRING ) ; } if ( serverProperties == null ) { throw new InvalidObjectException ( STRING ) ; } if ( host == null ) { throw new InvalidObjectException ( STRING ) ; } if ( port <= _NUM ) { throw new InvalidObjectException ( STRING + port ) ; } }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
long purge ( final int sampleSize ) { final int limit = Math . min ( sampleSize , getNumActive ( ) ) ; int numSamples = _NUM ; int i = _NUM ; final long [ ] samples = new long [ limit ] ; while ( numSamples < limit ) { if ( isActive ( i ) ) { samples [ numSamples ] = values [ i ] ; numSamples ++ ; } i ++ ; } final long val = QuickSelect . select ( samples , _NUM , numSamples - _NUM , limit / _NUM ) ; adjustAllValuesBy ( - _NUM * val ) ; keepOnlyPositiveCounts ( ) ; return val ; }
abstract public PathImpl schemeWalk ( String userPath , Map < String , Object > newAttributes , String newPath , int offset ) ;
OFChannelHandler ( @ Nonnull IOFSwitchManager switchManager , @ Nonnull INewOFConnectionListener newConnectionListener , @ Nonnull ChannelPipeline pipeline , @ Nonnull IDebugCounterService debugCounters , @ Nonnull Timer timer ) { Preconditions . checkNotNull ( switchManager , STRING ) ; Preconditions . checkNotNull ( newConnectionListener , STRING ) ; Preconditions . checkNotNull ( pipeline , STRING ) ; Preconditions . checkNotNull ( timer , STRING ) ; Preconditions . checkNotNull ( debugCounters , STRING ) ; this . pipeline = pipeline ; this . debugCounters = debugCounters ; this . newConnectionListener = newConnectionListener ; this . counters = switchManager . getCounters ( ) ; this . state = new InitState ( ) ; this . timer = timer ; log . debug ( STRING , String . format ( STRING , System . identityHashCode ( this ) ) ) ; }
public long objectFieldOffset ( Field field ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } return objectFieldOffset0 ( field ) ; }
public long objectFieldOffset ( Field field ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } return objectFieldOffset0 ( field ) ; }
public long objectFieldOffset ( Field field ) { if ( Modifier . isStatic ( field . getModifiers ( ) ) ) { throw new IllegalArgumentException ( STRING ) ; } return objectFieldOffset0 ( field ) ; }
public void notify_app_updated ( String package_name ) { InstalledApp app = InstalledApp . find_app ( package_name ) ; if ( app == null ) { return ; } final int pos = _installed_apps . indexOf ( app ) ; if ( pos != - _NUM ) { _installed_apps . remove ( pos ) ; _installed_apps . add ( pos , app ) ; notifyItemChanged ( pos ) ; } if ( app . is_update_available ( ) && ! app . has_notified ( ) ) { app . set_has_notified ( _BOOL ) ; app . save ( ) ; } }
public void notify_app_updated ( String package_name ) { InstalledApp app = InstalledApp . find_app ( package_name ) ; if ( app == null ) { return ; } final int pos = _installed_apps . indexOf ( app ) ; if ( pos != - _NUM ) { _installed_apps . remove ( pos ) ; _installed_apps . add ( pos , app ) ; notifyItemChanged ( pos ) ; } if ( app . is_update_available ( ) && ! app . has_notified ( ) ) { app . set_has_notified ( _BOOL ) ; app . save ( ) ; } }
protected void engineUpdate ( byte b ) throws SignatureException { messageDigest . update ( b ) ; needsReset = _BOOL ; }
public void addStrategicTarget ( String target ) { if ( StringUtil . isNullOrEmpty ( target ) ) { return ; } strategicBuildingTargets . add ( target ) ; }
public void addStrategicTarget ( String target ) { if ( StringUtil . isNullOrEmpty ( target ) ) { return ; } strategicBuildingTargets . add ( target ) ; }
public void addStrategicTarget ( String target ) { if ( StringUtil . isNullOrEmpty ( target ) ) { return ; } strategicBuildingTargets . add ( target ) ; }
public void endDrawing ( GL10 gl ) { gl . glDisable ( GL10 . GL_ALPHA_TEST ) ; gl . glMatrixMode ( GL10 . GL_PROJECTION ) ; gl . glPopMatrix ( ) ; gl . glMatrixMode ( GL10 . GL_MODELVIEW ) ; gl . glPopMatrix ( ) ; gl . glDisable ( GL10 . GL_TEXTURE_2D ) ; gl . glColor4x ( FixedPoint . ONE , FixedPoint . ONE , FixedPoint . ONE , FixedPoint . ONE ) ; }
private void Legends ( List < String > legends_list , List < Integer > color_code_list ) { textPaint . setColor ( Color . BLACK ) ; textPaint . setTextSize ( _NUM ) ; int left = ( int ) ( graphwidth * _NUM ) ; for ( int i = _NUM ; i < legends_list . size ( ) ; i ++ ) { String label = legends_list . get ( i ) ; float text_width = textPaint . measureText ( label , _NUM , label . length ( ) ) ; int color = color_code_list . get ( i ) ; if ( ! ( ( graphwidth - legendLeft ) > ( text_width + _NUM ) ) ) { legendTop -= _NUM ; legendLeft = left ; } addLegends ( canvas , color , legendTop , legendLeft , legendRight , legendBottom , label ) ; legendLeft += ( ( int ) text_width + _NUM ) ; } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { String tid = getThreadMapping ( ) ; out . writeObject ( tid ) ; out . writeObject ( this . userTransactionServerLookupName ) ; out . writeObject ( this . initialContextFactory ) ; out . writeObject ( this . providerUrl ) ; out . writeInt ( this . timeout ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { String tid = getThreadMapping ( ) ; out . writeObject ( tid ) ; out . writeObject ( this . userTransactionServerLookupName ) ; out . writeObject ( this . initialContextFactory ) ; out . writeObject ( this . providerUrl ) ; out . writeInt ( this . timeout ) ; }
public boolean isValidNumber ( PhoneNumber number ) { String regionCode = getRegionCodeForNumber ( number ) ; return isValidNumberForRegion ( number , regionCode ) ; }
public boolean isValidNumber ( PhoneNumber number ) { String regionCode = getRegionCodeForNumber ( number ) ; return isValidNumberForRegion ( number , regionCode ) ; }
private AsciiImgCache ( final Dimension characterImageSize , final Map < Character , GrayscaleMatrix > imageCache , final char [ ] characters ) { this . characterImageSize = characterImageSize ; this . imageCache = imageCache ; }
protected void collectSuperTypeNames ( ReferenceBinding binding , char [ ] [ ] path ) { ReferenceBinding superclass = binding . superclass ( ) ; if ( path != null && superclass != null ) { boolean samePackage = addIfSamePackage ( superclass . compoundName , path ) ; if ( ! samePackage ) path = null ; } if ( superclass != null ) { addToResult ( superclass . compoundName ) ; collectSuperTypeNames ( superclass , path ) ; } ReferenceBinding [ ] interfaces = binding . superInterfaces ( ) ; if ( interfaces != null ) { for ( int i = _NUM ; i < interfaces . length ; i ++ ) { ReferenceBinding interfaceBinding = interfaces [ i ] ; addToResult ( interfaceBinding . compoundName ) ; collectSuperTypeNames ( interfaceBinding , path ) ; } } }
public NoteComment ( Note note , String text , String nickname , int uid , String action , Date timestamp ) { this . note = note ; this . text = text . replaceAll ( STRING , STRING ) ; this . nickname = nickname . replaceAll ( STRING , STRING ) ; this . uid = uid ; this . action = action ; this . timestamp = timestamp ; }
@ Override public boolean lock ( ) { try { if ( ! FileFactory . isFileExist ( location , FileFactory . getFileType ( tmpPath ) ) ) { FileFactory . mkdirs ( location , FileFactory . getFileType ( tmpPath ) ) ; } String lockFilePath = location + CarbonCommonConstants . FILE_SEPARATOR + lockFile ; if ( ! FileFactory . isFileExist ( lockFilePath , FileFactory . getFileType ( location ) ) ) { FileFactory . createNewLockFile ( lockFilePath , FileFactory . getFileType ( location ) ) ; } fileOutputStream = new FileOutputStream ( lockFilePath ) ; channel = fileOutputStream . getChannel ( ) ; try { fileLock = channel . tryLock ( ) ; } catch ( OverlappingFileLockException e ) { return _BOOL ; } if ( null != fileLock ) { return _BOOL ; } else { return _BOOL ; } } catch ( IOException e ) { return _BOOL ; } }
static int resizeStamp ( int n ) { return Integer . numberOfLeadingZeros ( n ) | ( _NUM << ( RESIZE_STAMP_BITS - _NUM ) ) ; }
public static void writeShort ( DataOutput out , short v ) throws IOException { out . writeByte ( ( _NUM & v ) ) ; out . writeByte ( ( _NUM & ( v > > > _NUM ) ) ) ; }
@ Override protected void tearDown ( ) throws Exception { try { takeScreenShot ( ) ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } super . tearDown ( ) ; }
@ Override protected void tearDown ( ) throws Exception { try { takeScreenShot ( ) ; } catch ( Throwable throwable ) { throwable . printStackTrace ( ) ; } super . tearDown ( ) ; }
public DTEDLocator ( ) { super ( ) ; if ( logger . isLoggable ( Level . FINE ) ) { DEBUG = _BOOL ; } setCallback ( this ) ; }
public DTEDLocator ( ) { super ( ) ; if ( logger . isLoggable ( Level . FINE ) ) { DEBUG = _BOOL ; } setCallback ( this ) ; }
public DTEDLocator ( ) { super ( ) ; if ( logger . isLoggable ( Level . FINE ) ) { DEBUG = _BOOL ; } setCallback ( this ) ; }
@ Override public void characters ( char [ ] chars , int start , int length ) throws SAXException { elementText . append ( chars , start , length ) ; }
public static long persianToJulian ( long year , int month , int day ) { return _NUM * ( ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) + ( ( long ) Math . floor ( ( _NUM * ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) / _NUM ) ) + ( PersianCalendarConstants . PERSIAN_EPOCH - _NUM ) + _NUM * ( ( long ) Math . floor ( ( year - _NUM ) / _NUM ) ) + ( month < _NUM ? _NUM * month : _NUM * month + _NUM ) + day ; }
public static long persianToJulian ( long year , int month , int day ) { return _NUM * ( ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) + ( ( long ) Math . floor ( ( _NUM * ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) / _NUM ) ) + ( PersianCalendarConstants . PERSIAN_EPOCH - _NUM ) + _NUM * ( ( long ) Math . floor ( ( year - _NUM ) / _NUM ) ) + ( month < _NUM ? _NUM * month : _NUM * month + _NUM ) + day ; }
public static long persianToJulian ( long year , int month , int day ) { return _NUM * ( ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) + ( ( long ) Math . floor ( ( _NUM * ( ceil ( year - _NUM , _NUM ) + _NUM ) - _NUM ) / _NUM ) ) + ( PersianCalendarConstants . PERSIAN_EPOCH - _NUM ) + _NUM * ( ( long ) Math . floor ( ( year - _NUM ) / _NUM ) ) + ( month < _NUM ? _NUM * month : _NUM * month + _NUM ) + day ; }
private void ensureCapacity ( int desiredLongCount ) { if ( desiredLongCount <= bits . length ) { return ; } int newLength = Math . max ( desiredLongCount , bits . length * _NUM ) ; long [ ] newBits = new long [ newLength ] ; System . arraycopy ( bits , _NUM , newBits , _NUM , longCount ) ; this . bits = newBits ; }
private void ensureCapacity ( int desiredLongCount ) { if ( desiredLongCount <= bits . length ) { return ; } int newLength = Math . max ( desiredLongCount , bits . length * _NUM ) ; long [ ] newBits = new long [ newLength ] ; System . arraycopy ( bits , _NUM , newBits , _NUM , longCount ) ; this . bits = newBits ; }
public DocumentFragment parseFragment ( ) throws ParseException { return parseFragment ( makeDocument ( findDoctype ( ) , null , domImpl ) ) ; }
public DocumentFragment parseFragment ( ) throws ParseException { return parseFragment ( makeDocument ( findDoctype ( ) , null , domImpl ) ) ; }
public DocumentFragment parseFragment ( ) throws ParseException { return parseFragment ( makeDocument ( findDoctype ( ) , null , domImpl ) ) ; }
public DocumentFragment parseFragment ( ) throws ParseException { return parseFragment ( makeDocument ( findDoctype ( ) , null , domImpl ) ) ; }
public static int [ ] convertSelectionToModel ( JTable table ) { int [ ] selected = table . getSelectedRows ( ) ; for ( int i = _NUM ; i < selected . length ; i ++ ) { selected [ i ] = table . convertRowIndexToModel ( selected [ i ] ) ; } return selected ; }
public static int [ ] convertSelectionToModel ( JTable table ) { int [ ] selected = table . getSelectedRows ( ) ; for ( int i = _NUM ; i < selected . length ; i ++ ) { selected [ i ] = table . convertRowIndexToModel ( selected [ i ] ) ; } return selected ; }
@ Override public CompletableFuture < Boolean > allMatch ( final Predicate < ? super T > predicate ) { return CompletableFuture . supplyAsync ( null , exec ) ; }
public static String readFromStream ( InputStream is ) { InputStreamReader isr ; try { isr = new InputStreamReader ( is , STRING ) ; BufferedReader br = new BufferedReader ( isr ) ; StringBuilder sb = new StringBuilder ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { sb . append ( line ) ; sb . append ( STRING ) ; } br . close ( ) ; return sb . toString ( ) ; } catch ( UnsupportedEncodingException e ) { return null ; } catch ( IOException e ) { return null ; } }
protected static String escapeDot ( String identifierToEscape ) { int indexof = identifierToEscape . indexOf ( STRING ) ; if ( indexof == - _NUM ) { return identifierToEscape ; } StringBuilder builder = new StringBuilder ( ) ; for ( int i = _NUM ; i < identifierToEscape . length ( ) ; i ++ ) { char c = identifierToEscape . charAt ( i ) ; if ( c != STRING ) { builder . append ( c ) ; continue ; } if ( i > _NUM ) { if ( identifierToEscape . charAt ( i - _NUM ) == STRING ) { builder . append ( STRING ) ; continue ; } } builder . append ( STRING ) ; builder . append ( STRING ) ; } return builder . toString ( ) ; }
protected void finishAdding ( ) { noMoreAdding = _BOOL ; workSpace = null ; storageSpace = null ; wordCounts = null ; final int [ ] frqs = new int [ dimensionSize ] ; for ( int i = _NUM ; i < termDocumentFrequencys . length ( ) ; i ++ ) frqs [ i ] = termDocumentFrequencys . get ( i ) ; weighting . setWeight ( vectors , IntList . unmodifiableView ( frqs , dimensionSize ) ) ; for ( SparseVector vec : vectors ) weighting . applyTo ( vec ) ; termDocumentFrequencys = null ; }
protected void finishAdding ( ) { noMoreAdding = _BOOL ; workSpace = null ; storageSpace = null ; wordCounts = null ; final int [ ] frqs = new int [ dimensionSize ] ; for ( int i = _NUM ; i < termDocumentFrequencys . length ( ) ; i ++ ) frqs [ i ] = termDocumentFrequencys . get ( i ) ; weighting . setWeight ( vectors , IntList . unmodifiableView ( frqs , dimensionSize ) ) ; for ( SparseVector vec : vectors ) weighting . applyTo ( vec ) ; termDocumentFrequencys = null ; }
private List < String > readLines ( final BufferedReader reader ) throws IOException { final List < String > lines = new ArrayList < > ( ) ; String line ; for ( int lineNumber = _NUM ; ( line = reader . readLine ( ) ) != null ; lineNumber ++ ) { if ( line . startsWith ( STRING ) ) { final int lastLineIndex = lines . size ( ) - _NUM ; final String previousLine = lines . get ( lastLineIndex ) ; if ( lines . isEmpty ( ) || previousLine . isEmpty ( ) ) { throw DecodeException . fatalError ( ERR_TEMPLATE_FILE_INVALID_LEADING_SPACE . get ( lineNumber , line ) ) ; } lines . set ( lastLineIndex , previousLine + line . substring ( _NUM ) ) ; } else { lines . add ( line ) ; } } return lines ; }
public static String toHEXString ( String input ) { String hexTab = STRING ; StringBuilder output = new StringBuilder ( ) ; int x ; for ( int i = _NUM ; i < input . length ( ) ; i ++ ) { x = charCodeAt ( input , i ) ; output . append ( hexTab . charAt ( ( x > > > _NUM ) & _NUM ) ) ; output . append ( hexTab . charAt ( x & _NUM ) ) ; } return output . toString ( ) ; }
private static double parseDoubleValue ( String parseString , String openTag , String closeTag , DataTypeValidationException exception ) throws DataTypeValidationException { String tagValue ; tagValue = parseStringValue ( parseString , openTag , closeTag , exception ) ; double doubleValue ; try { doubleValue = Double . parseDouble ( tagValue ) ; } catch ( NumberFormatException e ) { throw e ; } return doubleValue ; }
private static double parseDoubleValue ( String parseString , String openTag , String closeTag , DataTypeValidationException exception ) throws DataTypeValidationException { String tagValue ; tagValue = parseStringValue ( parseString , openTag , closeTag , exception ) ; double doubleValue ; try { doubleValue = Double . parseDouble ( tagValue ) ; } catch ( NumberFormatException e ) { throw e ; } return doubleValue ; }
protected static List < PropertyValueExpression > toPropertyExpressions ( String ... properties ) { List < PropertyValueExpression > expr = new ArrayList < PropertyValueExpression > ( ) ; for ( String property : properties ) { expr . add ( getPropExpr ( property ) ) ; } return expr ; }
protected static List < PropertyValueExpression > toPropertyExpressions ( String ... properties ) { List < PropertyValueExpression > expr = new ArrayList < PropertyValueExpression > ( ) ; for ( String property : properties ) { expr . add ( getPropExpr ( property ) ) ; } return expr ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < UserDTO > > findAll ( @ RequestBody PageRequestByExample < UserDTO > prbe ) throws URISyntaxException { PageResponse < UserDTO > pageResponse = userDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < UserDTO > > findAll ( @ RequestBody PageRequestByExample < UserDTO > prbe ) throws URISyntaxException { PageResponse < UserDTO > pageResponse = userDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
@ RequestMapping ( value = STRING , method = POST , produces = APPLICATION_JSON_VALUE ) public ResponseEntity < PageResponse < UserDTO > > findAll ( @ RequestBody PageRequestByExample < UserDTO > prbe ) throws URISyntaxException { PageResponse < UserDTO > pageResponse = userDTOService . findAll ( prbe ) ; return new ResponseEntity < > ( pageResponse , new HttpHeaders ( ) , HttpStatus . OK ) ; }
public void addImageDownloadTask ( Runnable task ) { if ( imageDownloadExecutor == null || imageDownloadExecutor . isShutdown ( ) ) { imageDownloadExecutor = createImageDownloadExecutor ( ) ; } imageDownloadExecutor . execute ( task ) ; }
public static List < String > findBestTrailMatch ( List < List < String > > trails , List < String > matchTrail , boolean containFullTrail , boolean exact ) { List < String > best = null ; int partMatches = _NUM ; for ( List < String > candidateTrail : trails ) { int candidatePartMatches = _NUM ; Iterator < String > candidateIt = candidateTrail . iterator ( ) ; Iterator < String > matchIt = matchTrail . iterator ( ) ; while ( candidateIt . hasNext ( ) && matchIt . hasNext ( ) ) { String candidatePart = candidateIt . next ( ) ; String matchPart = matchIt . next ( ) ; if ( candidatePart . equals ( matchPart ) ) { candidatePartMatches ++ ; } else { break ; } } if ( candidatePartMatches == matchTrail . size ( ) && matchTrail . size ( ) == candidateTrail . size ( ) ) { return candidateTrail ; } else { if ( candidatePartMatches > partMatches ) { partMatches = candidatePartMatches ; best = candidateTrail ; } } } if ( exact ) { return null ; } else { if ( containFullTrail ) { if ( partMatches >= matchTrail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static List < String > findBestTrailMatch ( List < List < String > > trails , List < String > matchTrail , boolean containFullTrail , boolean exact ) { List < String > best = null ; int partMatches = _NUM ; for ( List < String > candidateTrail : trails ) { int candidatePartMatches = _NUM ; Iterator < String > candidateIt = candidateTrail . iterator ( ) ; Iterator < String > matchIt = matchTrail . iterator ( ) ; while ( candidateIt . hasNext ( ) && matchIt . hasNext ( ) ) { String candidatePart = candidateIt . next ( ) ; String matchPart = matchIt . next ( ) ; if ( candidatePart . equals ( matchPart ) ) { candidatePartMatches ++ ; } else { break ; } } if ( candidatePartMatches == matchTrail . size ( ) && matchTrail . size ( ) == candidateTrail . size ( ) ) { return candidateTrail ; } else { if ( candidatePartMatches > partMatches ) { partMatches = candidatePartMatches ; best = candidateTrail ; } } } if ( exact ) { return null ; } else { if ( containFullTrail ) { if ( partMatches >= matchTrail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static List < String > findBestTrailMatch ( List < List < String > > trails , List < String > matchTrail , boolean containFullTrail , boolean exact ) { List < String > best = null ; int partMatches = _NUM ; for ( List < String > candidateTrail : trails ) { int candidatePartMatches = _NUM ; Iterator < String > candidateIt = candidateTrail . iterator ( ) ; Iterator < String > matchIt = matchTrail . iterator ( ) ; while ( candidateIt . hasNext ( ) && matchIt . hasNext ( ) ) { String candidatePart = candidateIt . next ( ) ; String matchPart = matchIt . next ( ) ; if ( candidatePart . equals ( matchPart ) ) { candidatePartMatches ++ ; } else { break ; } } if ( candidatePartMatches == matchTrail . size ( ) && matchTrail . size ( ) == candidateTrail . size ( ) ) { return candidateTrail ; } else { if ( candidatePartMatches > partMatches ) { partMatches = candidatePartMatches ; best = candidateTrail ; } } } if ( exact ) { return null ; } else { if ( containFullTrail ) { if ( partMatches >= matchTrail . size ( ) ) { return best ; } else { return null ; } } else { return best ; } } }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
public static int indexOfIgnoreCase ( String src , String subS , int startIndex ) { return indexOfIgnoreCase ( src , subS , startIndex , src . length ( ) ) ; }
private Date parseDate ( String dateString ) throws ParseException { java . util . Date parsedDate = DateField . parse ( dateString ) ; if ( parsedDate == null ) return null ; return new Date ( parsedDate . getTime ( ) ) ; }
public java . lang . StringBuffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public java . lang . StringBuffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public java . lang . StringBuffer insert ( int offset , double d ) { internal . insert ( offset , d ) ; return this ; }
public SequenceTemplateParameterContext addSequenceParameter ( SequenceType seqType , SequenceUUID uuid , SequenceContextParameters paramName , String paramValue ) { initSequence ( seqType , uuid ) ; doAddParameter ( seqType , uuid , paramName , paramValue ) ; return this ; }
public CAbstractOperatorPanel ( ) { super ( new BorderLayout ( ) ) ; final JPanel mainPanel = new JPanel ( new BorderLayout ( ) ) ; mainPanel . setBorder ( new TitledBorder ( getBorderTitle ( ) ) ) ; final JPanel infoPanel = new JPanel ( new BorderLayout ( ) ) ; infoPanel . setBorder ( new EmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; m_infoField . setBackground ( infoPanel . getBackground ( ) ) ; m_infoField . setLineWrap ( _BOOL ) ; m_infoField . setWrapStyleWord ( _BOOL ) ; m_infoField . setEditable ( _BOOL ) ; infoPanel . add ( m_infoField , BorderLayout . CENTER ) ; mainPanel . add ( infoPanel , BorderLayout . CENTER ) ; add ( mainPanel , BorderLayout . CENTER ) ; }
protected void overrideDefaultStrategyMap ( final Map < String , S > map ) { }
protected void overrideDefaultStrategyMap ( final Map < String , S > map ) { }
protected void overrideDefaultStrategyMap ( final Map < String , S > map ) { }
protected void overrideDefaultStrategyMap ( final Map < String , S > map ) { }
public static void columnsFor ( ResultSet resultSet , TableEditor editor ) throws SQLException { List < Column > columns = new ArrayList < > ( ) ; columnsFor ( resultSet , null ) ; editor . setColumns ( columns ) ; }
public static void columnsFor ( ResultSet resultSet , TableEditor editor ) throws SQLException { List < Column > columns = new ArrayList < > ( ) ; columnsFor ( resultSet , null ) ; editor . setColumns ( columns ) ; }
@ ReactMethod public void rDeleteAll ( Callback errorCallback , Callback successCallback ) { try { ArrayList < Integer > ids = mNotificationManager . getIDs ( ) ; for ( Integer id : ids ) { try { mNotificationManager . delete ( id ) ; } catch ( Exception e ) { Log . e ( STRING , STRING + Log . getStackTraceString ( e ) ) ; } } successCallback . invoke ( ) ; } catch ( Exception e ) { errorCallback . invoke ( e . getMessage ( ) ) ; Log . e ( STRING , STRING + Log . getStackTraceString ( e ) ) ; } }
public static void clearRect ( Graphics2D g , Rectangle rect , Color background ) { if ( background != null ) { g . setColor ( background ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . CLEAR , _NUM ) ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; g . setComposite ( AlphaComposite . SrcOver ) ; } }
public static void clearRect ( Graphics2D g , Rectangle rect , Color background ) { if ( background != null ) { g . setColor ( background ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . CLEAR , _NUM ) ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; g . setComposite ( AlphaComposite . SrcOver ) ; } }
public static void clearRect ( Graphics2D g , Rectangle rect , Color background ) { if ( background != null ) { g . setColor ( background ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; } else { g . setComposite ( AlphaComposite . getInstance ( AlphaComposite . CLEAR , _NUM ) ) ; g . fillRect ( rect . x , rect . y , rect . width , rect . height ) ; g . setComposite ( AlphaComposite . SrcOver ) ; } }
public int edgeIndex ( TriangulationPoint p1 , TriangulationPoint p2 ) { if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } return - _NUM ; }
public int edgeIndex ( TriangulationPoint p1 , TriangulationPoint p2 ) { if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } return - _NUM ; }
public int edgeIndex ( TriangulationPoint p1 , TriangulationPoint p2 ) { if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } else if ( points [ _NUM ] == p1 ) { if ( points [ _NUM ] == p2 ) { return _NUM ; } else if ( points [ _NUM ] == p2 ) { return _NUM ; } } return - _NUM ; }
public static int compareCanonicalDecimals ( String dec1 , String dec2 ) { if ( dec1 . equals ( dec2 ) ) { return _NUM ; } if ( dec1 . charAt ( _NUM ) == STRING && dec2 . charAt ( _NUM ) != STRING ) { return - _NUM ; } if ( dec2 . charAt ( _NUM ) == STRING && dec1 . charAt ( _NUM ) != STRING ) { return _NUM ; } int dotIdx1 = dec1 . indexOf ( STRING ) ; int dotIdx2 = dec2 . indexOf ( STRING ) ; int result = dotIdx1 - dotIdx2 ; if ( result == _NUM ) { for ( int i = _NUM ; result == _NUM && i < dotIdx1 ; i ++ ) { result = dec1 . charAt ( i ) - dec2 . charAt ( i ) ; } int dec1Length = dec1 . length ( ) ; int dec2Length = dec2 . length ( ) ; int lastIdx = dec1Length <= dec2Length ? dec1Length : dec2Length ; for ( int i = dotIdx1 + _NUM ; result == _NUM && i < lastIdx ; i ++ ) { result = dec1 . charAt ( i ) - dec2 . charAt ( i ) ; } if ( result == _NUM ) { result = dec1Length - dec2Length ; } } if ( dec1 . charAt ( _NUM ) == STRING ) { result = - result ; } return result ; }
public static int compareCanonicalDecimals ( String dec1 , String dec2 ) { if ( dec1 . equals ( dec2 ) ) { return _NUM ; } if ( dec1 . charAt ( _NUM ) == STRING && dec2 . charAt ( _NUM ) != STRING ) { return - _NUM ; } if ( dec2 . charAt ( _NUM ) == STRING && dec1 . charAt ( _NUM ) != STRING ) { return _NUM ; } int dotIdx1 = dec1 . indexOf ( STRING ) ; int dotIdx2 = dec2 . indexOf ( STRING ) ; int result = dotIdx1 - dotIdx2 ; if ( result == _NUM ) { for ( int i = _NUM ; result == _NUM && i < dotIdx1 ; i ++ ) { result = dec1 . charAt ( i ) - dec2 . charAt ( i ) ; } int dec1Length = dec1 . length ( ) ; int dec2Length = dec2 . length ( ) ; int lastIdx = dec1Length <= dec2Length ? dec1Length : dec2Length ; for ( int i = dotIdx1 + _NUM ; result == _NUM && i < lastIdx ; i ++ ) { result = dec1 . charAt ( i ) - dec2 . charAt ( i ) ; } if ( result == _NUM ) { result = dec1Length - dec2Length ; } } if ( dec1 . charAt ( _NUM ) == STRING ) { result = - result ; } return result ; }
public Pointer toDenseMatrix ( cusparseHandle cusparseHandle , cublasHandle cublasHandle , int rows , int cols ) throws DMLRuntimeException { long size = rows * cols * Sizeof . DOUBLE ; Pointer A = JCudaObject . allocate ( size ) ; cusparseDcsr2dense ( cusparseHandle , rows , cols , descr , val , rowPtr , colInd , A , rows ) ; return A ; }
public Pointer toDenseMatrix ( cusparseHandle cusparseHandle , cublasHandle cublasHandle , int rows , int cols ) throws DMLRuntimeException { long size = rows * cols * Sizeof . DOUBLE ; Pointer A = JCudaObject . allocate ( size ) ; cusparseDcsr2dense ( cusparseHandle , rows , cols , descr , val , rowPtr , colInd , A , rows ) ; return A ; }
protected int createStepInstancesForJob ( String jobId , Map < String , String > parameters ) { int stepInstancesCreatedCount = _NUM ; Job job = jobs . getJobById ( jobId ) ; final Map < Step , List < StepInstance > > stepToStepInstances = new HashMap < > ( ) ; for ( Step step : job . getSteps ( ) ) { stepInstancesCreatedCount ++ ; StepInstance stepInstance = new StepInstance ( step ) ; stepInstance . addParameters ( parameters ) ; List < StepInstance > mappedStepInstance = stepToStepInstances . get ( step ) ; if ( mappedStepInstance == null ) { mappedStepInstance = new ArrayList < > ( ) ; stepToStepInstances . put ( step , mappedStepInstance ) ; } mappedStepInstance . add ( stepInstance ) ; } addDependenciesAndStore ( stepToStepInstances ) ; return stepInstancesCreatedCount ; }
public static String extractCollectionFromPath ( String path ) { String extractedCollectionName = null ; String pathModified = removeFromEndOfString ( path , SLASH ) ; String [ ] pathSegments = pathModified . split ( STRING ) ; if ( pathSegments . length > _NUM ) { extractedCollectionName = pathSegments [ pathSegments . length - _NUM ] ; } return extractedCollectionName ; }
private int [ ] pickAutoDetectedLocalAddress ( ) throws IOException { InetAddress addressObj = InetAddress . getLocalHost ( ) ; byte [ ] addr = addressObj . getAddress ( ) ; int b1 = addr [ _NUM ] & _NUM ; int b2 = addr [ _NUM ] & _NUM ; int b3 = addr [ _NUM ] & _NUM ; int b4 = addr [ _NUM ] & _NUM ; int [ ] ret = { b1 , b2 , b3 , b4 } ; return ret ; }
private int [ ] pickAutoDetectedLocalAddress ( ) throws IOException { InetAddress addressObj = InetAddress . getLocalHost ( ) ; byte [ ] addr = addressObj . getAddress ( ) ; int b1 = addr [ _NUM ] & _NUM ; int b2 = addr [ _NUM ] & _NUM ; int b3 = addr [ _NUM ] & _NUM ; int b4 = addr [ _NUM ] & _NUM ; int [ ] ret = { b1 , b2 , b3 , b4 } ; return ret ; }
private String readNodeAddress ( ) { String addr = STRING ; addr = nodeAddrField . getText ( ) ; if ( addr . equals ( STRING ) || addr . equals ( STRING ) || addr . equals ( STRING ) ) { addr = nodeAddr64Field . getText ( ) ; } return ( addr ) ; }
private byte [ ] readPayloadColumn ( ResultSet rows , int columnIndex ) throws SQLException { String str ; byte [ ] payload = EMPTY_DATA ; switch ( options . contentDataType ) { case CollectionDescriptor . CLOB_CONTENT : case CollectionDescriptor . CHAR_CONTENT : str = rows . getString ( columnIndex ) ; if ( str != null ) payload = str . getBytes ( ByteArray . DEFAULT_CHARSET ) ; break ; case CollectionDescriptor . NCLOB_CONTENT : case CollectionDescriptor . NCHAR_CONTENT : str = rows . getNString ( columnIndex ) ; if ( str != null ) payload = str . getBytes ( ByteArray . DEFAULT_CHARSET ) ; break ; case CollectionDescriptor . BLOB_CONTENT : case CollectionDescriptor . RAW_CONTENT : payload = rows . getBytes ( columnIndex ) ; break ; } return ( payload ) ; }
public boolean addToActiveList ( DownloadInfoRunnable downloadInfoRunnable ) { return activeListHasRoom ( ) && mActiveList . add ( downloadInfoRunnable ) ; }
public Builder withAcceptBacklog ( int acceptBacklog ) { properties . setProperty ( NettyOptions . ACCEPT_BACKLOG , String . valueOf ( Assert . argNot ( acceptBacklog , acceptBacklog <= _NUM , STRING ) ) ) ; return this ; }
public Builder withAcceptBacklog ( int acceptBacklog ) { properties . setProperty ( NettyOptions . ACCEPT_BACKLOG , String . valueOf ( Assert . argNot ( acceptBacklog , acceptBacklog <= _NUM , STRING ) ) ) ; return this ; }
protected int [ ] splitSentence ( String sentence ) { String [ ] w = sentence . split ( STRING ) ; int [ ] words = new int [ w . length ] ; for ( int i = _NUM ; i < w . length ; i ++ ) words [ i ] = Vocabulary . id ( w [ i ] ) ; return words ; }
public boolean isInGroup ( VisualItem item , String group ) { if ( ALL_ITEMS . equals ( group ) ) { return _BOOL ; } if ( item . getGroup ( ) == group ) { return _BOOL ; } TupleSet tset = getGroup ( group ) ; return ( tset == null ? _BOOL : tset . containsTuple ( item ) ) ; }
public boolean isInGroup ( VisualItem item , String group ) { if ( ALL_ITEMS . equals ( group ) ) { return _BOOL ; } if ( item . getGroup ( ) == group ) { return _BOOL ; } TupleSet tset = getGroup ( group ) ; return ( tset == null ? _BOOL : tset . containsTuple ( item ) ) ; }
public void removeValue ( Value value ) { actionValues . remove ( value ) ; actionValuesAsArray = null ; }
public synchronized BaseType createPointerType ( final BaseType baseType ) throws CouldntSaveDataException { Preconditions . checkNotNull ( baseType , STRING ) ; if ( baseType . pointedToBy ( ) != null ) { return baseType . pointedToBy ( ) ; } else { final String newTypeName = BaseType . getPointerTypeName ( baseType , baseType . getPointerLevel ( ) + _NUM ) ; final BaseType newType = instantiateType ( newTypeName , getDefaultPointerSize ( ) , _BOOL , baseType , BaseTypeCategory . POINTER ) ; notifyTypeAdded ( newType ) ; return newType ; } }
public synchronized BaseType createPointerType ( final BaseType baseType ) throws CouldntSaveDataException { Preconditions . checkNotNull ( baseType , STRING ) ; if ( baseType . pointedToBy ( ) != null ) { return baseType . pointedToBy ( ) ; } else { final String newTypeName = BaseType . getPointerTypeName ( baseType , baseType . getPointerLevel ( ) + _NUM ) ; final BaseType newType = instantiateType ( newTypeName , getDefaultPointerSize ( ) , _BOOL , baseType , BaseTypeCategory . POINTER ) ; notifyTypeAdded ( newType ) ; return newType ; } }
public synchronized BaseType createPointerType ( final BaseType baseType ) throws CouldntSaveDataException { Preconditions . checkNotNull ( baseType , STRING ) ; if ( baseType . pointedToBy ( ) != null ) { return baseType . pointedToBy ( ) ; } else { final String newTypeName = BaseType . getPointerTypeName ( baseType , baseType . getPointerLevel ( ) + _NUM ) ; final BaseType newType = instantiateType ( newTypeName , getDefaultPointerSize ( ) , _BOOL , baseType , BaseTypeCategory . POINTER ) ; notifyTypeAdded ( newType ) ; return newType ; } }
public synchronized BaseType createPointerType ( final BaseType baseType ) throws CouldntSaveDataException { Preconditions . checkNotNull ( baseType , STRING ) ; if ( baseType . pointedToBy ( ) != null ) { return baseType . pointedToBy ( ) ; } else { final String newTypeName = BaseType . getPointerTypeName ( baseType , baseType . getPointerLevel ( ) + _NUM ) ; final BaseType newType = instantiateType ( newTypeName , getDefaultPointerSize ( ) , _BOOL , baseType , BaseTypeCategory . POINTER ) ; notifyTypeAdded ( newType ) ; return newType ; } }
public synchronized BaseType createPointerType ( final BaseType baseType ) throws CouldntSaveDataException { Preconditions . checkNotNull ( baseType , STRING ) ; if ( baseType . pointedToBy ( ) != null ) { return baseType . pointedToBy ( ) ; } else { final String newTypeName = BaseType . getPointerTypeName ( baseType , baseType . getPointerLevel ( ) + _NUM ) ; final BaseType newType = instantiateType ( newTypeName , getDefaultPointerSize ( ) , _BOOL , baseType , BaseTypeCategory . POINTER ) ; notifyTypeAdded ( newType ) ; return newType ; } }
private IExpressionDescription add ( final String key , final IExpressionDescription expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + _NUM ] ; System . arraycopy ( facets , _NUM , ff , _NUM , facets . length ) ; facets = ff ; facets [ facets . length - _NUM ] = f ; return expr ; }
private IExpressionDescription add ( final String key , final IExpressionDescription expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + _NUM ] ; System . arraycopy ( facets , _NUM , ff , _NUM , facets . length ) ; facets = ff ; facets [ facets . length - _NUM ] = f ; return expr ; }
private IExpressionDescription add ( final String key , final IExpressionDescription expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + _NUM ] ; System . arraycopy ( facets , _NUM , ff , _NUM , facets . length ) ; facets = ff ; facets [ facets . length - _NUM ] = f ; return expr ; }
private IExpressionDescription add ( final String key , final IExpressionDescription expr ) { Facet f = new Facet ( key , expr ) ; Facet [ ] ff = new Facet [ facets . length + _NUM ] ; System . arraycopy ( facets , _NUM , ff , _NUM , facets . length ) ; facets = ff ; facets [ facets . length - _NUM ] = f ; return expr ; }
public void removeAllPlugins ( ) { Iterator < AbstractPlugin > iter = allPlugins . iterator ( ) ; while ( iter . hasNext ( ) ) { AbstractPlugin plugin = ( AbstractPlugin ) iter . next ( ) ; plugin . removePluginObserver ( this ) ; activePlugins . remove ( plugin ) ; iter . remove ( ) ; } }
public final TestSuite build ( ) { rootSuite = new TestSuite ( getSuiteName ( ) ) ; currentClassname = null ; try { for ( TestMethod test : testGrouping . getTests ( ) ) { if ( satisfiesAllPredicates ( test ) ) { addTest ( test ) ; } } if ( testCases . size ( ) > _NUM ) { for ( TestCase testCase : testCases ) { if ( satisfiesAllPredicates ( new TestMethod ( testCase ) ) ) { addTest ( testCase ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; TestSuite suite = new TestSuite ( getSuiteName ( ) ) ; suite . addTest ( new FailedToCreateTests ( exception ) ) ; return suite ; } return rootSuite ; }
public final TestSuite build ( ) { rootSuite = new TestSuite ( getSuiteName ( ) ) ; currentClassname = null ; try { for ( TestMethod test : testGrouping . getTests ( ) ) { if ( satisfiesAllPredicates ( test ) ) { addTest ( test ) ; } } if ( testCases . size ( ) > _NUM ) { for ( TestCase testCase : testCases ) { if ( satisfiesAllPredicates ( new TestMethod ( testCase ) ) ) { addTest ( testCase ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; TestSuite suite = new TestSuite ( getSuiteName ( ) ) ; suite . addTest ( new FailedToCreateTests ( exception ) ) ; return suite ; } return rootSuite ; }
public final TestSuite build ( ) { rootSuite = new TestSuite ( getSuiteName ( ) ) ; currentClassname = null ; try { for ( TestMethod test : testGrouping . getTests ( ) ) { if ( satisfiesAllPredicates ( test ) ) { addTest ( test ) ; } } if ( testCases . size ( ) > _NUM ) { for ( TestCase testCase : testCases ) { if ( satisfiesAllPredicates ( new TestMethod ( testCase ) ) ) { addTest ( testCase ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; TestSuite suite = new TestSuite ( getSuiteName ( ) ) ; suite . addTest ( new FailedToCreateTests ( exception ) ) ; return suite ; } return rootSuite ; }
public final TestSuite build ( ) { rootSuite = new TestSuite ( getSuiteName ( ) ) ; currentClassname = null ; try { for ( TestMethod test : testGrouping . getTests ( ) ) { if ( satisfiesAllPredicates ( test ) ) { addTest ( test ) ; } } if ( testCases . size ( ) > _NUM ) { for ( TestCase testCase : testCases ) { if ( satisfiesAllPredicates ( new TestMethod ( testCase ) ) ) { addTest ( testCase ) ; } } } } catch ( Exception exception ) { Log . i ( STRING , STRING , exception ) ; TestSuite suite = new TestSuite ( getSuiteName ( ) ) ; suite . addTest ( new FailedToCreateTests ( exception ) ) ; return suite ; } return rootSuite ; }
public boolean isEnumConstant ( ) { return ( getModifiers ( ) & Modifier . ENUM ) != _NUM ; }
private Boolean hasStateSpecificAttributes ( Node node ) { for ( Iterator < QName > attributes = node . getAttributeNames ( ) ; attributes != null && attributes . hasNext ( ) ; ) { QName qname = attributes . next ( ) ; String localPart = qname . getLocalPart ( ) ; if ( TextParser . isScopedName ( localPart ) ) return _BOOL ; } return _BOOL ; }
private Boolean hasStateSpecificAttributes ( Node node ) { for ( Iterator < QName > attributes = node . getAttributeNames ( ) ; attributes != null && attributes . hasNext ( ) ; ) { QName qname = attributes . next ( ) ; String localPart = qname . getLocalPart ( ) ; if ( TextParser . isScopedName ( localPart ) ) return _BOOL ; } return _BOOL ; }
private Boolean hasStateSpecificAttributes ( Node node ) { for ( Iterator < QName > attributes = node . getAttributeNames ( ) ; attributes != null && attributes . hasNext ( ) ; ) { QName qname = attributes . next ( ) ; String localPart = qname . getLocalPart ( ) ; if ( TextParser . isScopedName ( localPart ) ) return _BOOL ; } return _BOOL ; }
public OpenDJUpgrader ( EmbeddedOpenDJBackupManager backupManager , String installRoot , ServletContext servletCtx ) { this . backupManager = backupManager ; this . installRoot = installRoot ; this . servletCtx = servletCtx ; this . upgradeMarker = new File ( installRoot + STRING ) ; this . newVersion = readNewVersion ( ) ; OpenDJVersion currentVersion = readCurrentVersion ( ) ; if ( upgradeMarker . exists ( ) && newVersion . equals ( currentVersion ) ) { this . currentVersion = readVersionFromFile ( upgradeMarker ) ; } else { this . currentVersion = currentVersion ; } }
public DaylightCondition ( final DaylightPhase ... daylightPhases ) { super ( ) ; this . daylightPhases = Arrays . asList ( daylightPhases ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
public void testExampleKeystorePath ( ) { assertNotNull ( STRING + STRING + STRING , SSLTestConfig . TEST_KEYSTORE ) ; }
private void handleAutoNumbersForAdd ( Object [ ] row , WriteRowState writeRowState ) throws IOException { if ( _autoNumColumns . isEmpty ( ) ) { return ; } boolean enableInsert = isAllowAutoNumberInsert ( ) ; writeRowState . resetAutoNumber ( ) ; for ( ColumnImpl col : _autoNumColumns ) { Object inRowValue = getInputAutoNumberRowValue ( enableInsert , col , row ) ; ColumnImpl . AutoNumberGenerator autoNumGen = col . getAutoNumberGenerator ( ) ; Object rowValue = ( ( inRowValue == null ) ? autoNumGen . getNext ( writeRowState ) : autoNumGen . handleInsert ( writeRowState , inRowValue ) ) ; col . setRowValue ( row , rowValue ) ; } }
private boolean processRemovedNode ( final INaviViewNode node ) { if ( node instanceof INaviCodeNode ) { final INaviCodeNode cnode = ( INaviCodeNode ) node ; try { final INaviFunction targetFunction = cnode . getParentFunction ( ) ; if ( m_nodeCounter . containsKey ( targetFunction ) ) { final int newCounter = m_nodeCounter . get ( targetFunction ) - _NUM ; if ( newCounter == _NUM ) { m_nodeCounter . remove ( targetFunction ) ; final Set < CCrossReference > toDelete = new HashSet < CCrossReference > ( ) ; for ( final CCrossReference reference : m_crossReferences ) { if ( reference . getCalledFunction ( ) == targetFunction ) { toDelete . add ( reference ) ; } } m_crossReferences . removeAll ( toDelete ) ; return _BOOL ; } else { m_nodeCounter . put ( targetFunction , newCounter ) ; } } } catch ( final MaybeNullException exception ) { } } return _BOOL ; }
private boolean processRemovedNode ( final INaviViewNode node ) { if ( node instanceof INaviCodeNode ) { final INaviCodeNode cnode = ( INaviCodeNode ) node ; try { final INaviFunction targetFunction = cnode . getParentFunction ( ) ; if ( m_nodeCounter . containsKey ( targetFunction ) ) { final int newCounter = m_nodeCounter . get ( targetFunction ) - _NUM ; if ( newCounter == _NUM ) { m_nodeCounter . remove ( targetFunction ) ; final Set < CCrossReference > toDelete = new HashSet < CCrossReference > ( ) ; for ( final CCrossReference reference : m_crossReferences ) { if ( reference . getCalledFunction ( ) == targetFunction ) { toDelete . add ( reference ) ; } } m_crossReferences . removeAll ( toDelete ) ; return _BOOL ; } else { m_nodeCounter . put ( targetFunction , newCounter ) ; } } } catch ( final MaybeNullException exception ) { } } return _BOOL ; }
private boolean processRemovedNode ( final INaviViewNode node ) { if ( node instanceof INaviCodeNode ) { final INaviCodeNode cnode = ( INaviCodeNode ) node ; try { final INaviFunction targetFunction = cnode . getParentFunction ( ) ; if ( m_nodeCounter . containsKey ( targetFunction ) ) { final int newCounter = m_nodeCounter . get ( targetFunction ) - _NUM ; if ( newCounter == _NUM ) { m_nodeCounter . remove ( targetFunction ) ; final Set < CCrossReference > toDelete = new HashSet < CCrossReference > ( ) ; for ( final CCrossReference reference : m_crossReferences ) { if ( reference . getCalledFunction ( ) == targetFunction ) { toDelete . add ( reference ) ; } } m_crossReferences . removeAll ( toDelete ) ; return _BOOL ; } else { m_nodeCounter . put ( targetFunction , newCounter ) ; } } } catch ( final MaybeNullException exception ) { } } return _BOOL ; }
public static Window windowForWordInPosition ( int windowSize , int wordPos , List < String > sentence ) { List < String > window = new ArrayList < > ( ) ; List < String > onlyTokens = new ArrayList < > ( ) ; int contextSize = ( int ) Math . floor ( ( windowSize - _NUM ) / _NUM ) ; for ( int i = wordPos - contextSize ; i <= wordPos + contextSize ; i ++ ) { if ( i < _NUM ) window . add ( STRING ) ; else if ( i >= sentence . size ( ) ) window . add ( STRING ) ; else { onlyTokens . add ( sentence . get ( i ) ) ; window . add ( sentence . get ( i ) ) ; } } String wholeSentence = StringUtils . join ( sentence ) ; String window2 = StringUtils . join ( onlyTokens ) ; int begin = wholeSentence . indexOf ( window2 ) ; int end = begin + window2 . length ( ) ; return new Window ( window , begin , end ) ; }
public static < T > IList < T > create ( final IType t , final Stream < T > stream ) { return ( IList < T > ) stream . collect ( TO_GAMA_LIST ) ; }
public static < T > IList < T > create ( final IType t , final Stream < T > stream ) { return ( IList < T > ) stream . collect ( TO_GAMA_LIST ) ; }
public static < T > IList < T > create ( final IType t , final Stream < T > stream ) { return ( IList < T > ) stream . collect ( TO_GAMA_LIST ) ; }
void updateEntityConfig ( String realm , String cotName , String protocolType , Set trustedProviders ) throws COTException { if ( protocolType . equalsIgnoreCase ( COTConstants . IDFF ) ) { updateIDFFEntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . SAML2 ) ) { updateSAML2EntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . WS_FED ) ) { updateWSFedEntityConfig ( realm , cotName , trustedProviders ) ; } else { String [ ] args = { protocolType } ; throw new COTException ( STRING , args ) ; } }
void updateEntityConfig ( String realm , String cotName , String protocolType , Set trustedProviders ) throws COTException { if ( protocolType . equalsIgnoreCase ( COTConstants . IDFF ) ) { updateIDFFEntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . SAML2 ) ) { updateSAML2EntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . WS_FED ) ) { updateWSFedEntityConfig ( realm , cotName , trustedProviders ) ; } else { String [ ] args = { protocolType } ; throw new COTException ( STRING , args ) ; } }
void updateEntityConfig ( String realm , String cotName , String protocolType , Set trustedProviders ) throws COTException { if ( protocolType . equalsIgnoreCase ( COTConstants . IDFF ) ) { updateIDFFEntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . SAML2 ) ) { updateSAML2EntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . WS_FED ) ) { updateWSFedEntityConfig ( realm , cotName , trustedProviders ) ; } else { String [ ] args = { protocolType } ; throw new COTException ( STRING , args ) ; } }
void updateEntityConfig ( String realm , String cotName , String protocolType , Set trustedProviders ) throws COTException { if ( protocolType . equalsIgnoreCase ( COTConstants . IDFF ) ) { updateIDFFEntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . SAML2 ) ) { updateSAML2EntityConfig ( realm , cotName , trustedProviders ) ; } else if ( protocolType . equalsIgnoreCase ( COTConstants . WS_FED ) ) { updateWSFedEntityConfig ( realm , cotName , trustedProviders ) ; } else { String [ ] args = { protocolType } ; throw new COTException ( STRING , args ) ; } }
private void addOneSourceTokenToTLA ( String str , Region region ) { if ( region == null ) { addOneTokenToTLA ( str ) ; return ; } int beginCol = tlacodeNextLine . length ( ) ; int endCol = beginCol + str . length ( ) ; mappingVectorNextLine . addElement ( new MappingObject . SourceToken ( beginCol , endCol , region ) ) ; tlacodeNextLine = tlacodeNextLine + str ; }
public synchronized boolean verifyAndAdvanceState ( Byte newStep ) { logger . debug ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( newStep ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) ) ; if ( ! INIT_COMMAND_ORDER_LIST . contains ( newStep ) ) { return _BOOL ; } if ( INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) > _NUM ) { int currentIndex = INIT_COMMAND_ORDER_LIST . indexOf ( currentStep ) ; int newIndex = INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) ; if ( newIndex != currentIndex && newIndex - currentIndex > _NUM ) { if ( HALT_ON_IMPROPER_ORDER ) { setErrorState ( String . format ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ) ; return _BOOL ; } else { logger . warn ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ; } } } currentStep = newStep ; return _BOOL ; }
public synchronized boolean verifyAndAdvanceState ( Byte newStep ) { logger . debug ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( newStep ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) ) ; if ( ! INIT_COMMAND_ORDER_LIST . contains ( newStep ) ) { return _BOOL ; } if ( INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) > _NUM ) { int currentIndex = INIT_COMMAND_ORDER_LIST . indexOf ( currentStep ) ; int newIndex = INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) ; if ( newIndex != currentIndex && newIndex - currentIndex > _NUM ) { if ( HALT_ON_IMPROPER_ORDER ) { setErrorState ( String . format ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ) ; return _BOOL ; } else { logger . warn ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ; } } } currentStep = newStep ; return _BOOL ; }
public synchronized boolean verifyAndAdvanceState ( Byte newStep ) { logger . debug ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( newStep ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) ) ; if ( ! INIT_COMMAND_ORDER_LIST . contains ( newStep ) ) { return _BOOL ; } if ( INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) > _NUM ) { int currentIndex = INIT_COMMAND_ORDER_LIST . indexOf ( currentStep ) ; int newIndex = INIT_COMMAND_ORDER_LIST . indexOf ( newStep ) ; if ( newIndex != currentIndex && newIndex - currentIndex > _NUM ) { if ( HALT_ON_IMPROPER_ORDER ) { setErrorState ( String . format ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ) ; return _BOOL ; } else { logger . warn ( STRING , node . getNodeId ( ) , ZWaveSecurityCommandClass . commandToString ( currentStep ) , ZWaveSecurityCommandClass . commandToString ( newStep ) ) ; } } } currentStep = newStep ; return _BOOL ; }
public void addObjectDetail ( KMLObjectDetail objectDetail ) { elements . add ( objectDetail ) ; }
private int createFolder ( ) { if ( mNewDirectoryName != null && mSelectedDir != null && mSelectedDir . canWrite ( ) ) { File newDir = new File ( mSelectedDir , mNewDirectoryName ) ; if ( ! newDir . exists ( ) ) { boolean result = newDir . mkdir ( ) ; if ( result ) { changeDirectory ( newDir ) ; return R . string . create_folder_success ; } else { return R . string . create_folder_error ; } } else { return R . string . create_folder_error_already_exists ; } } else if ( mSelectedDir != null && ! mSelectedDir . canWrite ( ) ) { return R . string . create_folder_error_no_write_access ; } else { return R . string . create_folder_error ; } }
public char readLEChar ( ) throws IOException { int byte1 = in . read ( ) ; int byte2 = in . read ( ) ; if ( byte2 == - _NUM ) throw new EOFException ( ) ; return ( char ) ( ( byte2 << _NUM ) + byte1 ) ; }
protected void updateValues ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , _NUM , prev , _NUM , prev . length ) ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( data ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } else { prev = curr ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( ( allThreadsData ) null ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } prevMeasurementTime = currMeasurementTime ; currMeasurementTime = System . currentTimeMillis ( ) ; } }
protected void updateValues ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , _NUM , prev , _NUM , prev . length ) ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( data ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } else { prev = curr ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( ( allThreadsData ) null ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } prevMeasurementTime = currMeasurementTime ; currMeasurementTime = System . currentTimeMillis ( ) ; } }
protected void updateValues ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , _NUM , prev , _NUM , prev . length ) ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( data ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } else { prev = curr ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( ( allThreadsData ) null ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } prevMeasurementTime = currMeasurementTime ; currMeasurementTime = System . currentTimeMillis ( ) ; } }
protected void updateValues ( ) { synchronized ( workers ) { if ( prev . length == curr . length ) { System . arraycopy ( curr , _NUM , prev , _NUM , prev . length ) ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( data ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } else { prev = curr ; allThreadsData data = new allThreadsData ( ) ; data . setIterations ( curr ) ; data = readValues ( ( allThreadsData ) null ) ; curr = data . getIterations ( ) ; totalResponseTime = data . getTotalResponseTimes ( ) ; responseTimeStdDev = data . getResponseTimeStdDev ( ) ; } prevMeasurementTime = currMeasurementTime ; currMeasurementTime = System . currentTimeMillis ( ) ; } }
public void add ( Symbol symbol ) { symbols . add ( symbol ) ; }
private static void percentEncoder ( final String urlElement , final StringBuilder encodedBuffer ) { Reject . ifNull ( urlElement ) ; for ( int count = _NUM ; count < urlElement . length ( ) ; count ++ ) { final char c = urlElement . charAt ( count ) ; if ( VALID_CHARS . contains ( c ) ) { encodedBuffer . append ( c ) ; } else { encodedBuffer . append ( PERCENT_ENCODING_CHAR ) ; encodedBuffer . append ( Integer . toHexString ( c ) ) ; } } }
public boolean hasActiveTasks ( ) { boolean doesHaveTasks = _BOOL ; synchronized ( asyncTasks ) { if ( asyncTasks . isEmpty ( ) ) return _BOOL ; Iterator < RunnableScheduledFuture < ? > > i = asyncTasks . iterator ( ) ; while ( i . hasNext ( ) ) { RunnableScheduledFuture < ? > task = i . next ( ) ; if ( task . isDone ( ) ) i . remove ( ) ; else doesHaveTasks = _BOOL ; } } return doesHaveTasks ; }
public boolean hasActiveTasks ( ) { boolean doesHaveTasks = _BOOL ; synchronized ( asyncTasks ) { if ( asyncTasks . isEmpty ( ) ) return _BOOL ; Iterator < RunnableScheduledFuture < ? > > i = asyncTasks . iterator ( ) ; while ( i . hasNext ( ) ) { RunnableScheduledFuture < ? > task = i . next ( ) ; if ( task . isDone ( ) ) i . remove ( ) ; else doesHaveTasks = _BOOL ; } } return doesHaveTasks ; }
static String handleIllegalCharacterInResult ( final String result ) { String tempResult = result ; if ( tempResult != null && tempResult . contains ( STRING ) ) { tempResult = tempResult . replaceAll ( STRING , STRING ) ; } return tempResult ; }
private WebTarget createWebTarget ( String restPath , Map < String , String > queryParams ) { WebTarget webTarget ; try { URI u = new URI ( this . baseURI + STRING + restPath ) ; Client client = createrRestClient ( ) ; webTarget = client . target ( u ) ; if ( queryParams != null && ! queryParams . isEmpty ( ) ) { for ( Map . Entry < String , String > entry : queryParams . entrySet ( ) ) { if ( entry . getKey ( ) != null && entry . getValue ( ) != null ) { LOG . debug ( STRING , entry . getKey ( ) , entry . getValue ( ) ) ; webTarget = webTarget . queryParam ( entry . getKey ( ) , entry . getValue ( ) ) ; } } } } catch ( Exception e ) { LOG . error ( STRING , e ) ; return null ; } return webTarget ; }
protected void removeFromMarkedPosition ( ) { System . arraycopy ( buffer , read_pos , buffer , marked_pos , read_pos_end - read_pos ) ; read_pos_end -= ( read_pos - marked_pos ) ; read_pos = marked_pos ; }
protected void removeFromMarkedPosition ( ) { System . arraycopy ( buffer , read_pos , buffer , marked_pos , read_pos_end - read_pos ) ; read_pos_end -= ( read_pos - marked_pos ) ; read_pos = marked_pos ; }
protected void removeFromMarkedPosition ( ) { System . arraycopy ( buffer , read_pos , buffer , marked_pos , read_pos_end - read_pos ) ; read_pos_end -= ( read_pos - marked_pos ) ; read_pos = marked_pos ; }
public void addWorkspaceComponentListener ( final WorkspaceComponentListener listener ) { workspaceComponentListeners . add ( listener ) ; }
public static double heapSize ( Iterable < ClusterNode > nodes , int precision ) { double heap = _NUM ; for ( ClusterNode n : nodesPerJvm ( nodes ) ) { ClusterMetrics m = n . metrics ( ) ; heap += Math . max ( m . getHeapMemoryInitialized ( ) , m . getHeapMemoryMaximum ( ) ) ; } return roundedHeapSize ( heap , precision ) ; }
public void generate ( BatchEnvironment env , ClassDefinition cdef , File destDir ) { RemoteClass remoteClass = RemoteClass . forClass ( env , cdef ) ; if ( remoteClass == null ) return ; RMIGenerator gen ; try { gen = new RMIGenerator ( env , cdef , destDir , remoteClass , version ) ; } catch ( ClassNotFound e ) { env . error ( _NUM , STRING , e . name ) ; return ; } gen . generate ( ) ; }
@ Override public synchronized void close ( ) throws IOException { buffer = null ; isClosed = _BOOL ; notifyAll ( ) ; }
@ Override public synchronized void close ( ) throws IOException { buffer = null ; isClosed = _BOOL ; notifyAll ( ) ; }
@ Override public synchronized void close ( ) throws IOException { buffer = null ; isClosed = _BOOL ; notifyAll ( ) ; }
@ Override public synchronized void close ( ) throws IOException { buffer = null ; isClosed = _BOOL ; notifyAll ( ) ; }
private void write ( Coordinate [ ] coords , Writer writer , int level ) throws IOException { startLine ( level , writer ) ; startGeomTag ( GMLConstants . GML_COORDINATES , null , writer ) ; int dim = _NUM ; if ( coords . length > _NUM ) { if ( ! ( Double . isNaN ( coords [ _NUM ] . z ) ) ) dim = _NUM ; } boolean isNewLine = _BOOL ; for ( int i = _NUM ; i < coords . length ; i ++ ) { if ( isNewLine ) { startLine ( level + _NUM , writer ) ; isNewLine = _BOOL ; } if ( dim == _NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinateSeparator ) ; writer . write ( STRING + coords [ i ] . y ) ; } else if ( dim == _NUM ) { writer . write ( STRING + coords [ i ] . x ) ; writer . write ( coordinateSeparator ) ; writer . write ( STRING + coords [ i ] . y ) ; writer . write ( coordinateSeparator ) ; writer . write ( STRING + coords [ i ] . z ) ; } writer . write ( tupleSeparator ) ; if ( ( i + _NUM ) % maxCoordinatesPerLine == _NUM && i < coords . length - _NUM ) { writer . write ( STRING ) ; isNewLine = _BOOL ; } } if ( ! isNewLine ) writer . write ( STRING ) ; startLine ( level , writer ) ; endGeomTag ( GMLConstants . GML_COORDINATES , writer ) ; }
public static String serialise ( Node node ) { try { DOMImplementationRegistry registry = DOMImplementationRegistry . newInstance ( ) ; DOMImplementationLS lsImpl = ( DOMImplementationLS ) registry . getDOMImplementation ( STRING ) ; LSSerializer serializer = lsImpl . createLSSerializer ( ) ; return serializer . writeToString ( node ) ; } catch ( Exception e ) { log . fine ( STRING + e ) ; return STRING ; } }
public void addAttribute ( Attribute attribute ) { regularAttributes . add ( attribute ) ; }
public void addAttribute ( Attribute attribute ) { regularAttributes . add ( attribute ) ; }
public JRun4xConfigurationBuilder ( ) { try { DocumentBuilderFactory domFactory = DocumentBuilderFactory . newInstance ( ) ; builder = domFactory . newDocumentBuilder ( ) ; } catch ( Exception e ) { throw new CargoException ( STRING , e ) ; } }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { JTranscArrays . checkOffsetAndCount ( src . length , srcOffset , byteCount ) ; if ( byteCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + byteCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public ByteBuffer put ( byte [ ] src , int srcOffset , int byteCount ) { JTranscArrays . checkOffsetAndCount ( src . length , srcOffset , byteCount ) ; if ( byteCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + byteCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
default String resourceName ( String tableName , String type ) { return String . format ( RESOURCE_NAME , tableName , type ) ; }
public void init ( ) { if ( ! _initialized ) { super . init ( ) ; _detectPanel = new DetectionPanel ( this ) ; JPanel panel = new JPanel ( ) ; panel . setLayout ( new BoxLayout ( panel , BoxLayout . Y_AXIS ) ) ; panel . add ( Box . createVerticalGlue ( ) ) ; panel . add ( _detectPanel ) ; add ( panel , _NUM ) ; } }
private void copyACLs ( List < UnManagedCifsShareACL > origACLList , List < CifsShareACL > shareACLList , FileShare fileshare ) { CifsShareACL shareACL = null ; for ( UnManagedCifsShareACL origACL : origACLList ) { shareACL = new CifsShareACL ( ) ; shareACL . setId ( URIUtil . createId ( CifsShareACL . class ) ) ; shareACL . setUser ( origACL . getUser ( ) ) ; shareACL . setPermission ( origACL . getPermission ( ) ) ; shareACL . setShareName ( origACL . getShareName ( ) ) ; shareACL . setFileSystemId ( fileshare . getId ( ) ) ; shareACLList . add ( shareACL ) ; _logger . info ( STRING , shareACL . toString ( ) ) ; } }
private void copyACLs ( List < UnManagedCifsShareACL > origACLList , List < CifsShareACL > shareACLList , FileShare fileshare ) { CifsShareACL shareACL = null ; for ( UnManagedCifsShareACL origACL : origACLList ) { shareACL = new CifsShareACL ( ) ; shareACL . setId ( URIUtil . createId ( CifsShareACL . class ) ) ; shareACL . setUser ( origACL . getUser ( ) ) ; shareACL . setPermission ( origACL . getPermission ( ) ) ; shareACL . setShareName ( origACL . getShareName ( ) ) ; shareACL . setFileSystemId ( fileshare . getId ( ) ) ; shareACLList . add ( shareACL ) ; _logger . info ( STRING , shareACL . toString ( ) ) ; } }
public void ensureAdditionalCapacity ( final int size ) { final int newCount = visible . position ( ) + size ; if ( newCount > visible . capacity ( ) ) { final ByteBuffer newByteBuffer = ByteBuffer . allocate ( Math . max ( visible . capacity ( ) << _NUM , newCount ) ) ; visible . flip ( ) ; visible = newByteBuffer . put ( visible ) ; } }
public void ensureAdditionalCapacity ( final int size ) { final int newCount = visible . position ( ) + size ; if ( newCount > visible . capacity ( ) ) { final ByteBuffer newByteBuffer = ByteBuffer . allocate ( Math . max ( visible . capacity ( ) << _NUM , newCount ) ) ; visible . flip ( ) ; visible = newByteBuffer . put ( visible ) ; } }
public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - _NUM , p_path , p_queryString , p_fragment ) ; }
public URI ( String p_scheme , String p_host , String p_path , String p_queryString , String p_fragment ) throws MalformedURIException { this ( p_scheme , null , p_host , - _NUM , p_path , p_queryString , p_fragment ) ; }
public Jdk14Logger ( String name ) { this . jdkLogger = Logger . getLogger ( name ) ; }
public static Color deriveWithAlpha ( Color color , int alpha ) { return new Color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) , alpha ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public void paintComponent ( Graphics g ) { int x = PADDING ; int y = PADDING ; g . drawImage ( picture , x , y , scaleW , scaleH , null ) ; x += scaleW + PADDING ; g . drawImage ( picture , x , y , x + scaleW , y + scaleH , _NUM , _NUM , picture . getWidth ( ) , picture . getHeight ( ) , null ) ; x += scaleW + PADDING ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; g2d . translate ( x , y ) ; g2d . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , _NUM , _NUM , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; g2d = ( Graphics2D ) g . create ( ) ; AffineTransform at = new AffineTransform ( ) ; at . translate ( x , y ) ; at . scale ( SCALE_FACTOR , SCALE_FACTOR ) ; g2d . drawImage ( picture , at , null ) ; g2d . dispose ( ) ; x += scaleW + PADDING ; Image scaledImg = picture . getScaledInstance ( scaleW , scaleH , Image . SCALE_DEFAULT ) ; g . drawImage ( scaledImg , x , y , null ) ; }
public static Element [ ] addElement ( Element element , Element ... elements ) { Element [ ] newElements = new Element [ elements . length + _NUM ] ; newElements [ _NUM ] = element ; System . arraycopy ( elements , _NUM , newElements , _NUM , elements . length ) ; return newElements ; }
public static Element [ ] addElement ( Element element , Element ... elements ) { Element [ ] newElements = new Element [ elements . length + _NUM ] ; newElements [ _NUM ] = element ; System . arraycopy ( elements , _NUM , newElements , _NUM , elements . length ) ; return newElements ; }
public void testComputeClasspathForSimpleProject ( ) throws CoreException { addAndCreateSourceEntry ( javaProjectA , SRC_DIR_NAME , null ) ; List < File > actualCp = getListOfFiles ( GWTCompileRunner . computeClasspath ( javaProjectA ) ) ; List < File > expectedCp = new ArrayList < File > ( ) ; expectedCp . add ( getFile ( javaProjectA . getProject ( ) , SRC_DIR_NAME ) ) ; expectedCp . add ( getOutputOfProject ( javaProjectA ) ) ; assertEquals ( expectedCp , actualCp ) ; }
public static TempPath createFile ( ) throws IOException { return wrap ( Files . createTempFile ( PREFIX , SUFFIX ) ) ; }
public static TempPath createFile ( ) throws IOException { return wrap ( Files . createTempFile ( PREFIX , SUFFIX ) ) ; }
public final int updateAndGet ( IntUnaryOperator updateFunction ) { int prev , next ; do { prev = get ( ) ; next = updateFunction . applyAsInt ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final int updateAndGet ( IntUnaryOperator updateFunction ) { int prev , next ; do { prev = get ( ) ; next = updateFunction . applyAsInt ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final int updateAndGet ( IntUnaryOperator updateFunction ) { int prev , next ; do { prev = get ( ) ; next = updateFunction . applyAsInt ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final int updateAndGet ( IntUnaryOperator updateFunction ) { int prev , next ; do { prev = get ( ) ; next = updateFunction . applyAsInt ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public void addCommonHeader ( ) { addLine ( VERSION_LINE ) ; final Calendar cal = Calendar . getInstance ( ) ; final SimpleDateFormat sdf = new SimpleDateFormat ( STRING ) ; addLine ( META_STRING + STRING + sdf . format ( cal . getTime ( ) ) ) ; addLine ( META_STRING + STRING + Environment . getVersion ( ) ) ; addRunInfo ( ) ; }
public void addCommonHeader ( ) { addLine ( VERSION_LINE ) ; final Calendar cal = Calendar . getInstance ( ) ; final SimpleDateFormat sdf = new SimpleDateFormat ( STRING ) ; addLine ( META_STRING + STRING + sdf . format ( cal . getTime ( ) ) ) ; addLine ( META_STRING + STRING + Environment . getVersion ( ) ) ; addRunInfo ( ) ; }
public void addCommonHeader ( ) { addLine ( VERSION_LINE ) ; final Calendar cal = Calendar . getInstance ( ) ; final SimpleDateFormat sdf = new SimpleDateFormat ( STRING ) ; addLine ( META_STRING + STRING + sdf . format ( cal . getTime ( ) ) ) ; addLine ( META_STRING + STRING + Environment . getVersion ( ) ) ; addRunInfo ( ) ; }
public void generateRandomNetwork ( ) throws Exception { if ( m_otherBayesNet == null ) { Init ( m_nNrOfNodes , m_nCardinality ) ; generateRandomNetworkStructure ( m_nNrOfNodes , m_nNrOfArcs ) ; generateRandomDistributions ( m_nNrOfNodes , m_nCardinality ) ; } else { m_nNrOfNodes = m_otherBayesNet . getNrOfNodes ( ) ; m_ParentSets = m_otherBayesNet . getParentSets ( ) ; m_Distributions = m_otherBayesNet . getDistributions ( ) ; random = new Random ( m_nSeed ) ; ArrayList < Attribute > attInfo = new ArrayList < Attribute > ( m_nNrOfNodes ) ; for ( int iNode = _NUM ; iNode < m_nNrOfNodes ; iNode ++ ) { int nValues = m_otherBayesNet . getCardinality ( iNode ) ; ArrayList < String > nomStrings = new ArrayList < String > ( nValues + _NUM ) ; for ( int iValue = _NUM ; iValue < nValues ; iValue ++ ) { nomStrings . add ( m_otherBayesNet . getNodeValue ( iNode , iValue ) ) ; } Attribute att = new Attribute ( m_otherBayesNet . getNodeName ( iNode ) , nomStrings ) ; attInfo . add ( att ) ; } m_Instances = new Instances ( m_otherBayesNet . getName ( ) , attInfo , _NUM ) ; m_Instances . setClassIndex ( m_nNrOfNodes - _NUM ) ; } }
public void generateRandomNetwork ( ) throws Exception { if ( m_otherBayesNet == null ) { Init ( m_nNrOfNodes , m_nCardinality ) ; generateRandomNetworkStructure ( m_nNrOfNodes , m_nNrOfArcs ) ; generateRandomDistributions ( m_nNrOfNodes , m_nCardinality ) ; } else { m_nNrOfNodes = m_otherBayesNet . getNrOfNodes ( ) ; m_ParentSets = m_otherBayesNet . getParentSets ( ) ; m_Distributions = m_otherBayesNet . getDistributions ( ) ; random = new Random ( m_nSeed ) ; ArrayList < Attribute > attInfo = new ArrayList < Attribute > ( m_nNrOfNodes ) ; for ( int iNode = _NUM ; iNode < m_nNrOfNodes ; iNode ++ ) { int nValues = m_otherBayesNet . getCardinality ( iNode ) ; ArrayList < String > nomStrings = new ArrayList < String > ( nValues + _NUM ) ; for ( int iValue = _NUM ; iValue < nValues ; iValue ++ ) { nomStrings . add ( m_otherBayesNet . getNodeValue ( iNode , iValue ) ) ; } Attribute att = new Attribute ( m_otherBayesNet . getNodeName ( iNode ) , nomStrings ) ; attInfo . add ( att ) ; } m_Instances = new Instances ( m_otherBayesNet . getName ( ) , attInfo , _NUM ) ; m_Instances . setClassIndex ( m_nNrOfNodes - _NUM ) ; } }
@ Override @ Transactional public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; PersistentToken token = getPersistentToken ( cookieTokens ) ; persistentTokenRepository . delete ( token ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; PersistentToken token = getPersistentToken ( cookieTokens ) ; persistentTokenRepository . delete ( token ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; PersistentToken token = getPersistentToken ( cookieTokens ) ; persistentTokenRepository . delete ( token ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
@ Override @ Transactional public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { String rememberMeCookie = extractRememberMeCookie ( request ) ; if ( rememberMeCookie != null && rememberMeCookie . length ( ) != _NUM ) { try { String [ ] cookieTokens = decodeCookie ( rememberMeCookie ) ; PersistentToken token = getPersistentToken ( cookieTokens ) ; persistentTokenRepository . delete ( token ) ; } catch ( InvalidCookieException ice ) { log . info ( STRING ) ; } catch ( RememberMeAuthenticationException rmae ) { log . debug ( STRING ) ; } } super . logout ( request , response , authentication ) ; }
private static void writeDngBytesAndClose ( Image image , TotalCaptureResult captureResult , CameraCharacteristics characteristics , File dngFile ) { try ( DngCreator dngCreator = new DngCreator ( characteristics , captureResult ) ; FileOutputStream outputStream = new FileOutputStream ( dngFile ) ) { dngCreator . writeImage ( outputStream , image ) ; outputStream . close ( ) ; image . close ( ) ; } catch ( IOException e ) { Log . e ( TAG , STRING , e ) ; return ; } Log . i ( TAG , STRING + dngFile . getAbsolutePath ( ) ) ; }
public static Spannable createSpannableFromTextWithTemplate ( String text , CharSequence innerTemplate ) { SpannableString result = new SpannableString ( text ) ; if ( innerTemplate instanceof Spanned ) { int index = text . indexOf ( innerTemplate . toString ( ) ) ; if ( index >= _NUM ) { copySpans ( result , ( Spanned ) innerTemplate , index ) ; } } return result ; }
public static Spannable createSpannableFromTextWithTemplate ( String text , CharSequence innerTemplate ) { SpannableString result = new SpannableString ( text ) ; if ( innerTemplate instanceof Spanned ) { int index = text . indexOf ( innerTemplate . toString ( ) ) ; if ( index >= _NUM ) { copySpans ( result , ( Spanned ) innerTemplate , index ) ; } } return result ; }
public static Spannable createSpannableFromTextWithTemplate ( String text , CharSequence innerTemplate ) { SpannableString result = new SpannableString ( text ) ; if ( innerTemplate instanceof Spanned ) { int index = text . indexOf ( innerTemplate . toString ( ) ) ; if ( index >= _NUM ) { copySpans ( result , ( Spanned ) innerTemplate , index ) ; } } return result ; }
@ Override public EnterFromDateToToDateActivity . TimeObject add ( long time , int val ) { Calendar c = Calendar . getInstance ( ) ; c . setTimeInMillis ( time ) ; c . add ( Calendar . MONTH , val ) ; return timeObjectFromCalendar ( c ) ; }
public void acquire ( ) { int n = refCount . incrementAndGet ( ) ; }
void _setText ( byte [ ] text ) { this . _text = text ; this . _props = null ; }
private void kickOff ( Team offense ) { if ( gameTime <= _NUM ) return ; else { if ( gameTime < _NUM && ( ( gamePoss && ( awayScore - homeScore ) <= _NUM && ( awayScore - homeScore ) > _NUM ) || ( ! gamePoss && ( homeScore - awayScore ) <= _NUM && ( homeScore - awayScore ) > _NUM ) ) ) { if ( offense . getK ( _NUM ) . ratKickFum * Math . random ( ) > _NUM || Math . random ( ) < _NUM ) { gameEventLog += getEventPrefix ( ) + offense . abbr + STRING + offense . getK ( _NUM ) . name + STRING + offense . abbr + STRING ; } else { gameEventLog += getEventPrefix ( ) + offense . abbr + STRING + offense . getK ( _NUM ) . name + STRING ; gamePoss = ! gamePoss ; } gameYardLine = _NUM ; gameDown = _NUM ; gameYardsNeed = _NUM ; gameTime -= _NUM + _NUM * Math . random ( ) ; } else { gameYardLine = ( int ) ( _NUM - ( offense . getK ( _NUM ) . ratKickPow + _NUM - _NUM * Math . random ( ) ) ) ; if ( gameYardLine <= _NUM ) gameYardLine = _NUM ; gameDown = _NUM ; gameYardsNeed = _NUM ; gamePoss = ! gamePoss ; } gameTime -= _NUM * Math . random ( ) ; } }
private void kickOff ( Team offense ) { if ( gameTime <= _NUM ) return ; else { if ( gameTime < _NUM && ( ( gamePoss && ( awayScore - homeScore ) <= _NUM && ( awayScore - homeScore ) > _NUM ) || ( ! gamePoss && ( homeScore - awayScore ) <= _NUM && ( homeScore - awayScore ) > _NUM ) ) ) { if ( offense . getK ( _NUM ) . ratKickFum * Math . random ( ) > _NUM || Math . random ( ) < _NUM ) { gameEventLog += getEventPrefix ( ) + offense . abbr + STRING + offense . getK ( _NUM ) . name + STRING + offense . abbr + STRING ; } else { gameEventLog += getEventPrefix ( ) + offense . abbr + STRING + offense . getK ( _NUM ) . name + STRING ; gamePoss = ! gamePoss ; } gameYardLine = _NUM ; gameDown = _NUM ; gameYardsNeed = _NUM ; gameTime -= _NUM + _NUM * Math . random ( ) ; } else { gameYardLine = ( int ) ( _NUM - ( offense . getK ( _NUM ) . ratKickPow + _NUM - _NUM * Math . random ( ) ) ) ; if ( gameYardLine <= _NUM ) gameYardLine = _NUM ; gameDown = _NUM ; gameYardsNeed = _NUM ; gamePoss = ! gamePoss ; } gameTime -= _NUM * Math . random ( ) ; } }
private void shrinkValueSet ( int maxSize ) { if ( valueSet != null ) { if ( valueSet . size ( ) > maxSize ) { Set < String > newSet = new TreeSet < String > ( ) ; Iterator < String > i = valueSet . iterator ( ) ; int count = _NUM ; while ( i . hasNext ( ) && count < maxSize ) { newSet . add ( i . next ( ) ) ; count ++ ; } this . valueSet = newSet ; valueSetRelation = valueSetRelation . merge ( SetRelation . SUPERSET ) ; if ( owner != null ) { owner . setNominalDataWasShrinked ( _BOOL ) ; } } } }
public static void putCharLE ( long addr , char val ) { if ( UNALIGNED ) UNSAFE . putChar ( addr , Character . reverseBytes ( val ) ) ; else putCharByByte ( addr , val , _BOOL ) ; }
public HttpRequest contentLength ( final int value ) { connection . setFixedLengthStreamingMode ( value ) ; return this ; }
protected void purge ( ) { Reference reference = queue . poll ( ) ; while ( reference != null ) { purge ( reference ) ; reference = queue . poll ( ) ; } }
protected void purge ( ) { Reference reference = queue . poll ( ) ; while ( reference != null ) { purge ( reference ) ; reference = queue . poll ( ) ; } }
public DIssuerAlternativeName ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
public String phonemise ( String text , String pos , StringBuilder g2pMethod ) { String result = userdictLookup ( text , pos ) ; if ( result != null ) { g2pMethod . append ( STRING ) ; return result ; } result = lexiconLookup ( text , pos ) ; if ( result != null ) { g2pMethod . append ( STRING ) ; return result ; } String normalised = MaryUtils . normaliseUnicodeLetters ( text , getLocale ( ) ) ; if ( ! normalised . equals ( text ) ) { result = userdictLookup ( normalised , pos ) ; if ( result != null ) { g2pMethod . append ( STRING ) ; return result ; } result = lexiconLookup ( normalised , pos ) ; if ( result != null ) { g2pMethod . append ( STRING ) ; return result ; } } String phones = lts . predictPronunciation ( text ) ; result = lts . syllabify ( phones ) ; if ( result != null ) { g2pMethod . append ( STRING ) ; return result ; } return null ; }
@ RequestMapping ( value = STRING , method = RequestMethod . DELETE ) @ ResponseBody public RestWrapper delete ( @ PathVariable ( STRING ) Integer workflowId , Principal principal ) { RestWrapper restWrapper = null ; try { workflowTypeDAO . delete ( workflowId ) ; restWrapper = new RestWrapper ( null , RestWrapper . OK ) ; LOGGER . info ( STRING + workflowId + STRING + principal . getName ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
@ RequestMapping ( value = STRING , method = RequestMethod . DELETE ) @ ResponseBody public RestWrapper delete ( @ PathVariable ( STRING ) Integer workflowId , Principal principal ) { RestWrapper restWrapper = null ; try { workflowTypeDAO . delete ( workflowId ) ; restWrapper = new RestWrapper ( null , RestWrapper . OK ) ; LOGGER . info ( STRING + workflowId + STRING + principal . getName ( ) ) ; } catch ( Exception e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
protected abstract void body ( ) throws InterruptedException , IgniteInterruptedCheckedException ;
protected abstract void body ( ) throws InterruptedException , IgniteInterruptedCheckedException ;
private VisorNodeSuppressedErrorsJob ( Map < UUID , Long > arg , boolean debug ) { super ( arg , debug ) ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
protected SizeRequirements calculateMinorAxisRequirements ( int axis , SizeRequirements r ) { long min = _NUM ; long pref = _NUM ; long max = _NUM ; multiRowCells = _BOOL ; int n = getViewCount ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { View v = getView ( i ) ; if ( getRowsOccupied ( v ) > _NUM ) { multiRowCells = _BOOL ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } else { min = Math . max ( ( int ) v . getMinimumSpan ( axis ) , min ) ; pref = Math . max ( ( int ) v . getPreferredSpan ( axis ) , pref ) ; max = Math . max ( ( int ) v . getMaximumSpan ( axis ) , max ) ; } } if ( r == null ) { r = new SizeRequirements ( ) ; r . alignment = _NUM ; } r . preferred = ( int ) pref ; r . minimum = ( int ) min ; r . maximum = ( int ) max ; return r ; }
public static TcFeature create ( Class < ? extends Resource > featureName , Object ... parameters ) { String id = featureName . getSimpleName ( ) + System . nanoTime ( ) ; List < Object > params = getParameterAsString ( parameters ) ; params . add ( FeatureExtractorResource_ImplBase . PARAM_UNIQUE_EXTRACTOR_NAME ) ; params . add ( id ) ; TcFeature tcFeature = new TcFeature ( featureName , id , params . toArray ( ) ) ; return tcFeature ; }
public void close ( ) { Preconditions . checkState ( channel != null , STRING ) ; try { if ( channel . isOpen ( ) ) channel . close ( ) ; } catch ( IOException e ) { LOGGER . error ( STRING , path , e ) ; } finally { channel = null ; } }
public void initPresentation ( ) { createHelpWindow ( ) ; }
public void initPresentation ( ) { createHelpWindow ( ) ; }
public void initPresentation ( ) { createHelpWindow ( ) ; }
private static boolean match ( CharSequence string , CharSequence pattern , int sNdx , int pNdx ) { int pLen = pattern . length ( ) ; if ( pLen == _NUM ) { if ( pattern . charAt ( _NUM ) == STRING ) { return _BOOL ; } } int sLen = string . length ( ) ; boolean nextIsNotWildcard = _BOOL ; while ( _BOOL ) { if ( ( sNdx >= sLen ) == _BOOL ) { while ( ( pNdx < pLen ) && ( pattern . charAt ( pNdx ) == STRING ) ) { pNdx ++ ; } return pNdx >= pLen ; } if ( pNdx >= pLen ) { return _BOOL ; } char p = pattern . charAt ( pNdx ) ; if ( nextIsNotWildcard == _BOOL ) { if ( p == STRING ) { pNdx ++ ; nextIsNotWildcard = _BOOL ; continue ; } if ( p == STRING ) { sNdx ++ ; pNdx ++ ; continue ; } if ( p == STRING ) { char pNext = _NUM ; if ( pNdx + _NUM < pLen ) { pNext = pattern . charAt ( pNdx + _NUM ) ; } if ( pNext == STRING ) { pNdx ++ ; continue ; } int i ; pNdx ++ ; for ( i = string . length ( ) ; i >= sNdx ; i -- ) { if ( match ( string , pattern , i , pNdx ) == _BOOL ) { return _BOOL ; } } return _BOOL ; } } else { nextIsNotWildcard = _BOOL ; } if ( p != string . charAt ( sNdx ) ) { return _BOOL ; } sNdx ++ ; pNdx ++ ; } }
public BackgroundPainter ( Image image , boolean fixed , boolean tile ) { m_img = image ; MediaTracker mt = new MediaTracker ( new Container ( ) ) ; mt . addImage ( m_img , _NUM ) ; try { mt . waitForID ( _NUM ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } mt . removeImage ( m_img , _NUM ) ; m_fixed = fixed ; m_tiled = tile ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public TrustSource add ( File trustedCAPemFile ) { if ( trustedCAPemFile == null ) { throw new IllegalArgumentException ( STRING ) ; } String pemFileContents ; try { pemFileContents = Files . toString ( trustedCAPemFile , Charset . forName ( STRING ) ) ; } catch ( IOException e ) { throw new UncheckedIOException ( STRING + trustedCAPemFile . getAbsolutePath ( ) , e ) ; } return add ( pemFileContents ) ; }
public void parseCommandLine ( String [ ] args ) { String language = DEFAULT_LANGUAGE ; String country = DEFAULT_COUNTRY ; if ( args != null ) { for ( String arg : args ) { if ( arg . startsWith ( ARG_STRING ) ) { String locale = arg . substring ( ARG_STRING . length ( ) ) ; String [ ] components = locale . split ( STRING ) ; if ( components . length == _NUM ) { language = components [ _NUM ] ; country = components [ _NUM ] ; } } } } currentLocale = new Locale ( language , country ) ; }
public void run ( ) throws Exception { Logger log = LoggerFactory . getLogger ( RemoteServerExample . class ) ; SchedulerFactory sf = new StdSchedulerFactory ( ) ; Scheduler sched = sf . getScheduler ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; log . info ( STRING ) ; sched . start ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; try { Thread . sleep ( _NUM * _NUM ) ; } catch ( Exception e ) { } log . info ( STRING ) ; sched . shutdown ( _BOOL ) ; log . info ( STRING ) ; SchedulerMetaData metaData = sched . getMetaData ( ) ; log . info ( STRING + metaData . getNumberOfJobsExecuted ( ) + STRING ) ; }
public void run ( ) throws Exception { Logger log = LoggerFactory . getLogger ( RemoteServerExample . class ) ; SchedulerFactory sf = new StdSchedulerFactory ( ) ; Scheduler sched = sf . getScheduler ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; log . info ( STRING ) ; sched . start ( ) ; log . info ( STRING ) ; log . info ( STRING ) ; try { Thread . sleep ( _NUM * _NUM ) ; } catch ( Exception e ) { } log . info ( STRING ) ; sched . shutdown ( _BOOL ) ; log . info ( STRING ) ; SchedulerMetaData metaData = sched . getMetaData ( ) ; log . info ( STRING + metaData . getNumberOfJobsExecuted ( ) + STRING ) ; }
private void writeStatement ( ) throws RDFHandlerException , IOException { Statement st = statementQueue . remove ( ) ; int subjId = getValueId ( st . getSubject ( ) ) ; int predId = getValueId ( st . getPredicate ( ) ) ; int objId = getValueId ( st . getObject ( ) ) ; int contextId = getValueId ( st . getContext ( ) ) ; decValueFreq ( st . getSubject ( ) ) ; decValueFreq ( st . getPredicate ( ) ) ; decValueFreq ( st . getObject ( ) ) ; decValueFreq ( st . getContext ( ) ) ; out . writeByte ( STATEMENT ) ; writeValueOrId ( st . getSubject ( ) , subjId ) ; writeValueOrId ( st . getPredicate ( ) , predId ) ; writeValueOrId ( st . getObject ( ) , objId ) ; writeValueOrId ( st . getContext ( ) , contextId ) ; }
private static HashMap < String , Field > buildFieldCache ( Class < ? > cls ) { final HashMap < String , Field > cache = new HashMap < > ( ) ; final List < Field > fields = getAllFields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference refAnn = fld . getAnnotation ( Reference . class ) ; if ( refAnn != null ) name = selectColumnName ( refAnn , fld ) ; if ( name == null ) { final Column colAnn = fld . getAnnotation ( Column . class ) ; if ( colAnn != null ) name = selectColumnName ( colAnn , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
private static HashMap < String , Field > buildFieldCache ( Class < ? > cls ) { final HashMap < String , Field > cache = new HashMap < > ( ) ; final List < Field > fields = getAllFields ( cls ) ; for ( Field fld : fields ) { String name = null ; final Reference refAnn = fld . getAnnotation ( Reference . class ) ; if ( refAnn != null ) name = selectColumnName ( refAnn , fld ) ; if ( name == null ) { final Column colAnn = fld . getAnnotation ( Column . class ) ; if ( colAnn != null ) name = selectColumnName ( colAnn , fld ) ; } if ( name == null ) continue ; cache . put ( name , fld ) ; } return cache ; }
private double innerProduct ( Instance i1 , Instance i2 ) throws Exception { double result = _NUM ; int n1 = i1 . numValues ( ) ; int n2 = i2 . numValues ( ) ; int classIndex = m_Train . classIndex ( ) ; for ( int p1 = _NUM , p2 = _NUM ; p1 < n1 && p2 < n2 ; ) { int ind1 = i1 . index ( p1 ) ; int ind2 = i2 . index ( p2 ) ; if ( ind1 == ind2 ) { if ( ind1 != classIndex ) { result += i1 . valueSparse ( p1 ) * i2 . valueSparse ( p2 ) ; } p1 ++ ; p2 ++ ; } else if ( ind1 > ind2 ) { p2 ++ ; } else { p1 ++ ; } } result += _NUM ; if ( m_Exponent != _NUM ) { return Math . pow ( result , m_Exponent ) ; } else { return result ; } }
private static JFreeChart createChart ( ) { Number [ ] [ ] data = new Integer [ ] [ ] { { new Integer ( - _NUM ) , new Integer ( - _NUM ) } , { new Integer ( - _NUM ) , new Integer ( _NUM ) } , { new Integer ( _NUM ) , new Integer ( _NUM ) } } ; CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING , STRING , data ) ; return ChartFactory . createStackedBarChart3D ( STRING , STRING , STRING , dataset , PlotOrientation . HORIZONTAL , _BOOL , _BOOL , _BOOL ) ; }
@ Override public boolean containsKey ( Object key ) { if ( key == null ) { return entryForNullKey != null ; } int hash = key . hashCode ( ) ; hash ^= ( hash > > > _NUM ) ^ ( hash > > > _NUM ) ; hash ^= ( hash > > > _NUM ) ^ ( hash > > > _NUM ) ; HashMapEntry < K , V > [ ] tab = table ; for ( HashMapEntry < K , V > e = tab [ hash & ( tab . length - _NUM ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public boolean containsKey ( Object key ) { if ( key == null ) { return entryForNullKey != null ; } int hash = key . hashCode ( ) ; hash ^= ( hash > > > _NUM ) ^ ( hash > > > _NUM ) ; hash ^= ( hash > > > _NUM ) ^ ( hash > > > _NUM ) ; HashMapEntry < K , V > [ ] tab = table ; for ( HashMapEntry < K , V > e = tab [ hash & ( tab . length - _NUM ) ] ; e != null ; e = e . next ) { K eKey = e . key ; if ( eKey == key || ( e . hash == hash && key . equals ( eKey ) ) ) { return _BOOL ; } } return _BOOL ; }
static void appendLangItem ( XMPNode arrayNode , String itemLang , String itemValue ) throws XMPException { XMPNode newItem = new XMPNode ( ARRAY_ITEM_NAME , itemValue , null ) ; XMPNode langQual = new XMPNode ( XML_LANG , itemLang , null ) ; newItem . addQualifier ( langQual ) ; if ( ! X_DEFAULT . equals ( langQual . getValue ( ) ) ) { arrayNode . addChild ( newItem ) ; } else { arrayNode . addChild ( _NUM , newItem ) ; } }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
@ Override public void incrementAccessCount ( ) { accessCount . incrementAndGet ( ) ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
MyDCReceiver ( DirectChannelListener up ) { upCall = up ; }
public void mouseReleased ( final MouseEvent mouseEvent ) { if ( drawingWalls ) { setWallPoint2 ( mouseEvent . getPoint ( ) ) ; draggingPoint = null ; } }
public static String [ ] addStringToArray ( String [ ] array , String str ) { if ( ObjectUtils . isEmpty ( array ) ) { return new String [ ] { str } ; } String [ ] newArr = new String [ array . length + _NUM ] ; System . arraycopy ( array , _NUM , newArr , _NUM , array . length ) ; newArr [ array . length ] = str ; return newArr ; }
public static String [ ] addStringToArray ( String [ ] array , String str ) { if ( ObjectUtils . isEmpty ( array ) ) { return new String [ ] { str } ; } String [ ] newArr = new String [ array . length + _NUM ] ; System . arraycopy ( array , _NUM , newArr , _NUM , array . length ) ; newArr [ array . length ] = str ; return newArr ; }
protected void processOwningMappingKeys ( OneToOneMapping mapping ) { if ( derivesId ( ) ) { processForeignKeyRelationship ( mapping ) ; if ( hasMapsId ( ) ) { processMapsId ( mapping ) ; } else { processId ( mapping ) ; } } else if ( isOneToOnePrimaryKeyRelationship ( ) ) { processOneToOnePrimaryKeyRelationship ( mapping ) ; } else if ( hasJoinTable ( ) ) { mapping . setRelationTableMechanism ( new RelationTableMechanism ( ) ) ; processJoinTable ( mapping , mapping . getRelationTableMechanism ( ) , getJoinTableMetadata ( ) ) ; } else { processForeignKeyRelationship ( mapping ) ; } }
public static boolean gitGlobalConfig ( final AtomicReference < String > path ) { final String GlobalConfigFileName = STRING ; path . set ( null ) ; String globalPath = Path . combine ( Environment . getFolderPath ( Environment . SpecialFolder . UserProfile ) , GlobalConfigFileName ) ; if ( Path . fileExists ( globalPath ) ) { path . set ( globalPath ) ; } return path . get ( ) != null ; }
public void createLogPanel ( ) { if ( logPanel == null ) { TextBox t = new TextBox ( STRING , null , _NUM , TextField . ANY ) ; t . addCommand ( cancel ) ; t . setCommandListener ( this ) ; logPanel = t ; } }
public void createLogPanel ( ) { if ( logPanel == null ) { TextBox t = new TextBox ( STRING , null , _NUM , TextField . ANY ) ; t . addCommand ( cancel ) ; t . setCommandListener ( this ) ; logPanel = t ; } }
public void createLogPanel ( ) { if ( logPanel == null ) { TextBox t = new TextBox ( STRING , null , _NUM , TextField . ANY ) ; t . addCommand ( cancel ) ; t . setCommandListener ( this ) ; logPanel = t ; } }
public void createLogPanel ( ) { if ( logPanel == null ) { TextBox t = new TextBox ( STRING , null , _NUM , TextField . ANY ) ; t . addCommand ( cancel ) ; t . setCommandListener ( this ) ; logPanel = t ; } }
public List < C > instantiateClasses ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new ArrayList < > ( ) ; if ( getValue ( ) == null ) { config . reportError ( new UnusedParameterException ( STRING + getName ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : getValue ( ) ) { try { C instance = ClassGenericsUtil . tryInstantiate ( restrictionClass , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . reportError ( new WrongParameterValueException ( this , cls . getName ( ) , e ) ) ; } } return instances ; }
public List < C > instantiateClasses ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new ArrayList < > ( ) ; if ( getValue ( ) == null ) { config . reportError ( new UnusedParameterException ( STRING + getName ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : getValue ( ) ) { try { C instance = ClassGenericsUtil . tryInstantiate ( restrictionClass , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . reportError ( new WrongParameterValueException ( this , cls . getName ( ) , e ) ) ; } } return instances ; }
public List < C > instantiateClasses ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new ArrayList < > ( ) ; if ( getValue ( ) == null ) { config . reportError ( new UnusedParameterException ( STRING + getName ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : getValue ( ) ) { try { C instance = ClassGenericsUtil . tryInstantiate ( restrictionClass , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . reportError ( new WrongParameterValueException ( this , cls . getName ( ) , e ) ) ; } } return instances ; }
public List < C > instantiateClasses ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new ArrayList < > ( ) ; if ( getValue ( ) == null ) { config . reportError ( new UnusedParameterException ( STRING + getName ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : getValue ( ) ) { try { C instance = ClassGenericsUtil . tryInstantiate ( restrictionClass , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . reportError ( new WrongParameterValueException ( this , cls . getName ( ) , e ) ) ; } } return instances ; }
public List < C > instantiateClasses ( Parameterization config ) { config = config . descend ( this ) ; List < C > instances = new ArrayList < > ( ) ; if ( getValue ( ) == null ) { config . reportError ( new UnusedParameterException ( STRING + getName ( ) + STRING ) ) ; return instances ; } for ( Class < ? extends C > cls : getValue ( ) ) { try { C instance = ClassGenericsUtil . tryInstantiate ( restrictionClass , cls , config ) ; instances . add ( instance ) ; } catch ( Exception e ) { config . reportError ( new WrongParameterValueException ( this , cls . getName ( ) , e ) ) ; } } return instances ; }
public void run ( ) { if ( isTransient ) { throw new RuntimeException ( STRING ) ; } lock . lock ( ) ; try { final long begin = System . currentTimeMillis ( ) ; final int i = ( int ) snapshotCount % _NUM ; final File file = new File ( dataDir , BASENAME + i + EXT ) ; if ( ! dataDir . exists ( ) ) { if ( ! dataDir . mkdirs ( ) && ! dataDir . mkdirs ( ) ) { throw new RuntimeException ( STRING + dataDir ) ; } } final long entryCount ; synchronized ( commitTimeIndex ) { entryCount = SnapshotHelper . write ( commitTimeIndex , file ) ; } snapshotCount ++ ; final long elapsed = System . currentTimeMillis ( ) - begin ; log . warn ( STRING + snapshotCount + STRING + entryCount + STRING + file + STRING + elapsed ) ; } catch ( Throwable t ) { log . error ( t . getMessage ( ) , t ) ; return ; } finally { lock . unlock ( ) ; } }
public void run ( ) { if ( isTransient ) { throw new RuntimeException ( STRING ) ; } lock . lock ( ) ; try { final long begin = System . currentTimeMillis ( ) ; final int i = ( int ) snapshotCount % _NUM ; final File file = new File ( dataDir , BASENAME + i + EXT ) ; if ( ! dataDir . exists ( ) ) { if ( ! dataDir . mkdirs ( ) && ! dataDir . mkdirs ( ) ) { throw new RuntimeException ( STRING + dataDir ) ; } } final long entryCount ; synchronized ( commitTimeIndex ) { entryCount = SnapshotHelper . write ( commitTimeIndex , file ) ; } snapshotCount ++ ; final long elapsed = System . currentTimeMillis ( ) - begin ; log . warn ( STRING + snapshotCount + STRING + entryCount + STRING + file + STRING + elapsed ) ; } catch ( Throwable t ) { log . error ( t . getMessage ( ) , t ) ; return ; } finally { lock . unlock ( ) ; } }
public static void removeObjectAtOffset ( Object [ ] sourceArray , Object [ ] destinationArray , int offset ) { System . arraycopy ( sourceArray , _NUM , destinationArray , _NUM , offset ) ; System . arraycopy ( sourceArray , offset + _NUM , destinationArray , offset , sourceArray . length - offset - _NUM ) ; }
protected JsonDeserializer < Object > _findSubclassDeserializer ( DeserializationContext ctxt , Object bean , TokenBuffer unknownTokens ) throws IOException , JsonProcessingException { JsonDeserializer < Object > subDeser ; synchronized ( this ) { subDeser = ( _subDeserializers == null ) ? null : _subDeserializers . get ( new ClassKey ( bean . getClass ( ) ) ) ; } if ( subDeser != null ) { return subDeser ; } DeserializerProvider deserProv = ctxt . getDeserializerProvider ( ) ; if ( deserProv != null ) { JavaType type = ctxt . constructType ( bean . getClass ( ) ) ; subDeser = deserProv . findValueDeserializer ( ctxt . getConfig ( ) , type , _property ) ; if ( subDeser != null ) { synchronized ( this ) { if ( _subDeserializers == null ) { _subDeserializers = new HashMap < ClassKey , JsonDeserializer < Object > > ( ) ; ; } _subDeserializers . put ( new ClassKey ( bean . getClass ( ) ) , subDeser ) ; } } } return subDeser ; }
protected JsonDeserializer < Object > _findSubclassDeserializer ( DeserializationContext ctxt , Object bean , TokenBuffer unknownTokens ) throws IOException , JsonProcessingException { JsonDeserializer < Object > subDeser ; synchronized ( this ) { subDeser = ( _subDeserializers == null ) ? null : _subDeserializers . get ( new ClassKey ( bean . getClass ( ) ) ) ; } if ( subDeser != null ) { return subDeser ; } DeserializerProvider deserProv = ctxt . getDeserializerProvider ( ) ; if ( deserProv != null ) { JavaType type = ctxt . constructType ( bean . getClass ( ) ) ; subDeser = deserProv . findValueDeserializer ( ctxt . getConfig ( ) , type , _property ) ; if ( subDeser != null ) { synchronized ( this ) { if ( _subDeserializers == null ) { _subDeserializers = new HashMap < ClassKey , JsonDeserializer < Object > > ( ) ; ; } _subDeserializers . put ( new ClassKey ( bean . getClass ( ) ) , subDeser ) ; } } } return subDeser ; }
protected JsonDeserializer < Object > _findSubclassDeserializer ( DeserializationContext ctxt , Object bean , TokenBuffer unknownTokens ) throws IOException , JsonProcessingException { JsonDeserializer < Object > subDeser ; synchronized ( this ) { subDeser = ( _subDeserializers == null ) ? null : _subDeserializers . get ( new ClassKey ( bean . getClass ( ) ) ) ; } if ( subDeser != null ) { return subDeser ; } DeserializerProvider deserProv = ctxt . getDeserializerProvider ( ) ; if ( deserProv != null ) { JavaType type = ctxt . constructType ( bean . getClass ( ) ) ; subDeser = deserProv . findValueDeserializer ( ctxt . getConfig ( ) , type , _property ) ; if ( subDeser != null ) { synchronized ( this ) { if ( _subDeserializers == null ) { _subDeserializers = new HashMap < ClassKey , JsonDeserializer < Object > > ( ) ; ; } _subDeserializers . put ( new ClassKey ( bean . getClass ( ) ) , subDeser ) ; } } } return subDeser ; }
public LibUsbException ( final int errorCode ) { super ( String . format ( STRING , - errorCode , LibUsb . strError ( errorCode ) ) ) ; this . errorCode = errorCode ; }
public LibUsbException ( final int errorCode ) { super ( String . format ( STRING , - errorCode , LibUsb . strError ( errorCode ) ) ) ; this . errorCode = errorCode ; }
private Iterable < FragmentConstructor > createConstructors ( ) { return Collections . unmodifiableList ( Arrays . asList ( new BiomeDataConstructor ( Resolution . QUARTER ) , new EndIslandsConstructor ( ) , new ImageConstructor ( Resolution . QUARTER , LayerIds . BACKGROUND ) , new ImageConstructor ( Resolution . CHUNK , LayerIds . SLIME ) ) ) ; }
public static double [ ] expandArrayD ( int bufferSize , double [ ] currentArray ) { if ( currentArray == null ) { return new double [ bufferSize * _NUM ] ; } int length = currentArray . length ; double [ ] ret = new double [ length + bufferSize * _NUM ] ; System . arraycopy ( currentArray , _NUM , ret , _NUM , length ) ; return ret ; }
public static double [ ] expandArrayD ( int bufferSize , double [ ] currentArray ) { if ( currentArray == null ) { return new double [ bufferSize * _NUM ] ; } int length = currentArray . length ; double [ ] ret = new double [ length + bufferSize * _NUM ] ; System . arraycopy ( currentArray , _NUM , ret , _NUM , length ) ; return ret ; }
public static double [ ] expandArrayD ( int bufferSize , double [ ] currentArray ) { if ( currentArray == null ) { return new double [ bufferSize * _NUM ] ; } int length = currentArray . length ; double [ ] ret = new double [ length + bufferSize * _NUM ] ; System . arraycopy ( currentArray , _NUM , ret , _NUM , length ) ; return ret ; }
public void free ( Array < T > objects ) { for ( int i = _NUM , n = Math . min ( objects . size , max - freeObjects . size ) ; i < n ; i ++ ) freeObjects . add ( objects . get ( i ) ) ; }
public void populateEditText ( ArrayList < String > matches ) { toggleSearch ( ) ; String text = STRING ; for ( int x = _NUM ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + STRING ; } text = text . trim ( ) ; setSearchString ( text ) ; search ( text ) ; }
public void populateEditText ( ArrayList < String > matches ) { toggleSearch ( ) ; String text = STRING ; for ( int x = _NUM ; x < matches . size ( ) ; x ++ ) { text = text + matches . get ( x ) + STRING ; } text = text . trim ( ) ; setSearchString ( text ) ; search ( text ) ; }
private String resetPreferredIDPCookie ( String existingCookieValue , String toAddCookieValue , boolean bIsSAML2 ) { StringBuffer returnCookie = new StringBuffer ( ) ; String encodedCookieToAdd = Base64 . encode ( generateSuccinctID ( toAddCookieValue , bIsSAML2 ) ) ; StringTokenizer st = new StringTokenizer ( existingCookieValue , IDPDiscoveryConstants . PREFERRED_COOKIE_SEPERATOR ) ; while ( st . hasMoreTokens ( ) ) { String curIdpString = ( String ) st . nextToken ( ) ; if ( curIdpString . equals ( encodedCookieToAdd ) ) { continue ; } else { returnCookie . append ( curIdpString + STRING ) ; } } returnCookie . append ( encodedCookieToAdd ) ; return returnCookie . toString ( ) ; }
private String resetPreferredIDPCookie ( String existingCookieValue , String toAddCookieValue , boolean bIsSAML2 ) { StringBuffer returnCookie = new StringBuffer ( ) ; String encodedCookieToAdd = Base64 . encode ( generateSuccinctID ( toAddCookieValue , bIsSAML2 ) ) ; StringTokenizer st = new StringTokenizer ( existingCookieValue , IDPDiscoveryConstants . PREFERRED_COOKIE_SEPERATOR ) ; while ( st . hasMoreTokens ( ) ) { String curIdpString = ( String ) st . nextToken ( ) ; if ( curIdpString . equals ( encodedCookieToAdd ) ) { continue ; } else { returnCookie . append ( curIdpString + STRING ) ; } } returnCookie . append ( encodedCookieToAdd ) ; return returnCookie . toString ( ) ; }
public static Pair < String , String > parseTitleAndDateInBrackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( _NUM ) , m . group ( _NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parseTitleAndDateInBrackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( _NUM ) , m . group ( _NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parseTitleAndDateInBrackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( _NUM ) , m . group ( _NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parseTitleAndDateInBrackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( _NUM ) , m . group ( _NUM ) ) ; } return new Pair < > ( title , null ) ; }
public static Pair < String , String > parseTitleAndDateInBrackets ( String title ) { if ( title == null ) return new Pair < > ( null , null ) ; Pattern p = Pattern . compile ( STRING , Pattern . CASE_INSENSITIVE ) ; Matcher m = p . matcher ( title ) ; if ( m . find ( ) ) { return new Pair < > ( m . group ( _NUM ) , m . group ( _NUM ) ) ; } return new Pair < > ( title , null ) ; }
public void write ( byte [ ] b , int off , int len ) { if ( SysProperties . CHECK && ( len < _NUM || len % Constants . FILE_BLOCK_SIZE != _NUM ) ) { DbException . throwInternalError ( STRING + name + STRING + len ) ; } checkWritingAllowed ( ) ; checkPowerOff ( ) ; try { FileUtils . writeFully ( file , ByteBuffer . wrap ( b , off , len ) ) ; } catch ( IOException e ) { closeFileSilently ( ) ; throw DbException . convertIOException ( e , name ) ; } filePos += len ; fileLength = Math . max ( filePos , fileLength ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
private void writeKeystore ( File configDefaults ) throws IOException { File keystoreXML = new File ( configDefaults , STRING ) ; PrintStream writer = ServerConfigUtils . open ( keystoreXML ) ; writer . print ( STRING ) ; writer . print ( genPassword ( ) ) ; writer . println ( STRING ) ; ServerConfigUtils . close ( writer ) ; }
public RefactoringSessionTransformer ( final boolean projects ) { fProjects = projects ; }
protected void drawLinearFill ( Canvas c , ILineDataSet dataSet , Transformer trans , XBounds bounds ) { final Path filled = mGenerateFilledPathBuffer ; final int startingIndex = bounds . minIndex ; final int endingIndex = bounds . indexRange + bounds . minIndex ; final int indexInterval = _NUM ; int currentStartIndex = _NUM ; int currentEndIndex = indexInterval ; int iterations = _NUM ; do { currentStartIndex = startingIndex + ( iterations * indexInterval ) ; currentEndIndex = currentStartIndex + indexInterval ; currentEndIndex = currentEndIndex > endingIndex ? endingIndex : currentEndIndex ; if ( currentStartIndex <= currentEndIndex ) { generateFilledPath ( dataSet , currentStartIndex , currentEndIndex , filled ) ; trans . pathValueToPixel ( filled ) ; final Drawable drawable = dataSet . getFillDrawable ( ) ; if ( drawable != null ) { drawFilledPath ( c , filled , drawable ) ; } else { drawFilledPath ( c , filled , dataSet . getFillColor ( ) , dataSet . getFillAlpha ( ) ) ; } } iterations ++ ; } while ( currentStartIndex <= currentEndIndex ) ; }
protected void drawLinearFill ( Canvas c , ILineDataSet dataSet , Transformer trans , XBounds bounds ) { final Path filled = mGenerateFilledPathBuffer ; final int startingIndex = bounds . minIndex ; final int endingIndex = bounds . indexRange + bounds . minIndex ; final int indexInterval = _NUM ; int currentStartIndex = _NUM ; int currentEndIndex = indexInterval ; int iterations = _NUM ; do { currentStartIndex = startingIndex + ( iterations * indexInterval ) ; currentEndIndex = currentStartIndex + indexInterval ; currentEndIndex = currentEndIndex > endingIndex ? endingIndex : currentEndIndex ; if ( currentStartIndex <= currentEndIndex ) { generateFilledPath ( dataSet , currentStartIndex , currentEndIndex , filled ) ; trans . pathValueToPixel ( filled ) ; final Drawable drawable = dataSet . getFillDrawable ( ) ; if ( drawable != null ) { drawFilledPath ( c , filled , drawable ) ; } else { drawFilledPath ( c , filled , dataSet . getFillColor ( ) , dataSet . getFillAlpha ( ) ) ; } } iterations ++ ; } while ( currentStartIndex <= currentEndIndex ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { int dim = getDimensionality ( ) ; out . writeInt ( dim ) ; for ( double aMin : min ) { out . writeDouble ( aMin ) ; } for ( double aMax : max ) { out . writeDouble ( aMax ) ; } }
private void populateSubDomainHierarchyLazy ( Space space , DimensionIndex root , Axis axis , ArrayList < DimensionIndex > result , IDomain type ) throws InterruptedException , ScopeException { Object adapter = type . getAdapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; Axis source = axis ; try { DimensionIndex self = new DimensionIndex ( null , source ) ; subdomains . add ( self ) ; } catch ( DimensionStoreException e ) { logger . error ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimensionIndexInList ( result , axis ) ) { result . add ( DimensionIndexCreationUtils . createInvalidIndex ( root , axis , STRING ) ) ; } } }
private void populateSubDomainHierarchyLazy ( Space space , DimensionIndex root , Axis axis , ArrayList < DimensionIndex > result , IDomain type ) throws InterruptedException , ScopeException { Object adapter = type . getAdapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; Axis source = axis ; try { DimensionIndex self = new DimensionIndex ( null , source ) ; subdomains . add ( self ) ; } catch ( DimensionStoreException e ) { logger . error ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimensionIndexInList ( result , axis ) ) { result . add ( DimensionIndexCreationUtils . createInvalidIndex ( root , axis , STRING ) ) ; } } }
private void populateSubDomainHierarchyLazy ( Space space , DimensionIndex root , Axis axis , ArrayList < DimensionIndex > result , IDomain type ) throws InterruptedException , ScopeException { Object adapter = type . getAdapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; Axis source = axis ; try { DimensionIndex self = new DimensionIndex ( null , source ) ; subdomains . add ( self ) ; } catch ( DimensionStoreException e ) { logger . error ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimensionIndexInList ( result , axis ) ) { result . add ( DimensionIndexCreationUtils . createInvalidIndex ( root , axis , STRING ) ) ; } } }
private void populateSubDomainHierarchyLazy ( Space space , DimensionIndex root , Axis axis , ArrayList < DimensionIndex > result , IDomain type ) throws InterruptedException , ScopeException { Object adapter = type . getAdapter ( Domain . class ) ; if ( adapter != null && adapter instanceof Domain ) { Domain target = ( Domain ) adapter ; logger . info ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; Axis source = axis ; try { DimensionIndex self = new DimensionIndex ( null , source ) ; subdomains . add ( self ) ; } catch ( DimensionStoreException e ) { logger . error ( STRING + target . toString ( ) + STRING + space . toString ( ) ) ; } } else { logger . error ( STRING ) ; if ( ! dimensionIndexInList ( result , axis ) ) { result . add ( DimensionIndexCreationUtils . createInvalidIndex ( root , axis , STRING ) ) ; } } }
public List simulate ( ) { List [ ] val = new List [ _NUM ] ; for ( int i = _NUM ; i >= _NUM ; i -- ) { Village v = forward [ i ] ; if ( v != null ) { val [ i ] = v . simulate ( ) ; } } for ( int i = _NUM ; i >= _NUM ; i -- ) { List l = val [ i ] ; if ( l != null ) { for ( Enumeration e = l . elements ( ) ; e . hasMoreElements ( ) ; ) { Patient p = ( Patient ) e . nextElement ( ) ; hospital . putInHospital ( p ) ; } } } hospital . checkPatientsInside ( returned ) ; List up = hospital . checkPatientsAssess ( this ) ; hospital . checkPatientsWaiting ( ) ; Patient p = generatePatient ( ) ; if ( p != null ) { hospital . putInHospital ( p ) ; } return up ; }
private void endCurrentBeginNewWindow ( ) throws InterruptedException { queue . put ( new EndWindowTuple ( baseSeconds | windowId ) ) ; if ( ++ checkPointWindowCount == checkpointCount ) { queue . put ( new Tuple ( MessageType . CHECKPOINT , baseSeconds | windowId ) ) ; checkPointWindowCount = _NUM ; } if ( windowId == MAX_WINDOW_ID ) { advanceWindow ( ) ; run ( ) ; } else { advanceWindow ( ) ; queue . put ( new Tuple ( MessageType . BEGIN_WINDOW , baseSeconds | windowId ) ) ; } }
public FunctionTableModel ( ) { columnList . add ( Localisation . getString ( FunctionTableModel . class , STRING ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STRING ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STRING ) ) ; columnList . add ( Localisation . getString ( FunctionTableModel . class , STRING ) ) ; }
public static boolean compareSignatures ( String plainSignature , String genericSignature ) { GenericSignatureParser plainParser = new GenericSignatureParser ( plainSignature ) ; GenericSignatureParser genericParser = new GenericSignatureParser ( genericSignature ) ; if ( plainParser . getNumParameters ( ) != genericParser . getNumParameters ( ) ) { return _BOOL ; } return _BOOL ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
private int insertUnassignedGroup ( ) throws SQLException { PreparedStatement groupStatement ; final int ruleid = insertUnassignedRule ( ) ; final int evaluationOrder = getNumOfGroups ( ) + _NUM ; String unassignedGroupSqlStatement = STRING + GROUPS_TABLE + STRING + STRING + STRING ; unassignedGroupSqlStatement = String . format ( unassignedGroupSqlStatement , UNASSIGNED_GROUP , UNASSIGNED_GROUP_TYPE , UNASSIGNED_DATA_TYPE , ruleid , evaluationOrder ) ; groupStatement = prepareStatement ( unassignedGroupSqlStatement , new String [ ] { STRING } ) ; groupStatement . execute ( ) ; return getInternalId ( groupStatement ) ; }
public void add ( String name , Object ... args ) { list . add ( Parameterization . create ( name , args ) ) ; }
DefaultShellFolder ( ShellFolder parent , File f ) { super ( parent , f . getAbsolutePath ( ) ) ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public CharSequence subSequence ( int start , int end ) { return substring ( start , end ) ; }
public void writeField ( final String name , final char value ) throws java . io . IOException { writeField ( name , Character . toString ( value ) ) ; }
static double mypdf ( double value , double shape , double scale ) { return Math . exp ( ( shape - _NUM ) * Math . log ( value ) - value / scale - GammaFunction . logGamma ( shape ) - shape * Math . log ( scale ) ) ; }
static double mypdf ( double value , double shape , double scale ) { return Math . exp ( ( shape - _NUM ) * Math . log ( value ) - value / scale - GammaFunction . logGamma ( shape ) - shape * Math . log ( scale ) ) ; }
public boolean isReflectedEdge ( StmtEdge < SootMethod > e ) { return reflectedEdges . contains ( e ) ; }
public void testConstructorSignBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; int aSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public void testConstructorSignBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; int aSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public void testConstructorSignBytesPositive1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; int aSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , aNumber . signum ( ) ) ; }
public static String extractGroupName ( String groupName ) { Pattern p = Pattern . compile ( STRING ) ; Matcher matcher = p . matcher ( groupName ) ; if ( matcher . matches ( ) ) { return matcher . group ( _NUM ) ; } return groupName ; }
public static String extractGroupName ( String groupName ) { Pattern p = Pattern . compile ( STRING ) ; Matcher matcher = p . matcher ( groupName ) ; if ( matcher . matches ( ) ) { return matcher . group ( _NUM ) ; } return groupName ; }
protected Class findClass ( String name ) throws ClassNotFoundException { ClassManagerImpl bcm = ( ClassManagerImpl ) getClassManager ( ) ; ClassLoader cl = bcm . getLoaderForClass ( name ) ; Class c ; if ( cl != null && cl != this ) try { return cl . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { throw new ClassNotFoundException ( STRING + e ) ; } if ( getURLs ( ) . length > _NUM ) try { return super . findClass ( name ) ; } catch ( ClassNotFoundException e ) { } cl = bcm . getBaseLoader ( ) ; if ( cl != null && cl != this ) try { return cl . loadClass ( name ) ; } catch ( ClassNotFoundException e ) { } return bcm . plainClassForName ( name ) ; }
@ Override public int following ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; if ( cachedBreakPositions == null || offset < cachedBreakPositions [ _NUM ] || offset >= cachedBreakPositions [ cachedBreakPositions . length - _NUM ] ) { cachedBreakPositions = null ; return super . following ( offset ) ; } else { positionInCache = _NUM ; while ( positionInCache < cachedBreakPositions . length && offset >= cachedBreakPositions [ positionInCache ] ) { ++ positionInCache ; } text . setIndex ( cachedBreakPositions [ positionInCache ] ) ; return text . getIndex ( ) ; } }
@ Override public int following ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; if ( cachedBreakPositions == null || offset < cachedBreakPositions [ _NUM ] || offset >= cachedBreakPositions [ cachedBreakPositions . length - _NUM ] ) { cachedBreakPositions = null ; return super . following ( offset ) ; } else { positionInCache = _NUM ; while ( positionInCache < cachedBreakPositions . length && offset >= cachedBreakPositions [ positionInCache ] ) { ++ positionInCache ; } text . setIndex ( cachedBreakPositions [ positionInCache ] ) ; return text . getIndex ( ) ; } }
public boolean userHasGivenRoleInAnyTenant ( StorageOSUser user , Role ... roles ) { if ( userHasGivenRole ( user , URI . create ( user . getTenantId ( ) ) , roles ) ) { return _BOOL ; } Map < String , Collection < String > > allSubtenantRoles = null ; for ( Role role : roles ) { if ( isRoleTenantLevel ( role . toString ( ) ) ) { if ( allSubtenantRoles == null ) { allSubtenantRoles = getSubtenantRolesForUser ( user ) ; } for ( Collection < String > subtenantRoles : allSubtenantRoles . values ( ) ) { if ( subtenantRoles . contains ( role . toString ( ) ) ) { return _BOOL ; } } } } return _BOOL ; }
public boolean userHasGivenRoleInAnyTenant ( StorageOSUser user , Role ... roles ) { if ( userHasGivenRole ( user , URI . create ( user . getTenantId ( ) ) , roles ) ) { return _BOOL ; } Map < String , Collection < String > > allSubtenantRoles = null ; for ( Role role : roles ) { if ( isRoleTenantLevel ( role . toString ( ) ) ) { if ( allSubtenantRoles == null ) { allSubtenantRoles = getSubtenantRolesForUser ( user ) ; } for ( Collection < String > subtenantRoles : allSubtenantRoles . values ( ) ) { if ( subtenantRoles . contains ( role . toString ( ) ) ) { return _BOOL ; } } } } return _BOOL ; }
private void simulateStore ( final StoreInstruction instruction ) { final int index = instruction . getNumber ( ) ; final Element elementToStore = runtimeStack . pop ( ) ; if ( elementToStore instanceof MethodHandle ) mergeMethodHandleStore ( index , ( MethodHandle ) elementToStore ) ; else mergeElementStore ( index , instruction . getVariableType ( ) , elementToStore ) ; }
private VisorCacheMetricsCollectorJob ( IgniteBiTuple < Boolean , Collection < String > > arg , boolean debug ) { super ( arg , debug ) ; }
private static int escape ( char [ ] cc , char c , int index ) { cc [ index ++ ] = STRING ; cc [ index ++ ] = Character . forDigit ( ( c > > _NUM ) & _NUM , _NUM ) ; cc [ index ++ ] = Character . forDigit ( c & _NUM , _NUM ) ; return index ; }
public void storeNewPackageOrder ( ) { List < String > packageList = new ArrayList < String > ( ) ; for ( AppInfo actApp : mInstalledApps ) { packageList . add ( actApp . packageName ) ; } mSettings . setPackageOrder ( packageList ) ; }
public void storeNewPackageOrder ( ) { List < String > packageList = new ArrayList < String > ( ) ; for ( AppInfo actApp : mInstalledApps ) { packageList . add ( actApp . packageName ) ; } mSettings . setPackageOrder ( packageList ) ; }
private String noteToString ( Repository repo , Note note ) throws MissingObjectException , IOException , UnsupportedEncodingException { ObjectLoader loader = repo . open ( note . getData ( ) ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; loader . copyTo ( baos ) ; return new String ( baos . toByteArray ( ) , STRING ) ; }
private String noteToString ( Repository repo , Note note ) throws MissingObjectException , IOException , UnsupportedEncodingException { ObjectLoader loader = repo . open ( note . getData ( ) ) ; ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; loader . copyTo ( baos ) ; return new String ( baos . toByteArray ( ) , STRING ) ; }
private void updateStatistics ( ) { long currentTime = System . currentTimeMillis ( ) ; double diffTime = currentTime - lastTime ; double diffSeed = currentSeed - lastSeed ; double diffNFE = currentNFE - lastNFE ; double percentChange = ( diffSeed + ( diffNFE / maxNFE ) ) / totalSeeds ; if ( ( diffTime > _NUM ) && ( percentChange > _NUM ) ) { statistics . addValue ( diffTime / percentChange ) ; lastTime = currentTime ; lastSeed = currentSeed ; lastNFE = currentNFE ; } }
private void updateStatistics ( ) { long currentTime = System . currentTimeMillis ( ) ; double diffTime = currentTime - lastTime ; double diffSeed = currentSeed - lastSeed ; double diffNFE = currentNFE - lastNFE ; double percentChange = ( diffSeed + ( diffNFE / maxNFE ) ) / totalSeeds ; if ( ( diffTime > _NUM ) && ( percentChange > _NUM ) ) { statistics . addValue ( diffTime / percentChange ) ; lastTime = currentTime ; lastSeed = currentSeed ; lastNFE = currentNFE ; } }
private void updateStatistics ( ) { long currentTime = System . currentTimeMillis ( ) ; double diffTime = currentTime - lastTime ; double diffSeed = currentSeed - lastSeed ; double diffNFE = currentNFE - lastNFE ; double percentChange = ( diffSeed + ( diffNFE / maxNFE ) ) / totalSeeds ; if ( ( diffTime > _NUM ) && ( percentChange > _NUM ) ) { statistics . addValue ( diffTime / percentChange ) ; lastTime = currentTime ; lastSeed = currentSeed ; lastNFE = currentNFE ; } }
@ SuppressWarnings ( STRING ) public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; if ( initialCapacity > _NUM << _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; capacity = nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= _NUM ) throw new IllegalArgumentException ( STRING + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; mask = capacity - _NUM ; hashShift = _NUM - Long . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( _NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * _NUM ) ; pushIterations = Math . max ( Math . min ( capacity , _NUM ) , ( int ) Math . sqrt ( capacity ) / _NUM ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
@ SuppressWarnings ( STRING ) public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; if ( initialCapacity > _NUM << _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; capacity = nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= _NUM ) throw new IllegalArgumentException ( STRING + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; mask = capacity - _NUM ; hashShift = _NUM - Long . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( _NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * _NUM ) ; pushIterations = Math . max ( Math . min ( capacity , _NUM ) , ( int ) Math . sqrt ( capacity ) / _NUM ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
@ SuppressWarnings ( STRING ) public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; if ( initialCapacity > _NUM << _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; capacity = nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= _NUM ) throw new IllegalArgumentException ( STRING + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; mask = capacity - _NUM ; hashShift = _NUM - Long . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( _NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * _NUM ) ; pushIterations = Math . max ( Math . min ( capacity , _NUM ) , ( int ) Math . sqrt ( capacity ) / _NUM ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
@ SuppressWarnings ( STRING ) public LongMap ( int initialCapacity , float loadFactor ) { if ( initialCapacity < _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; if ( initialCapacity > _NUM << _NUM ) throw new IllegalArgumentException ( STRING + initialCapacity ) ; capacity = nextPowerOfTwo ( initialCapacity ) ; if ( loadFactor <= _NUM ) throw new IllegalArgumentException ( STRING + loadFactor ) ; this . loadFactor = loadFactor ; threshold = ( int ) ( capacity * loadFactor ) ; mask = capacity - _NUM ; hashShift = _NUM - Long . numberOfTrailingZeros ( capacity ) ; stashCapacity = Math . max ( _NUM , ( int ) Math . ceil ( Math . log ( capacity ) ) * _NUM ) ; pushIterations = Math . max ( Math . min ( capacity , _NUM ) , ( int ) Math . sqrt ( capacity ) / _NUM ) ; keyTable = new long [ capacity + stashCapacity ] ; valueTable = ( V [ ] ) new Object [ keyTable . length ] ; }
public final CompletableFuture < PartitionReceiver > createReceiver ( final String consumerGroupName , final String partitionId , final String startingOffset , boolean offsetInclusive ) throws ServiceBusException { return PartitionReceiver . create ( this . underlyingFactory , this . eventHubName , consumerGroupName , partitionId , startingOffset , offsetInclusive , null , PartitionReceiver . NULL_EPOCH , _BOOL ) ; }
public final CompletableFuture < PartitionReceiver > createReceiver ( final String consumerGroupName , final String partitionId , final String startingOffset , boolean offsetInclusive ) throws ServiceBusException { return PartitionReceiver . create ( this . underlyingFactory , this . eventHubName , consumerGroupName , partitionId , startingOffset , offsetInclusive , null , PartitionReceiver . NULL_EPOCH , _BOOL ) ; }
public final CompletableFuture < PartitionReceiver > createReceiver ( final String consumerGroupName , final String partitionId , final String startingOffset , boolean offsetInclusive ) throws ServiceBusException { return PartitionReceiver . create ( this . underlyingFactory , this . eventHubName , consumerGroupName , partitionId , startingOffset , offsetInclusive , null , PartitionReceiver . NULL_EPOCH , _BOOL ) ; }
public String putImage ( String theFolder , String theImageName , Bitmap theBitmap ) { if ( theFolder == null || theImageName == null || theBitmap == null ) return null ; this . DEFAULT_APP_IMAGEDATA_DIRECTORY = theFolder ; String mFullPath = setupFullPath ( theImageName ) ; if ( ! mFullPath . equals ( STRING ) ) { lastImagePath = mFullPath ; saveBitmap ( mFullPath , theBitmap ) ; } return mFullPath ; }
public boolean requiredResourceName ( Policy policy , String realmName , String name ) { getSvcTypeNameToActionsMap ( policy , realmName ) ; return requiredResourceNameService . contains ( name ) ; }
public boolean requiredResourceName ( Policy policy , String realmName , String name ) { getSvcTypeNameToActionsMap ( policy , realmName ) ; return requiredResourceNameService . contains ( name ) ; }
public Cursor newCursor ( String storeName ) throws UnknownStoreException { IStore < ByteArray , byte [ ] > store = getStore ( storeName ) ; int cursorId = rpcService . getTransactionId ( ) ; Cursor cursor = new Cursor ( cursorId , store . entries ( ) ) ; cursorMap . put ( Integer . valueOf ( cursorId ) , cursor ) ; return cursor ; }
public String validationForBifurcation ( final PropertyImpl propertyModel , final BasicProperty basicProperty , final String reason ) { final List < PropertyStatusValues > children = propertyStatusValuesDAO . getPropertyStatusValuesByReferenceBasicProperty ( basicProperty ) ; final Boolean parentBifurcated = isPropertyBifurcated ( basicProperty ) ; final Boolean childrenCreated = ! children . isEmpty ( ) ; String errorMsg = null ; if ( PROPERTY_MODIFY_REASON_BIFURCATE . equalsIgnoreCase ( reason ) ) { if ( parentBifurcated && ! childrenCreated ) errorMsg = STRING ; } else if ( PROPERTY_MODIFY_REASON_ADD_OR_ALTER . equalsIgnoreCase ( reason ) ) { if ( ! childrenCreated ) { if ( parentBifurcated ) errorMsg = STRING ; } else if ( ! parentBifurcated ) errorMsg = STRING ; } else if ( PROP_CREATE_RSN_BIFUR . equals ( reason ) ) if ( parentBifurcated ) getLatestHistoryProperty ( basicProperty . getUpicNo ( ) ) ; else basicProperty . getActiveProperty ( ) ; return errorMsg ; }
public ShortComponentRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public ShortComponentRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public static String indent ( int indent ) { StringBuffer s = new StringBuffer ( ) ; for ( int i = _NUM ; i < indent ; i ++ ) { s . append ( STRING ) ; } return s . toString ( ) ; }
private void checkOutdatedMovieDetails ( Cursor cursor ) { if ( hasIssuedOutdatedRefresh ) return ; cursor . moveToFirst ( ) ; long lastUpdated = cursor . getLong ( MovieDetailsQuery . UPDATED ) ; if ( System . currentTimeMillis ( ) > lastUpdated + Settings . DB_UPDATE_INTERVAL ) { hasIssuedOutdatedRefresh = _BOOL ; startSync ( _BOOL ) ; } }
private void checkOutdatedMovieDetails ( Cursor cursor ) { if ( hasIssuedOutdatedRefresh ) return ; cursor . moveToFirst ( ) ; long lastUpdated = cursor . getLong ( MovieDetailsQuery . UPDATED ) ; if ( System . currentTimeMillis ( ) > lastUpdated + Settings . DB_UPDATE_INTERVAL ) { hasIssuedOutdatedRefresh = _BOOL ; startSync ( _BOOL ) ; } }
private PieData generateDataPie ( int cnt ) { ArrayList < Entry > entries = new ArrayList < Entry > ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries . add ( new Entry ( ( int ) ( Math . random ( ) * _NUM ) + _NUM , i ) ) ; } PieDataSet d = new PieDataSet ( entries , STRING ) ; d . setSliceSpace ( _NUM ) ; d . setColors ( ColorTemplate . VORDIPLOM_COLORS ) ; PieData cd = new PieData ( getQuarters ( ) , d ) ; return cd ; }
public String nodeLabel ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public String nodeLabel ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public String nodeLabel ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public String nodeLabel ( ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( alpha ) ) ; sb . append ( STRING ) ; sb . append ( Formatter . convert ( beta ) ) ; if ( set ) { sb . append ( STRING ) ; sb . append ( Formatter . convert ( value ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public char [ ] readPassword ( ) { synchronized ( CONSOLE_LOCK ) { int previousState = setEcho ( _BOOL , _NUM ) ; try { String password = readLine ( ) ; writer . println ( ) ; return ( password == null ) ? null : password . toCharArray ( ) ; } finally { setEcho ( _BOOL , previousState ) ; } } }
public static void deleteFileTreeWithRetry ( Path dir ) throws IOException { IOException ioe = null ; final List < IOException > excs = deleteFileTreeUnchecked ( dir ) ; if ( ! excs . isEmpty ( ) ) { ioe = excs . remove ( _NUM ) ; for ( IOException x : excs ) ioe . addSuppressed ( x ) ; } if ( ioe != null ) throw ioe ; }
public Messages ( String name ) { this ( ( Messages ) null , name ) ; }
public Messages ( String name ) { this ( ( Messages ) null , name ) ; }
public String toString ( ) { return label . toString ( ) ; }
public String toString ( ) { return label . toString ( ) ; }
public String toString ( ) { return label . toString ( ) ; }
public String toString ( ) { return label . toString ( ) ; }
public StrBuilder deleteFirst ( String str ) { int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public StrBuilder deleteFirst ( String str ) { int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public StrBuilder deleteFirst ( String str ) { int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; if ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; } } return this ; }
public void add ( long start , long end , SequenceNameLocus region ) { if ( mSize == mStarts . length ) { final int newLen = mStarts . length * _NUM / _NUM + _NUM ; mStarts = Arrays . copyOf ( mStarts , newLen ) ; mEnds = Arrays . copyOf ( mEnds , newLen ) ; mRegions = Arrays . copyOf ( mRegions , newLen ) ; } mStarts [ mSize ] = start ; mEnds [ mSize ] = end ; mRegions [ mSize ] = region ; mSize ++ ; }
public static String dateToHeaderString ( Date dat ) { SimpleDateFormat fmt = new SimpleDateFormat ( HTTP_FORMAT , Locale . US ) ; fmt . setTimeZone ( GMT_ZONE ) ; return ( fmt . format ( dat ) ) ; }
public static String dateToHeaderString ( Date dat ) { SimpleDateFormat fmt = new SimpleDateFormat ( HTTP_FORMAT , Locale . US ) ; fmt . setTimeZone ( GMT_ZONE ) ; return ( fmt . format ( dat ) ) ; }
public void addMouseListener ( GlobalMouseListener listener ) { listeners . add ( listener ) ; }
private static long freeSpaceCalculation ( String path ) { StatFs stat = new StatFs ( path ) ; long blockSize = stat . getBlockSize ( ) ; long availableBlocks = stat . getAvailableBlocks ( ) ; return availableBlocks * blockSize / _NUM ; }
public static List < URI > ensureOneSnapshotPerReplicationGroup ( List < URI > snapshotURIs , DbClient dbClient ) { List < URI > filteredSnapshotURIs = new ArrayList < > ( ) ; Set < String > replicationGroups = new HashSet < > ( ) ; Iterator < BlockSnapshot > snapshotIter = dbClient . queryIterativeObjects ( BlockSnapshot . class , snapshotURIs ) ; while ( snapshotIter . hasNext ( ) ) { BlockSnapshot snapshot = snapshotIter . next ( ) ; String repGrpInstance = snapshot . getReplicationGroupInstance ( ) ; if ( replicationGroups . contains ( repGrpInstance ) ) { continue ; } replicationGroups . add ( repGrpInstance ) ; filteredSnapshotURIs . add ( snapshot . getId ( ) ) ; } return filteredSnapshotURIs ; }
public MVMap < K , V > openVersion ( long version ) { if ( readOnly ) { throw DataUtils . newUnsupportedOperationException ( STRING + STRING ) ; } DataUtils . checkArgument ( version >= createVersion , STRING , version , createVersion ) ; Page newest = null ; Page r = root ; if ( version >= r . getVersion ( ) && ( version == writeVersion || r . getVersion ( ) >= _NUM || version <= createVersion || store . getFileStore ( ) == null ) ) { newest = r ; } else { Page last = oldRoots . peekFirst ( ) ; if ( last == null || version < last . getVersion ( ) ) { return store . openMapVersion ( version , id , this ) ; } Iterator < Page > it = oldRoots . iterator ( ) ; while ( it . hasNext ( ) ) { Page p = it . next ( ) ; if ( p . getVersion ( ) > version ) { break ; } last = p ; } newest = last ; } MVMap < K , V > m = openReadOnly ( ) ; m . root = newest ; return m ; }
@ SuppressLint ( STRING ) public LongHashSet ( LongHashSet map ) { m_mask = map . m_mask ; m_fillFactor = map . m_fillFactor ; m_threshold = map . m_threshold ; m_size = map . m_size ; m_hasFreeKey = map . m_hasFreeKey ; if ( Build . VERSION . SDK_INT >= Build . VERSION_CODES . GINGERBREAD ) { m_data = Arrays . copyOf ( map . m_data , map . m_data . length ) ; } else { m_data = new long [ map . m_data . length ] ; System . arraycopy ( map . m_data , _NUM , m_data , _NUM , m_data . length ) ; } }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
@ Override public boolean equals ( Object o ) { if ( o == null ) { return _BOOL ; } if ( ! ( o instanceof Collection ) ) { return _BOOL ; } final Collection < ? > other = ( Collection < ? > ) o ; final Iterator < ? > self_iter = iterator ( ) ; final Iterator < ? > othr_iter = other . iterator ( ) ; while ( self_iter . hasNext ( ) && othr_iter . hasNext ( ) ) { if ( ! Objects . equals ( self_iter . next ( ) , othr_iter . next ( ) ) ) return _BOOL ; } return ! ( self_iter . hasNext ( ) || othr_iter . hasNext ( ) ) ; }
public MockResponse clearHeaders ( ) { headers . clear ( ) ; return this ; }
public static boolean pointOutsidePrefSize ( JTable table , int row , int column , Point p ) { if ( table . convertColumnIndexToModel ( column ) != _NUM || row == - _NUM ) { return _BOOL ; } TableCellRenderer tcr = table . getCellRenderer ( row , column ) ; Object value = table . getValueAt ( row , column ) ; Component cell = tcr . getTableCellRendererComponent ( table , value , _BOOL , _BOOL , row , column ) ; Dimension itemSize = cell . getPreferredSize ( ) ; Rectangle cellBounds = table . getCellRect ( row , column , _BOOL ) ; cellBounds . width = itemSize . width ; cellBounds . height = itemSize . height ; assert ( p . x >= cellBounds . x && p . y >= cellBounds . y ) ; return p . x > cellBounds . x + cellBounds . width || p . y > cellBounds . y + cellBounds . height ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + getStemmerList ( _NUM , STRING ) , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + getStemmerList ( _NUM , STRING ) , STRING , _NUM , STRING ) ) ; return result . elements ( ) ; }
private void paintUpperThumb ( Graphics g ) { Rectangle knobBounds = upperThumbRect ; int w = knobBounds . width ; int h = knobBounds . height ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; Shape thumbShape = createThumbShape ( w - _NUM , h - _NUM , _BOOL ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( knobBounds . x , knobBounds . y ) ; g2d . setColor ( Color . LIGHT_GRAY ) ; g2d . fill ( thumbShape ) ; g2d . setColor ( Color . GRAY ) ; g2d . draw ( thumbShape ) ; g2d . dispose ( ) ; }
private void paintUpperThumb ( Graphics g ) { Rectangle knobBounds = upperThumbRect ; int w = knobBounds . width ; int h = knobBounds . height ; Graphics2D g2d = ( Graphics2D ) g . create ( ) ; Shape thumbShape = createThumbShape ( w - _NUM , h - _NUM , _BOOL ) ; g2d . setRenderingHint ( RenderingHints . KEY_ANTIALIASING , RenderingHints . VALUE_ANTIALIAS_ON ) ; g2d . translate ( knobBounds . x , knobBounds . y ) ; g2d . setColor ( Color . LIGHT_GRAY ) ; g2d . fill ( thumbShape ) ; g2d . setColor ( Color . GRAY ) ; g2d . draw ( thumbShape ) ; g2d . dispose ( ) ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
SortedSet < String > typesToImport ( ) { SortedSet < String > typesToImport = new TreeSet < String > ( ) ; for ( Map . Entry < String , Spelling > entry : imports . entrySet ( ) ) { if ( entry . getValue ( ) . importIt ) { typesToImport . add ( entry . getKey ( ) ) ; } } return typesToImport ; }
public static boolean save ( File file , String content ) { boolean result ; BufferedWriter writer ; writer = null ; try { writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( content ) ; writer . flush ( ) ; result = _BOOL ; } catch ( Exception e ) { e . printStackTrace ( ) ; result = _BOOL ; } finally { if ( writer != null ) { try { writer . close ( ) ; } catch ( Exception e ) { } } } return result ; }
public void addModel ( NavigationModel other ) { for ( Group group : other . getGroups ( ) ) { addGroup ( group ) ; } for ( View view : other . getViews ( ) ) { addView ( view ) ; } }
public void addModel ( NavigationModel other ) { for ( Group group : other . getGroups ( ) ) { addGroup ( group ) ; } for ( View view : other . getViews ( ) ) { addView ( view ) ; } }
public void addModel ( NavigationModel other ) { for ( Group group : other . getGroups ( ) ) { addGroup ( group ) ; } for ( View view : other . getViews ( ) ) { addView ( view ) ; } }
public static DigitalOutput digitalOutput ( int port ) { return dioRegistrar . fetch ( port , DigitalOutput . class , null ) ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public static String normalizeRequestUri ( HttpServletRequest httpRequest ) { String retVal = httpRequest . getRequestURI ( ) ; String contextPath = httpRequest . getContextPath ( ) ; if ( retVal . startsWith ( contextPath ) ) { retVal = retVal . substring ( contextPath . length ( ) ) ; } String servletPath = httpRequest . getServletPath ( ) ; if ( retVal . startsWith ( servletPath ) ) { retVal = retVal . substring ( servletPath . length ( ) ) ; } return retVal ; }
public boolean removeAll ( ) { lock . lock ( ) ; try { if ( cookieJar . isEmpty ( ) ) { return _BOOL ; } cookieJar . clear ( ) ; domainIndex . clear ( ) ; uriIndex . clear ( ) ; } finally { lock . unlock ( ) ; } return _BOOL ; }
public boolean removeAll ( ) { lock . lock ( ) ; try { if ( cookieJar . isEmpty ( ) ) { return _BOOL ; } cookieJar . clear ( ) ; domainIndex . clear ( ) ; uriIndex . clear ( ) ; } finally { lock . unlock ( ) ; } return _BOOL ; }
public void add ( double x , double y ) { if ( len == data . length ) { data = Arrays . copyOf ( data , len << _NUM ) ; } data [ len ++ ] = x ; data [ len ++ ] = y ; minx = Math . min ( minx , x ) ; maxx = Math . max ( maxx , x ) ; miny = Math . min ( miny , y ) ; maxy = Math . max ( maxy , y ) ; }
public void makeImmutable ( ) { if ( ! mutable ) { return ; } mutable = _BOOL ; if ( ( content != null ) && ( ! content . isEmpty ( ) ) ) { content = Collections . unmodifiableList ( content ) ; } }
private void skipEntry ( ) throws ParsingException , IOException { while ( lookahead != STRING ) { switch ( lookahead ) { case StreamTokenizer . TT_NUMBER : throw new ParsingException ( st . lineno ( ) , STRING , ResourcesMgr . getString ( STRING ) + String . valueOf ( st . nval ) ) ; case StreamTokenizer . TT_EOF : throw new ParsingException ( ResourcesMgr . getString ( STRING ) ) ; default : lookahead = st . nextToken ( ) ; } } }
private void skipEntry ( ) throws ParsingException , IOException { while ( lookahead != STRING ) { switch ( lookahead ) { case StreamTokenizer . TT_NUMBER : throw new ParsingException ( st . lineno ( ) , STRING , ResourcesMgr . getString ( STRING ) + String . valueOf ( st . nval ) ) ; case StreamTokenizer . TT_EOF : throw new ParsingException ( ResourcesMgr . getString ( STRING ) ) ; default : lookahead = st . nextToken ( ) ; } } }
private void skipEntry ( ) throws ParsingException , IOException { while ( lookahead != STRING ) { switch ( lookahead ) { case StreamTokenizer . TT_NUMBER : throw new ParsingException ( st . lineno ( ) , STRING , ResourcesMgr . getString ( STRING ) + String . valueOf ( st . nval ) ) ; case StreamTokenizer . TT_EOF : throw new ParsingException ( ResourcesMgr . getString ( STRING ) ) ; default : lookahead = st . nextToken ( ) ; } } }
public void writeLine ( float [ ] column ) { String str = Float . toString ( column [ _NUM ] ) ; for ( int i = _NUM ; i < column . length ; ++ i ) { str += STRING + column [ i ] ; } writer . println ( str ) ; }
public static void sendCurrentWarning ( Object source , Throwable e ) { WarningSystem warning = getCurrent ( ) ; if ( warning != null ) warning . sendWarning ( source , e ) ; else { e . printStackTrace ( ) ; log . log ( Level . WARNING , e . toString ( ) , e ) ; } }
void startPrediction ( ) { timeStamp = System . currentTimeMillis ( ) ; }
public void removeTrackingIcon ( Object tag ) { if ( trackingIcons != null && trackingIcons . remove ( tag ) ) { repaint ( ) ; } }
protected void flagToRemoveFromMaintenanceQueue ( NodePortTuple npt ) { if ( toRemoveFromMaintenanceQueue . contains ( npt ) == _BOOL ) { toRemoveFromMaintenanceQueue . add ( npt ) ; } }
protected String readStringUTF16Z ( int addr ) { if ( addr == _NUM ) { return null ; } IMemoryReader memoryReader = MemoryReader . getMemoryReader ( addr , _NUM ) ; StringBuilder s = new StringBuilder ( ) ; while ( _BOOL ) { int char16 = memoryReader . readNext ( ) ; if ( char16 == _NUM ) { break ; } byte [ ] bytes = new byte [ _NUM ] ; bytes [ _NUM ] = ( byte ) char16 ; bytes [ _NUM ] = ( byte ) ( char16 > > _NUM ) ; s . append ( new String ( bytes , charset16 ) ) ; } return s . toString ( ) ; }
public synchronized void accessed ( Object object ) { historyList . remove ( object ) ; historyList . add ( object ) ; }
private void calculateC ( ) { int length = mSpecification . getExtremaCount ( ) - _NUM ; mIdealFrequencyResponse = new double [ length ] ; double sign = _NUM ; for ( int k = _NUM ; k < length ; k ++ ) { if ( k < mExtremalIndices . size ( ) ) { int index = mExtremalIndices . get ( k ) ; mIdealFrequencyResponse [ k ] = mGrid . getDesiredResponse ( ) [ index ] - ( sign * mDelta / mGrid . getWeight ( ) [ index ] ) ; sign = - sign ; } } }
private void calculateC ( ) { int length = mSpecification . getExtremaCount ( ) - _NUM ; mIdealFrequencyResponse = new double [ length ] ; double sign = _NUM ; for ( int k = _NUM ; k < length ; k ++ ) { if ( k < mExtremalIndices . size ( ) ) { int index = mExtremalIndices . get ( k ) ; mIdealFrequencyResponse [ k ] = mGrid . getDesiredResponse ( ) [ index ] - ( sign * mDelta / mGrid . getWeight ( ) [ index ] ) ; sign = - sign ; } } }
private Response doRSET ( SMTPSession session , String argument ) { if ( ( argument == null ) || ( argument . length ( ) == _NUM ) ) { session . resetState ( ) ; return OK ; } else { return SYNTAX_ERROR ; } }
private static boolean hasPanoPrefix ( Context context , Uri src ) { String name = getTrueFilename ( context , src ) ; return name != null && name . startsWith ( PREFIX_PANO ) ; }
private static boolean hasPanoPrefix ( Context context , Uri src ) { String name = getTrueFilename ( context , src ) ; return name != null && name . startsWith ( PREFIX_PANO ) ; }
public final void addPath ( @ NotNull AndroidStudioWizardPath path ) { myPaths . add ( path ) ; path . attachToWizard ( this ) ; myPathListIterator = new PathIterator ( myPaths ) ; }
public static Logger log ( ) { if ( nervous_system == null ) nervous_system = new Logger ( STRING , Logger . ATTR_TIME | Logger . ATTR_COLOR ) ; return nervous_system ; }
private void initScrollbar ( ) { m_scrollbar . addAdjustmentListener ( m_listener ) ; m_bottomScrollbar . addAdjustmentListener ( m_listener ) ; add ( m_scrollbar , BorderLayout . EAST ) ; add ( m_bottomScrollbar , BorderLayout . SOUTH ) ; }
private void initScrollbar ( ) { m_scrollbar . addAdjustmentListener ( m_listener ) ; m_bottomScrollbar . addAdjustmentListener ( m_listener ) ; add ( m_scrollbar , BorderLayout . EAST ) ; add ( m_bottomScrollbar , BorderLayout . SOUTH ) ; }
PBES1Core ( String cipherAlg ) throws NoSuchAlgorithmException , NoSuchPaddingException { algo = cipherAlg ; if ( algo . equals ( STRING ) ) { cipher = new CipherCore ( new DESCrypt ( ) , DESConstants . DES_BLOCK_SIZE ) ; } else if ( algo . equals ( STRING ) ) { cipher = new CipherCore ( new DESedeCrypt ( ) , DESConstants . DES_BLOCK_SIZE ) ; } else { throw new NoSuchAlgorithmException ( STRING + STRING + algo ) ; } cipher . setMode ( STRING ) ; cipher . setPadding ( STRING ) ; md = MessageDigest . getInstance ( STRING ) ; }
PBES1Core ( String cipherAlg ) throws NoSuchAlgorithmException , NoSuchPaddingException { algo = cipherAlg ; if ( algo . equals ( STRING ) ) { cipher = new CipherCore ( new DESCrypt ( ) , DESConstants . DES_BLOCK_SIZE ) ; } else if ( algo . equals ( STRING ) ) { cipher = new CipherCore ( new DESedeCrypt ( ) , DESConstants . DES_BLOCK_SIZE ) ; } else { throw new NoSuchAlgorithmException ( STRING + STRING + algo ) ; } cipher . setMode ( STRING ) ; cipher . setPadding ( STRING ) ; md = MessageDigest . getInstance ( STRING ) ; }
public abstract boolean canUserInitiateMoveFrom ( int squareId ) ;
public abstract boolean canUserInitiateMoveFrom ( int squareId ) ;
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static byte [ ] encryptPassword ( final String password , final byte [ ] seed ) throws NoSuchAlgorithmException { if ( password == null || password . equals ( STRING ) ) { return new byte [ _NUM ] ; } final MessageDigest messageDigest = MessageDigest . getInstance ( STRING ) ; final byte [ ] stage1 = messageDigest . digest ( password . getBytes ( ) ) ; messageDigest . reset ( ) ; final byte [ ] stage2 = messageDigest . digest ( stage1 ) ; messageDigest . reset ( ) ; messageDigest . update ( seed ) ; messageDigest . update ( stage2 ) ; final byte [ ] digest = messageDigest . digest ( ) ; final byte [ ] returnBytes = new byte [ digest . length ] ; for ( int i = _NUM ; i < digest . length ; i ++ ) { returnBytes [ i ] = ( byte ) ( stage1 [ i ] ^ digest [ i ] ) ; } return returnBytes ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public static boolean isSameEvent ( CalendarEventModel model , CalendarEventModel originalModel ) { if ( originalModel == null ) { return _BOOL ; } if ( model . mCalendarId != originalModel . mCalendarId ) { return _BOOL ; } if ( model . mId != originalModel . mId ) { return _BOOL ; } return _BOOL ; }
public void addEntry ( Entry e , int dataSetIndex ) { if ( e == null || dataSetIndex < _NUM || dataSetIndex >= mDataSets . size ( ) ) return ; IDataSet set = mDataSets . get ( dataSetIndex ) ; if ( ! set . addEntry ( e ) ) return ; calcMinMax ( e , set . getAxisDependency ( ) ) ; }
public void addEntry ( Entry e , int dataSetIndex ) { if ( e == null || dataSetIndex < _NUM || dataSetIndex >= mDataSets . size ( ) ) return ; IDataSet set = mDataSets . get ( dataSetIndex ) ; if ( ! set . addEntry ( e ) ) return ; calcMinMax ( e , set . getAxisDependency ( ) ) ; }
protected void addNameDefiner ( PsiElement definer ) { myDefiners . add ( definer ) ; }
protected void BuildFDArrayUsed ( int Font ) { int [ ] FDSelect = fonts [ Font ] . FDSelect ; for ( Integer glyphsInList1 : glyphsInList ) { int glyph = ( int ) glyphsInList1 ; int FD = FDSelect [ glyph ] ; FDArrayUsed . add ( FD ) ; } }
protected void BuildFDArrayUsed ( int Font ) { int [ ] FDSelect = fonts [ Font ] . FDSelect ; for ( Integer glyphsInList1 : glyphsInList ) { int glyph = ( int ) glyphsInList1 ; int FD = FDSelect [ glyph ] ; FDArrayUsed . add ( FD ) ; } }
public static String removeLast ( String input , int amount ) { if ( input . length ( ) >= amount ) { return input . substring ( _NUM , input . length ( ) - amount ) ; } else { return input ; } }
protected FileList files ( String dir ) { FileList list = new FileList ( ) ; addFiles ( list , new File ( dir ) ) ; return list ; }
private static String [ ] splitComponents ( String str ) { List < String > l = new ArrayList < > ( ) ; int last = _NUM ; int depth = _NUM ; char [ ] chars = str . toCharArray ( ) ; for ( int i = _NUM ; i < chars . length ; i ++ ) { switch ( chars [ i ] ) { case STRING : depth ++ ; break ; case STRING : depth -- ; break ; case STRING : if ( depth == _NUM ) { String s = str . substring ( last , i ) ; l . add ( s ) ; last = i + _NUM ; } break ; default : } } String s = str . substring ( last ) ; if ( s . length ( ) != _NUM ) { l . add ( s ) ; } String [ ] rc = new String [ l . size ( ) ] ; l . toArray ( rc ) ; return rc ; }
private PropertyMapping populatePropertyMapping ( ExtensionProperty ep ) { PropertyMapping pm = mapping . getField ( ep . getQualname ( ) ) ; if ( pm == null ) { pm = new PropertyMapping ( ) ; } pm . setTerm ( ep ) ; return pm ; }
private PropertyMapping populatePropertyMapping ( ExtensionProperty ep ) { PropertyMapping pm = mapping . getField ( ep . getQualname ( ) ) ; if ( pm == null ) { pm = new PropertyMapping ( ) ; } pm . setTerm ( ep ) ; return pm ; }
public boolean loadProperties ( URL url , Properties props ) { try { InputStream propsIn = url . openStream ( ) ; props . load ( propsIn ) ; return _BOOL ; } catch ( java . io . IOException e ) { return _BOOL ; } }
public boolean loadProperties ( URL url , Properties props ) { try { InputStream propsIn = url . openStream ( ) ; props . load ( propsIn ) ; return _BOOL ; } catch ( java . io . IOException e ) { return _BOOL ; } }
public final void write ( String s ) throws IOException { write ( s , _NUM , s . length ( ) ) ; }
public final void write ( String s ) throws IOException { write ( s , _NUM , s . length ( ) ) ; }
public final void write ( String s ) throws IOException { write ( s , _NUM , s . length ( ) ) ; }
protected long writeCodedValues ( final PrefixCoder coder , final IRaba raba , final Byte2Symbol byte2symbol , final long [ ] codedValueOffset , final OutputBitStream obs ) throws IOException { final int nvalues = raba . size ( ) ; if ( codedValueOffset != null ) { if ( codedValueOffset . length != nvalues + _NUM ) throw new IllegalArgumentException ( ) ; } long bitsWritten = _NUM ; for ( int i = _NUM ; i < nvalues ; i ++ ) { if ( codedValueOffset != null ) codedValueOffset [ i ] = bitsWritten ; final byte [ ] a = raba . get ( i ) ; if ( a != null ) { for ( byte b : a ) { final int symbol = byte2symbol . byte2symbol ( b ) ; if ( symbol == - _NUM ) throw new UnsupportedOperationException ( STRING + b ) ; bitsWritten += coder . encode ( symbol , obs ) ; } } } if ( codedValueOffset != null ) codedValueOffset [ nvalues ] = bitsWritten ; if ( log . isDebugEnabled ( ) ) log . debug ( STRING + Arrays . toString ( codedValueOffset ) ) ; return bitsWritten ; }
GridMemcachedMessage ( ) { }
@ edu . umd . cs . findbugs . annotations . SuppressFBWarnings ( value = STRING , justification = STRING ) protected void purgeStream ( @ Nonnull java . io . InputStream serialStream ) throws java . io . IOException { int count = serialStream . available ( ) ; log . debug ( STRING + count + STRING ) ; while ( count > _NUM ) { serialStream . skip ( count ) ; count = serialStream . available ( ) ; } }
public void selectTrack ( int index ) { selectedTrackIndex = index ; ExposedTrack selectedTrack = tracks . get ( selectedTrackIndex ) ; selectedVariantIndex = selectedTrack . defaultVariantIndex ; variants = selectedTrack . variants ; variantPlaylists = new HlsMediaPlaylist [ variants . length ] ; variantLastPlaylistLoadTimesMs = new long [ variants . length ] ; variantBlacklistTimes = new long [ variants . length ] ; }
public void put ( int key , E value ) { int i = ContainerHelpers . binarySearch ( mKeys , mSize , key ) ; if ( i >= _NUM ) { mValues [ i ] = value ; } else { i = ~ i ; if ( i < mSize && mValues [ i ] == DELETED ) { mKeys [ i ] = key ; mValues [ i ] = value ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; i = ~ ContainerHelpers . binarySearch ( mKeys , mSize , key ) ; } if ( mSize >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( mSize + _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } if ( mSize - i != _NUM ) { System . arraycopy ( mKeys , i , mKeys , i + _NUM , mSize - i ) ; System . arraycopy ( mValues , i , mValues , i + _NUM , mSize - i ) ; } mKeys [ i ] = key ; mValues [ i ] = value ; mSize ++ ; } }
public static void deleteFiles ( File [ ] files , boolean wait ) { FileDeleteTask task = new FileDeleteTask ( files ) ; if ( wait ) task . run ( ) ; else { Thread t = new Thread ( task ) ; t . start ( ) ; } }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return _BOOL ; } if ( ! super . equals ( obj ) ) { return _BOOL ; } if ( ! ( obj instanceof WaterfallBarRenderer ) ) { return _BOOL ; } WaterfallBarRenderer that = ( WaterfallBarRenderer ) obj ; if ( ! PaintUtilities . equal ( this . firstBarPaint , that . firstBarPaint ) ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . lastBarPaint , that . lastBarPaint ) ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . positiveBarPaint , that . positiveBarPaint ) ) { return _BOOL ; } if ( ! PaintUtilities . equal ( this . negativeBarPaint , that . negativeBarPaint ) ) { return _BOOL ; } return _BOOL ; }
protected static String timestr ( long time_val , long total_time ) { boolean neg ; long ms = _NUM ; long sec = _NUM ; long percent10 ; String pad ; neg = time_val < _NUM ; if ( neg ) time_val = - time_val ; ms = time_val % _NUM ; sec = time_val / _NUM ; if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else pad = STRING ; percent10 = ( time_val * _NUM ) / total_time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % _NUM ) / _NUM ) + ( ( ms % _NUM ) / _NUM ) + ( ms % _NUM ) + STRING + STRING + percent10 / _NUM + STRING + percent10 % _NUM + STRING ; }
protected static String timestr ( long time_val , long total_time ) { boolean neg ; long ms = _NUM ; long sec = _NUM ; long percent10 ; String pad ; neg = time_val < _NUM ; if ( neg ) time_val = - time_val ; ms = time_val % _NUM ; sec = time_val / _NUM ; if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else pad = STRING ; percent10 = ( time_val * _NUM ) / total_time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % _NUM ) / _NUM ) + ( ( ms % _NUM ) / _NUM ) + ( ms % _NUM ) + STRING + STRING + percent10 / _NUM + STRING + percent10 % _NUM + STRING ; }
protected static String timestr ( long time_val , long total_time ) { boolean neg ; long ms = _NUM ; long sec = _NUM ; long percent10 ; String pad ; neg = time_val < _NUM ; if ( neg ) time_val = - time_val ; ms = time_val % _NUM ; sec = time_val / _NUM ; if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else if ( sec < _NUM ) pad = STRING ; else pad = STRING ; percent10 = ( time_val * _NUM ) / total_time ; return ( neg ? STRING : STRING ) + pad + sec + STRING + ( ( ms % _NUM ) / _NUM ) + ( ( ms % _NUM ) / _NUM ) + ( ms % _NUM ) + STRING + STRING + percent10 / _NUM + STRING + percent10 % _NUM + STRING ; }
private void mergeReleased ( List < Segment > segments , List < OffsetPredicate > predicates , Segment compactSegment ) { for ( int i = _NUM ; i < segments . size ( ) ; i ++ ) { mergeReleasedEntries ( segments . get ( i ) , predicates . get ( i ) , compactSegment ) ; } }
private void mergeReleased ( List < Segment > segments , List < OffsetPredicate > predicates , Segment compactSegment ) { for ( int i = _NUM ; i < segments . size ( ) ; i ++ ) { mergeReleasedEntries ( segments . get ( i ) , predicates . get ( i ) , compactSegment ) ; } }
public DOMTestDocumentBuilderFactory newInstance ( DocumentBuilderSetting [ ] newSettings ) throws DOMTestIncompatibleException { if ( newSettings == null ) { return this ; } DocumentBuilderSetting [ ] mergedSettings = mergeSettings ( newSettings ) ; return new BatikTestDocumentBuilderFactory ( mergedSettings ) ; }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > _NUM ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > _NUM ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > _NUM ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > _NUM ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
private void buildPTR ( ) { double [ ] temp_row ; double [ ] [ ] PTRA ; int k ; PivotTransform pt ; PTR = Matrix . identity ( n , n ) ; PTRA = PTR . getArray ( ) ; k = pivotTransformQueue . size ( ) ; while ( k -- > _NUM ) { pt = pivotTransformQueue . removeLast ( ) ; temp_row = PTRA [ pt . pos1 ] ; PTRA [ pt . pos1 ] = PTRA [ pt . pos2 ] ; PTRA [ pt . pos2 ] = temp_row ; } }
protected abstract Collection < CommunicationSummaryStatistics > doGetCommunicationSummaryStatistics ( String tenantId , Criteria criteria ) ;
protected void updateRadioLinks ( ) { m_SetTestBut . setEnabled ( m_TestSplitBut . isSelected ( ) ) ; if ( ( m_SetTestFrame != null ) && ( ! m_TestSplitBut . isSelected ( ) ) ) { m_SetTestFrame . setVisible ( _BOOL ) ; } m_PercentText . setEnabled ( m_PercentBut . isSelected ( ) ) ; m_PercentLab . setEnabled ( m_PercentBut . isSelected ( ) ) ; m_ClassCombo . setEnabled ( m_ClassesToClustersBut . isSelected ( ) ) ; updateCapabilitiesFilter ( m_ClustererEditor . getCapabilitiesFilter ( ) ) ; }
protected Point2D correct ( Point2D anchor , Rectangle2D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . getX ( ) , y = anchor . getY ( ) ; double x1 = bounds . getMinX ( ) , y1 = bounds . getMinY ( ) ; double x2 = bounds . getMaxX ( ) , y2 = bounds . getMaxY ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m_tmp . setLocation ( x , y ) ; return m_tmp ; }
protected Point2D correct ( Point2D anchor , Rectangle2D bounds ) { if ( anchor == null ) return anchor ; double x = anchor . getX ( ) , y = anchor . getY ( ) ; double x1 = bounds . getMinX ( ) , y1 = bounds . getMinY ( ) ; double x2 = bounds . getMaxX ( ) , y2 = bounds . getMaxY ( ) ; x = ( x < x1 ? x1 : ( x > x2 ? x2 : x ) ) ; y = ( y < y1 ? y1 : ( y > y2 ? y2 : y ) ) ; m_tmp . setLocation ( x , y ) ; return m_tmp ; }
private List < String > replaceDotInMustacheKeys ( final List < String > mustacheKeys ) { final List < String > fixedMustacheKeys = new ArrayList < > ( ) ; for ( String mustacheKey : mustacheKeys ) { fixedMustacheKeys . add ( mustacheKey . replace ( STRING , STRING ) ) ; } return fixedMustacheKeys ; }
private List < String > replaceDotInMustacheKeys ( final List < String > mustacheKeys ) { final List < String > fixedMustacheKeys = new ArrayList < > ( ) ; for ( String mustacheKey : mustacheKeys ) { fixedMustacheKeys . add ( mustacheKey . replace ( STRING , STRING ) ) ; } return fixedMustacheKeys ; }
private List < String > replaceDotInMustacheKeys ( final List < String > mustacheKeys ) { final List < String > fixedMustacheKeys = new ArrayList < > ( ) ; for ( String mustacheKey : mustacheKeys ) { fixedMustacheKeys . add ( mustacheKey . replace ( STRING , STRING ) ) ; } return fixedMustacheKeys ; }
private List < String > replaceDotInMustacheKeys ( final List < String > mustacheKeys ) { final List < String > fixedMustacheKeys = new ArrayList < > ( ) ; for ( String mustacheKey : mustacheKeys ) { fixedMustacheKeys . add ( mustacheKey . replace ( STRING , STRING ) ) ; } return fixedMustacheKeys ; }
public PrintfFormat ( String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public PrintfFormat ( String fmtArg ) throws IllegalArgumentException { this ( Locale . getDefault ( ) , fmtArg ) ; }
public GammaFitnessFunction ( int genomeLength , double alpha , double beta , int stateSize , boolean randomFittest ) { GammaDistribution gamma = new GammaDistribution ( beta , alpha ) ; fitness = new double [ genomeLength ] [ stateSize ] ; fittest = new byte [ genomeLength ] ; int fitpos = _NUM ; for ( int i = _NUM ; i < genomeLength ; i ++ ) { if ( randomFittest ) { fitpos = MathUtils . nextInt ( stateSize ) ; } fitness [ i ] [ fitpos ] = _NUM ; fittest [ i ] = ( byte ) fitpos ; for ( int j = _NUM ; j < stateSize ; j ++ ) { if ( j != fitpos ) { double prob = Math . round ( MathUtils . nextDouble ( ) * _NUM ) / _NUM ; while ( ( prob <= _NUM ) || ( prob >= _NUM ) ) { prob = Math . round ( MathUtils . nextDouble ( ) * _NUM ) / _NUM ; } fitness [ i ] [ j ] = Math . max ( _NUM , _NUM - gamma . quantile ( prob ) ) ; } } } }
private void showTimeSendingStrategyValidationMessage ( ) { sendingValueDecoration . setDescriptionText ( STRING ) ; }
public final T end ( int i ) { while ( i -- > _NUM && ! tagStack . isEmpty ( ) ) { end ( ) ; } return getSelf ( ) ; }
protected void subscribeStop ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForStop ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
protected void subscribeStop ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForStop ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
protected void subscribeStop ( String nameValue ) throws Throwable { URI observerUri = URI . create ( observerServiceUriForStop ) ; waitForSubscriptionToAppear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; verifyNotification ( nameValue , observerUri ) ; JsExecutor . executeSynchronously ( null ) ; waitForSubscriptionToDisappear ( observerUri , EXAMPLES_SUBSCRIPTIONS ) ; }
@ NamespacePermission ( fields = STRING , permissions = NamespacePermissionEnum . READ ) private void mockMethod ( String namespace ) { }
public MonthDateFormat ( Locale locale , int chars ) { this ( TimeZone . getDefault ( ) , locale , chars , _BOOL , _BOOL ) ; }
public boolean doesNotDistribute ( ) { return _BOOL ; }
public boolean doesNotDistribute ( ) { return _BOOL ; }
public boolean doesNotDistribute ( ) { return _BOOL ; }
protected final void acceptAnnotations ( final MethodVisitor mv ) { int n = visibleTypeAnnotations == null ? _NUM : visibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = visibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } n = invisibleTypeAnnotations == null ? _NUM : invisibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = invisibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } }
protected final void acceptAnnotations ( final MethodVisitor mv ) { int n = visibleTypeAnnotations == null ? _NUM : visibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = visibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } n = invisibleTypeAnnotations == null ? _NUM : invisibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = invisibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } }
protected final void acceptAnnotations ( final MethodVisitor mv ) { int n = visibleTypeAnnotations == null ? _NUM : visibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = visibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } n = invisibleTypeAnnotations == null ? _NUM : invisibleTypeAnnotations . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { TypeAnnotationNode an = invisibleTypeAnnotations . get ( i ) ; an . accept ( mv . visitInsnAnnotation ( an . typeRef , an . typePath , an . desc , _BOOL ) ) ; } }
public static int nextSetBit ( long [ ] v , int start ) { int wordindex = start > > > LONG_LOG2_SIZE ; if ( wordindex >= v . length ) { return - _NUM ; } long cur = v [ wordindex ] & ( LONG_ALL_BITS << start ) ; for ( ; ; ) { if ( cur != _NUM ) { return ( wordindex * Long . SIZE ) + Long . numberOfTrailingZeros ( cur ) ; } wordindex ++ ; if ( wordindex == v . length ) { return - _NUM ; } cur = v [ wordindex ] ; } }
public boolean onDeath ( ) { attackTarget = null ; return nextMod != null && nextMod . onDeath ( ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public String encode ( ByteBuffer aBuffer ) { byte [ ] buf = getBytes ( aBuffer ) ; return encode ( buf ) ; }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
public void prepareFilter ( float transition ) { try { method . invoke ( filter , new Object [ ] { new Float ( transition ) } ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( STRING + property ) ; } }
private static int [ ] [ ] successors ( final List < Vector3D > vertices , final List < int [ ] > facets , final int [ ] [ ] references ) { final int [ ] [ ] successors = new int [ vertices . size ( ) ] [ references [ _NUM ] . length ] ; for ( final int [ ] s : successors ) { Arrays . fill ( s , - _NUM ) ; } for ( int v = _NUM ; v < vertices . size ( ) ; ++ v ) { for ( int k = _NUM ; k < successors [ v ] . length && references [ v ] [ k ] >= _NUM ; ++ k ) { final int [ ] facet = facets . get ( references [ v ] [ k ] ) ; int i = _NUM ; while ( i < facet . length && facet [ i ] != v ) { ++ i ; } successors [ v ] [ k ] = facet [ ( i + _NUM ) % facet . length ] ; for ( int l = _NUM ; l < k ; ++ l ) { if ( successors [ v ] [ l ] == successors [ v ] [ k ] ) { final Vector3D start = vertices . get ( v ) ; final Vector3D end = vertices . get ( successors [ v ] [ k ] ) ; throw new MathIllegalArgumentException ( LocalizedGeometryFormats . FACET_ORIENTATION_MISMATCH , start . getX ( ) , start . getY ( ) , start . getZ ( ) , end . getX ( ) , end . getY ( ) , end . getZ ( ) ) ; } } } } return successors ; }
public int expandAll ( int level ) { int expanded = _NUM ; for ( int i = _NUM ; i < mItems . size ( ) ; i ++ ) { T item = getItem ( i ) ; if ( isExpandable ( item ) ) { IExpandable expandable = ( IExpandable ) item ; if ( expandable . getExpansionLevel ( ) <= level && expand ( i , _BOOL , _BOOL ) > _NUM ) { expanded ++ ; } } } return expanded ; }
NumberStrategy ( final int field ) { this . field = field ; }
NumberStrategy ( final int field ) { this . field = field ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = _NUM ; while ( i < N ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = _NUM ; while ( i < N ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = _NUM ; while ( i < N ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public static final void writeListXml ( List val , String name , XmlSerializer out ) throws XmlPullParserException , IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } int N = val . size ( ) ; int i = _NUM ; while ( i < N ) { writeValueXml ( val . get ( i ) , null , out ) ; i ++ ; } out . endTag ( null , STRING ) ; }
public boolean canLoad ( Entity unit , boolean checkElev ) { if ( this instanceof Infantry ) { return _BOOL ; } if ( ! unit . isEnemyOf ( this ) ) { Enumeration < Transporter > iter = transports . elements ( ) ; while ( iter . hasMoreElements ( ) ) { Transporter next = iter . nextElement ( ) ; if ( next . canLoad ( unit ) && ( ! checkElev || ( unit . getElevation ( ) == getElevation ( ) ) ) ) { return _BOOL ; } } } return _BOOL ; }
public static WorkspaceComponent deserializeWorkspaceComponent ( final Class < ? > clazz , final String name , final InputStream input , final String format ) { try { Method method = clazz . getMethod ( STRING , InputStream . class , String . class , String . class ) ; WorkspaceComponent wc = ( WorkspaceComponent ) method . invoke ( null , input , name , format ) ; wc . setChangedSinceLastSave ( _BOOL ) ; return wc ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
public static boolean isAtomicUpdate ( final AddUpdateCommand cmd ) { SolrInputDocument sdoc = cmd . getSolrInputDocument ( ) ; for ( SolrInputField sif : sdoc . values ( ) ) { if ( sif . getValue ( ) instanceof Map ) { return _BOOL ; } } return _BOOL ; }
public static boolean isAtomicUpdate ( final AddUpdateCommand cmd ) { SolrInputDocument sdoc = cmd . getSolrInputDocument ( ) ; for ( SolrInputField sif : sdoc . values ( ) ) { if ( sif . getValue ( ) instanceof Map ) { return _BOOL ; } } return _BOOL ; }
public static boolean isAtomicUpdate ( final AddUpdateCommand cmd ) { SolrInputDocument sdoc = cmd . getSolrInputDocument ( ) ; for ( SolrInputField sif : sdoc . values ( ) ) { if ( sif . getValue ( ) instanceof Map ) { return _BOOL ; } } return _BOOL ; }
public static boolean isAtomicUpdate ( final AddUpdateCommand cmd ) { SolrInputDocument sdoc = cmd . getSolrInputDocument ( ) ; for ( SolrInputField sif : sdoc . values ( ) ) { if ( sif . getValue ( ) instanceof Map ) { return _BOOL ; } } return _BOOL ; }
public static java . lang . Integer valueOf ( java . lang . String s , int radix ) throws java . lang . NumberFormatException { return new Integer ( parseInt ( s , radix ) ) ; }
public static < T extends Entity > T create ( Cursor cursor , Class < T > cls , String ... projection ) { try { T entity = cls . newInstance ( ) ; Field [ ] fields = new Field [ projection . length ] ; for ( int i = _NUM , size = projection . length ; i < size ; i ++ ) { fields [ i ] = getColumnField ( projection [ i ] , entity ) ; } return create ( entity , cursor , cls , fields ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public static void write ( InputStream in , OutputStream out , boolean closeBoth ) throws IOException { byte [ ] buff = new byte [ _NUM ] ; int read = _NUM ; while ( ( read = in . read ( buff ) ) > _NUM ) { out . write ( buff , _NUM , read ) ; } out . flush ( ) ; if ( closeBoth ) { safeCloseStreams ( in , out ) ; } }
@ Override public boolean supportsAuthentication ( ) { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STRING ) ; } return _BOOL ; }
public final static int writeSecurityBufferAndUpdatePointer ( ByteArrayOutputStream baos , short len , int pointer ) throws IOException { baos . write ( writeSecurityBuffer ( len , pointer ) ) ; return pointer + len ; }
public final static int writeSecurityBufferAndUpdatePointer ( ByteArrayOutputStream baos , short len , int pointer ) throws IOException { baos . write ( writeSecurityBuffer ( len , pointer ) ) ; return pointer + len ; }
public final static int writeSecurityBufferAndUpdatePointer ( ByteArrayOutputStream baos , short len , int pointer ) throws IOException { baos . write ( writeSecurityBuffer ( len , pointer ) ) ; return pointer + len ; }
public final static int writeSecurityBufferAndUpdatePointer ( ByteArrayOutputStream baos , short len , int pointer ) throws IOException { baos . write ( writeSecurityBuffer ( len , pointer ) ) ; return pointer + len ; }
static public int cancelOperation ( int token ) { int canceled = _NUM ; synchronized ( sWorkQueue ) { Iterator < OperationInfo > it = sWorkQueue . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if ( AsyncQueryService . localLOGV ) { Log . d ( TAG , STRING + token + STRING + canceled ) ; } return canceled ; }
static public int cancelOperation ( int token ) { int canceled = _NUM ; synchronized ( sWorkQueue ) { Iterator < OperationInfo > it = sWorkQueue . iterator ( ) ; while ( it . hasNext ( ) ) { if ( it . next ( ) . token == token ) { it . remove ( ) ; ++ canceled ; } } } if ( AsyncQueryService . localLOGV ) { Log . d ( TAG , STRING + token + STRING + canceled ) ; } return canceled ; }
@ Override protected void stopService ( ) { Thread t = keepAliveThread ; keepAliveThread = null ; if ( t != null ) { t . interrupt ( ) ; } }
protected double now ( ) { return System . currentTimeMillis ( ) ; }
default Properties asProperties ( ) { return asProperties ( null ) ; }
public static String [ ] toStringArray ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
public static String [ ] toStringArray ( Enumeration < String > enumeration ) { if ( enumeration == null ) { return null ; } List < String > list = Collections . list ( enumeration ) ; return list . toArray ( new String [ list . size ( ) ] ) ; }
public final static boolean isPotentialZipArchive ( String name ) { int lastDot = name . lastIndexOf ( STRING ) ; if ( lastDot == - _NUM ) { return _BOOL ; } if ( name . lastIndexOf ( File . separatorChar ) > lastDot ) { return _BOOL ; } int length = name . length ( ) ; int extensionLength = length - lastDot - _NUM ; if ( extensionLength == EXTENSION_java . length ( ) ) { for ( int i = extensionLength - _NUM ; i >= _NUM ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_java . charAt ( i ) ) { break ; } if ( i == _NUM ) { return _BOOL ; } } } if ( extensionLength == EXTENSION_class . length ( ) ) { for ( int i = extensionLength - _NUM ; i >= _NUM ; i -- ) { if ( Character . toLowerCase ( name . charAt ( length - extensionLength + i ) ) != EXTENSION_class . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; } return _BOOL ; }
public CsvWriter put ( int index , String value ) throws CsvException { if ( disposition == null ) { disposition = new HashMap < Character , Disposition > ( _NUM ) ; for ( char c : escapedChars . toCharArray ( ) ) { disposition . put ( c , Disposition . escape ) ; } for ( char c : suppressedChars . toCharArray ( ) ) { disposition . put ( c , Disposition . suppress ) ; } } if ( row == null ) { int size = getWidth ( ) ; row = new ArrayList < String > ( size ) ; for ( int i = _NUM ; i < size ; i ++ ) row . add ( null ) ; colCount = _NUM ; } if ( index < _NUM || index > row . size ( ) ) { throw new CsvException ( STRING + index + STRING + value + STRING + row . size ( ) ) ; } int arrayIndex = index - _NUM ; if ( row . get ( arrayIndex ) != null ) { throw new CsvException ( STRING + index + STRING + row . get ( arrayIndex ) + STRING + value + STRING ) ; } if ( value == null ) { if ( this . nullPolicy == NullPolicy . emptyString ) value = processString ( STRING ) ; else if ( nullPolicy == NullPolicy . skip ) value = null ; else value = nullValue ; } else { value = processString ( value ) ; } row . set ( arrayIndex , value ) ; colCount ++ ; return this ; }
void add ( int start , int end ) { final Map . Entry < Integer , Integer > floor = mIntervals . floorEntry ( start ) ; final Map . Entry < Integer , Integer > endFloor = mIntervals . lowerEntry ( end ) ; final int actualStart ; final int actualEnd ; if ( floor != null && start >= floor . getKey ( ) && end <= floor . getValue ( ) ) { return ; } if ( floor == null || start > floor . getValue ( ) ) { actualStart = start ; } else { actualStart = Math . min ( floor . getKey ( ) , start ) ; } if ( endFloor == null ) { actualEnd = end ; } else { actualEnd = Math . max ( endFloor . getValue ( ) , end ) ; } removeContainedBy ( actualStart , actualEnd ) ; mIntervals . put ( actualStart , actualEnd ) ; }
protected Integer columnIndex ( Map < String , Integer > loadColIdxs , String dbName ) { Integer colIdx = loadColIdxs . get ( dbName . toUpperCase ( ) ) ; if ( colIdx == null ) throw new IllegalStateException ( STRING + dbName ) ; return colIdx ; }
protected Integer columnIndex ( Map < String , Integer > loadColIdxs , String dbName ) { Integer colIdx = loadColIdxs . get ( dbName . toUpperCase ( ) ) ; if ( colIdx == null ) throw new IllegalStateException ( STRING + dbName ) ; return colIdx ; }
@ SuppressWarnings ( STRING ) public void load ( byte [ ] data ) throws Exception { if ( data == null ) { return ; } if ( schemaValidator != null ) { try ( InputStream in = new ByteArrayInputStream ( data ) ) { validateSchemaWithValidator ( in ) ; } } try ( InputStream in = new ByteArrayInputStream ( data ) ) { Unmarshaller unmarshaller = jaxbCtx . createUnmarshaller ( ) ; root = ( JAXBElement < T > ) unmarshaller . unmarshal ( in ) ; confType = root . getValue ( ) ; } }
private static FloatBuffer allocateTextureBuffer ( float u , float v ) { float texturepoints [ ] = { _NUM , _NUM , _NUM , v , u , _NUM , u , v } ; ByteBuffer byteBuffer = ByteBuffer . allocateDirect ( texturepoints . length * SIZEOF_FLOAT ) ; byteBuffer . order ( ByteOrder . nativeOrder ( ) ) ; FloatBuffer texBuffer = byteBuffer . asFloatBuffer ( ) ; texBuffer . put ( texturepoints ) ; texBuffer . position ( _NUM ) ; return texBuffer ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private List < ValidationError > validate ( ) { List < ValidationError > errors = Lists . newArrayList ( ) ; Module module = getModule ( ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateModule ( module ) ) ; AndroidFacet facet = null ; if ( module != null ) { facet = AndroidFacet . getInstance ( module ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateFacet ( facet , module ) ) ; } errors . addAll ( configState . validate ( facet ) ) ; errors . addAll ( BlazeAndroidRunConfigurationValidationUtil . validateLabel ( getLabel ( ) , configuration . getProject ( ) , Kind . ANDROID_BINARY ) ) ; return errors ; }
private static byte [ ] generateMultipartBoundary ( ) { final Random rand = new Random ( ) ; final byte [ ] bytes = new byte [ rand . nextInt ( _NUM ) + _NUM ] ; for ( int i = _NUM ; i < bytes . length ; i ++ ) { bytes [ i ] = MULTIPART_CHARS [ rand . nextInt ( MULTIPART_CHARS . length ) ] ; } return bytes ; }
public static HTTPResponse delete ( URL url , String username , String password , long timeout , boolean redirect , String charset , String useragent , ProxyData proxy , lucee . commons . net . http . Header [ ] headers ) throws IOException { HttpDelete delete = new HttpDelete ( url . toExternalForm ( ) ) ; return _invoke ( url , delete , username , password , timeout , redirect , charset , useragent , proxy , headers , null ) ; }
public void render ( Graphics2D g , Shape shape ) { render ( g , shape , _BOOL ) ; }
public void render ( Graphics2D g , Shape shape ) { render ( g , shape , _BOOL ) ; }
public static final String removeQueryString ( final String path ) { return path . replaceFirst ( STRING , StringUtils . EMPTY ) ; }
private static boolean checkInstanceIdsReturnedFromAWS ( int numberOfInstance , List < String > instanceIds ) { if ( instanceIds == null || instanceIds . size ( ) == _NUM ) { return _BOOL ; } return ( instanceIds . size ( ) == numberOfInstance ) ; }
private static boolean checkInstanceIdsReturnedFromAWS ( int numberOfInstance , List < String > instanceIds ) { if ( instanceIds == null || instanceIds . size ( ) == _NUM ) { return _BOOL ; } return ( instanceIds . size ( ) == numberOfInstance ) ; }
public static FeaturesConfig fromXml ( final InputStream toConvert ) throws JAXBException { Unmarshaller stringUnmarshaller = getUnmarshaller ( ) ; return ( FeaturesConfig ) stringUnmarshaller . unmarshal ( toConvert ) ; }
public static FeaturesConfig fromXml ( final InputStream toConvert ) throws JAXBException { Unmarshaller stringUnmarshaller = getUnmarshaller ( ) ; return ( FeaturesConfig ) stringUnmarshaller . unmarshal ( toConvert ) ; }
public static String toDateString ( java . util . Date date , String format ) { if ( date == null ) return STRING ; SimpleDateFormat dateFormat = null ; if ( format != null ) { dateFormat = new SimpleDateFormat ( format ) ; } else { dateFormat = new SimpleDateFormat ( ) ; } Calendar calendar = Calendar . getInstance ( ) ; calendar . setTime ( date ) ; return dateFormat . format ( date ) ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new ArrayList < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; MultiTrie2 m = new MultiTrie2 ( forward ) ; m . tries = h ; return m ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new ArrayList < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; MultiTrie2 m = new MultiTrie2 ( forward ) ; m . tries = h ; return m ; }
@ Override public Trie reduce ( Reduce by ) { List < Trie > h = new ArrayList < > ( ) ; for ( Trie trie : tries ) h . add ( trie . reduce ( by ) ) ; MultiTrie2 m = new MultiTrie2 ( forward ) ; m . tries = h ; return m ; }
public ClassifierReference ( QualifiedName qualifiedName , URI uri ) { this . classifierName = qualifiedName . getLastSegment ( ) ; List < String > frontSegments = qualifiedName . getSegments ( ) ; if ( frontSegments . size ( ) > _NUM ) { StringJoiner joiner = new StringJoiner ( N4JSQualifiedNameConverter . DELIMITER ) ; for ( String segment : frontSegments . subList ( _NUM , frontSegments . size ( ) - _NUM ) ) { joiner . add ( segment ) ; } this . classifierModuleSpecifier = joiner . toString ( ) ; } else { this . classifierModuleSpecifier = STRING ; } this . uri = uri ; }
public ClassifierReference ( QualifiedName qualifiedName , URI uri ) { this . classifierName = qualifiedName . getLastSegment ( ) ; List < String > frontSegments = qualifiedName . getSegments ( ) ; if ( frontSegments . size ( ) > _NUM ) { StringJoiner joiner = new StringJoiner ( N4JSQualifiedNameConverter . DELIMITER ) ; for ( String segment : frontSegments . subList ( _NUM , frontSegments . size ( ) - _NUM ) ) { joiner . add ( segment ) ; } this . classifierModuleSpecifier = joiner . toString ( ) ; } else { this . classifierModuleSpecifier = STRING ; } this . uri = uri ; }
public Histogram ( RangeWithCount ... items ) { this ( Arrays . stream ( items ) ) ; }
public void componentResized ( ComponentEvent e ) { JScrollBar bar = getVerticalScrollBar ( ) ; int incr = ( int ) ( getSize ( ) . getHeight ( ) - ( bar . getUnitIncrement ( _NUM ) * _NUM ) ) ; getVerticalScrollBar ( ) . setBlockIncrement ( incr ) ; }
public NotificationSet parseXML ( ) { if ( document == null ) { return null ; } Element notifSetElem = document . getDocumentElement ( ) ; NotificationSet notificationSet = new NotificationSet ( ) ; setNotificationSetAttributes ( notifSetElem , notificationSet ) ; NodeList notifs = notifSetElem . getElementsByTagName ( STRING ) ; if ( notifs == null ) { return notificationSet ; } int nodeLen = notifs . getLength ( ) ; for ( int i = _NUM ; i < nodeLen ; i ++ ) { notificationSet . addNotification ( parseNotificationElement ( ( Element ) notifs . item ( i ) ) ) ; } return notificationSet ; }
public NotificationSet parseXML ( ) { if ( document == null ) { return null ; } Element notifSetElem = document . getDocumentElement ( ) ; NotificationSet notificationSet = new NotificationSet ( ) ; setNotificationSetAttributes ( notifSetElem , notificationSet ) ; NodeList notifs = notifSetElem . getElementsByTagName ( STRING ) ; if ( notifs == null ) { return notificationSet ; } int nodeLen = notifs . getLength ( ) ; for ( int i = _NUM ; i < nodeLen ; i ++ ) { notificationSet . addNotification ( parseNotificationElement ( ( Element ) notifs . item ( i ) ) ) ; } return notificationSet ; }
public NotificationSet parseXML ( ) { if ( document == null ) { return null ; } Element notifSetElem = document . getDocumentElement ( ) ; NotificationSet notificationSet = new NotificationSet ( ) ; setNotificationSetAttributes ( notifSetElem , notificationSet ) ; NodeList notifs = notifSetElem . getElementsByTagName ( STRING ) ; if ( notifs == null ) { return notificationSet ; } int nodeLen = notifs . getLength ( ) ; for ( int i = _NUM ; i < nodeLen ; i ++ ) { notificationSet . addNotification ( parseNotificationElement ( ( Element ) notifs . item ( i ) ) ) ; } return notificationSet ; }
public List < Integer > diffWaysToCompute ( String input ) { List < Integer > res = new LinkedList < > ( ) ; for ( int i = _NUM ; i < input . length ( ) ; i ++ ) { char c = input . charAt ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { List < Integer > left = diffWaysToCompute ( input . substring ( _NUM , i ) ) ; List < Integer > right = diffWaysToCompute ( input . substring ( i + _NUM , input . length ( ) ) ) ; for ( int j = _NUM ; j < left . size ( ) ; j ++ ) { for ( int k = _NUM ; k < right . size ( ) ; k ++ ) { res . add ( calculate ( c , left . get ( j ) , right . get ( k ) ) ) ; } } } } if ( res . size ( ) == _NUM ) { res . add ( Integer . parseInt ( input ) ) ; } return res ; }
public List < Integer > diffWaysToCompute ( String input ) { List < Integer > res = new LinkedList < > ( ) ; for ( int i = _NUM ; i < input . length ( ) ; i ++ ) { char c = input . charAt ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { List < Integer > left = diffWaysToCompute ( input . substring ( _NUM , i ) ) ; List < Integer > right = diffWaysToCompute ( input . substring ( i + _NUM , input . length ( ) ) ) ; for ( int j = _NUM ; j < left . size ( ) ; j ++ ) { for ( int k = _NUM ; k < right . size ( ) ; k ++ ) { res . add ( calculate ( c , left . get ( j ) , right . get ( k ) ) ) ; } } } } if ( res . size ( ) == _NUM ) { res . add ( Integer . parseInt ( input ) ) ; } return res ; }
@ Override public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }
@ Override public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }
@ Override public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }
@ Override public void drawBackground ( Graphics2D g2 , Rectangle2D area ) { fillBackground ( g2 , area , this . orientation ) ; drawBackgroundImage ( g2 , area ) ; }
public static int calcRLen ( int diff ) { return ( int ) Math . round ( _NUM * Math . log ( rand . nextInt ( diff + _NUM ) + _NUM ) + rand . nextInt ( _NUM ) ) ; }
private static String unsignedToString ( int value ) { if ( value >= _NUM ) { return Integer . toString ( value ) ; } else { return Long . toString ( ( value ) & _NUM ) ; } }
private boolean sendMessageToDefaultCallback ( final PluginResult message ) { if ( jsDefaultCallback == null ) { defaultCallbackStoredResults . add ( message ) ; return _BOOL ; } message . setKeepCallback ( _BOOL ) ; jsDefaultCallback . sendPluginResult ( message ) ; return _BOOL ; }
private boolean sendMessageToDefaultCallback ( final PluginResult message ) { if ( jsDefaultCallback == null ) { defaultCallbackStoredResults . add ( message ) ; return _BOOL ; } message . setKeepCallback ( _BOOL ) ; jsDefaultCallback . sendPluginResult ( message ) ; return _BOOL ; }
private boolean sendMessageToDefaultCallback ( final PluginResult message ) { if ( jsDefaultCallback == null ) { defaultCallbackStoredResults . add ( message ) ; return _BOOL ; } message . setKeepCallback ( _BOOL ) ; jsDefaultCallback . sendPluginResult ( message ) ; return _BOOL ; }
TypeDeclaration declaringType ( ) ;
public void logEquals ( ) { for ( int i = _NUM ; i < A . length ; i ++ ) for ( int j = _NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void logEquals ( ) { for ( int i = _NUM ; i < A . length ; i ++ ) for ( int j = _NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void logEquals ( ) { for ( int i = _NUM ; i < A . length ; i ++ ) for ( int j = _NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void logEquals ( ) { for ( int i = _NUM ; i < A . length ; i ++ ) for ( int j = _NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
public void logEquals ( ) { for ( int i = _NUM ; i < A . length ; i ++ ) for ( int j = _NUM ; j < A [ i ] . length ; j ++ ) A [ i ] [ j ] = Math . log ( A [ i ] [ j ] ) ; }
private void serverClientMessage ( ) throws Exception { Ignite ignite = grid ( SERVER_NODE_IDX ) ; ClusterGroup grp = ignite . cluster ( ) . forClients ( ) ; assert grp . nodes ( ) . size ( ) > _NUM ; registerListenerAndSendMessages ( ignite , grp ) ; }
private void serverClientMessage ( ) throws Exception { Ignite ignite = grid ( SERVER_NODE_IDX ) ; ClusterGroup grp = ignite . cluster ( ) . forClients ( ) ; assert grp . nodes ( ) . size ( ) > _NUM ; registerListenerAndSendMessages ( ignite , grp ) ; }
private void serverClientMessage ( ) throws Exception { Ignite ignite = grid ( SERVER_NODE_IDX ) ; ClusterGroup grp = ignite . cluster ( ) . forClients ( ) ; assert grp . nodes ( ) . size ( ) > _NUM ; registerListenerAndSendMessages ( ignite , grp ) ; }
private void addConnectionDescendants ( Collection < Connection > connections , List < ObjectPermission . Type > permissions ) throws GuacamoleException { if ( connections . isEmpty ( ) ) return ; Collection < String > identifiers = new ArrayList < String > ( ) ; for ( Connection connection : connections ) identifiers . addAll ( connection . getSharingProfileIdentifiers ( ) ) ; if ( permissions != null && ! permissions . isEmpty ( ) ) identifiers = sharingProfilePermissions . getAccessibleObjects ( permissions , identifiers ) ; if ( ! identifiers . isEmpty ( ) ) { Collection < SharingProfile > sharingProfiles = sharingProfileDirectory . getAll ( identifiers ) ; addSharingProfiles ( sharingProfiles ) ; } }
private void addConnectionDescendants ( Collection < Connection > connections , List < ObjectPermission . Type > permissions ) throws GuacamoleException { if ( connections . isEmpty ( ) ) return ; Collection < String > identifiers = new ArrayList < String > ( ) ; for ( Connection connection : connections ) identifiers . addAll ( connection . getSharingProfileIdentifiers ( ) ) ; if ( permissions != null && ! permissions . isEmpty ( ) ) identifiers = sharingProfilePermissions . getAccessibleObjects ( permissions , identifiers ) ; if ( ! identifiers . isEmpty ( ) ) { Collection < SharingProfile > sharingProfiles = sharingProfileDirectory . getAll ( identifiers ) ; addSharingProfiles ( sharingProfiles ) ; } }
private void addConnectionDescendants ( Collection < Connection > connections , List < ObjectPermission . Type > permissions ) throws GuacamoleException { if ( connections . isEmpty ( ) ) return ; Collection < String > identifiers = new ArrayList < String > ( ) ; for ( Connection connection : connections ) identifiers . addAll ( connection . getSharingProfileIdentifiers ( ) ) ; if ( permissions != null && ! permissions . isEmpty ( ) ) identifiers = sharingProfilePermissions . getAccessibleObjects ( permissions , identifiers ) ; if ( ! identifiers . isEmpty ( ) ) { Collection < SharingProfile > sharingProfiles = sharingProfileDirectory . getAll ( identifiers ) ; addSharingProfiles ( sharingProfiles ) ; } }
private void addConnectionDescendants ( Collection < Connection > connections , List < ObjectPermission . Type > permissions ) throws GuacamoleException { if ( connections . isEmpty ( ) ) return ; Collection < String > identifiers = new ArrayList < String > ( ) ; for ( Connection connection : connections ) identifiers . addAll ( connection . getSharingProfileIdentifiers ( ) ) ; if ( permissions != null && ! permissions . isEmpty ( ) ) identifiers = sharingProfilePermissions . getAccessibleObjects ( permissions , identifiers ) ; if ( ! identifiers . isEmpty ( ) ) { Collection < SharingProfile > sharingProfiles = sharingProfileDirectory . getAll ( identifiers ) ; addSharingProfiles ( sharingProfiles ) ; } }
private static Map < String , SchemaObjectMappingDTO > populateObjectSchema ( Collection < IdentityStoreObjectMapping > objectMappings ) throws DTOMapperException { Map < String , SchemaObjectMappingDTO > objectSchemaMappings = new HashMap < String , SchemaObjectMappingDTO > ( ) ; try { for ( IdentityStoreObjectMapping objectMapping : objectMappings ) { String objectId = objectMapping . getObjectId ( ) ; String objectClass = objectMapping . getObjectClass ( ) ; Map < String , String > attributeMappings = new HashMap < String , String > ( ) ; for ( IdentityStoreAttributeMapping attributeMapping : objectMapping . getAttributeMappings ( ) ) { attributeMappings . put ( attributeMapping . getAttributeId ( ) , attributeMapping . getAttributeName ( ) ) ; } objectSchemaMappings . put ( objectId , new SchemaObjectMappingDTO ( objectClass , attributeMappings ) ) ; } } catch ( Exception ex ) { throw new DTOMapperException ( STRING ) ; } return objectSchemaMappings ; }
private static Map < String , SchemaObjectMappingDTO > populateObjectSchema ( Collection < IdentityStoreObjectMapping > objectMappings ) throws DTOMapperException { Map < String , SchemaObjectMappingDTO > objectSchemaMappings = new HashMap < String , SchemaObjectMappingDTO > ( ) ; try { for ( IdentityStoreObjectMapping objectMapping : objectMappings ) { String objectId = objectMapping . getObjectId ( ) ; String objectClass = objectMapping . getObjectClass ( ) ; Map < String , String > attributeMappings = new HashMap < String , String > ( ) ; for ( IdentityStoreAttributeMapping attributeMapping : objectMapping . getAttributeMappings ( ) ) { attributeMappings . put ( attributeMapping . getAttributeId ( ) , attributeMapping . getAttributeName ( ) ) ; } objectSchemaMappings . put ( objectId , new SchemaObjectMappingDTO ( objectClass , attributeMappings ) ) ; } } catch ( Exception ex ) { throw new DTOMapperException ( STRING ) ; } return objectSchemaMappings ; }
private static Map < String , SchemaObjectMappingDTO > populateObjectSchema ( Collection < IdentityStoreObjectMapping > objectMappings ) throws DTOMapperException { Map < String , SchemaObjectMappingDTO > objectSchemaMappings = new HashMap < String , SchemaObjectMappingDTO > ( ) ; try { for ( IdentityStoreObjectMapping objectMapping : objectMappings ) { String objectId = objectMapping . getObjectId ( ) ; String objectClass = objectMapping . getObjectClass ( ) ; Map < String , String > attributeMappings = new HashMap < String , String > ( ) ; for ( IdentityStoreAttributeMapping attributeMapping : objectMapping . getAttributeMappings ( ) ) { attributeMappings . put ( attributeMapping . getAttributeId ( ) , attributeMapping . getAttributeName ( ) ) ; } objectSchemaMappings . put ( objectId , new SchemaObjectMappingDTO ( objectClass , attributeMappings ) ) ; } } catch ( Exception ex ) { throw new DTOMapperException ( STRING ) ; } return objectSchemaMappings ; }
private static Map < String , SchemaObjectMappingDTO > populateObjectSchema ( Collection < IdentityStoreObjectMapping > objectMappings ) throws DTOMapperException { Map < String , SchemaObjectMappingDTO > objectSchemaMappings = new HashMap < String , SchemaObjectMappingDTO > ( ) ; try { for ( IdentityStoreObjectMapping objectMapping : objectMappings ) { String objectId = objectMapping . getObjectId ( ) ; String objectClass = objectMapping . getObjectClass ( ) ; Map < String , String > attributeMappings = new HashMap < String , String > ( ) ; for ( IdentityStoreAttributeMapping attributeMapping : objectMapping . getAttributeMappings ( ) ) { attributeMappings . put ( attributeMapping . getAttributeId ( ) , attributeMapping . getAttributeName ( ) ) ; } objectSchemaMappings . put ( objectId , new SchemaObjectMappingDTO ( objectClass , attributeMappings ) ) ; } } catch ( Exception ex ) { throw new DTOMapperException ( STRING ) ; } return objectSchemaMappings ; }
private static Map < String , SchemaObjectMappingDTO > populateObjectSchema ( Collection < IdentityStoreObjectMapping > objectMappings ) throws DTOMapperException { Map < String , SchemaObjectMappingDTO > objectSchemaMappings = new HashMap < String , SchemaObjectMappingDTO > ( ) ; try { for ( IdentityStoreObjectMapping objectMapping : objectMappings ) { String objectId = objectMapping . getObjectId ( ) ; String objectClass = objectMapping . getObjectClass ( ) ; Map < String , String > attributeMappings = new HashMap < String , String > ( ) ; for ( IdentityStoreAttributeMapping attributeMapping : objectMapping . getAttributeMappings ( ) ) { attributeMappings . put ( attributeMapping . getAttributeId ( ) , attributeMapping . getAttributeName ( ) ) ; } objectSchemaMappings . put ( objectId , new SchemaObjectMappingDTO ( objectClass , attributeMappings ) ) ; } } catch ( Exception ex ) { throw new DTOMapperException ( STRING ) ; } return objectSchemaMappings ; }
public static void deleteDirectoryQuickly ( File dir ) throws IOException { if ( ! dir . exists ( ) ) { return ; } final File to = new File ( dir . getAbsolutePath ( ) + System . currentTimeMillis ( ) ) ; dir . renameTo ( to ) ; if ( ! dir . exists ( ) ) { dir . mkdirs ( ) ; } if ( to . exists ( ) ) { String deleteCmd = STRING + to ; Runtime runtime = Runtime . getRuntime ( ) ; try { Process process = runtime . exec ( deleteCmd ) ; process . waitFor ( ) ; } catch ( IOException e ) { } catch ( InterruptedException e ) { e . printStackTrace ( ) ; } } if ( ! to . exists ( ) ) { return ; } deleteDirectoryRecursively ( to ) ; if ( to . exists ( ) ) { to . delete ( ) ; } }
public static String transformAllLineSeparators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replaceAll ( STRING ) ; } return text ; }
public static String transformAllLineSeparators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replaceAll ( STRING ) ; } return text ; }
public static String transformAllLineSeparators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replaceAll ( STRING ) ; } return text ; }
public static String transformAllLineSeparators ( String text ) { Pattern crlf = Pattern . compile ( STRING ) ; Matcher m = crlf . matcher ( text ) ; if ( m . find ( ) ) { text = m . replaceAll ( STRING ) ; } return text ; }
protected < T > void runTasksConcurrent ( final List < AbstractTask < T > > tasks ) throws InterruptedException { assert resourceManager . overflowTasksConcurrent >= _NUM ; try { final List < Future < T > > futures = resourceManager . getConcurrencyManager ( ) . invokeAll ( tasks , resourceManager . overflowTimeout , TimeUnit . MILLISECONDS ) ; final Iterator < AbstractTask < T > > titr = tasks . iterator ( ) ; for ( Future < ? extends Object > f : futures ) { final AbstractTask < T > task = titr . next ( ) ; getFutureForTask ( f , task , _NUM , TimeUnit . NANOSECONDS ) ; } } finally { } }
public void bindKeyStore ( final KeyStoreService keyStoreService ) { this . keyStore = keyStoreService ; }
public void bindKeyStore ( final KeyStoreService keyStoreService ) { this . keyStore = keyStoreService ; }
public void registerCallbackHandler ( SMSObjectListener changeListener ) throws SMSException { objectListener = changeListener ; if ( ! notificationInitialized ) { String notificationFlag = SystemProperties . get ( NOTIFICATION_PROPERTY , STRING ) ; if ( notificationFlag . equalsIgnoreCase ( STRING ) ) { try { URL url = WebtopNaming . getNotificationURL ( ) ; PLLClient . addNotificationHandler ( JAXRPCUtil . SMS_SERVICE , new SMSNotificationHandler ( ) ) ; client . send ( STRING , url . toString ( ) , null , null ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + STRING + url ) ; } } catch ( Exception e ) { if ( debug . warningEnabled ( ) ) { debug . warning ( STRING + STRING + e . getMessage ( ) + STRING ) ; } startPollingThreadIfEnabled ( getCachePollingInterval ( ) ) ; } } else { startPollingThreadIfEnabled ( getCachePollingInterval ( ) ) ; } notificationInitialized = _BOOL ; } }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
public IVariable [ ] extractRobotDebugVariables ( final int stackTraceId , final Map < String , Object > newVariables ) { final RobotDebugVariablesContext currentVariablesContext = findCurrentVariablesContext ( stackTraceId ) ; Map < String , IVariable > previousVariablesMap = initPreviousVariablesState ( currentVariablesContext ) ; final Map < String , IVariable > nonGlobalVariablesMap = new LinkedHashMap < > ( ) ; if ( previousVariablesMap == null ) { initNewNonGlobalVariables ( newVariables , nonGlobalVariablesMap ) ; } else { initVariablesComparingWithPreviousState ( newVariables , previousVariablesMap , nonGlobalVariablesMap ) ; } final LinkedList < IVariable > currentVariablesList = createCurrentVariablesList ( nonGlobalVariablesMap ) ; saveCurrentVariablesState ( stackTraceId , currentVariablesContext , nonGlobalVariablesMap ) ; return currentVariablesList . toArray ( new IVariable [ currentVariablesList . size ( ) ] ) ; }
EvalThread ( ContextInfo contextInfo ) { super ( null ) ; this . contextInfo = contextInfo ; setDaemon ( _BOOL ) ; }
public ThreadQueue ( ) { qThreads = new LinkedList ( ) ; }
public ThreadQueue ( ) { qThreads = new LinkedList ( ) ; }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
private static void generateEvents ( ) throws Exception { String regionName = Region . SEPARATOR + REGION_NAME ; Region region = cache . getRegion ( regionName ) ; for ( int i = _NUM ; i < TOTAL_PUTS ; i ++ ) { region . put ( STRING + i , STRING + i ) ; } Thread . sleep ( DISPATCHER_SLOWSTART_TIME + _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { region . put ( LAST_KEY , STRING ) ; } }
protected void addToGUI ( JPanel gui , JTextField b , String cmd ) { b . setActionCommand ( cmd ) ; b . addActionListener ( this ) ; gui . add ( b ) ; }
private OpEnum ( String name ) { this . name = name ; map . put ( name , this ) ; }
private void historyAdd ( String text ) { if ( ! text . isEmpty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
private void historyAdd ( String text ) { if ( ! text . isEmpty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
private void historyAdd ( String text ) { if ( ! text . isEmpty ( ) ) { history . remove ( text ) ; history . add ( text ) ; } }
public static Attribute attributeFromAnnotationValue ( ProcessingEnvironment env , ExecutableElement meth , AnnotationValue av ) { return av . accept ( new AttributeCreator ( env , meth ) , null ) ; }
private < T extends Draft3Resource > T lookForResource ( Draft3ResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > _NUM ? resources . get ( _NUM ) : null ; }
private < T extends Draft3Resource > T lookForResource ( Draft3ResourceType type , Class < T > clazz ) { List < T > resources = lookForResources ( type , clazz ) ; return resources != null && resources . size ( ) > _NUM ? resources . get ( _NUM ) : null ; }
public void enable ( ) { if ( this . taskId == - _NUM ) { start ( ) ; } }
public static String trimAndConvertEmptyToNull ( String str ) { if ( str == null ) { return null ; } String newStr = str . trim ( ) ; if ( newStr . length ( ) < _NUM ) { return null ; } return newStr ; }
public static String trimAndConvertEmptyToNull ( String str ) { if ( str == null ) { return null ; } String newStr = str . trim ( ) ; if ( newStr . length ( ) < _NUM ) { return null ; } return newStr ; }
public static String trimAndConvertEmptyToNull ( String str ) { if ( str == null ) { return null ; } String newStr = str . trim ( ) ; if ( newStr . length ( ) < _NUM ) { return null ; } return newStr ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer oldSize = Integer . valueOf ( _trainHashTable . size ( ) ) ; _trainHashTable . remove ( train . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _trainHashTable . size ( ) ) ) ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer oldSize = Integer . valueOf ( _trainHashTable . size ( ) ) ; _trainHashTable . remove ( train . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _trainHashTable . size ( ) ) ) ; }
public void deregister ( Train train ) { if ( train == null ) { return ; } train . dispose ( ) ; Integer oldSize = Integer . valueOf ( _trainHashTable . size ( ) ) ; _trainHashTable . remove ( train . getId ( ) ) ; setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _trainHashTable . size ( ) ) ) ; }
protected void removeRange ( int fromIndex , int toIndex ) { modCount ++ ; int numMoved = elementCount - toIndex ; System . arraycopy ( elementData , toIndex , elementData , fromIndex , numMoved ) ; int newElementCount = elementCount - ( toIndex - fromIndex ) ; while ( elementCount != newElementCount ) elementData [ -- elementCount ] = null ; }
protected void removeRange ( int fromIndex , int toIndex ) { modCount ++ ; int numMoved = elementCount - toIndex ; System . arraycopy ( elementData , toIndex , elementData , fromIndex , numMoved ) ; int newElementCount = elementCount - ( toIndex - fromIndex ) ; while ( elementCount != newElementCount ) elementData [ -- elementCount ] = null ; }
protected void removeRange ( int fromIndex , int toIndex ) { modCount ++ ; int numMoved = elementCount - toIndex ; System . arraycopy ( elementData , toIndex , elementData , fromIndex , numMoved ) ; int newElementCount = elementCount - ( toIndex - fromIndex ) ; while ( elementCount != newElementCount ) elementData [ -- elementCount ] = null ; }
protected void removeRange ( int fromIndex , int toIndex ) { modCount ++ ; int numMoved = elementCount - toIndex ; System . arraycopy ( elementData , toIndex , elementData , fromIndex , numMoved ) ; int newElementCount = elementCount - ( toIndex - fromIndex ) ; while ( elementCount != newElementCount ) elementData [ -- elementCount ] = null ; }
public void update ( String wsId , long activityTime ) { if ( expirePeriod > _NUM ) { activeWorkspaces . put ( wsId , activityTime + expirePeriod ) ; } }
private void runReadTest ( byte [ ] input , CompressionMode mode ) throws IOException { runReadTest ( input , mode , mode ) ; }
private void runReadTest ( byte [ ] input , CompressionMode mode ) throws IOException { runReadTest ( input , mode , mode ) ; }
private void runReadTest ( byte [ ] input , CompressionMode mode ) throws IOException { runReadTest ( input , mode , mode ) ; }
public R paramsToMultipartEntity ( ) { try { mHttpEntity = createMultipartEntity ( _BOOL ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ( R ) this ; }
public R paramsToMultipartEntity ( ) { try { mHttpEntity = createMultipartEntity ( _BOOL ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return ( R ) this ; }
private static native int mlockall ( int flags ) ;
private static native int mlockall ( int flags ) ;
private static native int mlockall ( int flags ) ;
public static int tryParseInt ( String toParse , String defaultValue ) { int result ; try { result = Integer . parseInt ( toParse ) ; } catch ( NumberFormatException ex ) { result = Integer . parseInt ( defaultValue ) ; } return result ; }
public static int tryParseInt ( String toParse , String defaultValue ) { int result ; try { result = Integer . parseInt ( toParse ) ; } catch ( NumberFormatException ex ) { result = Integer . parseInt ( defaultValue ) ; } return result ; }
public static int tryParseInt ( String toParse , String defaultValue ) { int result ; try { result = Integer . parseInt ( toParse ) ; } catch ( NumberFormatException ex ) { result = Integer . parseInt ( defaultValue ) ; } return result ; }
public static int tryParseInt ( String toParse , String defaultValue ) { int result ; try { result = Integer . parseInt ( toParse ) ; } catch ( NumberFormatException ex ) { result = Integer . parseInt ( defaultValue ) ; } return result ; }
private void release ( ) { _pages . clear ( ) ; _pages_rendered . clear ( ) ; _error = null ; _isWorking = _BOOL ; file_name = null ; file = null ; if ( _ringProgressDialog != null ) { _ringProgressDialog . dismiss ( ) ; _ringProgressDialog = null ; } }
public void registerCodeNodeContextMenuExtension ( final ICodeNodeExtension extension ) { Preconditions . checkNotNull ( extension , STRING ) ; m_codeNodeExtensions . add ( extension ) ; }
public void registerCodeNodeContextMenuExtension ( final ICodeNodeExtension extension ) { Preconditions . checkNotNull ( extension , STRING ) ; m_codeNodeExtensions . add ( extension ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private int [ ] mergeEstimators ( HyperLogLogPlus other ) { other . mergeTempList ( ) ; int [ ] tmp = other . getSparseSet ( ) ; mergeTempList ( ) ; int [ ] set = sparseSet ; List < Integer > newSet = new ArrayList < Integer > ( ) ; int seti = _NUM ; int tmpi = _NUM ; while ( seti < set . length || tmpi < tmp . length ) { if ( seti >= set . length ) { newSet . add ( tmp [ tmpi ++ ] ) ; } else if ( tmpi >= tmp . length ) { newSet . add ( set [ seti ++ ] ) ; } else { int setVal = set [ seti ] ; int tmpVal = tmp [ tmpi ] ; if ( getSparseIndex ( setVal ) == getSparseIndex ( tmpVal ) ) { newSet . add ( Math . min ( setVal , tmpVal ) ) ; tmpi ++ ; seti ++ ; } else if ( getSparseIndex ( setVal ) < getSparseIndex ( tmpVal ) ) { newSet . add ( setVal ) ; seti ++ ; } else { newSet . add ( tmpVal ) ; tmpi ++ ; } } } return toIntArray ( newSet ) ; }
private Object executePlus ( PageContext pc , SQL sql , Query qr , ZExpression expression , int row ) throws PageException { Object left = executeExp ( pc , sql , qr , expression . getOperand ( _NUM ) , row ) ; Object right = executeExp ( pc , sql , qr , expression . getOperand ( _NUM ) , row ) ; try { return new Double ( Caster . toDoubleValue ( left ) + Caster . toDoubleValue ( right ) ) ; } catch ( PageException e ) { return Caster . toString ( left ) + Caster . toString ( right ) ; } }
public void addSubNode ( final NavNode subNode ) { subNodes . add ( subNode ) ; subNode . setParent ( this ) ; Collections . sort ( subNodes , NODE_COMPARATOR ) ; }
private void handleServiceBoundH ( ) { if ( mVerb != VERB_BINDING ) { closeAndCleanupJobH ( _BOOL ) ; return ; } if ( mCancelled . get ( ) ) { closeAndCleanupJobH ( _BOOL ) ; return ; } try { mVerb = VERB_STARTING ; scheduleOpTimeOut ( ) ; service . startJob ( mParams ) ; } catch ( RemoteException e ) { e . printStackTrace ( ) ; } }
public double normalizedKernel ( char [ ] s , char [ ] t ) { double k1 = unnormalizedKernel ( s , s ) ; double k2 = unnormalizedKernel ( t , t ) ; double normTerm = Math . sqrt ( k1 * k2 ) ; return unnormalizedKernel ( s , t ) / normTerm ; }
public double normalizedKernel ( char [ ] s , char [ ] t ) { double k1 = unnormalizedKernel ( s , s ) ; double k2 = unnormalizedKernel ( t , t ) ; double normTerm = Math . sqrt ( k1 * k2 ) ; return unnormalizedKernel ( s , t ) / normTerm ; }
@ Override public void dispose ( ) { if ( receiveThread != null ) { receiveThread . interrupt ( ) ; try { receiveThread . join ( ) ; } catch ( InterruptedException e ) { } receiveThread = null ; } if ( serialPort != null ) { serialPort . close ( ) ; serialPort = null ; } logger . info ( STRING ) ; super . dispose ( ) ; }
static protected String [ ] splitLineCSV ( String line ) { char [ ] c = line . toCharArray ( ) ; int rough = _NUM ; boolean quote = _BOOL ; for ( int i = _NUM ; i < c . length ; i ++ ) { if ( ! quote && ( c [ i ] == STRING ) ) { rough ++ ; } else if ( c [ i ] == STRING ) { quote = ! quote ; } } String [ ] pieces = new String [ rough ] ; int pieceCount = _NUM ; int offset = _NUM ; while ( offset < c . length ) { int start = offset ; int stop = nextComma ( c , offset ) ; offset = stop + _NUM ; if ( c [ start ] == STRING && c [ stop - _NUM ] == STRING ) { start ++ ; stop -- ; } int i = start ; int ii = start ; while ( i < stop ) { if ( c [ i ] == STRING ) { i ++ ; } if ( i != ii ) { c [ ii ] = c [ i ] ; } i ++ ; ii ++ ; } String s = new String ( c , start , ii - start ) ; pieces [ pieceCount ++ ] = s ; } for ( int i = pieceCount ; i < pieces . length ; i ++ ) { pieces [ i ] = STRING ; } return pieces ; }
private void handlePreparedStatementClusterError ( Throwable e ) { int hndNum = prepStatementHandlersCnt . incrementAndGet ( ) ; try { synchronized ( prepStatementHandlersCnt ) { if ( hndNum != _NUM ) { log . warning ( STRING , e ) ; return ; } log . warning ( STRING , e ) ; refresh ( ) ; log . warning ( STRING ) ; } } finally { if ( hndNum == _NUM ) prepStatementHandlersCnt . set ( - _NUM ) ; } }
public Document create ( String database , String table , String json ) throws IndexParseException { verifyTable ( database , table ) ; Document doc = new Document ( ) ; doc . setTable ( database , table ) ; doc . setObjectAsString ( json ) ; doc . setUuid ( UUID . randomUUID ( ) ) ; ValidationEngine . validateAndThrow ( doc ) ; try { Document created = docRepo . create ( doc ) ; notifyAllPlugins ( NotifierPlugin . MutateType . CREATE , created ) ; return created ; } catch ( RuntimeException e ) { if ( e . getCause ( ) != null && e . getCause ( ) instanceof IndexParseException ) { throw ( IndexParseException ) e . getCause ( ) ; } else { throw e ; } } }
public String query ( String handler , SolrQueryRequest req ) throws Exception { try ( SolrCore core = getCoreInc ( ) ) { SolrQueryResponse rsp = new SolrQueryResponse ( ) ; SolrRequestInfo . setRequestInfo ( new SolrRequestInfo ( req , rsp ) ) ; core . execute ( core . getRequestHandler ( handler ) , req , rsp ) ; if ( rsp . getException ( ) != null ) { throw rsp . getException ( ) ; } StringWriter sw = new StringWriter ( _NUM ) ; QueryResponseWriter responseWriter = core . getQueryResponseWriter ( req ) ; responseWriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . toString ( ) ; } finally { req . close ( ) ; SolrRequestInfo . clearRequestInfo ( ) ; } }
public String query ( String handler , SolrQueryRequest req ) throws Exception { try ( SolrCore core = getCoreInc ( ) ) { SolrQueryResponse rsp = new SolrQueryResponse ( ) ; SolrRequestInfo . setRequestInfo ( new SolrRequestInfo ( req , rsp ) ) ; core . execute ( core . getRequestHandler ( handler ) , req , rsp ) ; if ( rsp . getException ( ) != null ) { throw rsp . getException ( ) ; } StringWriter sw = new StringWriter ( _NUM ) ; QueryResponseWriter responseWriter = core . getQueryResponseWriter ( req ) ; responseWriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . toString ( ) ; } finally { req . close ( ) ; SolrRequestInfo . clearRequestInfo ( ) ; } }
public String query ( String handler , SolrQueryRequest req ) throws Exception { try ( SolrCore core = getCoreInc ( ) ) { SolrQueryResponse rsp = new SolrQueryResponse ( ) ; SolrRequestInfo . setRequestInfo ( new SolrRequestInfo ( req , rsp ) ) ; core . execute ( core . getRequestHandler ( handler ) , req , rsp ) ; if ( rsp . getException ( ) != null ) { throw rsp . getException ( ) ; } StringWriter sw = new StringWriter ( _NUM ) ; QueryResponseWriter responseWriter = core . getQueryResponseWriter ( req ) ; responseWriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . toString ( ) ; } finally { req . close ( ) ; SolrRequestInfo . clearRequestInfo ( ) ; } }
public String query ( String handler , SolrQueryRequest req ) throws Exception { try ( SolrCore core = getCoreInc ( ) ) { SolrQueryResponse rsp = new SolrQueryResponse ( ) ; SolrRequestInfo . setRequestInfo ( new SolrRequestInfo ( req , rsp ) ) ; core . execute ( core . getRequestHandler ( handler ) , req , rsp ) ; if ( rsp . getException ( ) != null ) { throw rsp . getException ( ) ; } StringWriter sw = new StringWriter ( _NUM ) ; QueryResponseWriter responseWriter = core . getQueryResponseWriter ( req ) ; responseWriter . write ( sw , req , rsp ) ; req . close ( ) ; return sw . toString ( ) ; } finally { req . close ( ) ; SolrRequestInfo . clearRequestInfo ( ) ; } }
public void storeDeviceTypeCertificate ( String path , String secret , String deviceTypeId ) throws KeyStoreException { char [ ] secretAsChars = secret . toCharArray ( ) ; Certificate certificate = null ; Key key = null ; try { KeyStore tempKeyStore = load ( STRING , path , secretAsChars ) ; String alias = STRING ; key = tempKeyStore . getKey ( alias , secretAsChars ) ; certificate = tempKeyStore . getCertificate ( alias ) ; } catch ( KeyStoreException | NoSuchAlgorithmException | UnrecoverableKeyException e ) { throw new KeyStoreException ( STRING , e ) ; } storeCertificate ( STRING , certificate , key ) ; }
public byte [ ] decryptMacKey ( String encMacKeyBase64 , String serverPublicKeyBase64 ) throws AssociationException { byte [ ] hzz = getDigestedZZ ( serverPublicKeyBase64 ) ; byte [ ] encMacKey = Base64 . decodeBase64 ( encMacKeyBase64 . getBytes ( ) ) ; if ( hzz . length != encMacKey . length ) throw new AssociationException ( STRING ) ; byte [ ] macKey = new byte [ hzz . length ] ; for ( int i = _NUM ; i < hzz . length ; i ++ ) { byte b1 = hzz [ i ] ; byte b2 = encMacKey [ i ] ; macKey [ i ] = ( byte ) ( b1 ^ b2 ) ; } if ( DEBUG ) _log . debug ( STRING + new String ( Base64 . encodeBase64 ( macKey ) ) ) ; return macKey ; }
public byte [ ] decryptMacKey ( String encMacKeyBase64 , String serverPublicKeyBase64 ) throws AssociationException { byte [ ] hzz = getDigestedZZ ( serverPublicKeyBase64 ) ; byte [ ] encMacKey = Base64 . decodeBase64 ( encMacKeyBase64 . getBytes ( ) ) ; if ( hzz . length != encMacKey . length ) throw new AssociationException ( STRING ) ; byte [ ] macKey = new byte [ hzz . length ] ; for ( int i = _NUM ; i < hzz . length ; i ++ ) { byte b1 = hzz [ i ] ; byte b2 = encMacKey [ i ] ; macKey [ i ] = ( byte ) ( b1 ^ b2 ) ; } if ( DEBUG ) _log . debug ( STRING + new String ( Base64 . encodeBase64 ( macKey ) ) ) ; return macKey ; }
public int noOfTabs ( ) { return m_curWinTab . getTabCount ( ) ; }
default < T > void forEachMatchingFieldNameWithBoolean ( String regex , BiConsumer < String , Boolean > function ) { forEachMatchingFieldNameWithBoolean ( Pattern . compile ( regex ) , _NUM , function ) ; }
public boolean connect ( final String address ) { if ( isScanning ) scanLeDevice ( _BOOL ) ; close ( ) ; if ( mBluetoothAdapter == null || address == null ) { Log . w ( TAG , STRING ) ; return _BOOL ; } if ( mBluetoothGatt != null && mBluetoothDeviceAddress != null && address . equals ( mBluetoothDeviceAddress ) ) { Log . d ( TAG , STRING ) ; if ( mBluetoothGatt . connect ( ) ) { mConnState = STATE_CONNECTING ; return _BOOL ; } else { return _BOOL ; } } final BluetoothDevice device = mBluetoothAdapter . getRemoteDevice ( address ) ; if ( device == null ) { Log . w ( TAG , STRING ) ; return _BOOL ; } mBluetoothGatt = device . connectGatt ( this , _BOOL , mGattCallback ) ; Log . d ( TAG , STRING ) ; mBluetoothDeviceAddress = address ; mConnState = STATE_CONNECTING ; return _BOOL ; }
public boolean connect ( final String address ) { if ( isScanning ) scanLeDevice ( _BOOL ) ; close ( ) ; if ( mBluetoothAdapter == null || address == null ) { Log . w ( TAG , STRING ) ; return _BOOL ; } if ( mBluetoothGatt != null && mBluetoothDeviceAddress != null && address . equals ( mBluetoothDeviceAddress ) ) { Log . d ( TAG , STRING ) ; if ( mBluetoothGatt . connect ( ) ) { mConnState = STATE_CONNECTING ; return _BOOL ; } else { return _BOOL ; } } final BluetoothDevice device = mBluetoothAdapter . getRemoteDevice ( address ) ; if ( device == null ) { Log . w ( TAG , STRING ) ; return _BOOL ; } mBluetoothGatt = device . connectGatt ( this , _BOOL , mGattCallback ) ; Log . d ( TAG , STRING ) ; mBluetoothDeviceAddress = address ; mConnState = STATE_CONNECTING ; return _BOOL ; }
public < T extends JCTree > void printExprs ( List < T > trees , String sep ) throws IOException { if ( trees . nonEmpty ( ) ) { printExpr ( trees . head ) ; for ( List < T > l = trees . tail ; l . nonEmpty ( ) ; l = l . tail ) { print ( sep ) ; if ( sep . endsWith ( STRING ) ) { align ( ) ; } printExpr ( l . head ) ; } } }
public < T extends JCTree > void printExprs ( List < T > trees , String sep ) throws IOException { if ( trees . nonEmpty ( ) ) { printExpr ( trees . head ) ; for ( List < T > l = trees . tail ; l . nonEmpty ( ) ; l = l . tail ) { print ( sep ) ; if ( sep . endsWith ( STRING ) ) { align ( ) ; } printExpr ( l . head ) ; } } }
public ArgumentException ( final LocalizableMessage message ) { super ( String . valueOf ( message ) ) ; this . message = message ; }
final boolean doAdvance ( ) { if ( buffer == null ) { if ( finished ) return _BOOL ; init ( ) ; initPartialTraversalState ( ) ; nextToConsume = _NUM ; bufferSink . begin ( spliterator . getExactSizeIfKnown ( ) ) ; return fillBuffer ( ) ; } else { ++ nextToConsume ; boolean hasNext = nextToConsume < buffer . count ( ) ; if ( ! hasNext ) { nextToConsume = _NUM ; buffer . clear ( ) ; hasNext = fillBuffer ( ) ; } return hasNext ; } }
public static Path createTempFile ( String prefix , String suffix ) throws IOException { Path tempDirPath = Paths . get ( SystemProperties . getTempFilesPath ( ) ) ; return createTempFile ( tempDirPath , prefix , suffix ) ; }
public static Path createTempFile ( String prefix , String suffix ) throws IOException { Path tempDirPath = Paths . get ( SystemProperties . getTempFilesPath ( ) ) ; return createTempFile ( tempDirPath , prefix , suffix ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
private String printDFormat ( short x ) { return printDFormat ( Short . toString ( x ) ) ; }
public boolean removeEntryFromCache ( IEntryHolder entryHolder ) { return removeEntryFromCache ( entryHolder , _BOOL , _BOOL , null , RecentDeleteCodes . NONE ) ; }
public void findEndBlock ( ) throws IOException { try { String token ; do { token = readToken ( STRING ) ; } while ( ! token . equalsIgnoreCase ( STRING ) && ! token . equalsIgnoreCase ( STRING ) ) ; } catch ( EOFException e ) { } nextBlock = UNKNOWN_BLOCK ; }
public static String determineInitialCheckOutPage ( ShoppingCart cart ) { String page = DEFAULT_INIT_CHECKOUT_PAGE ; if ( cart == null ) return page ; if ( ! cart . shippingApplies ( ) ) { cart . setAllShipmentMethodTypeId ( STRING ) ; cart . setAllCarrierPartyId ( STRING ) ; page = STRING ; } return page ; }
public static String determineInitialCheckOutPage ( ShoppingCart cart ) { String page = DEFAULT_INIT_CHECKOUT_PAGE ; if ( cart == null ) return page ; if ( ! cart . shippingApplies ( ) ) { cart . setAllShipmentMethodTypeId ( STRING ) ; cart . setAllCarrierPartyId ( STRING ) ; page = STRING ; } return page ; }
public static String determineInitialCheckOutPage ( ShoppingCart cart ) { String page = DEFAULT_INIT_CHECKOUT_PAGE ; if ( cart == null ) return page ; if ( ! cart . shippingApplies ( ) ) { cart . setAllShipmentMethodTypeId ( STRING ) ; cart . setAllCarrierPartyId ( STRING ) ; page = STRING ; } return page ; }
public static String determineInitialCheckOutPage ( ShoppingCart cart ) { String page = DEFAULT_INIT_CHECKOUT_PAGE ; if ( cart == null ) return page ; if ( ! cart . shippingApplies ( ) ) { cart . setAllShipmentMethodTypeId ( STRING ) ; cart . setAllCarrierPartyId ( STRING ) ; page = STRING ; } return page ; }
public static String determineInitialCheckOutPage ( ShoppingCart cart ) { String page = DEFAULT_INIT_CHECKOUT_PAGE ; if ( cart == null ) return page ; if ( ! cart . shippingApplies ( ) ) { cart . setAllShipmentMethodTypeId ( STRING ) ; cart . setAllCarrierPartyId ( STRING ) ; page = STRING ; } return page ; }
public static String convertID3v23GenreToGeneric ( String value ) { if ( value . contains ( STRING ) && value . lastIndexOf ( STRING ) < value . length ( ) - _NUM ) { return checkBracketed ( value . substring ( _NUM , value . lastIndexOf ( STRING ) ) ) + STRING + value . substring ( value . lastIndexOf ( STRING ) + _NUM ) ; } else { return checkBracketed ( value ) ; } }
public static String convertID3v23GenreToGeneric ( String value ) { if ( value . contains ( STRING ) && value . lastIndexOf ( STRING ) < value . length ( ) - _NUM ) { return checkBracketed ( value . substring ( _NUM , value . lastIndexOf ( STRING ) ) ) + STRING + value . substring ( value . lastIndexOf ( STRING ) + _NUM ) ; } else { return checkBracketed ( value ) ; } }
public static String convertID3v23GenreToGeneric ( String value ) { if ( value . contains ( STRING ) && value . lastIndexOf ( STRING ) < value . length ( ) - _NUM ) { return checkBracketed ( value . substring ( _NUM , value . lastIndexOf ( STRING ) ) ) + STRING + value . substring ( value . lastIndexOf ( STRING ) + _NUM ) ; } else { return checkBracketed ( value ) ; } }
public boolean removeChild ( SMSFlatFileTreeNode node , String baseDir ) { boolean removed = _BOOL ; for ( Iterator i = children . iterator ( ) ; ( i . hasNext ( ) ) && ! removed ; ) { SMSFlatFileTreeNode c = ( SMSFlatFileTreeNode ) i . next ( ) ; if ( c . equals ( node ) ) { i . remove ( ) ; node . clear ( baseDir ) ; removed = _BOOL ; } } return removed ; }
public boolean startsWith ( String str ) { if ( str == null ) { return _BOOL ; } int len = str . length ( ) ; if ( len == _NUM ) { return _BOOL ; } if ( len > size ) { return _BOOL ; } for ( int i = _NUM ; i < len ; i ++ ) { if ( buffer [ i ] != str . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
protected void initializeWithPluginMetrics ( ) { m_pluginMetrics . clear ( ) ; List < AbstractEvaluationMetric > pluginMetrics = m_eval . getPluginMetrics ( ) ; if ( pluginMetrics != null && pluginMetrics . size ( ) > _NUM ) { for ( AbstractEvaluationMetric m : pluginMetrics ) { List < String > statNames = m . getStatisticNames ( ) ; for ( String s : statNames ) { m_pluginMetrics . put ( s . toLowerCase ( ) , m ) ; } } } }
public void testCase8 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aBytes ) ; BigInteger bNumber = new BigInteger ( bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { ByteBuffer buffer = ByteBuffer . wrap ( ( byte [ ] ) newVal ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { byte [ ] valueByte = new byte [ buffer . getInt ( ) ] ; buffer . get ( valueByte ) ; BigDecimal valueBigDecimal = DataTypeUtil . byteToBigDecimal ( valueByte ) ; aggVal = aggVal . add ( valueBigDecimal ) ; count += buffer . getDouble ( ) ; firstTime = _BOOL ; } return ; } if ( firstTime ) { aggVal = ( BigDecimal ) newVal ; firstTime = _BOOL ; } else { aggVal = aggVal . add ( ( BigDecimal ) newVal ) ; } count ++ ; }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { ByteBuffer buffer = ByteBuffer . wrap ( ( byte [ ] ) newVal ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { byte [ ] valueByte = new byte [ buffer . getInt ( ) ] ; buffer . get ( valueByte ) ; BigDecimal valueBigDecimal = DataTypeUtil . byteToBigDecimal ( valueByte ) ; aggVal = aggVal . add ( valueBigDecimal ) ; count += buffer . getDouble ( ) ; firstTime = _BOOL ; } return ; } if ( firstTime ) { aggVal = ( BigDecimal ) newVal ; firstTime = _BOOL ; } else { aggVal = aggVal . add ( ( BigDecimal ) newVal ) ; } count ++ ; }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { ByteBuffer buffer = ByteBuffer . wrap ( ( byte [ ] ) newVal ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { byte [ ] valueByte = new byte [ buffer . getInt ( ) ] ; buffer . get ( valueByte ) ; BigDecimal valueBigDecimal = DataTypeUtil . byteToBigDecimal ( valueByte ) ; aggVal = aggVal . add ( valueBigDecimal ) ; count += buffer . getDouble ( ) ; firstTime = _BOOL ; } return ; } if ( firstTime ) { aggVal = ( BigDecimal ) newVal ; firstTime = _BOOL ; } else { aggVal = aggVal . add ( ( BigDecimal ) newVal ) ; } count ++ ; }
@ Override public void agg ( Object newVal ) { if ( newVal instanceof byte [ ] ) { ByteBuffer buffer = ByteBuffer . wrap ( ( byte [ ] ) newVal ) ; buffer . rewind ( ) ; while ( buffer . hasRemaining ( ) ) { byte [ ] valueByte = new byte [ buffer . getInt ( ) ] ; buffer . get ( valueByte ) ; BigDecimal valueBigDecimal = DataTypeUtil . byteToBigDecimal ( valueByte ) ; aggVal = aggVal . add ( valueBigDecimal ) ; count += buffer . getDouble ( ) ; firstTime = _BOOL ; } return ; } if ( firstTime ) { aggVal = ( BigDecimal ) newVal ; firstTime = _BOOL ; } else { aggVal = aggVal . add ( ( BigDecimal ) newVal ) ; } count ++ ; }
public < T > T guard ( final Callable < T > r ) throws Exception { incThread ( ) ; try { return r . call ( ) ; } finally { decThread ( ) ; } }
public < T > T guard ( final Callable < T > r ) throws Exception { incThread ( ) ; try { return r . call ( ) ; } finally { decThread ( ) ; } }
public < T > T guard ( final Callable < T > r ) throws Exception { incThread ( ) ; try { return r . call ( ) ; } finally { decThread ( ) ; } }
public void focusGained ( FocusEvent e ) { comboBox . repaint ( ) ; }
public void focusGained ( FocusEvent e ) { comboBox . repaint ( ) ; }
public void focusGained ( FocusEvent e ) { comboBox . repaint ( ) ; }
private void beforeName ( ) throws IOException { int context = peek ( ) ; if ( context == NONEMPTY_OBJECT ) { out . write ( STRING ) ; } else if ( context != EMPTY_OBJECT ) { throw new IllegalStateException ( STRING ) ; } newline ( ) ; replaceTop ( DANGLING_NAME ) ; }
private void beforeName ( ) throws IOException { int context = peek ( ) ; if ( context == NONEMPTY_OBJECT ) { out . write ( STRING ) ; } else if ( context != EMPTY_OBJECT ) { throw new IllegalStateException ( STRING ) ; } newline ( ) ; replaceTop ( DANGLING_NAME ) ; }
public static Time convertTime ( Value value , Calendar calendar ) { if ( value == ValueNull . INSTANCE ) { return null ; } ValueTime t = ( ValueTime ) value . convertTo ( Value . TIME ) ; Calendar cal = ( Calendar ) calendar . clone ( ) ; cal . clear ( ) ; cal . setLenient ( _BOOL ) ; long nanos = t . getNanos ( ) ; long millis = nanos / _NUM ; nanos -= millis * _NUM ; long s = millis / _NUM ; millis -= s * _NUM ; long m = s / _NUM ; s -= m * _NUM ; long h = m / _NUM ; m -= h * _NUM ; setCalendarFields ( cal , _NUM , _NUM , _NUM , ( int ) h , ( int ) m , ( int ) s , ( int ) millis ) ; long ms = cal . getTimeInMillis ( ) ; return new Time ( ms ) ; }
private ConcurrentSkipListMap . Node < K , V > hiNode ( ) { if ( hi == null ) return m . findLast ( ) ; else if ( hiInclusive ) return m . findNear ( hi , LT | EQ ) ; else return m . findNear ( hi , LT ) ; }
private ConcurrentSkipListMap . Node < K , V > hiNode ( ) { if ( hi == null ) return m . findLast ( ) ; else if ( hiInclusive ) return m . findNear ( hi , LT | EQ ) ; else return m . findNear ( hi , LT ) ; }
private ConcurrentSkipListMap . Node < K , V > hiNode ( ) { if ( hi == null ) return m . findLast ( ) ; else if ( hiInclusive ) return m . findNear ( hi , LT | EQ ) ; else return m . findNear ( hi , LT ) ; }
public void saveMRU ( ) { if ( mru . changed ) { try { ObjectOutputStream out = new ObjectOutputStream ( new FileOutputStream ( new File ( directory , MRUFILE ) ) ) ; out . writeObject ( mru ) ; out . close ( ) ; } catch ( Exception e ) { Log . e ( STRING , STRING , e ) ; } } }
public String displayNodeWithInstrumentation ( Node node ) { if ( node == null ) { return STRING ; } final StringBuilder sb = new StringBuilder ( ) ; sb . append ( displayNodeName ( node ) ) ; sb . append ( STRING ) ; sb . append ( displayTags ( node ) ) ; if ( node . getParent ( ) instanceof WrapperNode ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( displaySourceInfo ( node ) ) ; return sb . toString ( ) ; }
public String displayNodeWithInstrumentation ( Node node ) { if ( node == null ) { return STRING ; } final StringBuilder sb = new StringBuilder ( ) ; sb . append ( displayNodeName ( node ) ) ; sb . append ( STRING ) ; sb . append ( displayTags ( node ) ) ; if ( node . getParent ( ) instanceof WrapperNode ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( displaySourceInfo ( node ) ) ; return sb . toString ( ) ; }
public String displayNodeWithInstrumentation ( Node node ) { if ( node == null ) { return STRING ; } final StringBuilder sb = new StringBuilder ( ) ; sb . append ( displayNodeName ( node ) ) ; sb . append ( STRING ) ; sb . append ( displayTags ( node ) ) ; if ( node . getParent ( ) instanceof WrapperNode ) { sb . append ( STRING ) ; } sb . append ( STRING ) ; sb . append ( displaySourceInfo ( node ) ) ; return sb . toString ( ) ; }
public Multimap < String , String > loadRelations ( DBTransaction transaction , String charname ) throws SQLException { HashMultimap < String , String > map = HashMultimap . create ( ) ; String query = STRING ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING , charname ) ; ResultSet resultSet = transaction . query ( query , params ) ; while ( resultSet . next ( ) ) { map . put ( resultSet . getString ( _NUM ) , resultSet . getString ( _NUM ) ) ; } return map ; }
public Multimap < String , String > loadRelations ( DBTransaction transaction , String charname ) throws SQLException { HashMultimap < String , String > map = HashMultimap . create ( ) ; String query = STRING ; Map < String , Object > params = new HashMap < String , Object > ( ) ; params . put ( STRING , charname ) ; ResultSet resultSet = transaction . query ( query , params ) ; while ( resultSet . next ( ) ) { map . put ( resultSet . getString ( _NUM ) , resultSet . getString ( _NUM ) ) ; } return map ; }
private static String removeSubTrailers ( String decodedSubject ) { int subStringStart = _NUM ; int subStringEnd = decodedSubject . length ( ) ; int originalSize = decodedSubject . length ( ) ; int curPos = originalSize - _NUM ; while ( _BOOL ) { char c = decodedSubject . charAt ( curPos -- ) ; if ( c == WS ) { subStringEnd -- ; } else { if ( subStringEnd > FWD_PARENS . length ( ) && decodedSubject . endsWith ( FWD_PARENS ) ) { subStringEnd -= FWD_PARENS . length ( ) ; } break ; } } decodedSubject = decodedSubject . substring ( subStringStart , subStringEnd ) ; return decodedSubject ; }
@ SuppressWarnings ( STRING ) public Iterator < Node > xpathIterator ( String xpath ) { List < Node > nodes = XMLUtil . selectNodes ( document , xpath ) ; return nodes . iterator ( ) ; }
@ SuppressWarnings ( STRING ) public Iterator < Node > xpathIterator ( String xpath ) { List < Node > nodes = XMLUtil . selectNodes ( document , xpath ) ; return nodes . iterator ( ) ; }
private void rollBackVpoolOnVplexBackendVolume ( Volume volume , List < Volume > volumesToUpdate , DbClient dbClient , URI oldVpoolURI ) { Volume backendSrc = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendSrc != null ) { _log . info ( STRING , backendSrc . getId ( ) , backendSrc . getLabel ( ) ) ; backendSrc . setVirtualPool ( oldVpoolURI ) ; _log . info ( STRING , oldVpoolURI ) ; volumesToUpdate . add ( backendSrc ) ; Volume backendHa = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendHa != null ) { _log . info ( STRING , backendHa . getId ( ) , backendHa . getLabel ( ) ) ; VirtualPool oldVpoolObj = dbClient . queryObject ( VirtualPool . class , oldVpoolURI ) ; VirtualPool oldHAVpool = VirtualPool . getHAVPool ( oldVpoolObj , dbClient ) ; if ( oldHAVpool == null ) { oldHAVpool = oldVpoolObj ; } backendHa . setVirtualPool ( oldHAVpool . getId ( ) ) ; _log . info ( STRING , oldHAVpool . getId ( ) ) ; volumesToUpdate . add ( backendHa ) ; } } }
private void rollBackVpoolOnVplexBackendVolume ( Volume volume , List < Volume > volumesToUpdate , DbClient dbClient , URI oldVpoolURI ) { Volume backendSrc = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendSrc != null ) { _log . info ( STRING , backendSrc . getId ( ) , backendSrc . getLabel ( ) ) ; backendSrc . setVirtualPool ( oldVpoolURI ) ; _log . info ( STRING , oldVpoolURI ) ; volumesToUpdate . add ( backendSrc ) ; Volume backendHa = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendHa != null ) { _log . info ( STRING , backendHa . getId ( ) , backendHa . getLabel ( ) ) ; VirtualPool oldVpoolObj = dbClient . queryObject ( VirtualPool . class , oldVpoolURI ) ; VirtualPool oldHAVpool = VirtualPool . getHAVPool ( oldVpoolObj , dbClient ) ; if ( oldHAVpool == null ) { oldHAVpool = oldVpoolObj ; } backendHa . setVirtualPool ( oldHAVpool . getId ( ) ) ; _log . info ( STRING , oldHAVpool . getId ( ) ) ; volumesToUpdate . add ( backendHa ) ; } } }
private void rollBackVpoolOnVplexBackendVolume ( Volume volume , List < Volume > volumesToUpdate , DbClient dbClient , URI oldVpoolURI ) { Volume backendSrc = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendSrc != null ) { _log . info ( STRING , backendSrc . getId ( ) , backendSrc . getLabel ( ) ) ; backendSrc . setVirtualPool ( oldVpoolURI ) ; _log . info ( STRING , oldVpoolURI ) ; volumesToUpdate . add ( backendSrc ) ; Volume backendHa = VPlexUtil . getVPLEXBackendVolume ( volume , _BOOL , dbClient , _BOOL ) ; if ( backendHa != null ) { _log . info ( STRING , backendHa . getId ( ) , backendHa . getLabel ( ) ) ; VirtualPool oldVpoolObj = dbClient . queryObject ( VirtualPool . class , oldVpoolURI ) ; VirtualPool oldHAVpool = VirtualPool . getHAVPool ( oldVpoolObj , dbClient ) ; if ( oldHAVpool == null ) { oldHAVpool = oldVpoolObj ; } backendHa . setVirtualPool ( oldHAVpool . getId ( ) ) ; _log . info ( STRING , oldHAVpool . getId ( ) ) ; volumesToUpdate . add ( backendHa ) ; } } }
public DateTimeParserBucket ( long instantLocal , Chronology chrono , Locale locale , Integer pivotYear , int defaultYear ) { super ( ) ; chrono = DateTimeUtils . getChronology ( chrono ) ; iMillis = instantLocal ; iZone = chrono . getZone ( ) ; iChrono = chrono . withUTC ( ) ; iLocale = ( locale == null ? Locale . getDefault ( ) : locale ) ; iPivotYear = pivotYear ; iDefaultYear = defaultYear ; }
private void buildRevCallGraph ( ) { rev_call_graph = new HashMap < Integer , LinkedList < CgEdge > > ( ) ; for ( int i = _NUM ; i < n_func ; ++ i ) { CgEdge p = call_graph [ i ] ; while ( p != null ) { LinkedList < CgEdge > list = rev_call_graph . get ( p . t ) ; if ( list == null ) { list = new LinkedList < CgEdge > ( ) ; rev_call_graph . put ( p . t , list ) ; } list . add ( p ) ; p = p . next ; } } }
public void markTokens ( int lineIndex , TokenHandler tokenHandler ) { Segment seg = new Segment ( ) ; if ( lineIndex < _NUM || lineIndex >= lineMgr . getLineCount ( ) ) throw new ArrayIndexOutOfBoundsException ( STRING + lineMgr . getLineCount ( ) + STRING + lineIndex ) ; int firstInvalidLineContext = lineMgr . getFirstInvalidLineContext ( ) ; int start ; if ( firstInvalidLineContext == - _NUM ) { start = lineIndex ; } else { start = Math . min ( firstInvalidLineContext , lineIndex ) ; } TokenMarker . LineContext oldContext = null ; TokenMarker . LineContext context = null ; for ( int i = start ; i <= lineIndex ; i ++ ) { getLineText ( i , seg ) ; oldContext = lineMgr . getLineContext ( i ) ; TokenMarker . LineContext prevContext = ( ( i == _NUM ) ? null : lineMgr . getLineContext ( i - _NUM ) ) ; TokenHandler _tokenHandler = i == lineIndex ? tokenHandler : DummyTokenHandler . INSTANCE ; context = markTokens ( seg , prevContext , _tokenHandler ) ; lineMgr . setLineContext ( i , context ) ; } int lineCount = lineMgr . getLineCount ( ) ; if ( lineCount - _NUM == lineIndex ) lineMgr . setFirstInvalidLineContext ( - _NUM ) ; else if ( oldContext != context ) lineMgr . setFirstInvalidLineContext ( lineIndex + _NUM ) ; else if ( firstInvalidLineContext == - _NUM ) ; else { lineMgr . setFirstInvalidLineContext ( Math . max ( firstInvalidLineContext , lineIndex + _NUM ) ) ; } }
public void addCondition ( DataTableFilterCondition condition ) { if ( condition == null ) { return ; } conditionStack . add ( condition ) ; setSelectedIndices ( updateSelection ( ) ) ; informDataTableFilteredListener ( ) ; }
private FormBody bodyFromMap ( Map < String , String > map ) { FormBody . Builder formBody = new FormBody . Builder ( ) ; if ( map != null ) { for ( final Map . Entry < String , String > entrySet : map . entrySet ( ) ) { if ( entrySet . getValue ( ) != null ) { formBody . add ( entrySet . getKey ( ) , entrySet . getValue ( ) ) ; } } } return formBody . build ( ) ; }
private void createPressImageView ( View v , int x , int y ) { mWindowLayoutParams = new WindowManager . LayoutParams ( ) ; mWindowLayoutParams . gravity = Gravity . TOP | Gravity . LEFT ; mWindowLayoutParams . x = x - mPoint2ItemLeft + mOffset2Left ; mWindowLayoutParams . y = y - mPoint2ItemTop + mOffset2Top - mStatusHeight ; mWindowLayoutParams . alpha = _NUM ; mWindowLayoutParams . width = WindowManager . LayoutParams . WRAP_CONTENT ; mWindowLayoutParams . height = WindowManager . LayoutParams . WRAP_CONTENT ; mWindowLayoutParams . flags = WindowManager . LayoutParams . FLAG_NOT_FOCUSABLE | WindowManager . LayoutParams . FLAG_NOT_TOUCHABLE ; mDragImageView = new ImageView ( getContext ( ) ) ; v . setDrawingCacheEnabled ( _BOOL ) ; Bitmap bitmap = Bitmap . createBitmap ( v . getDrawingCache ( ) ) ; mDragImageView . setImageBitmap ( bitmap ) ; v . destroyDrawingCache ( ) ; mWindowManager . addView ( mDragImageView , mWindowLayoutParams ) ; }
private List < String > missingcloaks2 ( final Player player , final boolean hash ) { String doneText2 = player . getQuest ( QUEST_SLOT ) ; final List < String > neededCopy2 = new LinkedList < String > ( NEEDEDCLOAKS2 ) ; if ( doneText2 == null ) { doneText2 = STRING ; } final List < String > done2 = Arrays . asList ( doneText2 . split ( STRING ) ) ; neededCopy2 . removeAll ( done2 ) ; if ( hash ) { final List < String > result2 = new LinkedList < String > ( ) ; for ( final String cloak : neededCopy2 ) { result2 . add ( STRING + cloak ) ; } return result2 ; } return neededCopy2 ; }
private List < String > missingcloaks2 ( final Player player , final boolean hash ) { String doneText2 = player . getQuest ( QUEST_SLOT ) ; final List < String > neededCopy2 = new LinkedList < String > ( NEEDEDCLOAKS2 ) ; if ( doneText2 == null ) { doneText2 = STRING ; } final List < String > done2 = Arrays . asList ( doneText2 . split ( STRING ) ) ; neededCopy2 . removeAll ( done2 ) ; if ( hash ) { final List < String > result2 = new LinkedList < String > ( ) ; for ( final String cloak : neededCopy2 ) { result2 . add ( STRING + cloak ) ; } return result2 ; } return neededCopy2 ; }
private List < String > missingcloaks2 ( final Player player , final boolean hash ) { String doneText2 = player . getQuest ( QUEST_SLOT ) ; final List < String > neededCopy2 = new LinkedList < String > ( NEEDEDCLOAKS2 ) ; if ( doneText2 == null ) { doneText2 = STRING ; } final List < String > done2 = Arrays . asList ( doneText2 . split ( STRING ) ) ; neededCopy2 . removeAll ( done2 ) ; if ( hash ) { final List < String > result2 = new LinkedList < String > ( ) ; for ( final String cloak : neededCopy2 ) { result2 . add ( STRING + cloak ) ; } return result2 ; } return neededCopy2 ; }
@ Deprecated public static List < Integer > range ( int fromIncl , int toExcl ) { A . ensure ( fromIncl >= _NUM , STRING ) ; A . ensure ( toExcl >= _NUM , STRING ) ; A . ensure ( toExcl >= fromIncl , STRING ) ; if ( toExcl == fromIncl ) return Collections . emptyList ( ) ; List < Integer > list = new ArrayList < > ( toExcl - fromIncl ) ; for ( int i = fromIncl ; i < toExcl ; i ++ ) list . add ( i ) ; return list ; }
@ Deprecated public static List < Integer > range ( int fromIncl , int toExcl ) { A . ensure ( fromIncl >= _NUM , STRING ) ; A . ensure ( toExcl >= _NUM , STRING ) ; A . ensure ( toExcl >= fromIncl , STRING ) ; if ( toExcl == fromIncl ) return Collections . emptyList ( ) ; List < Integer > list = new ArrayList < > ( toExcl - fromIncl ) ; for ( int i = fromIncl ; i < toExcl ; i ++ ) list . add ( i ) ; return list ; }
@ Deprecated public static List < Integer > range ( int fromIncl , int toExcl ) { A . ensure ( fromIncl >= _NUM , STRING ) ; A . ensure ( toExcl >= _NUM , STRING ) ; A . ensure ( toExcl >= fromIncl , STRING ) ; if ( toExcl == fromIncl ) return Collections . emptyList ( ) ; List < Integer > list = new ArrayList < > ( toExcl - fromIncl ) ; for ( int i = fromIncl ; i < toExcl ; i ++ ) list . add ( i ) ; return list ; }
public static void createAndShowTableDemoFrame ( ) { JFrame frame = new JFrame ( STRING + InternalUtilities . getProjectVersionString ( ) ) ; frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; TableEditorsDemo tableDemoPanel = new TableEditorsDemo ( ) ; frame . setContentPane ( tableDemoPanel ) ; tableDemoPanel . setOpaque ( _BOOL ) ; frame . pack ( ) ; frame . setSize ( new Dimension ( _NUM , _NUM ) ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( _BOOL ) ; }
public static void createAndShowTableDemoFrame ( ) { JFrame frame = new JFrame ( STRING + InternalUtilities . getProjectVersionString ( ) ) ; frame . setDefaultCloseOperation ( JFrame . DISPOSE_ON_CLOSE ) ; TableEditorsDemo tableDemoPanel = new TableEditorsDemo ( ) ; frame . setContentPane ( tableDemoPanel ) ; tableDemoPanel . setOpaque ( _BOOL ) ; frame . pack ( ) ; frame . setSize ( new Dimension ( _NUM , _NUM ) ) ; frame . setLocationRelativeTo ( null ) ; frame . setVisible ( _BOOL ) ; }
protected void validateParameters ( final RowValue parameters ) throws SQLException { final RowDescriptor parameterDescriptor = getParameterDescriptor ( ) ; final int expectedSize = parameterDescriptor != null ? parameterDescriptor . getCount ( ) : _NUM ; final int actualSize = parameters . getCount ( ) ; if ( actualSize != expectedSize ) { throw new SQLNonTransientException ( String . format ( STRING , expectedSize , actualSize ) , STRING ) ; } for ( int fieldIndex = _NUM ; fieldIndex < actualSize ; fieldIndex ++ ) { FieldValue fieldValue = parameters . getFieldValue ( fieldIndex ) ; if ( fieldValue == null || ! fieldValue . isInitialized ( ) ) { throw new SQLTransientException ( String . format ( STRING , fieldIndex + _NUM ) , STRING ) ; } } }
protected void validateParameters ( final RowValue parameters ) throws SQLException { final RowDescriptor parameterDescriptor = getParameterDescriptor ( ) ; final int expectedSize = parameterDescriptor != null ? parameterDescriptor . getCount ( ) : _NUM ; final int actualSize = parameters . getCount ( ) ; if ( actualSize != expectedSize ) { throw new SQLNonTransientException ( String . format ( STRING , expectedSize , actualSize ) , STRING ) ; } for ( int fieldIndex = _NUM ; fieldIndex < actualSize ; fieldIndex ++ ) { FieldValue fieldValue = parameters . getFieldValue ( fieldIndex ) ; if ( fieldValue == null || ! fieldValue . isInitialized ( ) ) { throw new SQLTransientException ( String . format ( STRING , fieldIndex + _NUM ) , STRING ) ; } } }
public static boolean matchesUrl ( final HttpServletRequest request , final String path ) { final Pattern pattern = Pattern . compile ( STRING + path + STRING , Pattern . CASE_INSENSITIVE ) ; if ( request . getRequestURI ( ) != null ) { final Matcher m = pattern . matcher ( request . getRequestURI ( ) ) ; return m . matches ( ) ; } return _BOOL ; }
public static boolean matchesUrl ( final HttpServletRequest request , final String path ) { final Pattern pattern = Pattern . compile ( STRING + path + STRING , Pattern . CASE_INSENSITIVE ) ; if ( request . getRequestURI ( ) != null ) { final Matcher m = pattern . matcher ( request . getRequestURI ( ) ) ; return m . matches ( ) ; } return _BOOL ; }
public String serialize ( PageContext pc , Object object , boolean serializeQueryByColumns ) throws ConverterException { StringBuilder sb = new StringBuilder ( ) ; _serialize ( pc , null , object , sb , serializeQueryByColumns , new HashSet < Object > ( ) ) ; return sb . toString ( ) ; }
public StaticSETofInts ( int [ ] keys ) { a = new int [ keys . length ] ; for ( int i = _NUM ; i < keys . length ; i ++ ) a [ i ] = keys [ i ] ; Arrays . sort ( a ) ; for ( int i = _NUM ; i < a . length ; i ++ ) if ( a [ i ] == a [ i - _NUM ] ) throw new IllegalArgumentException ( STRING ) ; }
public boolean handleLongClick ( View v , float x , float y ) { synchronized ( actionModeCallbackLock ) { if ( ( currentActionModeCallback instanceof PathCreationActionModeCallback ) ) { Log . d ( STRING , STRING ) ; return _BOOL ; } } v . performHapticFeedback ( HapticFeedbackConstants . LONG_PRESS ) ; if ( main . startSupportActionMode ( new LongClickActionModeCallback ( x , y ) ) == null ) { main . startSupportActionMode ( new PathCreationActionModeCallback ( x , y ) ) ; } return _BOOL ; }
public boolean handleLongClick ( View v , float x , float y ) { synchronized ( actionModeCallbackLock ) { if ( ( currentActionModeCallback instanceof PathCreationActionModeCallback ) ) { Log . d ( STRING , STRING ) ; return _BOOL ; } } v . performHapticFeedback ( HapticFeedbackConstants . LONG_PRESS ) ; if ( main . startSupportActionMode ( new LongClickActionModeCallback ( x , y ) ) == null ) { main . startSupportActionMode ( new PathCreationActionModeCallback ( x , y ) ) ; } return _BOOL ; }
@ Override public Instances defineDataFormat ( ) throws Exception { Random random = new Random ( getSeed ( ) ) ; setRandom ( random ) ; Instances dataset ; ArrayList < Attribute > attributes = new ArrayList < Attribute > ( _NUM ) ; Attribute attribute ; boolean classFlag = getClassFlag ( ) ; ArrayList < String > classValues = null ; if ( classFlag ) { classValues = new ArrayList < String > ( m_NumClusters ) ; } for ( int i = _NUM ; i < getNumAttributes ( ) ; i ++ ) { attribute = new Attribute ( STRING + i ) ; attributes . add ( attribute ) ; } if ( classFlag ) { for ( int i = _NUM ; i < m_NumClusters ; i ++ ) { classValues . add ( STRING + i ) ; } attribute = new Attribute ( STRING , classValues ) ; attributes . add ( attribute ) ; } dataset = new Instances ( getRelationNameToUse ( ) , attributes , _NUM ) ; if ( classFlag ) { dataset . setClassIndex ( getNumAttributes ( ) ) ; } Instances format = new Instances ( dataset , _NUM ) ; setDatasetFormat ( format ) ; m_ClusterList = defineClusters ( random ) ; return dataset ; }
private void writeCsvFile ( String filename , int numberOfLinesAfterHeader ) { BufferedWriter bw = IOUtils . getBufferedWriter ( filename ) ; try { for ( int i = _NUM ; i < numberOfLinesAfterHeader ; i ++ ) { bw . write ( STRING ) ; bw . newLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } } }
private void writeCsvFile ( String filename , int numberOfLinesAfterHeader ) { BufferedWriter bw = IOUtils . getBufferedWriter ( filename ) ; try { for ( int i = _NUM ; i < numberOfLinesAfterHeader ; i ++ ) { bw . write ( STRING ) ; bw . newLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } } }
private void writeCsvFile ( String filename , int numberOfLinesAfterHeader ) { BufferedWriter bw = IOUtils . getBufferedWriter ( filename ) ; try { for ( int i = _NUM ; i < numberOfLinesAfterHeader ; i ++ ) { bw . write ( STRING ) ; bw . newLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } } }
private void writeCsvFile ( String filename , int numberOfLinesAfterHeader ) { BufferedWriter bw = IOUtils . getBufferedWriter ( filename ) ; try { for ( int i = _NUM ; i < numberOfLinesAfterHeader ; i ++ ) { bw . write ( STRING ) ; bw . newLine ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } finally { try { bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; fail ( STRING + filename ) ; } } }
private boolean mapPatternElemPos ( int nesting , boolean isStart , boolean isAttrName ) { if ( _NUM == nesting ) { if ( m_patternMapSize >= m_patternMap . length ) { int patternMap [ ] = m_patternMap ; int len = m_patternMap . length ; m_patternMap = new int [ m_patternMapSize + _NUM ] ; System . arraycopy ( patternMap , _NUM , m_patternMap , _NUM , len ) ; } if ( ! isStart ) { m_patternMap [ m_patternMapSize - _NUM ] -= TARGETEXTRA ; } m_patternMap [ m_patternMapSize ] = ( m_compiler . getTokenQueueSize ( ) - ( isAttrName ? _NUM : _NUM ) ) + TARGETEXTRA ; m_patternMapSize ++ ; isStart = _BOOL ; } return isStart ; }
default boolean isImmutable ( ) { return _BOOL ; }
default boolean isImmutable ( ) { return _BOOL ; }
default boolean isImmutable ( ) { return _BOOL ; }
private float [ ] calculateShiftToPositionBBoxOfPointsAt ( float left , float top , List < Point > points ) { double minX = Double . MAX_VALUE ; double maxY = - Double . MAX_VALUE ; for ( Point point : points ) { minX = Math . min ( point . getX ( ) , minX ) ; maxY = Math . max ( point . getY ( ) , maxY ) ; } float dx = ( float ) ( left - minX ) ; float dy = ( float ) ( top - maxY ) ; return new float [ ] { dx , dy } ; }
private float [ ] calculateShiftToPositionBBoxOfPointsAt ( float left , float top , List < Point > points ) { double minX = Double . MAX_VALUE ; double maxY = - Double . MAX_VALUE ; for ( Point point : points ) { minX = Math . min ( point . getX ( ) , minX ) ; maxY = Math . max ( point . getY ( ) , maxY ) ; } float dx = ( float ) ( left - minX ) ; float dy = ( float ) ( top - maxY ) ; return new float [ ] { dx , dy } ; }
public List < Map < String , Object > > query ( String sql ) { try { return query ( stat . executeQuery ( sql ) ) ; } catch ( SQLException e ) { throw convert ( e ) ; } }
public float [ ] evaluate ( String inputFileName ) { JavaRDD < String > lines = jsc . textFile ( inputFileName ) ; DataFrame dataset = createDataFrame ( lines . collect ( ) ) ; return evaluate ( dataset ) ; }
public float [ ] evaluate ( String inputFileName ) { JavaRDD < String > lines = jsc . textFile ( inputFileName ) ; DataFrame dataset = createDataFrame ( lines . collect ( ) ) ; return evaluate ( dataset ) ; }
public MultiwayPoolBuilder < K , R > expireAfterWrite ( long duration , TimeUnit unit ) { checkState ( expireAfterWriteNanos == UNSET_INT , STRING , expireAfterWriteNanos ) ; checkArgument ( duration >= _NUM , STRING , duration , unit ) ; expireAfterWriteNanos = unit . toNanos ( duration ) ; return this ; }
public MultiwayPoolBuilder < K , R > expireAfterWrite ( long duration , TimeUnit unit ) { checkState ( expireAfterWriteNanos == UNSET_INT , STRING , expireAfterWriteNanos ) ; checkArgument ( duration >= _NUM , STRING , duration , unit ) ; expireAfterWriteNanos = unit . toNanos ( duration ) ; return this ; }
public MultiwayPoolBuilder < K , R > expireAfterWrite ( long duration , TimeUnit unit ) { checkState ( expireAfterWriteNanos == UNSET_INT , STRING , expireAfterWriteNanos ) ; checkArgument ( duration >= _NUM , STRING , duration , unit ) ; expireAfterWriteNanos = unit . toNanos ( duration ) ; return this ; }
public static ClassName generateMigrationName ( String packageName , Schema from , Schema to ) { return ClassName . get ( packageName , String . format ( Locale . US , STRING , from . getVersion ( ) , to . getVersion ( ) ) ) ; }
@ Override @ SuppressForbidden ( reason = STRING ) public void activateOptions ( ) { if ( follow ) { if ( target . equals ( SYSTEM_ERR ) ) { setWriter ( createWriter ( new SystemErrStream ( ) ) ) ; } else { setWriter ( createWriter ( new SystemOutStream ( ) ) ) ; } } else { if ( target . equals ( SYSTEM_ERR ) ) { setWriter ( createWriter ( System . err ) ) ; } else { setWriter ( createWriter ( System . out ) ) ; } } super . activateOptions ( ) ; }
public static String findPreferredIDP ( String realm , HttpServletRequest request ) { if ( request == null ) { return null ; } String succinctID = request . getParameter ( IFSConstants . PROVIDER_ID_KEY ) ; if ( ( succinctID == null ) || succinctID . length ( ) == _NUM ) { debug . message ( STRING ) ; return null ; } succinctID = succinctID . trim ( ) ; String preferredSuccinctId = null ; StringTokenizer st = new StringTokenizer ( succinctID , STRING ) ; while ( st . hasMoreTokens ( ) ) { preferredSuccinctId = st . nextToken ( ) ; if ( ( preferredSuccinctId . length ( ) < _NUM ) && st . hasMoreTokens ( ) ) { preferredSuccinctId = preferredSuccinctId + STRING + st . nextToken ( ) ; } } preferredSuccinctId = SAMLUtils . byteArrayToString ( Base64 . decode ( preferredSuccinctId ) ) ; return getProviderIDFromSuccinctID ( realm , preferredSuccinctId ) ; }
public static int findMinutesInReminderList ( ArrayList < Integer > values , int minutes ) { int index = values . indexOf ( minutes ) ; if ( index == - _NUM ) { Log . e ( TAG , STRING + minutes + STRING ) ; return _NUM ; } return index ; }
static public final float cosDeg ( float degrees ) { return Sin . table [ ( int ) ( ( degrees + _NUM ) * degToIndex ) & SIN_MASK ] ; }
public Object save ( Object entity ) { Object key = PropertyUtils . getPropertyValue ( entity , repositoryMetadata . getIdentifierProperty ( ) ) ; log . info ( STRING + key ) ; if ( key == null && keyGenerator != null ) { log . info ( STRING ) ; key = keyGenerator . generate ( ) ; log . debug ( STRING + key ) ; PropertyUtils . setPropertyValue ( entity , repositoryMetadata . getIdentifierProperty ( ) , key ) ; } if ( key == null ) { log . warn ( STRING ) ; } dataStore . save ( ( Serializable ) key , entity ) ; return entity ; }
public Object save ( Object entity ) { Object key = PropertyUtils . getPropertyValue ( entity , repositoryMetadata . getIdentifierProperty ( ) ) ; log . info ( STRING + key ) ; if ( key == null && keyGenerator != null ) { log . info ( STRING ) ; key = keyGenerator . generate ( ) ; log . debug ( STRING + key ) ; PropertyUtils . setPropertyValue ( entity , repositoryMetadata . getIdentifierProperty ( ) , key ) ; } if ( key == null ) { log . warn ( STRING ) ; } dataStore . save ( ( Serializable ) key , entity ) ; return entity ; }
public int readGolomb ( int divisor ) throws IOException { int q = _NUM ; while ( readBit ( MAX_PROBABILITY / _NUM ) ) { q ++ ; } int bit = _NUM - Integer . numberOfLeadingZeros ( divisor - _NUM ) ; int r = _NUM ; if ( bit >= _NUM ) { int cutOff = ( _NUM << bit ) - divisor ; for ( ; bit > _NUM ; bit -- ) { r = ( r << _NUM ) + ( readBit ( MAX_PROBABILITY / _NUM ) ? _NUM : _NUM ) ; } if ( r >= cutOff ) { r = ( r << _NUM ) + ( readBit ( MAX_PROBABILITY / _NUM ) ? _NUM : _NUM ) - cutOff ; } } return q * divisor + r ; }
public void not ( ) { mv . visitInsn ( Opcodes . ICONST_1 ) ; mv . visitInsn ( Opcodes . IXOR ) ; }
protected void copyResponseEntity ( HttpResponse proxyResponse , HttpServletResponse servletResponse ) throws IOException { HttpEntity entity = proxyResponse . getEntity ( ) ; if ( entity != null ) { OutputStream servletOutputStream = servletResponse . getOutputStream ( ) ; entity . writeTo ( servletOutputStream ) ; } }
@ SuppressWarnings ( STRING ) private void relaxViterbiRule ( UnaryRule ur , short intState1 , short [ ] [ ] intSubStates1 , short intState2 , short [ ] [ ] intSubStates2 ) { throw new Error ( STRING ) ; }
@ SuppressWarnings ( STRING ) private void relaxViterbiRule ( UnaryRule ur , short intState1 , short [ ] [ ] intSubStates1 , short intState2 , short [ ] [ ] intSubStates2 ) { throw new Error ( STRING ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return PATH ; case _NUM : return BLOCK_SIZE_BYTES ; case _NUM : return TOTAL_LBA_BLOCKS ; case _NUM : return TOTAL_SPACE ; default : return null ; } }
private static String canonizeTypeString ( String str ) { String canon = str . trim ( ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; return canon ; }
private static String canonizeTypeString ( String str ) { String canon = str . trim ( ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; return canon ; }
private static String canonizeTypeString ( String str ) { String canon = str . trim ( ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; canon = canon . replaceAll ( STRING , STRING ) ; return canon ; }
private static Intent createCallActivityIntent ( Context context , URLSpan [ ] urlSpans ) { TelephonyManager tm = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; if ( tm . getPhoneType ( ) == TelephonyManager . PHONE_TYPE_NONE ) { return null ; } for ( int span_i = _NUM ; span_i < urlSpans . length ; span_i ++ ) { URLSpan urlSpan = urlSpans [ span_i ] ; String urlString = urlSpan . getURL ( ) ; if ( urlString . startsWith ( TEL_PREFIX ) ) { Intent callIntent = new Intent ( Intent . ACTION_DIAL , Uri . parse ( urlString ) ) ; callIntent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; return callIntent ; } } return null ; }
private static Intent createCallActivityIntent ( Context context , URLSpan [ ] urlSpans ) { TelephonyManager tm = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; if ( tm . getPhoneType ( ) == TelephonyManager . PHONE_TYPE_NONE ) { return null ; } for ( int span_i = _NUM ; span_i < urlSpans . length ; span_i ++ ) { URLSpan urlSpan = urlSpans [ span_i ] ; String urlString = urlSpan . getURL ( ) ; if ( urlString . startsWith ( TEL_PREFIX ) ) { Intent callIntent = new Intent ( Intent . ACTION_DIAL , Uri . parse ( urlString ) ) ; callIntent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; return callIntent ; } } return null ; }
private static Intent createCallActivityIntent ( Context context , URLSpan [ ] urlSpans ) { TelephonyManager tm = ( TelephonyManager ) context . getSystemService ( Context . TELEPHONY_SERVICE ) ; if ( tm . getPhoneType ( ) == TelephonyManager . PHONE_TYPE_NONE ) { return null ; } for ( int span_i = _NUM ; span_i < urlSpans . length ; span_i ++ ) { URLSpan urlSpan = urlSpans [ span_i ] ; String urlString = urlSpan . getURL ( ) ; if ( urlString . startsWith ( TEL_PREFIX ) ) { Intent callIntent = new Intent ( Intent . ACTION_DIAL , Uri . parse ( urlString ) ) ; callIntent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ) ; return callIntent ; } } return null ; }
private ArrayList < Individuum > initialPopulation ( int popsize ) { ArrayList < Individuum > population = new ArrayList < > ( popsize ) ; for ( int i = _NUM ; i < popsize ; i ++ ) { short [ ] gene = new short [ dim ] ; Arrays . fill ( gene , DONT_CARE ) ; int countDim = k ; while ( countDim > _NUM ) { int z = random . nextInt ( dim ) ; if ( gene [ z ] != DONT_CARE ) { continue ; } gene [ z ] = ( short ) ( random . nextInt ( phi ) + GENE_OFFSET ) ; countDim -- ; } population . add ( makeIndividuum ( gene ) ) ; } return population ; }
private void handleIncomingMessage ( SerialMessage incomingMessage ) { logger . debug ( incomingMessage . toString ( ) ) ; try { switch ( incomingMessage . getMessageType ( ) ) { case Request : handleIncomingRequestMessage ( incomingMessage ) ; break ; case Response : handleIncomingResponseMessage ( incomingMessage ) ; break ; default : logger . warn ( STRING , incomingMessage . getMessageType ( ) ) ; } } catch ( ZWaveSerialMessageException e ) { logger . error ( STRING , e . getMessage ( ) ) ; } }
private void handleIncomingMessage ( SerialMessage incomingMessage ) { logger . debug ( incomingMessage . toString ( ) ) ; try { switch ( incomingMessage . getMessageType ( ) ) { case Request : handleIncomingRequestMessage ( incomingMessage ) ; break ; case Response : handleIncomingResponseMessage ( incomingMessage ) ; break ; default : logger . warn ( STRING , incomingMessage . getMessageType ( ) ) ; } } catch ( ZWaveSerialMessageException e ) { logger . error ( STRING , e . getMessage ( ) ) ; } }
private void handleIncomingMessage ( SerialMessage incomingMessage ) { logger . debug ( incomingMessage . toString ( ) ) ; try { switch ( incomingMessage . getMessageType ( ) ) { case Request : handleIncomingRequestMessage ( incomingMessage ) ; break ; case Response : handleIncomingResponseMessage ( incomingMessage ) ; break ; default : logger . warn ( STRING , incomingMessage . getMessageType ( ) ) ; } } catch ( ZWaveSerialMessageException e ) { logger . error ( STRING , e . getMessage ( ) ) ; } }
protected void defaultSort ( Comparator < ? super T > comparator ) { Collections . sort ( this , comparator ) ; }
@ Override public int [ ] unrank ( ) { if ( k == _NUM ) return new int [ _NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - _NUM - currentIndex ; long e = ( n - k ) * count / n ; int t = n - k + _NUM ; int m = k ; int p = n - _NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + _NUM ; if ( e > _NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > _NUM ) ; return combi ; }
@ Override public int [ ] unrank ( ) { if ( k == _NUM ) return new int [ _NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - _NUM - currentIndex ; long e = ( n - k ) * count / n ; int t = n - k + _NUM ; int m = k ; int p = n - _NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + _NUM ; if ( e > _NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > _NUM ) ; return combi ; }
@ Override public int [ ] unrank ( ) { if ( k == _NUM ) return new int [ _NUM ] ; int [ ] combi = new int [ k ] ; long rank = count - _NUM - currentIndex ; long e = ( n - k ) * count / n ; int t = n - k + _NUM ; int m = k ; int p = n - _NUM ; do { if ( e <= rank ) { combi [ k - m ] = n - t - m + _NUM ; if ( e > _NUM ) { rank = rank - e ; e = m * e / p ; } m -- ; p -- ; } else { e = ( p - m ) * e / p ; t -- ; p -- ; } } while ( m > _NUM ) ; return combi ; }
public String findMatch ( Pattern pattern , String text ) { return findMatch ( pattern , text , _NUM ) ; }
public String findMatch ( Pattern pattern , String text ) { return findMatch ( pattern , text , _NUM ) ; }
protected RequestHandle sendRequest ( DefaultHttpClient client , HttpContext httpContext , HttpUriRequest uriRequest , String contentType , ResponseHandlerInterface responseHandler , Context context ) { if ( contentType != null ) { uriRequest . setHeader ( STRING , contentType ) ; } responseHandler . setRequestHeaders ( uriRequest . getAllHeaders ( ) ) ; responseHandler . setRequestURI ( uriRequest . getURI ( ) ) ; Future < ? > request = threadPool . submit ( new AsyncHttpRequest ( client , httpContext , uriRequest , responseHandler ) ) ; if ( context != null ) { List < WeakReference < Future < ? > > > requestList = requestMap . get ( context ) ; if ( requestList == null ) { requestList = new LinkedList < WeakReference < Future < ? > > > ( ) ; requestMap . put ( context , requestList ) ; } requestList . add ( new WeakReference < Future < ? > > ( request ) ) ; } return new RequestHandle ( request ) ; }
public final void openFallbackInputStream ( ) throws DataFallbackException { if ( inputBuf == null ) { if ( LOG . isDebugEnabled ( ) ) LOG . debug ( STRING + dataFile . getName ( ) + STRING ) ; try { setInput ( new BufferedReader ( new FileReader ( dataFile ) ) ) ; } catch ( IOException e ) { throw new DataFallbackException ( e . getMessage ( ) ) ; } } }
void pushBack ( ) throws IOException { iis . seek ( iis . getStreamPosition ( ) - bufAvail ) ; bufAvail = _NUM ; bufPtr = _NUM ; }
protected void drawPoint ( Graphics2D g , PlotterPoint point , ColorProvider colorProvider , int midX , int midY , double radius ) { int x = midX ; int y = midY ; x += ( int ) ( point . getX ( ) * radius * scale ) ; y -= ( int ) ( point . getY ( ) * radius * scale ) ; Color pointColor = Color . red ; if ( colorColumn != - _NUM ) { pointColor = colorProvider . getPointColor ( point . getColor ( ) ) ; } drawPoint ( g , x , y , pointColor , point . getBorderColor ( ) ) ; }
public static void clear ( String throttlingPointName ) { setThrottlingPointRates ( throttlingPointName , Collections . EMPTY_MAP ) ; }
public static void clear ( String throttlingPointName ) { setThrottlingPointRates ( throttlingPointName , Collections . EMPTY_MAP ) ; }
@ Override protected void prepareBlock ( ) { double [ ] frame = getNextFrame ( ) ; if ( frame == null ) return ; int frameLength = frameProvider . getFrameLengthSamples ( ) ; if ( processor != null ) processor . applyInline ( frame , _NUM , frameLength ) ; if ( outputWindow != null ) outputWindow . applyInline ( frame , _NUM , frameLength ) ; if ( memory . length < frameLength ) { double [ ] oldMemory = memory ; memory = new double [ frameLength ] ; System . arraycopy ( oldMemory , _NUM , memory , _NUM , oldMemory . length ) ; } for ( int i = _NUM ; i < frameLength ; i ++ ) { memory [ i ] += frame [ i ] ; } }
@ Override protected void prepareBlock ( ) { double [ ] frame = getNextFrame ( ) ; if ( frame == null ) return ; int frameLength = frameProvider . getFrameLengthSamples ( ) ; if ( processor != null ) processor . applyInline ( frame , _NUM , frameLength ) ; if ( outputWindow != null ) outputWindow . applyInline ( frame , _NUM , frameLength ) ; if ( memory . length < frameLength ) { double [ ] oldMemory = memory ; memory = new double [ frameLength ] ; System . arraycopy ( oldMemory , _NUM , memory , _NUM , oldMemory . length ) ; } for ( int i = _NUM ; i < frameLength ; i ++ ) { memory [ i ] += frame [ i ] ; } }
@ SuppressWarnings ( STRING ) public < R > SimpleReactStream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
@ SuppressWarnings ( STRING ) public < R > SimpleReactStream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
@ SuppressWarnings ( STRING ) public < R > SimpleReactStream < R > from ( final Collection < R > collection ) { return from ( collection . stream ( ) ) ; }
protected Region createAckRegion ( boolean mirror , boolean conflate ) throws CacheException { final AttributesFactory factory = new AttributesFactory ( ) ; factory . setScope ( Scope . DISTRIBUTED_ACK ) ; if ( mirror ) { factory . setDataPolicy ( DataPolicy . REPLICATE ) ; } if ( conflate ) { factory . setEnableAsyncConflation ( _BOOL ) ; } final Region r = createRootRegion ( STRING , factory . create ( ) ) ; return r ; }
@ Override public Query newPrefixQuery ( String text ) { if ( settings . lowercaseExpandedTerms ( ) ) { text = text . toLowerCase ( settings . locale ( ) ) ; } BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( _BOOL ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { if ( settings . analyzeWildcard ( ) ) { Query analyzedQuery = newPossiblyAnalyzedQuery ( entry . getKey ( ) , text ) ; analyzedQuery . setBoost ( entry . getValue ( ) ) ; bq . add ( analyzedQuery , BooleanClause . Occur . SHOULD ) ; } else { PrefixQuery prefix = new PrefixQuery ( new Term ( entry . getKey ( ) , text ) ) ; prefix . setBoost ( entry . getValue ( ) ) ; bq . add ( prefix , BooleanClause . Occur . SHOULD ) ; } } catch ( RuntimeException e ) { return rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
@ Override public Query newPrefixQuery ( String text ) { if ( settings . lowercaseExpandedTerms ( ) ) { text = text . toLowerCase ( settings . locale ( ) ) ; } BooleanQuery . Builder bq = new BooleanQuery . Builder ( ) ; bq . setDisableCoord ( _BOOL ) ; for ( Map . Entry < String , Float > entry : weights . entrySet ( ) ) { try { if ( settings . analyzeWildcard ( ) ) { Query analyzedQuery = newPossiblyAnalyzedQuery ( entry . getKey ( ) , text ) ; analyzedQuery . setBoost ( entry . getValue ( ) ) ; bq . add ( analyzedQuery , BooleanClause . Occur . SHOULD ) ; } else { PrefixQuery prefix = new PrefixQuery ( new Term ( entry . getKey ( ) , text ) ) ; prefix . setBoost ( entry . getValue ( ) ) ; bq . add ( prefix , BooleanClause . Occur . SHOULD ) ; } } catch ( RuntimeException e ) { return rethrowUnlessLenient ( e ) ; } } return super . simplify ( bq . build ( ) ) ; }
public static void checkDuplicatedValue ( List < ExecutableElement > elements , Class clazz ) { Set < String > values = new HashSet < > ( ) ; for ( ExecutableElement method : elements ) { List < String > value = getValueFromAnnotation ( method , clazz ) ; if ( ! values . addAll ( value ) ) { throw new DuplicatedValueException ( value , method , clazz ) ; } } }
public static void checkDuplicatedValue ( List < ExecutableElement > elements , Class clazz ) { Set < String > values = new HashSet < > ( ) ; for ( ExecutableElement method : elements ) { List < String > value = getValueFromAnnotation ( method , clazz ) ; if ( ! values . addAll ( value ) ) { throw new DuplicatedValueException ( value , method , clazz ) ; } } }
public static void checkDuplicatedValue ( List < ExecutableElement > elements , Class clazz ) { Set < String > values = new HashSet < > ( ) ; for ( ExecutableElement method : elements ) { List < String > value = getValueFromAnnotation ( method , clazz ) ; if ( ! values . addAll ( value ) ) { throw new DuplicatedValueException ( value , method , clazz ) ; } } }
public static Calendar next ( Calendar self ) { Calendar result = ( Calendar ) self . clone ( ) ; result . add ( Calendar . DAY_OF_YEAR , _NUM ) ; return result ; }
public void init ( String componentName ) throws LogException { accessLogger = ( com . sun . identity . log . Logger ) Logger . getLogger ( componentName + STRING ) ; errorLogger = ( com . sun . identity . log . Logger ) Logger . getLogger ( componentName + STRING ) ; try { msgProvider = MessageProviderFactory . getProvider ( componentName ) ; } catch ( IOException e ) { debug . error ( STRING , e ) ; } }
public void readData ( DataInput din ) throws IOException { int length = getDataLength ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { din . readByte ( ) ; } }
public void readData ( DataInput din ) throws IOException { int length = getDataLength ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { din . readByte ( ) ; } }
public static Command createAppendTextIfAbsentToFileCommand ( Path pathToFile , String textToAppend , String checkIfTextPresentRegex ) { return createCommand ( getAppendTextToFileCommand ( pathToFile , textToAppend , checkIfTextPresentRegex , _BOOL ) ) ; }
public static Command createAppendTextIfAbsentToFileCommand ( Path pathToFile , String textToAppend , String checkIfTextPresentRegex ) { return createCommand ( getAppendTextToFileCommand ( pathToFile , textToAppend , checkIfTextPresentRegex , _BOOL ) ) ; }
@ Override public void store ( DataOutput os ) throws IOException { super . store ( os ) ; }
public UmaPendingRequest readPendingRequest ( String id ) throws ResourceException { try { return store . read ( id ) ; } catch ( NotFoundException e ) { throw new org . forgerock . json . resource . NotFoundException ( STRING + id + STRING , e ) ; } catch ( ServerException e ) { throw new InternalServerErrorException ( STRING + id , e ) ; } }
private void loadEvents ( ) throws XMLStreamException { if ( ! xmlEventReader . hasNext ( ) ) { done = _BOOL ; return ; } XMLEvent event = xmlEventReader . nextEvent ( ) ; event = eventTransformer . transform ( event ) ; xmlWriteStream . reset ( ) ; xmlEventWriter . add ( event ) ; xmlEventWriter . flush ( ) ; xmlInStream = new ByteArrayInputStream ( xmlWriteStream . toByteArray ( ) ) ; }
void generate ( XmlWriter w ) throws IOException { List < XmlWriter . Attribute > attrs = null ; if ( count > _NUM ) { attrs = Collections . singletonList ( new XmlWriter . Attribute ( STRING , Integer . toString ( count ) ) ) ; } w . simpleElement ( GoogleBaseNamespaces . GM , STRING , attrs , value ) ; }
@ Fluent public < T > Job on ( String event , Handler < Message < T > > handler ) { logger . debug ( STRING + Kue . getCertainJobAddress ( event , this ) ) ; eventBus . consumer ( Kue . getCertainJobAddress ( event , this ) , handler ) ; return this ; }
@ Fluent public < T > Job on ( String event , Handler < Message < T > > handler ) { logger . debug ( STRING + Kue . getCertainJobAddress ( event , this ) ) ; eventBus . consumer ( Kue . getCertainJobAddress ( event , this ) , handler ) ; return this ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
protected SizeRequirements calculateMajorAxisRequirements ( int axis , SizeRequirements r ) { SizeRequirements req = super . calculateMajorAxisRequirements ( axis , r ) ; req . maximum = Integer . MAX_VALUE ; return req ; }
public Commitment commit ( byte [ ] message ) { if ( message . length > byteLength / _NUM ) { throw new DataLengthException ( STRING ) ; } byte [ ] w = new byte [ byteLength - message . length ] ; random . nextBytes ( w ) ; return new Commitment ( w , calculateCommitment ( w , message ) ) ; }
@ Override public VariableSet initializeforwardLV ( VariableSet activeIn ) throws LanguageException { for ( Statement s : _statements ) { s . initializeforwardLV ( activeIn ) ; VariableSet read = s . variablesRead ( ) ; VariableSet updated = s . variablesUpdated ( ) ; if ( s instanceof WhileStatement || s instanceof IfStatement || s instanceof ForStatement ) { raiseValidateError ( STRING , _BOOL ) ; } if ( read != null ) { for ( String var : read . getVariableNames ( ) ) { if ( ! _updated . containsVariable ( var ) ) { _gen . addVariable ( var , read . getVariable ( var ) ) ; } } } _read . addVariables ( read ) ; _updated . addVariables ( updated ) ; if ( updated != null ) { for ( String var : updated . getVariableNames ( ) ) { _kill . addVariable ( var , _updated . getVariable ( var ) ) ; } } } _liveOut = new VariableSet ( ) ; _liveOut . addVariables ( activeIn ) ; _liveOut . addVariables ( _updated ) ; return _liveOut ; }
@ Override public VariableSet initializeforwardLV ( VariableSet activeIn ) throws LanguageException { for ( Statement s : _statements ) { s . initializeforwardLV ( activeIn ) ; VariableSet read = s . variablesRead ( ) ; VariableSet updated = s . variablesUpdated ( ) ; if ( s instanceof WhileStatement || s instanceof IfStatement || s instanceof ForStatement ) { raiseValidateError ( STRING , _BOOL ) ; } if ( read != null ) { for ( String var : read . getVariableNames ( ) ) { if ( ! _updated . containsVariable ( var ) ) { _gen . addVariable ( var , read . getVariable ( var ) ) ; } } } _read . addVariables ( read ) ; _updated . addVariables ( updated ) ; if ( updated != null ) { for ( String var : updated . getVariableNames ( ) ) { _kill . addVariable ( var , _updated . getVariable ( var ) ) ; } } } _liveOut = new VariableSet ( ) ; _liveOut . addVariables ( activeIn ) ; _liveOut . addVariables ( _updated ) ; return _liveOut ; }
@ Override public VariableSet initializeforwardLV ( VariableSet activeIn ) throws LanguageException { for ( Statement s : _statements ) { s . initializeforwardLV ( activeIn ) ; VariableSet read = s . variablesRead ( ) ; VariableSet updated = s . variablesUpdated ( ) ; if ( s instanceof WhileStatement || s instanceof IfStatement || s instanceof ForStatement ) { raiseValidateError ( STRING , _BOOL ) ; } if ( read != null ) { for ( String var : read . getVariableNames ( ) ) { if ( ! _updated . containsVariable ( var ) ) { _gen . addVariable ( var , read . getVariable ( var ) ) ; } } } _read . addVariables ( read ) ; _updated . addVariables ( updated ) ; if ( updated != null ) { for ( String var : updated . getVariableNames ( ) ) { _kill . addVariable ( var , _updated . getVariable ( var ) ) ; } } } _liveOut = new VariableSet ( ) ; _liveOut . addVariables ( activeIn ) ; _liveOut . addVariables ( _updated ) ; return _liveOut ; }
@ Override public VariableSet initializeforwardLV ( VariableSet activeIn ) throws LanguageException { for ( Statement s : _statements ) { s . initializeforwardLV ( activeIn ) ; VariableSet read = s . variablesRead ( ) ; VariableSet updated = s . variablesUpdated ( ) ; if ( s instanceof WhileStatement || s instanceof IfStatement || s instanceof ForStatement ) { raiseValidateError ( STRING , _BOOL ) ; } if ( read != null ) { for ( String var : read . getVariableNames ( ) ) { if ( ! _updated . containsVariable ( var ) ) { _gen . addVariable ( var , read . getVariable ( var ) ) ; } } } _read . addVariables ( read ) ; _updated . addVariables ( updated ) ; if ( updated != null ) { for ( String var : updated . getVariableNames ( ) ) { _kill . addVariable ( var , _updated . getVariable ( var ) ) ; } } } _liveOut = new VariableSet ( ) ; _liveOut . addVariables ( activeIn ) ; _liveOut . addVariables ( _updated ) ; return _liveOut ; }
public String intValueToStringValue ( Integer intVal ) { if ( intVal == null ) return null ; final String enumString = enumIntToStringMap . get ( intVal ) ; if ( enumString != null ) return enumString ; return DEFAULT_VALUE . toString ( ) ; }
public void addToTDA ( String file ) { tdaPanel . addDumpFile ( file ) ; }
public void removeTemporaryMaps ( BitField objectIds ) { for ( String mapName : store . getMapNames ( ) ) { if ( mapName . startsWith ( STRING ) ) { MVMap < ? , ? > map = store . openMap ( mapName ) ; store . removeMap ( map ) ; } else if ( mapName . startsWith ( STRING ) || mapName . startsWith ( STRING ) ) { int id = Integer . parseInt ( mapName . substring ( _NUM + mapName . indexOf ( STRING ) ) ) ; if ( ! objectIds . get ( id ) ) { ValueDataType keyType = new ValueDataType ( null , null , null ) ; ValueDataType valueType = new ValueDataType ( null , null , null ) ; Transaction t = transactionStore . begin ( ) ; TransactionMap < ? , ? > m = t . openMap ( mapName , keyType , valueType ) ; transactionStore . removeMap ( m ) ; t . commit ( ) ; } } } }
public void reset ( ) throws IOException { m_structure = null ; m_Buffer = null ; setRetrieval ( NONE ) ; if ( m_File != null ) { setFile ( new File ( m_File ) ) ; } else if ( ( m_URL != null ) && ! m_URL . equals ( STRING ) ) { setURL ( m_URL ) ; } }
public static long pop_array ( long [ ] arr , int wordOffset , int numWords ) { long popCount = _NUM ; for ( int i = wordOffset , end = wordOffset + numWords ; i < end ; ++ i ) { popCount += Long . bitCount ( arr [ i ] ) ; } return popCount ; }
@ Override public String toString ( ) { StringBuffer buff = new StringBuffer ( ) ; if ( m_correlations == null ) { buff . append ( STRING ) ; } else { buff . append ( STRING ) ; if ( m_detailedOutput && m_detailedOutputBuff . length ( ) > _NUM ) { buff . append ( STRING ) ; buff . append ( m_detailedOutputBuff ) ; } } return buff . toString ( ) ; }
public static void unRegisterClientApp ( Context context ) throws AppCatalogException { String serverIP = Preference . getString ( context , Constants . PreferenceFlag . IP ) ; if ( serverIP != null && ! serverIP . isEmpty ( ) ) { String applicationName = Preference . getString ( context , Constants . CLIENT_NAME ) ; String consumerKey = Preference . getString ( context , Constants . CLIENT_ID ) ; String userId = Preference . getString ( context , Constants . USERNAME ) ; if ( applicationName != null && ! applicationName . isEmpty ( ) && consumerKey != null && ! consumerKey . isEmpty ( ) && userId != null && ! userId . isEmpty ( ) ) { UnregisterProfile profile = new UnregisterProfile ( ) ; profile . setApplicationName ( applicationName ) ; profile . setConsumerKey ( consumerKey ) ; profile . setUserId ( userId ) ; ServerConfig utils = new ServerConfig ( ) ; utils . setServerIP ( serverIP ) ; DynamicClientManager dynamicClientManager = new DynamicClientManager ( ) ; boolean isUnregistered = dynamicClientManager . unregisterClient ( profile , utils , context ) ; if ( ! isUnregistered ) { Log . e ( TAG , STRING ) ; } } else { Log . e ( TAG , STRING ) ; } } else { Log . e ( TAG , STRING ) ; } }
public String quoteString ( String str ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; if ( StringUtils . isNotBlank ( str ) ) { sb . append ( escapeQuotes ( str ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public String quoteString ( String str ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; if ( StringUtils . isNotBlank ( str ) ) { sb . append ( escapeQuotes ( str ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public static boolean isNativeCodeLoaded ( ) { return NativeCodeLoader . isNativeCodeLoaded ( ) ; }
public void auditAccessDenied ( String resource , String action , String authzModule , SSOToken token ) { init ( ) ; if ( authzLogger != null && msgProvider != null ) { final LogRecord record = msgProvider . createLogRecord ( STRING , new String [ ] { STRING + resource , action , authzModule } , token ) ; if ( record != null ) { authzLogger . log ( record , AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) ) ; } } }
public void auditAccessDenied ( String resource , String action , String authzModule , SSOToken token ) { init ( ) ; if ( authzLogger != null && msgProvider != null ) { final LogRecord record = msgProvider . createLogRecord ( STRING , new String [ ] { STRING + resource , action , authzModule } , token ) ; if ( record != null ) { authzLogger . log ( record , AccessController . doPrivileged ( AdminTokenAction . getInstance ( ) ) ) ; } } }
public ModuleHandle addModule ( String moduleName , String sessionKey ) { String sanitizedModuleName = generateUniqueNameIfNullOrEmpty ( moduleName , STRING ) ; ModuleHandle moduleHandle = new ModuleHandle ( sanitizedModuleName , sessionKey ) ; synchronized ( privateInstanceLock ) { modules . add ( moduleHandle ) ; } setTerminated ( _BOOL ) ; return moduleHandle ; }
private boolean selectID ( int nodeID , boolean show ) { if ( m_root == null ) return _BOOL ; log . config ( STRING + nodeID + STRING + show + STRING + m_root ) ; MTreeNode node = m_root . findNode ( nodeID ) ; if ( node != null ) { TreePath treePath = new TreePath ( node . getPath ( ) ) ; log . config ( STRING + node + STRING + treePath . toString ( ) ) ; tree . setSelectionPath ( treePath ) ; if ( show ) { tree . makeVisible ( treePath ) ; tree . scrollPathToVisible ( treePath ) ; } return _BOOL ; } log . info ( STRING + nodeID ) ; return _BOOL ; }
private boolean selectID ( int nodeID , boolean show ) { if ( m_root == null ) return _BOOL ; log . config ( STRING + nodeID + STRING + show + STRING + m_root ) ; MTreeNode node = m_root . findNode ( nodeID ) ; if ( node != null ) { TreePath treePath = new TreePath ( node . getPath ( ) ) ; log . config ( STRING + node + STRING + treePath . toString ( ) ) ; tree . setSelectionPath ( treePath ) ; if ( show ) { tree . makeVisible ( treePath ) ; tree . scrollPathToVisible ( treePath ) ; } return _BOOL ; } log . info ( STRING + nodeID ) ; return _BOOL ; }
private boolean selectID ( int nodeID , boolean show ) { if ( m_root == null ) return _BOOL ; log . config ( STRING + nodeID + STRING + show + STRING + m_root ) ; MTreeNode node = m_root . findNode ( nodeID ) ; if ( node != null ) { TreePath treePath = new TreePath ( node . getPath ( ) ) ; log . config ( STRING + node + STRING + treePath . toString ( ) ) ; tree . setSelectionPath ( treePath ) ; if ( show ) { tree . makeVisible ( treePath ) ; tree . scrollPathToVisible ( treePath ) ; } return _BOOL ; } log . info ( STRING + nodeID ) ; return _BOOL ; }
private Node < K , V > findPredecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new NullPointerException ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compareTo ( k ) > _NUM ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
private Node < K , V > findPredecessor ( Comparable < ? super K > key ) { if ( key == null ) throw new NullPointerException ( ) ; for ( ; ; ) { Index < K , V > q = head ; Index < K , V > r = q . right ; for ( ; ; ) { if ( r != null ) { Node < K , V > n = r . node ; K k = n . key ; if ( n . value == null ) { if ( ! q . unlink ( r ) ) break ; r = q . right ; continue ; } if ( key . compareTo ( k ) > _NUM ) { q = r ; r = r . right ; continue ; } } Index < K , V > d = q . down ; if ( d != null ) { q = d ; r = d . right ; } else return q . node ; } } }
public static String formatTime ( long time ) { SimpleDateFormat sdf = new SimpleDateFormat ( STRING ) ; Calendar c = Calendar . getInstance ( ) ; c . setTimeInMillis ( time * _NUM ) ; return sdf . format ( c . getTime ( ) ) ; }
public void updateAccessTime ( ) { attributes . setLastAccessedTime ( System . currentTimeMillis ( ) ) ; }
public void updateAccessTime ( ) { attributes . setLastAccessedTime ( System . currentTimeMillis ( ) ) ; }
public boolean noVersionReceivedFromServer ( ) { return versionTag == null && region . concurrencyChecksEnabled && region . getServerProxy ( ) != null && ! op . isLocal ( ) && ! isOriginRemote ( ) ; }
public void addEngineer ( String engineerName ) { if ( engineerName . length ( ) <= _NUM ) { return ; } engineers . add ( engineerName ) ; engineersTable . refresh ( _BOOL ) ; migrationTask . addEngineers ( engineerName ) ; }
public void addEngineer ( String engineerName ) { if ( engineerName . length ( ) <= _NUM ) { return ; } engineers . add ( engineerName ) ; engineersTable . refresh ( _BOOL ) ; migrationTask . addEngineers ( engineerName ) ; }
public void addEngineer ( String engineerName ) { if ( engineerName . length ( ) <= _NUM ) { return ; } engineers . add ( engineerName ) ; engineersTable . refresh ( _BOOL ) ; migrationTask . addEngineers ( engineerName ) ; }
@ Override public long freeMemory ( long windowId ) throws IOException { long size = keyStream . dataSizeUpToWindow ( windowId ) + valueStream . dataSizeUpToWindow ( windowId ) ; windowsForFreeMemory . add ( windowId ) ; return size ; }
@ Override public long freeMemory ( long windowId ) throws IOException { long size = keyStream . dataSizeUpToWindow ( windowId ) + valueStream . dataSizeUpToWindow ( windowId ) ; windowsForFreeMemory . add ( windowId ) ; return size ; }
public void close ( ) throws IOException { raf . close ( ) ; }
@ NotNull default B append ( @ NotNull CharSequence cs ) throws BufferOverflowException { return append ( cs , _NUM , cs . length ( ) ) ; }
public static Binding asBinding ( final QuerySolution map ) { if ( map != null ) { BindingHashMap result = new BindingHashMap ( ) ; Iterator < String > varNames = map . varNames ( ) ; while ( varNames . hasNext ( ) ) { String varName = varNames . next ( ) ; RDFNode node = map . get ( varName ) ; if ( node != null ) { result . add ( Var . alloc ( varName ) , node . asNode ( ) ) ; } } return result ; } else { return null ; } }
public List < File > generatedFiles ( ) { return Collections . unmodifiableList ( generatedFiles ) ; }
public static void allowItemForRecycling ( Object stack ) { recyclingAllowed . add ( ApiUtils . convertToValidRecipeInput ( stack ) ) ; }
public static void allowItemForRecycling ( Object stack ) { recyclingAllowed . add ( ApiUtils . convertToValidRecipeInput ( stack ) ) ; }
private void resetBlockletProcessingCount ( ) { blockletProcessingCount . set ( _NUM ) ; }
public String toString ( ) { StringBuffer buf = new StringBuffer ( NODE + STRING + getFeature ( ) + STRING + OPERAND_MATCHES ) ; buf . append ( getValueString ( ) + STRING ) ; buf . append ( Integer . toString ( qtrue ) + STRING ) ; buf . append ( Integer . toString ( qfalse ) ) ; return buf . toString ( ) ; }
void loadItemsIntoSlots ( final Player player ) { final String [ ] slotsItems = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; try { for ( final String slotName : slotsItems ) { if ( ! player . hasSlot ( slotName ) ) { continue ; } final RPSlot slot = player . getSlot ( slotName ) ; final PlayerSlot newSlot ; if ( slotName . equals ( STRING ) ) { newSlot = new PlayerKeyringSlot ( slotName ) ; } else if ( slotName . equals ( STRING ) ) { newSlot = new PlayerTradeSlot ( slotName ) ; } else { newSlot = new PlayerSlot ( slotName ) ; } loadSlotContent ( player , slot , newSlot ) ; } for ( final Banks bank : Banks . values ( ) ) { final RPSlot slot = player . getSlot ( bank . getSlotName ( ) ) ; final PlayerSlot newSlot = new BankSlot ( bank ) ; loadSlotContent ( player , slot , newSlot ) ; } } catch ( final RuntimeException e ) { logger . error ( STRING , e ) ; } }
public LZMAInputStream ( InputStream in , int memoryLimit ) throws IOException { DataInputStream inData = new DataInputStream ( in ) ; byte propsByte = inData . readByte ( ) ; int dictSize = _NUM ; for ( int i = _NUM ; i < _NUM ; ++ i ) dictSize |= inData . readUnsignedByte ( ) << ( _NUM * i ) ; long uncompSize = _NUM ; for ( int i = _NUM ; i < _NUM ; ++ i ) uncompSize |= ( long ) inData . readUnsignedByte ( ) << ( _NUM * i ) ; int memoryNeeded = getMemoryUsage ( dictSize , propsByte ) ; if ( memoryLimit != - _NUM && memoryNeeded > memoryLimit ) throw new MemoryLimitException ( memoryNeeded , memoryLimit ) ; initialize ( in , uncompSize , propsByte , dictSize , null ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean trainingMode ) { TIntDoubleHashMap fMap = new TIntDoubleHashMap ( features . size ( ) ) ; for ( Feature feature : features ) { final int featureId = FeatureUtilities . getFeatureId ( lexicon , trainingMode , feature ) ; if ( featureId < _NUM ) continue ; double value = feature . getValue ( ) + fMap . get ( featureId ) ; fMap . put ( featureId , value ) ; } int [ ] idsOriginal = fMap . keys ( ) ; int [ ] ids = new int [ idsOriginal . length ] ; System . arraycopy ( idsOriginal , _NUM , ids , _NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ fMap . size ( ) ] ; int count = _NUM ; for ( int key : ids ) { vals [ count ++ ] = fMap . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean trainingMode ) { TIntDoubleHashMap fMap = new TIntDoubleHashMap ( features . size ( ) ) ; for ( Feature feature : features ) { final int featureId = FeatureUtilities . getFeatureId ( lexicon , trainingMode , feature ) ; if ( featureId < _NUM ) continue ; double value = feature . getValue ( ) + fMap . get ( featureId ) ; fMap . put ( featureId , value ) ; } int [ ] idsOriginal = fMap . keys ( ) ; int [ ] ids = new int [ idsOriginal . length ] ; System . arraycopy ( idsOriginal , _NUM , ids , _NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ fMap . size ( ) ] ; int count = _NUM ; for ( int key : ids ) { vals [ count ++ ] = fMap . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public static Pair < int [ ] , double [ ] > convert ( Set < Feature > features , Lexicon lexicon , boolean trainingMode ) { TIntDoubleHashMap fMap = new TIntDoubleHashMap ( features . size ( ) ) ; for ( Feature feature : features ) { final int featureId = FeatureUtilities . getFeatureId ( lexicon , trainingMode , feature ) ; if ( featureId < _NUM ) continue ; double value = feature . getValue ( ) + fMap . get ( featureId ) ; fMap . put ( featureId , value ) ; } int [ ] idsOriginal = fMap . keys ( ) ; int [ ] ids = new int [ idsOriginal . length ] ; System . arraycopy ( idsOriginal , _NUM , ids , _NUM , ids . length ) ; Arrays . sort ( ids ) ; double [ ] vals = new double [ fMap . size ( ) ] ; int count = _NUM ; for ( int key : ids ) { vals [ count ++ ] = fMap . get ( key ) ; } return new Pair < > ( ids , vals ) ; }
public int parse ( String argv [ ] ) throws IOException , HelpRequestedException { return parse ( argv , _BOOL ) ; }
public int parse ( String argv [ ] ) throws IOException , HelpRequestedException { return parse ( argv , _BOOL ) ; }
public Z21Message ( byte [ ] a , int l ) { super ( String . valueOf ( a ) ) ; setBinary ( _BOOL ) ; }
public Z21Message ( byte [ ] a , int l ) { super ( String . valueOf ( a ) ) ; setBinary ( _BOOL ) ; }
public boolean matches ( Function function , String id ) { return mFunction == function && mID != null && id != null && id . matches ( mID . replace ( STRING , STRING ) ) ; }
public boolean matches ( Function function , String id ) { return mFunction == function && mID != null && id != null && id . matches ( mID . replace ( STRING , STRING ) ) ; }
public void insertBitmap ( final BufferedImage bitmap , final int x , final int y , final int xx , final int yy , final FilterMode filter ) { insertBitmap ( bitmap , x , y , bitmap . getRGB ( xx , yy ) , filter ) ; }
public void insertBitmap ( final BufferedImage bitmap , final int x , final int y , final int xx , final int yy , final FilterMode filter ) { insertBitmap ( bitmap , x , y , bitmap . getRGB ( xx , yy ) , filter ) ; }
public void insertBitmap ( final BufferedImage bitmap , final int x , final int y , final int xx , final int yy , final FilterMode filter ) { insertBitmap ( bitmap , x , y , bitmap . getRGB ( xx , yy ) , filter ) ; }
public void insertBitmap ( final BufferedImage bitmap , final int x , final int y , final int xx , final int yy , final FilterMode filter ) { insertBitmap ( bitmap , x , y , bitmap . getRGB ( xx , yy ) , filter ) ; }
public void createConnection ( NetworkInterface anotherInterface ) { if ( ! isConnected ( anotherInterface ) && ( this != anotherInterface ) ) { Connection con = new VBRConnection ( this . host , this , anotherInterface . getHost ( ) , anotherInterface ) ; connect ( con , anotherInterface ) ; } }
public void createConnection ( NetworkInterface anotherInterface ) { if ( ! isConnected ( anotherInterface ) && ( this != anotherInterface ) ) { Connection con = new VBRConnection ( this . host , this , anotherInterface . getHost ( ) , anotherInterface ) ; connect ( con , anotherInterface ) ; } }
public void createConnection ( NetworkInterface anotherInterface ) { if ( ! isConnected ( anotherInterface ) && ( this != anotherInterface ) ) { Connection con = new VBRConnection ( this . host , this , anotherInterface . getHost ( ) , anotherInterface ) ; connect ( con , anotherInterface ) ; } }
protected EObject createInitialModel ( ) { EClass eClass = ( EClass ) eipPackage . getEClassifier ( initialObjectCreationPage . getInitialObjectName ( ) ) ; EObject rootObject = eipFactory . create ( eClass ) ; return rootObject ; }
public void removeDragEventHandlers ( ) { node . removeEventHandler ( TouchEvent . ANY , touchHandler ) ; node . removeEventHandler ( MouseEvent . ANY , mouseHandler ) ; }
@ UiThread public void collapseParent ( int parentPosition ) { collapseParent ( mParentList . get ( parentPosition ) ) ; }
@ UiThread public void collapseParent ( int parentPosition ) { collapseParent ( mParentList . get ( parentPosition ) ) ; }
public void addListener ( ConnectableDeviceListener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void addListener ( ConnectableDeviceListener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void addListener ( ConnectableDeviceListener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public void addListener ( ConnectableDeviceListener listener ) { if ( ! listeners . contains ( listener ) ) { listeners . add ( listener ) ; } }
public IdsQuery ( Class < T > type , Object [ ] ids , Object routing , QueryResultType queryResultType ) { this ( type . getName ( ) , ids , routing , null , queryResultType ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids , Object routing , QueryResultType queryResultType ) { this ( type . getName ( ) , ids , routing , null , queryResultType ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids , Object routing , QueryResultType queryResultType ) { this ( type . getName ( ) , ids , routing , null , queryResultType ) ; }
@ Override public void resetReferences ( ) { _refs . clear ( ) ; }
public @ NonNull ChargeRequest . Builder autoReturn ( long timeout , TimeUnit unit ) { long autoReturnMillis ; if ( timeout != RegisterApi . AUTO_RETURN_NO_TIMEOUT ) { autoReturnMillis = unit . toMillis ( timeout ) ; nonNull ( unit , STRING ) ; if ( autoReturnMillis < RegisterApi . AUTO_RETURN_TIMEOUT_MIN_MILLIS ) { throw new IllegalArgumentException ( STRING + RegisterApi . AUTO_RETURN_TIMEOUT_MIN_MILLIS ) ; } if ( autoReturnMillis > RegisterApi . AUTO_RETURN_TIMEOUT_MAX_MILLIS ) { throw new IllegalArgumentException ( STRING + RegisterApi . AUTO_RETURN_TIMEOUT_MAX_MILLIS ) ; } } else { autoReturnMillis = RegisterApi . AUTO_RETURN_NO_TIMEOUT ; } this . autoReturnMillis = autoReturnMillis ; return this ; }
protected void installKeyboardActions ( mxGraphComponent graphComponent ) { InputMap inputMap = getInputMap ( JComponent . WHEN_ANCESTOR_OF_FOCUSED_COMPONENT ) ; SwingUtilities . replaceUIInputMap ( graphComponent , JComponent . WHEN_ANCESTOR_OF_FOCUSED_COMPONENT , inputMap ) ; inputMap = getInputMap ( JComponent . WHEN_FOCUSED ) ; SwingUtilities . replaceUIInputMap ( graphComponent , JComponent . WHEN_FOCUSED , inputMap ) ; SwingUtilities . replaceUIActionMap ( graphComponent , createActionMap ( ) ) ; }
private void registerEnd ( final String prefixSingular , final String prefixPlural , final String endString ) { prefixEndList . add ( new PrefixEntry ( endString , prefixSingular , prefixPlural ) ) ; registerPrefix ( prefixSingular , prefixPlural ) ; }
private void registerEnd ( final String prefixSingular , final String prefixPlural , final String endString ) { prefixEndList . add ( new PrefixEntry ( endString , prefixSingular , prefixPlural ) ) ; registerPrefix ( prefixSingular , prefixPlural ) ; }
public void remove ( Individual individual ) { individuals . remove ( individual ) ; }
@ SuppressWarnings ( STRING ) private static String parseGwtRpcMethodName ( InputStream stream , String charEncoding ) { try { final Scanner scanner ; if ( charEncoding == null ) { scanner = new Scanner ( stream ) ; } else { scanner = new Scanner ( stream , charEncoding ) ; } scanner . useDelimiter ( GWT_RPC_SEPARATOR_CHAR_PATTERN ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; scanner . next ( ) ; return STRING + scanner . next ( ) ; } catch ( final NoSuchElementException e ) { LOG . debug ( STRING , e ) ; return null ; } }
private void changeAnnouncement ( Player activePlayer , String announcement ) { if ( legionRestrictions . canChangeAnnouncement ( activePlayer . getLegionMember ( ) , announcement ) ) { Legion legion = activePlayer . getLegion ( ) ; Timestamp currentTime = new Timestamp ( System . currentTimeMillis ( ) ) ; storeNewAnnouncement ( legion . getLegionId ( ) , currentTime , announcement ) ; legion . addAnnouncementToList ( currentTime , announcement ) ; PacketSendUtility . sendPacket ( activePlayer , SM_SYSTEM_MESSAGE . STR_GUILD_WRITE_NOTICE_DONE ) ; PacketSendUtility . broadcastPacketToLegion ( legion , new SM_LEGION_EDIT ( _NUM , ( int ) ( System . currentTimeMillis ( ) / _NUM ) , announcement ) ) ; } }
private void changeAnnouncement ( Player activePlayer , String announcement ) { if ( legionRestrictions . canChangeAnnouncement ( activePlayer . getLegionMember ( ) , announcement ) ) { Legion legion = activePlayer . getLegion ( ) ; Timestamp currentTime = new Timestamp ( System . currentTimeMillis ( ) ) ; storeNewAnnouncement ( legion . getLegionId ( ) , currentTime , announcement ) ; legion . addAnnouncementToList ( currentTime , announcement ) ; PacketSendUtility . sendPacket ( activePlayer , SM_SYSTEM_MESSAGE . STR_GUILD_WRITE_NOTICE_DONE ) ; PacketSendUtility . broadcastPacketToLegion ( legion , new SM_LEGION_EDIT ( _NUM , ( int ) ( System . currentTimeMillis ( ) / _NUM ) , announcement ) ) ; } }
private void changeAnnouncement ( Player activePlayer , String announcement ) { if ( legionRestrictions . canChangeAnnouncement ( activePlayer . getLegionMember ( ) , announcement ) ) { Legion legion = activePlayer . getLegion ( ) ; Timestamp currentTime = new Timestamp ( System . currentTimeMillis ( ) ) ; storeNewAnnouncement ( legion . getLegionId ( ) , currentTime , announcement ) ; legion . addAnnouncementToList ( currentTime , announcement ) ; PacketSendUtility . sendPacket ( activePlayer , SM_SYSTEM_MESSAGE . STR_GUILD_WRITE_NOTICE_DONE ) ; PacketSendUtility . broadcastPacketToLegion ( legion , new SM_LEGION_EDIT ( _NUM , ( int ) ( System . currentTimeMillis ( ) / _NUM ) , announcement ) ) ; } }
private void changeAnnouncement ( Player activePlayer , String announcement ) { if ( legionRestrictions . canChangeAnnouncement ( activePlayer . getLegionMember ( ) , announcement ) ) { Legion legion = activePlayer . getLegion ( ) ; Timestamp currentTime = new Timestamp ( System . currentTimeMillis ( ) ) ; storeNewAnnouncement ( legion . getLegionId ( ) , currentTime , announcement ) ; legion . addAnnouncementToList ( currentTime , announcement ) ; PacketSendUtility . sendPacket ( activePlayer , SM_SYSTEM_MESSAGE . STR_GUILD_WRITE_NOTICE_DONE ) ; PacketSendUtility . broadcastPacketToLegion ( legion , new SM_LEGION_EDIT ( _NUM , ( int ) ( System . currentTimeMillis ( ) / _NUM ) , announcement ) ) ; } }
public void createWSFedProvider ( String realm , String entityId , Map values ) throws AMConsoleException { try { List < String > metaAliases = getFederationAlias ( values , MetaTemplateParameters . P_WS_FED_ALIASES ) ; Set < String > duplicateCheck = new HashSet < String > ( metaAliases ) ; if ( duplicateCheck . size ( ) < metaAliases . size ( ) ) { throw new AMConsoleException ( getLocalizedString ( STRING ) ) ; } WSFederationMetaManager metaManager = new WSFederationMetaManager ( ) ; metaManager . validateMetaAliasForNewEntity ( realm , metaAliases ) ; String metadata = CreateWSFedMetaDataTemplate . createStandardMetaTemplate ( entityId , values , requestURL ) ; String extendedData = CreateWSFedMetaDataTemplate . createExtendedMetaTemplate ( entityId , values ) ; FederationElement elt = ( FederationElement ) WSFederationMetaUtils . convertStringToJAXB ( metadata ) ; String federationID = elt . getFederationID ( ) ; if ( federationID == null ) { federationID = WSFederationConstants . DEFAULT_FEDERATION_ID ; } metaManager . createFederation ( realm , elt ) ; FederationConfigElement cfg = ( FederationConfigElement ) WSFederationMetaUtils . convertStringToJAXB ( extendedData ) ; metaManager . createEntityConfig ( realm , cfg ) ; } catch ( WSFederationMetaException ex ) { throw new AMConsoleException ( ex . getMessage ( ) ) ; } catch ( JAXBException ex ) { throw new AMConsoleException ( ex . getMessage ( ) ) ; } catch ( CertificateEncodingException ex ) { throw new AMConsoleException ( ex . getMessage ( ) ) ; } }
private int parseCurrentNumber ( ByteBuf buffer ) { int number = _NUM ; int readerIndex = buffer . readerIndex ( ) ; byte b = _NUM ; while ( _BOOL ) { if ( ! buffer . isReadable ( ) ) return Integer . MIN_VALUE ; b = buffer . readByte ( ) ; if ( Character . isDigit ( b ) ) { number = number * _NUM + ( int ) ( b - STRING ) ; readerIndex ++ ; } else { buffer . readerIndex ( readerIndex ) ; break ; } } return number ; }
private String popAndEncodeAsJs ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == _NUM ) { return null ; } int totalPayloadLen = _NUM ; int numMessagesToSend = _NUM ; for ( JsMessage message : queue ) { int messageSize = message . calculateEncodedLength ( ) + _NUM ; if ( numMessagesToSend > _NUM && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > _NUM ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += _NUM ; } boolean willSendAllMessages = numMessagesToSend == queue . size ( ) ; StringBuilder sb = new StringBuilder ( totalPayloadLen + ( willSendAllMessages ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; if ( willSendAllMessages && ( i + _NUM == numMessagesToSend ) ) { message . encodeAsJsMessage ( sb ) ; } else { sb . append ( STRING ) ; message . encodeAsJsMessage ( sb ) ; sb . append ( STRING ) ; } } if ( ! willSendAllMessages ) { sb . append ( STRING ) ; } for ( int i = willSendAllMessages ? _NUM : _NUM ; i < numMessagesToSend ; ++ i ) { sb . append ( STRING ) ; } String ret = sb . toString ( ) ; return ret ; } }
public Enumeration < String > enumerateMeasures ( ) { Vector < String > result = new Vector < String > ( ) ; result . addElement ( STRING ) ; result . addElement ( STRING ) ; return result . elements ( ) ; }
public Enumeration < String > enumerateMeasures ( ) { Vector < String > result = new Vector < String > ( ) ; result . addElement ( STRING ) ; result . addElement ( STRING ) ; return result . elements ( ) ; }
private void addToSearchCriteriaParameterMap ( String key , String value ) { if ( searchCriteriaParameterMap . containsKey ( key ) ) { ArrayList < String > arrayList = searchCriteriaParameterMap . get ( key ) ; arrayList . add ( value ) ; searchCriteriaParameterMap . put ( key , arrayList ) ; } else { ArrayList < String > arrayList = new ArrayList < > ( ) ; arrayList . add ( value ) ; searchCriteriaParameterMap . put ( key , arrayList ) ; } }
private boolean exposed ( int modifiers ) { return _NUM != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
private boolean exposed ( int modifiers ) { return _NUM != ( modifiers & ( Modifier . PUBLIC | Modifier . PROTECTED ) ) ; }
static double computeFinalSum ( double [ ] summands ) { double tmp = summands [ _NUM ] + summands [ _NUM ] ; double simpleSum = summands [ summands . length - _NUM ] ; if ( Double . isNaN ( tmp ) && Double . isInfinite ( simpleSum ) ) { return simpleSum ; } else { return tmp ; } }
static double computeFinalSum ( double [ ] summands ) { double tmp = summands [ _NUM ] + summands [ _NUM ] ; double simpleSum = summands [ summands . length - _NUM ] ; if ( Double . isNaN ( tmp ) && Double . isInfinite ( simpleSum ) ) { return simpleSum ; } else { return tmp ; } }
static double computeFinalSum ( double [ ] summands ) { double tmp = summands [ _NUM ] + summands [ _NUM ] ; double simpleSum = summands [ summands . length - _NUM ] ; if ( Double . isNaN ( tmp ) && Double . isInfinite ( simpleSum ) ) { return simpleSum ; } else { return tmp ; } }
static double computeFinalSum ( double [ ] summands ) { double tmp = summands [ _NUM ] + summands [ _NUM ] ; double simpleSum = summands [ summands . length - _NUM ] ; if ( Double . isNaN ( tmp ) && Double . isInfinite ( simpleSum ) ) { return simpleSum ; } else { return tmp ; } }
private boolean checkIfVolumeSizeExceedingPoolSize ( CIMArgument [ ] inArgs , CIMArgument [ ] outArgs ) { if ( getVolumeSize ( inArgs ) > getVolumeSize ( outArgs ) ) { return _BOOL ; } return _BOOL ; }
private boolean checkIfVolumeSizeExceedingPoolSize ( CIMArgument [ ] inArgs , CIMArgument [ ] outArgs ) { if ( getVolumeSize ( inArgs ) > getVolumeSize ( outArgs ) ) { return _BOOL ; } return _BOOL ; }
public int size ( ) { return cache . size ( ) ; }
private int deleteAllContacts ( Iterator < String > contactsIter ) { int totalContactsDeleted = _NUM ; while ( contactsIter . hasNext ( ) ) totalContactsDeleted += deleteContact ( contactsIter . next ( ) ) ; return totalContactsDeleted ; }
private void updateTitle ( int selected ) { if ( mActionMode != null ) { if ( mTitleProvider != null ) mActionMode . setTitle ( mTitleProvider . getTitle ( selected ) ) ; else mActionMode . setTitle ( String . valueOf ( selected ) ) ; } }
private void updateTitle ( int selected ) { if ( mActionMode != null ) { if ( mTitleProvider != null ) mActionMode . setTitle ( mTitleProvider . getTitle ( selected ) ) ; else mActionMode . setTitle ( String . valueOf ( selected ) ) ; } }
public float indexerScore ( String url , NutchDocument doc , WebPage row , float initScore ) { return ( float ) Math . pow ( row . getScore ( ) , scorePower ) * initScore ; }
public abstract void onPinSet ( String pin ) ;
public abstract void onPinSet ( String pin ) ;
public Label ( String tag ) { id = tag . intern ( ) ; opc = opc_label ; operand = null ; }
public Label ( String tag ) { id = tag . intern ( ) ; opc = opc_label ; operand = null ; }
private void log ( IStatus status ) { ResourcesPlugin . log ( status ) ; }
private void log ( IStatus status ) { ResourcesPlugin . log ( status ) ; }
protected List < DecompoundedWord > makeSplit ( String aWord ) { List < DecompoundedWord > result = new ArrayList < DecompoundedWord > ( ) ; for ( int i = _NUM ; i < aWord . length ( ) ; i ++ ) { String leftWord = aWord . substring ( _NUM , i + _NUM ) ; String rightWord = aWord . substring ( i + _NUM ) ; boolean leftGood = dict . contains ( leftWord ) && leftWord . length ( ) >= minWordLength ; boolean rightGood = rightWord . length ( ) > minRestLength || rightWord . length ( ) == _NUM ; if ( leftGood && rightGood ) { DecompoundedWord split = DecompoundedWord . createFromString ( leftWord + STRING + rightWord ) ; split . setSplitPos ( i ) ; result . add ( split ) ; } for ( String morpheme : morphemes . getAll ( ) ) { try { String leftWithoutMorpheme = leftWord . substring ( _NUM , leftWord . length ( ) - morpheme . length ( ) ) ; if ( leftWord . endsWith ( morpheme ) && dict . contains ( leftWithoutMorpheme ) && rightGood ) { DecompoundedWord split = DecompoundedWord . createFromString ( leftWithoutMorpheme + STRING + morpheme + STRING + rightWord ) ; split . setSplitPos ( i ) ; result . add ( split ) ; } } catch ( StringIndexOutOfBoundsException e ) { continue ; } } } return result ; }
public void add ( Individual individual ) { individuals . add ( individual ) ; }
public static void sort ( Object [ ] array , int start , int end ) { ComparableTimSort . sort ( array , start , end ) ; }
private void run ( ) { try { Thread current = Thread . currentThread ( ) ; char [ ] buf = new char [ _NUM ] ; for ( int len = in . read ( buf ) ; len != - _NUM ; len = in . read ( buf ) ) { append ( buf , _NUM , len ) ; if ( current != thread ) { break ; } } } catch ( IOException e ) { logger . error ( e . getMessage ( ) , e ) ; } trace ( STRING ) ; }
private static Boolean isValidIPV4 ( final String ipAddress ) { boolean status = _BOOL ; if ( StringUtils . isNotEmpty ( ipAddress ) ) { status = InetAddressUtils . isIPv4Address ( ipAddress ) ; } return status ; }
private static Boolean isValidIPV4 ( final String ipAddress ) { boolean status = _BOOL ; if ( StringUtils . isNotEmpty ( ipAddress ) ) { status = InetAddressUtils . isIPv4Address ( ipAddress ) ; } return status ; }
public void readData ( DataInput din ) throws IOException { status = din . readByte ( ) & _NUM ; }
static private < S > long writeSPOs ( final AbstractTripleStore database , final AbstractTripleStore statementStore , final SPO [ ] stmts , final int numStmts , final IWrittenSPOArray callback ) { final IChunkedOrderedIterator < ISPO > itr = new ChunkedArrayIterator < ISPO > ( numStmts , stmts , null ) ; final AbstractTripleStore sink = statementStore != null ? statementStore : database ; if ( log . isInfoEnabled ( ) ) { log . info ( STRING + numStmts + STRING + ( statementStore != null ? STRING : STRING ) ) ; if ( DEBUG ) { for ( int i = _NUM ; i < numStmts ; i ++ ) { log . debug ( STRING + stmts [ i ] ) ; } } } final long nwritten = database . addStatements ( sink , _BOOL , itr , null ) ; if ( callback != null ) { callback . didWriteSPOs ( stmts , numStmts ) ; } return nwritten ; }
public int last ( ) { return prev ( arguments != null ? arguments . size ( ) : _NUM ) ; }
public MultiMapImpl ( int maxCapacity ) { _maxCapacity = maxCapacity ; int size = _NUM ; _keys = ( K [ ] ) new Object [ size ] ; _values = ( List < V > [ ] ) new List [ size ] ; _size = _NUM ; }
public List < Instruction > reduceInstructions ( final List < Instruction > instructions ) { lock . lock ( ) ; try { this . instructions = instructions ; stackSizeSimulator . buildStackSizes ( instructions ) ; return reduceInstructionsInternal ( instructions ) ; } finally { lock . unlock ( ) ; } }
public void actionPerformed ( ActionEvent e ) { boolean ok ; int retVal ; if ( ! checkModified ( ) ) return ; retVal = m_FileChooser . showOpenDialog ( FileScriptingPanel . this ) ; if ( retVal != JFileChooser . APPROVE_OPTION ) return ; ok = m_Script . open ( m_FileChooser . getSelectedFile ( ) ) ; m_TextCode . setCaretPosition ( _NUM ) ; if ( ! ok ) JOptionPane . showMessageDialog ( FileScriptingPanel . this , STRING + m_FileChooser . getSelectedFile ( ) + STRING ) ; notifyTitleUpdatedListeners ( new TitleUpdatedEvent ( FileScriptingPanel . this ) ) ; }
public ArbitraryLengthPathNode ( final TermNode left , final TermNode right , final VarNode tVarLeft , final VarNode tVarRight , final long lowerBound , final long upperBound ) { this ( new BOp [ ] { new JoinGroupNode ( ) } , NV . asMap ( new NV ( Annotations . LEFT_TERM , left ) , new NV ( Annotations . RIGHT_TERM , right ) , new NV ( Annotations . TRANSITIVITY_VAR_LEFT , tVarLeft ) , new NV ( Annotations . TRANSITIVITY_VAR_RIGHT , tVarRight ) , new NV ( Annotations . DROP_VARS , new ArrayList < VarNode > ( ) ) , new NV ( Annotations . LOWER_BOUND , lowerBound ) , new NV ( Annotations . UPPER_BOUND , upperBound ) ) ) ; final Set < VarNode > dropVars = new LinkedHashSet < > ( ) ; dropVars . add ( tVarLeft ) ; dropVars . add ( tVarRight ) ; setProperty ( Annotations . DROP_VARS , dropVars ) ; }
protected final void addWorker ( WorkerThread worker ) { synchronized ( workers ) { workers . add ( worker ) ; } }
protected final void addWorker ( WorkerThread worker ) { synchronized ( workers ) { workers . add ( worker ) ; } }
protected void updateComboBoxesLoadChange ( ) { if ( autoTrackCheckBox . isSelected ( ) ) { updateLocationTrackComboBox ( ) ; } if ( autoDestinationTrackCheckBox . isSelected ( ) ) { updateDestinationTrackComboBox ( ) ; } if ( autoFinalDestTrackCheckBox . isSelected ( ) ) { updateFinalDestination ( ) ; } }
protected void updateComboBoxesLoadChange ( ) { if ( autoTrackCheckBox . isSelected ( ) ) { updateLocationTrackComboBox ( ) ; } if ( autoDestinationTrackCheckBox . isSelected ( ) ) { updateDestinationTrackComboBox ( ) ; } if ( autoFinalDestTrackCheckBox . isSelected ( ) ) { updateFinalDestination ( ) ; } }
protected void updateComboBoxesLoadChange ( ) { if ( autoTrackCheckBox . isSelected ( ) ) { updateLocationTrackComboBox ( ) ; } if ( autoDestinationTrackCheckBox . isSelected ( ) ) { updateDestinationTrackComboBox ( ) ; } if ( autoFinalDestTrackCheckBox . isSelected ( ) ) { updateFinalDestination ( ) ; } }
private void updateColumnMaps ( int columnIndex ) { deleteColumnIndexFromMaps ( columnIndex ) ; addColumnToColumnsMaps ( columnIndex , columnMetaData . get ( columnIndex ) ) ; }
private void updateColumnMaps ( int columnIndex ) { deleteColumnIndexFromMaps ( columnIndex ) ; addColumnToColumnsMaps ( columnIndex , columnMetaData . get ( columnIndex ) ) ; }
public PollingScanDiskSpaceMonitor ( Set < Path > watchPaths , long pollingIntervalMillis ) { this . watchPaths = Collections . unmodifiableSet ( new HashSet < > ( watchPaths ) ) ; this . pollingIntervalMillis = pollingIntervalMillis ; }
public PollingScanDiskSpaceMonitor ( Set < Path > watchPaths , long pollingIntervalMillis ) { this . watchPaths = Collections . unmodifiableSet ( new HashSet < > ( watchPaths ) ) ; this . pollingIntervalMillis = pollingIntervalMillis ; }
public PollingScanDiskSpaceMonitor ( Set < Path > watchPaths , long pollingIntervalMillis ) { this . watchPaths = Collections . unmodifiableSet ( new HashSet < > ( watchPaths ) ) ; this . pollingIntervalMillis = pollingIntervalMillis ; }
public int nextInt ( ) { return next ( _NUM ) ; }
public int nextInt ( ) { return next ( _NUM ) ; }
public int nextInt ( ) { return next ( _NUM ) ; }
public int nextInt ( ) { return next ( _NUM ) ; }
public int nextInt ( ) { return next ( _NUM ) ; }
public int nextInt ( ) { return next ( _NUM ) ; }
protected void recordSelected ( int key ) { return ; }
protected void recordSelected ( int key ) { return ; }
protected abstract void performExtraSetupOnDeployable ( Object webapp ) throws Exception ;
protected abstract void performExtraSetupOnDeployable ( Object webapp ) throws Exception ;
protected abstract void performExtraSetupOnDeployable ( Object webapp ) throws Exception ;
public Connection next ( String method ) throws IOException { for ( Connection pooled ; ( pooled = pool . get ( address ) ) != null ; ) { if ( method . equals ( STRING ) || pooled . isReadable ( ) ) return pooled ; pooled . close ( ) ; } if ( ! hasNextTlsMode ( ) ) { if ( ! hasNextInetSocketAddress ( ) ) { if ( ! hasNextProxy ( ) ) { if ( ! hasNextPostponed ( ) ) { throw new NoSuchElementException ( ) ; } return new Connection ( nextPostponed ( ) ) ; } lastProxy = nextProxy ( ) ; resetNextInetSocketAddress ( lastProxy ) ; } lastInetSocketAddress = nextInetSocketAddress ( ) ; resetNextTlsMode ( ) ; } boolean modernTls = nextTlsMode ( ) == TLS_MODE_MODERN ; Route route = new Route ( address , lastProxy , lastInetSocketAddress , modernTls ) ; if ( routeDatabase . shouldPostpone ( route ) ) { postponedRoutes . add ( route ) ; return next ( method ) ; } return new Connection ( route ) ; }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeInt ( DBIDUtil . asInteger ( routingObjectID ) ) ; out . writeDouble ( parentDistance ) ; out . writeDouble ( coveringRadius ) ; }
public TransformerException ( Throwable e ) { super ( e . toString ( ) ) ; this . containedException = e ; this . locator = null ; }
public TransformerException ( Throwable e ) { super ( e . toString ( ) ) ; this . containedException = e ; this . locator = null ; }
public TransformerException ( Throwable e ) { super ( e . toString ( ) ) ; this . containedException = e ; this . locator = null ; }
public void delete ( SSOToken token , String objName ) throws SMSException , SSOException { if ( ( objName == null ) || ( objName . length ( ) == _NUM ) ) { throw new IllegalArgumentException ( STRING ) ; } String objKey = objName . toLowerCase ( ) ; String filepath = null ; mRWLock . readRequest ( ) ; try { filepath = mNameMap . getProperty ( objKey ) ; if ( ( filepath == null ) && mDebug . messageEnabled ( ) ) { mDebug . message ( STRING + objName + STRING ) ; } } finally { mRWLock . readDone ( ) ; } if ( filepath != null ) { mRWLock . writeRequest ( ) ; try { filepath = mNameMap . getProperty ( objKey ) ; if ( filepath == null ) { if ( mDebug . messageEnabled ( ) ) { mDebug . message ( STRING + objName + STRING ) ; } } else { File filehandle = new File ( filepath ) ; File parentDir = filehandle . getParentFile ( ) ; deleteDir ( parentDir ) ; objName = objName . toLowerCase ( ) ; Enumeration keysEnum = mNameMap . keys ( ) ; while ( keysEnum . hasMoreElements ( ) ) { String key = ( String ) keysEnum . nextElement ( ) ; if ( key . endsWith ( objName ) ) { mNameMap . remove ( key ) ; } } saveProperties ( mNameMap , mNameMapHandle , null ) ; } } finally { mRWLock . writeDone ( ) ; } } }
public void add ( Attr attr ) { if ( attr == null ) return ; Attr attr1 = findAttribute ( attr . getName ( ) ) ; if ( attr1 == null ) { _attrs . add ( attr ) ; } else { attr1 . addValues ( attr . getStringValues ( ) ) ; } }
public void testMergeOneFilterIntoDocumentWithMultipleFilters ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; List < String > filterNames = WebXmlUtils . getFilterNames ( srcWebXml ) ; assertEquals ( _NUM , filterNames . size ( ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; }
public void testMergeOneFilterIntoDocumentWithMultipleFilters ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; List < String > filterNames = WebXmlUtils . getFilterNames ( srcWebXml ) ; assertEquals ( _NUM , filterNames . size ( ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; }
public void testMergeOneFilterIntoDocumentWithMultipleFilters ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; List < String > filterNames = WebXmlUtils . getFilterNames ( srcWebXml ) ; assertEquals ( _NUM , filterNames . size ( ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; }
public void testMergeOneFilterIntoDocumentWithMultipleFilters ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . mergeFilters ( mergeWebXml ) ; List < String > filterNames = WebXmlUtils . getFilterNames ( srcWebXml ) ; assertEquals ( _NUM , filterNames . size ( ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; assertEquals ( STRING , filterNames . get ( _NUM ) ) ; }
void recordAccess ( HashEntry < K , V > header , EvictionPolicy evictionPolicy ) { waitForModifyPermition ( header ) ; remove ( ) ; addBefore ( ( HashEntry < K , V > ) evictionPolicy . recordAccess ( header , this ) ) ; accessCount ++ ; lastAccessedTime = System . currentTimeMillis ( ) ; grandModifyAndCloneAllPermition ( header ) ; }
void recordAccess ( HashEntry < K , V > header , EvictionPolicy evictionPolicy ) { waitForModifyPermition ( header ) ; remove ( ) ; addBefore ( ( HashEntry < K , V > ) evictionPolicy . recordAccess ( header , this ) ) ; accessCount ++ ; lastAccessedTime = System . currentTimeMillis ( ) ; grandModifyAndCloneAllPermition ( header ) ; }
private int reconcilePutPermits ( ) { putPermits += takeSidePutPermits ; takeSidePutPermits = _NUM ; return putPermits ; }
private CollectionProcessingEngine buildCPE ( ) throws BaleenException { if ( collectionReader == null ) { throw new BaleenException ( STRING ) ; } Map < String , AnalysisEngineDescription > analysisEngines = new LinkedHashMap < > ( ) ; analysisEngines . putAll ( annotators ) ; analysisEngines . putAll ( consumers ) ; if ( analysisEngines . isEmpty ( ) ) { throw new BaleenException ( STRING ) ; } AnalysisEngineDescription cpeAEs = null ; try { List < String > names = new ArrayList < > ( ) ; names . addAll ( analysisEngines . keySet ( ) ) ; List < AnalysisEngineDescription > engines = new ArrayList < > ( ) ; engines . addAll ( analysisEngines . values ( ) ) ; cpeAEs = AnalysisEngineFactory . createEngineDescription ( engines , names , null , null , null ) ; } catch ( ResourceInitializationException rie ) { throw new BaleenException ( STRING , rie ) ; } org . apache . uima . fit . cpe . CpeBuilder builder = new org . apache . uima . fit . cpe . CpeBuilder ( ) ; try { builder . setReader ( collectionReader ) ; builder . setAnalysisEngine ( cpeAEs ) ; } catch ( Exception e ) { throw new BaleenException ( STRING , e ) ; } try { return builder . createCpe ( null ) ; } catch ( Exception e ) { throw new BaleenException ( STRING , e ) ; } }
private CollectionProcessingEngine buildCPE ( ) throws BaleenException { if ( collectionReader == null ) { throw new BaleenException ( STRING ) ; } Map < String , AnalysisEngineDescription > analysisEngines = new LinkedHashMap < > ( ) ; analysisEngines . putAll ( annotators ) ; analysisEngines . putAll ( consumers ) ; if ( analysisEngines . isEmpty ( ) ) { throw new BaleenException ( STRING ) ; } AnalysisEngineDescription cpeAEs = null ; try { List < String > names = new ArrayList < > ( ) ; names . addAll ( analysisEngines . keySet ( ) ) ; List < AnalysisEngineDescription > engines = new ArrayList < > ( ) ; engines . addAll ( analysisEngines . values ( ) ) ; cpeAEs = AnalysisEngineFactory . createEngineDescription ( engines , names , null , null , null ) ; } catch ( ResourceInitializationException rie ) { throw new BaleenException ( STRING , rie ) ; } org . apache . uima . fit . cpe . CpeBuilder builder = new org . apache . uima . fit . cpe . CpeBuilder ( ) ; try { builder . setReader ( collectionReader ) ; builder . setAnalysisEngine ( cpeAEs ) ; } catch ( Exception e ) { throw new BaleenException ( STRING , e ) ; } try { return builder . createCpe ( null ) ; } catch ( Exception e ) { throw new BaleenException ( STRING , e ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . isEmpty ( ) ) { List < Transaction > tail = new ArrayList < > ( mTransactions . size ( ) + _NUM ) ; mTransactions . drainTo ( tail ) ; mTransactions . add ( transaction ) ; mTransactions . addAll ( tail ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . isEmpty ( ) ) { List < Transaction > tail = new ArrayList < > ( mTransactions . size ( ) + _NUM ) ; mTransactions . drainTo ( tail ) ; mTransactions . add ( transaction ) ; mTransactions . addAll ( tail ) ; } }
public void insert ( Transaction transaction ) { LOG . debug ( STRING + transaction ) ; if ( ! transaction . isEmpty ( ) ) { List < Transaction > tail = new ArrayList < > ( mTransactions . size ( ) + _NUM ) ; mTransactions . drainTo ( tail ) ; mTransactions . add ( transaction ) ; mTransactions . addAll ( tail ) ; } }
public static Properties filterProperties ( Properties properties , String prefix ) { Properties ret = new Properties ( ) ; if ( properties != null && prefix != null ) { prefix = prefix . endsWith ( STRING ) ? prefix : prefix + STRING ; for ( String name : properties . stringPropertyNames ( ) ) { String newName = removeLeadingDots ( name ) ; if ( newName . startsWith ( prefix ) ) { newName = newName . length ( ) > prefix . length ( ) ? newName . substring ( prefix . length ( ) ) : STRING ; newName = removeLeadingDots ( newName ) ; if ( newName . length ( ) > _NUM ) { ret . setProperty ( newName , properties . getProperty ( name ) ) ; } } } } return ret ; }
private void readGlyphNames ( int base ) { if ( base == _NUM ) { glyphnames = new int [ _NUM ] ; for ( int i = _NUM ; i < glyphnames . length ; i ++ ) { glyphnames [ i ] = i ; } return ; } else if ( base == _NUM ) { glyphnames = FontSupport . type1CExpertCharset ; return ; } else if ( base == _NUM ) { glyphnames = FontSupport . type1CExpertSubCharset ; return ; } glyphnames = new int [ nglyphs ] ; glyphnames [ _NUM ] = _NUM ; pos = base ; int t = readByte ( ) ; if ( t == _NUM ) { for ( int i = _NUM ; i < nglyphs ; i ++ ) { glyphnames [ i ] = readInt ( _NUM ) ; } } else if ( t == _NUM ) { int n = _NUM ; while ( n < nglyphs ) { int sid = readInt ( _NUM ) ; int range = readByte ( ) + _NUM ; for ( int i = _NUM ; i < range ; i ++ ) { glyphnames [ n ++ ] = sid ++ ; } } } else if ( t == _NUM ) { int n = _NUM ; while ( n < nglyphs ) { int sid = readInt ( _NUM ) ; int range = readInt ( _NUM ) + _NUM ; for ( int i = _NUM ; i < range ; i ++ ) { glyphnames [ n ++ ] = sid ++ ; } } } }
private double extremum_alpha_n ( int n , double [ ] alpha ) { if ( vec . doubleValue ( n ) == _NUM ) { return MathUtil . HALFPI ; } double tan = _NUM ; for ( int j = n + _NUM ; j < vec . getDimensionality ( ) ; j ++ ) { double alpha_j = j == vec . getDimensionality ( ) - _NUM ? _NUM : alpha [ j ] ; tan += vec . doubleValue ( j ) * sinusProduct ( n + _NUM , j , alpha ) * Math . cos ( alpha_j ) ; } tan /= vec . doubleValue ( n ) ; double alpha_n = Math . atan ( tan ) ; if ( alpha_n < _NUM ) { alpha_n = Math . PI + alpha_n ; } return alpha_n ; }
private double extremum_alpha_n ( int n , double [ ] alpha ) { if ( vec . doubleValue ( n ) == _NUM ) { return MathUtil . HALFPI ; } double tan = _NUM ; for ( int j = n + _NUM ; j < vec . getDimensionality ( ) ; j ++ ) { double alpha_j = j == vec . getDimensionality ( ) - _NUM ? _NUM : alpha [ j ] ; tan += vec . doubleValue ( j ) * sinusProduct ( n + _NUM , j , alpha ) * Math . cos ( alpha_j ) ; } tan /= vec . doubleValue ( n ) ; double alpha_n = Math . atan ( tan ) ; if ( alpha_n < _NUM ) { alpha_n = Math . PI + alpha_n ; } return alpha_n ; }
@ Override public Dimension preferredLayoutSize ( Container parent ) { Dimension rd , mbd ; Insets i = rootPane . getInsets ( ) ; Container contentPane = rootPane . getContentPane ( ) ; JMenuBar menuBar = rootPane . getJMenuBar ( ) ; if ( contentPane . isVisible ( ) ) { rd = contentPane . getPreferredSize ( ) ; } else { rd = new Dimension ( _NUM , contentPane . getPreferredSize ( ) . height ) ; } if ( menuBar != null && menuBar . isVisible ( ) ) { mbd = menuBar . getPreferredSize ( ) ; } else { mbd = new Dimension ( _NUM , _NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
@ Override public Dimension preferredLayoutSize ( Container parent ) { Dimension rd , mbd ; Insets i = rootPane . getInsets ( ) ; Container contentPane = rootPane . getContentPane ( ) ; JMenuBar menuBar = rootPane . getJMenuBar ( ) ; if ( contentPane . isVisible ( ) ) { rd = contentPane . getPreferredSize ( ) ; } else { rd = new Dimension ( _NUM , contentPane . getPreferredSize ( ) . height ) ; } if ( menuBar != null && menuBar . isVisible ( ) ) { mbd = menuBar . getPreferredSize ( ) ; } else { mbd = new Dimension ( _NUM , _NUM ) ; } return new Dimension ( Math . max ( rd . width , mbd . width ) + i . left + i . right , rd . height + mbd . height + i . top + i . bottom ) ; }
public void testWillResetXPathAfterRecursion ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STRING ) ; XppDom dom2 = XppFactory . buildDom ( STRING ) ; assertEquals ( - _NUM , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; assertEquals ( _NUM , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; }
public void testWillResetXPathAfterRecursion ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STRING ) ; XppDom dom2 = XppFactory . buildDom ( STRING ) ; assertEquals ( - _NUM , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; assertEquals ( _NUM , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; }
public void testWillResetXPathAfterRecursion ( ) throws Exception { XppDom dom1 = XppFactory . buildDom ( STRING ) ; XppDom dom2 = XppFactory . buildDom ( STRING ) ; assertEquals ( - _NUM , comparator . compare ( dom1 , dom2 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; assertEquals ( _NUM , comparator . compare ( dom2 , dom1 ) ) ; assertEquals ( STRING , xpath . get ( ) ) ; }
public List < ValueBox > addArgumentHotspots ( String signature , int arg ) { List < ValueBox > sigSpots = StringAnalysis . getArgumentExpressions ( signature , arg ) ; return addArgumentHotspots ( signature , arg , sigSpots ) ; }
public void testCase14 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = - _NUM ; int bSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM , - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
public static String convertResourcePathToClassName ( String resourcePath ) { Assert . notNull ( resourcePath , STRING ) ; return resourcePath . replace ( STRING , STRING ) ; }
public static int toIntValue ( String str ) throws ExpressionException { return ( int ) toDoubleValue ( str , _BOOL ) ; }
public static void createDirs ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdirs ( ) && ! target . exists ( ) ) { throw new AdeUsageException ( STRING + target . getPath ( ) ) ; } }
public RequestHandle put ( String url , ResponseHandlerInterface responseHandler ) { return put ( null , url , null , responseHandler ) ; }
public RequestHandle put ( String url , ResponseHandlerInterface responseHandler ) { return put ( null , url , null , responseHandler ) ; }
public RequestHandle put ( String url , ResponseHandlerInterface responseHandler ) { return put ( null , url , null , responseHandler ) ; }
public TextEditor indent ( int spaces ) { StringBuffer sb = new StringBuffer ( spaces ) ; for ( int i = _NUM ; i < spaces ; i ++ ) { sb . append ( STRING ) ; } return replaceAll ( STRING , sb . toString ( ) ) ; }
public TextEditor indent ( int spaces ) { StringBuffer sb = new StringBuffer ( spaces ) ; for ( int i = _NUM ; i < spaces ; i ++ ) { sb . append ( STRING ) ; } return replaceAll ( STRING , sb . toString ( ) ) ; }
public CharBuffer append ( double d ) { return append ( String . valueOf ( d ) ) ; }
public void addPhoneNumber ( PhoneNumberEntity phoneNumber ) { phoneNumbers . add ( phoneNumber ) ; }
public static void putUnsignedByte ( ByteBuffer bb , short v , int offset ) { bb . put ( offset , ( byte ) ( v & _NUM ) ) ; }
public ProjectedStream addView ( String namespace , String name , List < Expression > parameters ) { views . add ( View . create ( namespace , name , parameters ) ) ; return this ; }
public GPathResult parse ( final File file ) throws IOException , SAXException { final FileInputStream fis = new FileInputStream ( file ) ; final InputSource input = new InputSource ( fis ) ; input . setSystemId ( STRING + file . getAbsolutePath ( ) ) ; try { return parse ( input ) ; } finally { fis . close ( ) ; } }
public GPathResult parse ( final File file ) throws IOException , SAXException { final FileInputStream fis = new FileInputStream ( file ) ; final InputSource input = new InputSource ( fis ) ; input . setSystemId ( STRING + file . getAbsolutePath ( ) ) ; try { return parse ( input ) ; } finally { fis . close ( ) ; } }
public void updateStrengthOfWins ( ) { int strWins = _NUM ; for ( int i = _NUM ; i < _NUM ; ++ i ) { Game g = gameSchedule . get ( i ) ; if ( g . homeTeam == this ) { strWins += Math . pow ( _NUM - g . awayTeam . rankTeamPollScore , _NUM ) ; } else { strWins += Math . pow ( _NUM - g . homeTeam . rankTeamPollScore , _NUM ) ; } } teamStrengthOfWins = strWins / _NUM ; for ( Team t : gameWinsAgainst ) { teamStrengthOfWins += Math . pow ( t . wins , _NUM ) ; } }
public static int readVarInt ( ByteBuffer buff ) { int b = buff . get ( ) ; if ( b >= _NUM ) { return b ; } return readVarIntRest ( buff , b ) ; }
protected void loadChars ( AbstractMRReply msg , DataInputStream istream ) throws IOException { int i ; for ( i = _NUM ; i < msg . maxSize ( ) ; i ++ ) { byte char1 = readByteProtected ( istream ) ; if ( flushReceiveChars ) { log . warn ( STRING , msg . toString ( ) ) ; msg . flush ( ) ; i = _NUM ; flushReceiveChars = _BOOL ; } if ( canReceive ( ) ) { msg . setElement ( i , char1 ) ; if ( endOfMessage ( msg ) ) { break ; } } else { i -- ; log . error ( STRING , Integer . toHexString ( char1 ) ) ; } } }
protected void loadChars ( AbstractMRReply msg , DataInputStream istream ) throws IOException { int i ; for ( i = _NUM ; i < msg . maxSize ( ) ; i ++ ) { byte char1 = readByteProtected ( istream ) ; if ( flushReceiveChars ) { log . warn ( STRING , msg . toString ( ) ) ; msg . flush ( ) ; i = _NUM ; flushReceiveChars = _BOOL ; } if ( canReceive ( ) ) { msg . setElement ( i , char1 ) ; if ( endOfMessage ( msg ) ) { break ; } } else { i -- ; log . error ( STRING , Integer . toHexString ( char1 ) ) ; } } }
public static < T > Task < T > from ( CompletionStage < T > stage ) { if ( stage instanceof Task ) { return ( Task < T > ) stage ; } final Task < T > t = new Task < > ( ) ; stage . handle ( null ) ; return t ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { return ( Instance ) instance . copy ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { setVisible ( _BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { setVisible ( _BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { setVisible ( _BOOL ) ; } timer . stop ( ) ; }
public void stop ( boolean hide ) { if ( hide ) { setVisible ( _BOOL ) ; } timer . stop ( ) ; }
public List < ? > range ( Value begin , Value end ) { List < Object > results = new ArrayList < Object > ( ) ; Key [ ] elementKeys = getElementKeys ( ) ; if ( elementKeys != null && elementKeys . length > _NUM ) { List < Record > records = fetchSubRecords ( elementKeys ) ; for ( Record record : records ) { if ( record != null && filterBinByRange ( record , ListElementBinName , begin , end ) ) { results . add ( record . getValue ( ListElementBinName ) ) ; } } } return results ; }
public static int randGaussian ( final int mean , final int sd ) { return ( int ) ( rand . nextGaussian ( ) * sd + mean ) ; }
@ RequestMapping ( value = STRING ) public void metadataError ( Locale locale , @ PathVariable ( value = STRING ) String tenant , HttpServletResponse response ) throws IOException { logger . info ( STRING , locale . toString ( ) , tenant ) ; metadataDefaultTenantBindingError ( locale , response ) ; }
static boolean internalPut ( @ NonNull String key , @ NonNull Object object ) { try { OutputStreamWriter osw = new OutputStreamWriter ( mCache . openStream ( key ) ) ; mGson . toJson ( object , osw ) ; osw . close ( ) ; return _BOOL ; } catch ( Exception e ) { return _BOOL ; } }
static int measureIndentationUnits ( IDocument document , int lineOfInvocationOffset , int lineOffset , IJavaProject project ) throws BadLocationException { Map < ? , ? > options = project . getOptions ( _BOOL ) ; String lineText = document . get ( lineOffset , document . getLineLength ( lineOfInvocationOffset ) ) ; int indentationUnits = IndentManipulation . measureIndentUnits ( lineText , IndentManipulation . getTabWidth ( options ) , IndentManipulation . getIndentWidth ( options ) ) ; return indentationUnits ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; i18n = Environment . getI18n ( ) ; beanContextChildSupport = new BeanContextChildSupport ( this ) ; }
public void addRangeRestriction ( String ColumnName , Object Code , Object Code_to ) { Restriction r = new Restriction ( ColumnName , Code , Code_to , null , null , null , _BOOL , _NUM ) ; m_list . add ( r ) ; }
public String toJson ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STRING ) ; boolean notTheFirst = _BOOL ; List < ? > entries = getAllParentlessEntries ( ) ; for ( Object entryUncasted : entries ) { Entry entry = ( Entry ) entryUncasted ; if ( notTheFirst ) { result . append ( STRING ) ; } appendIndentation ( _NUM , result ) ; result . append ( JsonBuilder . quote ( entry . getId ( ) ) ) ; result . append ( STRING ) ; toJsonEntryHelper ( entry , result , _NUM , _BOOL , _BOOL ) ; notTheFirst = _BOOL ; } result . append ( STRING ) ; return result . toString ( ) ; }
public String toJson ( ) { StringBuilder result = new StringBuilder ( ) ; result . append ( STRING ) ; boolean notTheFirst = _BOOL ; List < ? > entries = getAllParentlessEntries ( ) ; for ( Object entryUncasted : entries ) { Entry entry = ( Entry ) entryUncasted ; if ( notTheFirst ) { result . append ( STRING ) ; } appendIndentation ( _NUM , result ) ; result . append ( JsonBuilder . quote ( entry . getId ( ) ) ) ; result . append ( STRING ) ; toJsonEntryHelper ( entry , result , _NUM , _BOOL , _BOOL ) ; notTheFirst = _BOOL ; } result . append ( STRING ) ; return result . toString ( ) ; }
private static void writeFile ( File file , List < String > lines ) throws IOException { if ( ! file . exists ( ) ) file . createNewFile ( ) ; FileWriter fw = new FileWriter ( file ) ; BufferedWriter Bw = new BufferedWriter ( fw ) ; PrintWriter pw = new PrintWriter ( Bw ) ; for ( String line : lines ) pw . println ( line ) ; Bw . close ( ) ; fw . close ( ) ; pw . close ( ) ; }
public void removeMouseMode ( String id ) { for ( MapMouseMode med : mouseModes ) { if ( id . equals ( med . getID ( ) ) ) { removeMouseMode ( med ) ; break ; } } }
public void removeMouseMode ( String id ) { for ( MapMouseMode med : mouseModes ) { if ( id . equals ( med . getID ( ) ) ) { removeMouseMode ( med ) ; break ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
public void calculateDerived ( ) { mean = Double . NaN ; stdDev = Double . NaN ; if ( count > _NUM ) { mean = sum / count ; stdDev = Double . POSITIVE_INFINITY ; if ( count > _NUM ) { stdDev = sumSq - ( sum * sum ) / count ; stdDev /= ( count - _NUM ) ; if ( stdDev < _NUM ) { stdDev = _NUM ; } stdDev = Math . sqrt ( stdDev ) ; } } }
private void weightedMedian ( int iteration , mxGraphHierarchyModel model ) { boolean downwardSweep = ( iteration % _NUM == _NUM ) ; if ( downwardSweep ) { for ( int j = model . maxRank - _NUM ; j >= _NUM ; j -- ) { medianRank ( j , downwardSweep ) ; } } else { for ( int j = _NUM ; j < model . maxRank ; j ++ ) { medianRank ( j , downwardSweep ) ; } } }
public Vector ( double comp [ ] ) throws NegativeArraySizeException { int n = comp . length ; if ( n <= _NUM ) throw new NegativeArraySizeException ( STRING ) ; components = new double [ n ] ; System . arraycopy ( comp , _NUM , components , _NUM , n ) ; }
public static SortedSet < String > extractOutcomeLabelsFromFeatureVectorFiles ( File ... files ) throws IOException { SortedSet < String > result = new TreeSet < > ( ) ; for ( File file : files ) { result . addAll ( extractOutcomeLabels ( file ) ) ; } return result ; }
private void displayPopupMenu ( final MouseEvent event ) { final int selectedIndex = getSelectionIndex ( event ) ; if ( selectedIndex != - _NUM ) { final JPopupMenu popupMenu = getPopupMenu ( event . getX ( ) , event . getY ( ) , selectedIndex ) ; if ( popupMenu != null ) { popupMenu . show ( this , event . getX ( ) , event . getY ( ) ) ; } } }
protected void addTags ( E data , Builder builder ) { PlatformIdent platformIdent = cachedDataService . getPlatformIdentForId ( data . getPlatformIdent ( ) ) ; builder . tag ( Series . TAG_AGENT_ID , String . valueOf ( data . getPlatformIdent ( ) ) ) ; if ( null != platformIdent ) { builder . tag ( Series . TAG_AGENT_NAME , platformIdent . getAgentName ( ) ) ; } }
protected void addTags ( E data , Builder builder ) { PlatformIdent platformIdent = cachedDataService . getPlatformIdentForId ( data . getPlatformIdent ( ) ) ; builder . tag ( Series . TAG_AGENT_ID , String . valueOf ( data . getPlatformIdent ( ) ) ) ; if ( null != platformIdent ) { builder . tag ( Series . TAG_AGENT_NAME , platformIdent . getAgentName ( ) ) ; } }
protected void addTags ( E data , Builder builder ) { PlatformIdent platformIdent = cachedDataService . getPlatformIdentForId ( data . getPlatformIdent ( ) ) ; builder . tag ( Series . TAG_AGENT_ID , String . valueOf ( data . getPlatformIdent ( ) ) ) ; if ( null != platformIdent ) { builder . tag ( Series . TAG_AGENT_NAME , platformIdent . getAgentName ( ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ _NUM ] ; ObjectMapper mapper = new ObjectMapper ( ) ; try { argMap = mapper . readValue ( temp [ _NUM ] , new TypeReference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { ConsoleUtils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . onNext ( createObservable ( marble ) ) ; } else { ps . onNext ( createHotObservable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ _NUM ] ; ObjectMapper mapper = new ObjectMapper ( ) ; try { argMap = mapper . readValue ( temp [ _NUM ] , new TypeReference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { ConsoleUtils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . onNext ( createObservable ( marble ) ) ; } else { ps . onNext ( createHotObservable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ _NUM ] ; ObjectMapper mapper = new ObjectMapper ( ) ; try { argMap = mapper . readValue ( temp [ _NUM ] , new TypeReference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { ConsoleUtils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . onNext ( createObservable ( marble ) ) ; } else { ps . onNext ( createHotObservable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ _NUM ] ; ObjectMapper mapper = new ObjectMapper ( ) ; try { argMap = mapper . readValue ( temp [ _NUM ] , new TypeReference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { ConsoleUtils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . onNext ( createObservable ( marble ) ) ; } else { ps . onNext ( createHotObservable ( marble ) ) ; } }
public void add ( String marble ) { if ( marble . contains ( STRING ) ) { String [ ] temp = marble . split ( STRING ) ; marble = temp [ _NUM ] ; ObjectMapper mapper = new ObjectMapper ( ) ; try { argMap = mapper . readValue ( temp [ _NUM ] , new TypeReference < Map < String , Map < String , String > > > ( ) { } ) ; } catch ( Exception e ) { ConsoleUtils . error ( STRING ) ; } } if ( marble . contains ( STRING ) || marble . contains ( STRING ) ) { ps . onNext ( createObservable ( marble ) ) ; } else { ps . onNext ( createHotObservable ( marble ) ) ; } }
public Projection create ( Properties props ) throws ProjectionException { try { LatLonPoint llp = convertToLLP ( ( Point2D ) props . get ( ProjectionFactory . CENTER ) ) ; float scale = PropUtils . floatFromProperties ( props , ProjectionFactory . SCALE , _NUM ) ; int height = PropUtils . intFromProperties ( props , ProjectionFactory . HEIGHT , _NUM ) ; int width = PropUtils . intFromProperties ( props , ProjectionFactory . WIDTH , _NUM ) ; double central_meridian = PropUtils . doubleFromProperties ( props , CentralMeridianProperty , centralMeridian ) ; double sp_one = PropUtils . doubleFromProperties ( props , StandardParallelOneProperty , standardParallel1 ) ; double sp_two = PropUtils . doubleFromProperties ( props , StandardParallelTwoProperty , standardParallel2 ) ; double rl = PropUtils . doubleFromProperties ( props , ReferenceLatitudeProperty , referenceLatitude ) ; double fe = PropUtils . doubleFromProperties ( props , FalseEastingProperty , falseEasting ) ; double fn = PropUtils . doubleFromProperties ( props , FalseNorthingProperty , falseNorthing ) ; Ellipsoid ellps = ( Ellipsoid ) props . get ( ProjectionFactory . DATUM ) ; return new LambertConformal ( llp , scale , width , height , central_meridian , sp_one , sp_two , rl , fe , fn , ellps ) ; } catch ( Exception e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + e . getMessage ( ) ) ; } } throw new ProjectionException ( STRING ) ; }
public Projection create ( Properties props ) throws ProjectionException { try { LatLonPoint llp = convertToLLP ( ( Point2D ) props . get ( ProjectionFactory . CENTER ) ) ; float scale = PropUtils . floatFromProperties ( props , ProjectionFactory . SCALE , _NUM ) ; int height = PropUtils . intFromProperties ( props , ProjectionFactory . HEIGHT , _NUM ) ; int width = PropUtils . intFromProperties ( props , ProjectionFactory . WIDTH , _NUM ) ; double central_meridian = PropUtils . doubleFromProperties ( props , CentralMeridianProperty , centralMeridian ) ; double sp_one = PropUtils . doubleFromProperties ( props , StandardParallelOneProperty , standardParallel1 ) ; double sp_two = PropUtils . doubleFromProperties ( props , StandardParallelTwoProperty , standardParallel2 ) ; double rl = PropUtils . doubleFromProperties ( props , ReferenceLatitudeProperty , referenceLatitude ) ; double fe = PropUtils . doubleFromProperties ( props , FalseEastingProperty , falseEasting ) ; double fn = PropUtils . doubleFromProperties ( props , FalseNorthingProperty , falseNorthing ) ; Ellipsoid ellps = ( Ellipsoid ) props . get ( ProjectionFactory . DATUM ) ; return new LambertConformal ( llp , scale , width , height , central_meridian , sp_one , sp_two , rl , fe , fn , ellps ) ; } catch ( Exception e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING + e . getMessage ( ) ) ; } } throw new ProjectionException ( STRING ) ; }
public synchronized void writeTo ( final OutputStream out ) throws IOException { int remaining = this . count ; for ( byte [ ] buf : this . buffers ) { int c = Math . min ( buf . length , remaining ) ; out . write ( buf , _NUM , c ) ; remaining -= c ; if ( remaining == _NUM ) { break ; } } }
public Location ( double latitude , double longitude , int xOffset , int yOffset , String name , OMGraphic locationMarker ) { setLocation ( latitude , longitude , xOffset , yOffset ) ; this . name = name ; if ( logger . isLoggable ( Level . FINER ) ) { logger . finer ( STRING + latitude + STRING + longitude + STRING + x + STRING + y + STRING + name + STRING ) ; } if ( locationMarker == null ) { location = new OMPoint ( lat , lon , xOffset , yOffset ) ; } else { location = locationMarker ; } label = new OMText ( lat , lon , xOffset , yOffset , name , OMText . JUSTIFY_LEFT ) ; }
public static void unbindReferences ( View view ) { try { if ( view != null ) { view . destroyDrawingCache ( ) ; unbindViewReferences ( view ) ; if ( view instanceof ViewGroup ) { unbindViewGroupReferences ( ( ViewGroup ) view ) ; } } } catch ( Throwable e ) { } }
private void updateBackendVolume ( BlockConsistencyGroup cg , Volume backendVolume , DbClient dbClient ) { if ( backendVolume != null ) { String backendCG = cg . getCgNameOnStorageSystem ( backendVolume . getStorageController ( ) ) ; if ( backendCG != null && ! backendCG . isEmpty ( ) ) { log . info ( STRING , backendVolume . getLabel ( ) , backendCG ) ; backendVolume . setReplicationGroupInstance ( backendCG ) ; dbClient . updateObject ( backendVolume ) ; } } }
public void testPurge ( ) throws Exception { List < MemoryFile > files = new ArrayList < MemoryFile > ( ) ; try { while ( _BOOL ) { MemoryFile newFile = new MemoryFile ( STRING , _NUM ) ; newFile . allowPurging ( _BOOL ) ; newFile . writeBytes ( testString , _NUM , _NUM , testString . length ) ; files . add ( newFile ) ; for ( MemoryFile file : files ) { try { file . readBytes ( testString , _NUM , _NUM , testString . length ) ; } catch ( IOException e ) { return ; } } } } finally { for ( MemoryFile fileToClose : files ) { fileToClose . close ( ) ; } } }
public void testPurge ( ) throws Exception { List < MemoryFile > files = new ArrayList < MemoryFile > ( ) ; try { while ( _BOOL ) { MemoryFile newFile = new MemoryFile ( STRING , _NUM ) ; newFile . allowPurging ( _BOOL ) ; newFile . writeBytes ( testString , _NUM , _NUM , testString . length ) ; files . add ( newFile ) ; for ( MemoryFile file : files ) { try { file . readBytes ( testString , _NUM , _NUM , testString . length ) ; } catch ( IOException e ) { return ; } } } } finally { for ( MemoryFile fileToClose : files ) { fileToClose . close ( ) ; } } }
public static List < String > changeCase ( List < String > list ) { if ( list != null ) { List < String > result = new ArrayList < String > ( ) ; for ( String element : list ) { result . add ( changeCase ( element ) ) ; } return result ; } return null ; }
public static List < String > changeCase ( List < String > list ) { if ( list != null ) { List < String > result = new ArrayList < String > ( ) ; for ( String element : list ) { result . add ( changeCase ( element ) ) ; } return result ; } return null ; }
public static List < String > changeCase ( List < String > list ) { if ( list != null ) { List < String > result = new ArrayList < String > ( ) ; for ( String element : list ) { result . add ( changeCase ( element ) ) ; } return result ; } return null ; }
public static List < String > changeCase ( List < String > list ) { if ( list != null ) { List < String > result = new ArrayList < String > ( ) ; for ( String element : list ) { result . add ( changeCase ( element ) ) ; } return result ; } return null ; }
public static List < String > changeCase ( List < String > list ) { if ( list != null ) { List < String > result = new ArrayList < String > ( ) ; for ( String element : list ) { result . add ( changeCase ( element ) ) ; } return result ; } return null ; }
public static < T > DelayedActionQueue < T > create ( DelayedActionListener < T > listener , long delay ) { DelayedActionQueue < T > q = new DelayedActionQueue < > ( listener , delay ) ; q . start ( ) ; return q ; }
public PlainSaslAuthenticator ( final Vertx vertx ) { this . vertx = Objects . requireNonNull ( vertx ) ; }
public void addAll ( T [ ] items ) { if ( mEventDelegate != null ) mEventDelegate . addData ( items == null ? _NUM : items . length ) ; if ( items != null && items . length != _NUM ) { synchronized ( mLock ) { Collections . addAll ( mObjects , items ) ; } } int dataCount = items == null ? _NUM : items . length ; if ( mObserver != null ) mObserver . onItemRangeInserted ( getCount ( ) - dataCount + _NUM , dataCount ) ; if ( mNotifyOnChange ) notifyItemRangeInserted ( headers . size ( ) + getCount ( ) - dataCount + _NUM , dataCount ) ; log ( STRING + ( ( headers . size ( ) + getCount ( ) - dataCount + _NUM ) + STRING + ( dataCount ) ) ) ; }
public void addAll ( T [ ] items ) { if ( mEventDelegate != null ) mEventDelegate . addData ( items == null ? _NUM : items . length ) ; if ( items != null && items . length != _NUM ) { synchronized ( mLock ) { Collections . addAll ( mObjects , items ) ; } } int dataCount = items == null ? _NUM : items . length ; if ( mObserver != null ) mObserver . onItemRangeInserted ( getCount ( ) - dataCount + _NUM , dataCount ) ; if ( mNotifyOnChange ) notifyItemRangeInserted ( headers . size ( ) + getCount ( ) - dataCount + _NUM , dataCount ) ; log ( STRING + ( ( headers . size ( ) + getCount ( ) - dataCount + _NUM ) + STRING + ( dataCount ) ) ) ; }
public static void writeResultFile ( String filename , Map < String , List < QueryResponseJSON > > resultMap ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( filename ) ) ) ) { for ( Entry < String , List < QueryResponseJSON > > entry : resultMap . entrySet ( ) ) { for ( QueryResponseJSON hitJSON : entry . getValue ( ) ) { bw . write ( hitJSON . getJSONString ( ) ) ; bw . newLine ( ) ; } } } }
public static void writeResultFile ( String filename , Map < String , List < QueryResponseJSON > > resultMap ) throws IOException { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( new File ( filename ) ) ) ) { for ( Entry < String , List < QueryResponseJSON > > entry : resultMap . entrySet ( ) ) { for ( QueryResponseJSON hitJSON : entry . getValue ( ) ) { bw . write ( hitJSON . getJSONString ( ) ) ; bw . newLine ( ) ; } } } }
protected void startDownload ( int blocks ) { if ( blocks > _NUM ) log . info ( STRING + blocks + STRING + ( blocks > _NUM ? STRING : STRING ) ) ; }
private static void checkPermission ( ) throws SecurityException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING ) ) ; } }
void addChildLink ( HTMLLink childLink ) { if ( childLinks == null ) { childLinks = new Vector ( ) ; } childLinks . addElement ( childLink ) ; }
static final int advanceProbe ( int probe ) { probe ^= probe << _NUM ; probe ^= probe > > > _NUM ; probe ^= probe << _NUM ; UNSAFE . putInt ( Thread . currentThread ( ) , PROBE , probe ) ; return probe ; }
public static Packet toPacket ( byte [ ] octets ) { int packetLen = octets [ _NUM ] & _NUM ; packetLen |= ( ( octets [ _NUM ] << _NUM ) & _NUM ) ; return toPacket ( ByteBuffer . wrap ( octets , _NUM , packetLen ) ) ; }
public void removeDefaultValue ( String value ) throws SMSException , SSOException { Set defaultValues = getDefaultValues ( ) ; if ( defaultValues != Collections . EMPTY_SET ) { defaultValues . remove ( value ) ; updateDefaultValues ( defaultValues ) ; } }
public CResultsTableModel ( final Object [ ] [ ] data , final String [ ] columnNames ) { super ( data , columnNames ) ; }
public void addStringToTable ( final byte [ ] oldString , final byte newString ) { final int length = oldString . length ; final byte [ ] string = new byte [ length + _NUM ] ; System . arraycopy ( oldString , _NUM , string , _NUM , length ) ; string [ length ] = newString ; addStringToTable ( string ) ; }
static boolean isExist ( String libName , int version ) { String file = _targetSoFile ( libName , version ) ; File a = new File ( file ) ; return a . exists ( ) ; }
public ForumPostConfig update ( ForumPostConfig config ) { config . addCredentials ( this ) ; String xml = POST ( this . url + STRING , config . toXML ( ) ) ; Element root = parse ( xml ) ; if ( root == null ) { return null ; } try { config = new ForumPostConfig ( ) ; config . parseXML ( root ) ; return config ; } catch ( Exception exception ) { this . exception = SDKException . parseFailure ( exception ) ; throw this . exception ; } }
public synchronized void removeListener ( Object listener ) { if ( listeners != null ) { listeners . remove ( listener ) ; } }
private void loadTranslationsCacheIfEmpty ( ) { if ( translationCache . isEmpty ( ) ) { for ( ObjectTranslation translation : translations ) { if ( translation . getLocale ( ) != null && translation . getProperty ( ) != null && ! StringUtils . isEmpty ( translation . getValue ( ) ) ) { String key = ObjectTranslation . getCacheKey ( translation . getLocale ( ) , translation . getProperty ( ) ) ; translationCache . put ( key , translation . getValue ( ) ) ; } } } }
public static List < String > readLines ( File file ) throws IOException { return readLines ( file , Charset . defaultCharset ( ) ) ; }
public static List < String > readLines ( File file ) throws IOException { return readLines ( file , Charset . defaultCharset ( ) ) ; }
private RecordBuffer < R > onTakeSuccess ( RecordBuffer < R > buffer , long elapsed ) { queuedRecords -= buffer . sizeRecords ( ) ; queuedBytes -= buffer . sizeBytesWithOverhead ( ) ; checkPendingRecords ( ) ; totalTakenBuffers . incrementAndGet ( ) ; notFull . signal ( ) ; return buffer ; }
private RecordBuffer < R > onTakeSuccess ( RecordBuffer < R > buffer , long elapsed ) { queuedRecords -= buffer . sizeRecords ( ) ; queuedBytes -= buffer . sizeBytesWithOverhead ( ) ; checkPendingRecords ( ) ; totalTakenBuffers . incrementAndGet ( ) ; notFull . signal ( ) ; return buffer ; }
private RecordBuffer < R > onTakeSuccess ( RecordBuffer < R > buffer , long elapsed ) { queuedRecords -= buffer . sizeRecords ( ) ; queuedBytes -= buffer . sizeBytesWithOverhead ( ) ; checkPendingRecords ( ) ; totalTakenBuffers . incrementAndGet ( ) ; notFull . signal ( ) ; return buffer ; }
public ScriptBuilder data ( byte [ ] data ) { if ( data . length == _NUM ) return smallNum ( _NUM ) ; else return data ( chunks . size ( ) , data ) ; }
public ScriptBuilder data ( byte [ ] data ) { if ( data . length == _NUM ) return smallNum ( _NUM ) ; else return data ( chunks . size ( ) , data ) ; }
private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , Float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - _NUM ; r >= _NUM ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == _NUM ) continue ; int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) continue ; int rowSize = _NUM ; int sIx = ( r << _NUM ) + _NUM ; int len = Math . min ( ( group . span << _NUM ) , fss . sizes . length - sIx ) - _NUM ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) rowSize += sz ; } if ( rowSize < cSize && len > _NUM ) { for ( int eagerness = _NUM , newRowSize = _NUM ; eagerness < _NUM && newRowSize < cSize ; eagerness ++ ) newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } }
private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , Float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - _NUM ; r >= _NUM ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == _NUM ) continue ; int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) continue ; int rowSize = _NUM ; int sIx = ( r << _NUM ) + _NUM ; int len = Math . min ( ( group . span << _NUM ) , fss . sizes . length - sIx ) - _NUM ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) rowSize += sz ; } if ( rowSize < cSize && len > _NUM ) { for ( int eagerness = _NUM , newRowSize = _NUM ; eagerness < _NUM && newRowSize < cSize ; eagerness ++ ) newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } }
private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , Float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - _NUM ; r >= _NUM ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == _NUM ) continue ; int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) continue ; int rowSize = _NUM ; int sIx = ( r << _NUM ) + _NUM ; int len = Math . min ( ( group . span << _NUM ) , fss . sizes . length - sIx ) - _NUM ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) rowSize += sz ; } if ( rowSize < cSize && len > _NUM ) { for ( int eagerness = _NUM , newRowSize = _NUM ; eagerness < _NUM && newRowSize < cSize ; eagerness ++ ) newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } }
private void adjustMinPrefForSpanningComps ( DimConstraint [ ] specs , Float [ ] defPush , FlowSizeSpec fss , ArrayList < LinkedDimGroup > [ ] groupsLists ) { for ( int r = groupsLists . length - _NUM ; r >= _NUM ; r -- ) { ArrayList < LinkedDimGroup > groups = groupsLists [ r ] ; for ( LinkedDimGroup group : groups ) { if ( group . span == _NUM ) continue ; int [ ] sizes = group . getMinPrefMax ( ) ; for ( int s = LayoutUtil . MIN ; s <= LayoutUtil . PREF ; s ++ ) { int cSize = sizes [ s ] ; if ( cSize == LayoutUtil . NOT_SET ) continue ; int rowSize = _NUM ; int sIx = ( r << _NUM ) + _NUM ; int len = Math . min ( ( group . span << _NUM ) , fss . sizes . length - sIx ) - _NUM ; for ( int j = sIx ; j < sIx + len ; j ++ ) { int sz = fss . sizes [ j ] [ s ] ; if ( sz != LayoutUtil . NOT_SET ) rowSize += sz ; } if ( rowSize < cSize && len > _NUM ) { for ( int eagerness = _NUM , newRowSize = _NUM ; eagerness < _NUM && newRowSize < cSize ; eagerness ++ ) newRowSize = fss . expandSizes ( specs , defPush , cSize , sIx , len , s , eagerness ) ; } } } } }
public void removeMapping ( String virtual ) throws ExpressionException , SecurityException { checkWriteAccess ( ) ; _removeMapping ( virtual ) ; }
public void optimize ( ) { for ( int i = operations . size ( ) - _NUM ; i >= _NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof ClearOperation ) { while ( i > _NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public void optimize ( ) { for ( int i = operations . size ( ) - _NUM ; i >= _NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof ClearOperation ) { while ( i > _NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public void optimize ( ) { for ( int i = operations . size ( ) - _NUM ; i >= _NUM ; i -- ) { Operation o = operations . get ( i ) ; if ( o instanceof ClearOperation ) { while ( i > _NUM ) { operations . remove ( i ) ; i -- ; } return ; } } }
public MsrpSession createMsrpClientSession ( String remoteHost , int remotePort , String remoteMsrpPath , MsrpEventListener listener , String fingerprint ) { if ( logger . isActivated ( ) ) { logger . info ( STRING + remoteHost + STRING + remotePort ) ; } mMsrpSession = new MsrpSession ( mRcsSettings ) ; mMsrpSession . setFrom ( getLocalMsrpPath ( ) ) ; mMsrpSession . setTo ( remoteMsrpPath ) ; MsrpConnection connection = new MsrpClientConnection ( mMsrpSession , remoteHost , remotePort , mSecured , fingerprint ) ; mMsrpSession . setConnection ( connection ) ; mMsrpSession . addMsrpEventListener ( listener ) ; return mMsrpSession ; }
static private String INT_Max ( ) { int tempValue = Integer . MAX_VALUE ; return String . valueOf ( tempValue ) ; }
public void writeExternal ( ObjectOutput out ) throws IOException { out . writeFloat ( x ) ; out . writeFloat ( y ) ; }
@ SuppressWarnings ( STRING ) private void validateAndPopulate ( Boolean allowNonUpnFormat ) throws InvalidTokenException { JAXBElement < AssertionType > jaxbParserResult = null ; try { Unmarshaller unmarshaller = _jaxbContext . createUnmarshaller ( ) ; unmarshaller . setSchema ( SAML_SCHEMA ) ; jaxbParserResult = ( JAXBElement < AssertionType > ) unmarshaller . unmarshal ( _parsedToken ) ; } catch ( JAXBException e ) { _log . info ( PARSING_TOKEN_ERROR_MSG , e ) ; throw new MalformedTokenException ( PARSING_TOKEN_ERROR_MSG , e ) ; } AssertionType assertion = jaxbParserResult . getValue ( ) ; parseAssertionAttributes ( assertion ) ; parseConditions ( assertion . getConditions ( ) , allowNonUpnFormat ) ; parseSubject ( assertion . getSubject ( ) ) ; parseIssuer ( assertion . getIssuer ( ) ) ; parseAuthnStatement ( assertion . getAuthnStatementOrAttributeStatement ( ) ) ; if ( assertion . getAuthnStatementOrAttributeStatement ( ) != null ) { parseAttributeStatement ( assertion . getAuthnStatementOrAttributeStatement ( ) ) ; } if ( assertion . getAdvice ( ) != null ) { parseAdvice ( assertion . getAdvice ( ) ) ; } _log . debug ( STRING ) ; }
@ SuppressWarnings ( STRING ) private void validateAndPopulate ( Boolean allowNonUpnFormat ) throws InvalidTokenException { JAXBElement < AssertionType > jaxbParserResult = null ; try { Unmarshaller unmarshaller = _jaxbContext . createUnmarshaller ( ) ; unmarshaller . setSchema ( SAML_SCHEMA ) ; jaxbParserResult = ( JAXBElement < AssertionType > ) unmarshaller . unmarshal ( _parsedToken ) ; } catch ( JAXBException e ) { _log . info ( PARSING_TOKEN_ERROR_MSG , e ) ; throw new MalformedTokenException ( PARSING_TOKEN_ERROR_MSG , e ) ; } AssertionType assertion = jaxbParserResult . getValue ( ) ; parseAssertionAttributes ( assertion ) ; parseConditions ( assertion . getConditions ( ) , allowNonUpnFormat ) ; parseSubject ( assertion . getSubject ( ) ) ; parseIssuer ( assertion . getIssuer ( ) ) ; parseAuthnStatement ( assertion . getAuthnStatementOrAttributeStatement ( ) ) ; if ( assertion . getAuthnStatementOrAttributeStatement ( ) != null ) { parseAttributeStatement ( assertion . getAuthnStatementOrAttributeStatement ( ) ) ; } if ( assertion . getAdvice ( ) != null ) { parseAdvice ( assertion . getAdvice ( ) ) ; } _log . debug ( STRING ) ; }
private void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , _BOOL ) ; }
private void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , _BOOL ) ; }
private void writeAttr ( String name , String val ) throws IOException { writeAttr ( name , val , _BOOL ) ; }
@ Synchronized ( STRING ) @ SuppressWarnings ( STRING ) public C createChannel ( @ NonNull String name ) { C chan = ( C ) botFactory . createChannel ( bot , name ) ; channelNameMap . put ( name . toLowerCase ( locale ) , chan ) ; return chan ; }
@ Synchronized ( STRING ) @ SuppressWarnings ( STRING ) public C createChannel ( @ NonNull String name ) { C chan = ( C ) botFactory . createChannel ( bot , name ) ; channelNameMap . put ( name . toLowerCase ( locale ) , chan ) ; return chan ; }
public int addJSON ( JSONObject j , Table table ) { if ( ! mDb . belowMemThreshold ( ) ) { Log . e ( LOGTAG , STRING ) ; return DB_OUT_OF_MEMORY_ERROR ; } final String tableName = table . getName ( ) ; Cursor c = null ; int count = DB_UPDATE_ERROR ; synchronized ( mDb ) { try { final SQLiteDatabase db = mDb . getWritableDatabase ( ) ; final ContentValues cv = new ContentValues ( ) ; cv . put ( KEY_DATA , j . toString ( ) ) ; cv . put ( KEY_CREATED_AT , System . currentTimeMillis ( ) ) ; db . insert ( tableName , null , cv ) ; c = db . rawQuery ( STRING + tableName , null ) ; c . moveToFirst ( ) ; count = c . getInt ( _NUM ) ; } catch ( final SQLiteException e ) { Log . e ( LOGTAG , STRING + tableName + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } initDB ( ) ; } catch ( final IllegalStateException e ) { Log . e ( LOGTAG , STRING + tableName + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } initDB ( ) ; } finally { if ( c != null ) { c . close ( ) ; } mDb . close ( ) ; } } return count ; }
public int addJSON ( JSONObject j , Table table ) { if ( ! mDb . belowMemThreshold ( ) ) { Log . e ( LOGTAG , STRING ) ; return DB_OUT_OF_MEMORY_ERROR ; } final String tableName = table . getName ( ) ; Cursor c = null ; int count = DB_UPDATE_ERROR ; synchronized ( mDb ) { try { final SQLiteDatabase db = mDb . getWritableDatabase ( ) ; final ContentValues cv = new ContentValues ( ) ; cv . put ( KEY_DATA , j . toString ( ) ) ; cv . put ( KEY_CREATED_AT , System . currentTimeMillis ( ) ) ; db . insert ( tableName , null , cv ) ; c = db . rawQuery ( STRING + tableName , null ) ; c . moveToFirst ( ) ; count = c . getInt ( _NUM ) ; } catch ( final SQLiteException e ) { Log . e ( LOGTAG , STRING + tableName + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } initDB ( ) ; } catch ( final IllegalStateException e ) { Log . e ( LOGTAG , STRING + tableName + STRING , e ) ; if ( c != null ) { c . close ( ) ; c = null ; } initDB ( ) ; } finally { if ( c != null ) { c . close ( ) ; } mDb . close ( ) ; } } return count ; }
@ RequiresPermission ( PERMISSION ) @ Override public boolean requestSend ( ) { Activity activity = mActivity . get ( ) ; if ( activity == null ) return _BOOL ; if ( Log . isLoggable ( Log . VERBOSE ) ) Log . v ( STRING ) ; if ( checkSelfPermission ( activity , PERMISSION ) != PackageManager . PERMISSION_GRANTED ) { requestPermissions ( activity , new String [ ] { PERMISSION } , PERMISSION_REQUEST_CODE ) ; return _BOOL ; } return getFreshLocation ( new SenderLocationListener ( this ) ) ; }
public synchronized void stop ( ) throws NoSuchObjectException { if ( isRunning ( ) ) { isRunning = ! UnicastRemoteObject . unexportObject ( registry , _BOOL ) ; } }
public synchronized void stop ( ) throws NoSuchObjectException { if ( isRunning ( ) ) { isRunning = ! UnicastRemoteObject . unexportObject ( registry , _BOOL ) ; } }
public synchronized void stop ( ) throws NoSuchObjectException { if ( isRunning ( ) ) { isRunning = ! UnicastRemoteObject . unexportObject ( registry , _BOOL ) ; } }
void findClassesDerivingFrom ( String super_name , Map < String , ClassReader > zipClasses , Map < String , ClassReader > inOutFound ) throws LogAbortException { ClassReader super_clazz = findClass ( super_name , zipClasses , inOutFound ) ; for ( Entry < String , ClassReader > entry : zipClasses . entrySet ( ) ) { String className = entry . getKey ( ) ; if ( super_name . equals ( className ) ) { continue ; } ClassReader classReader = entry . getValue ( ) ; ClassReader parent_cr = classReader ; while ( parent_cr != null ) { String parent_name = internalToBinaryClassName ( parent_cr . getSuperName ( ) ) ; if ( parent_name == null ) { break ; } else if ( super_name . equals ( parent_name ) ) { inOutFound . put ( className , classReader ) ; break ; } parent_cr = zipClasses . get ( parent_name ) ; } } }
void findClassesDerivingFrom ( String super_name , Map < String , ClassReader > zipClasses , Map < String , ClassReader > inOutFound ) throws LogAbortException { ClassReader super_clazz = findClass ( super_name , zipClasses , inOutFound ) ; for ( Entry < String , ClassReader > entry : zipClasses . entrySet ( ) ) { String className = entry . getKey ( ) ; if ( super_name . equals ( className ) ) { continue ; } ClassReader classReader = entry . getValue ( ) ; ClassReader parent_cr = classReader ; while ( parent_cr != null ) { String parent_name = internalToBinaryClassName ( parent_cr . getSuperName ( ) ) ; if ( parent_name == null ) { break ; } else if ( super_name . equals ( parent_name ) ) { inOutFound . put ( className , classReader ) ; break ; } parent_cr = zipClasses . get ( parent_name ) ; } } }
void findClassesDerivingFrom ( String super_name , Map < String , ClassReader > zipClasses , Map < String , ClassReader > inOutFound ) throws LogAbortException { ClassReader super_clazz = findClass ( super_name , zipClasses , inOutFound ) ; for ( Entry < String , ClassReader > entry : zipClasses . entrySet ( ) ) { String className = entry . getKey ( ) ; if ( super_name . equals ( className ) ) { continue ; } ClassReader classReader = entry . getValue ( ) ; ClassReader parent_cr = classReader ; while ( parent_cr != null ) { String parent_name = internalToBinaryClassName ( parent_cr . getSuperName ( ) ) ; if ( parent_name == null ) { break ; } else if ( super_name . equals ( parent_name ) ) { inOutFound . put ( className , classReader ) ; break ; } parent_cr = zipClasses . get ( parent_name ) ; } } }
public CreateRequest ( ContentFormat contentFormat , int objectId , Collection < LwM2mResource > resources ) { this ( contentFormat , objectId , resources . toArray ( new LwM2mResource [ resources . size ( ) ] ) ) ; }
private static void savePgr ( DispatchContext dctx , GenericValue pgr ) { Map < String , GenericValue > context = UtilMisc . < String , GenericValue > toMap ( STRING , pgr ) ; LocalDispatcher dispatcher = dctx . getDispatcher ( ) ; Delegator delegator = dctx . getDelegator ( ) ; try { dispatcher . addRollbackService ( STRING , context , _BOOL ) ; delegator . create ( pgr ) ; } catch ( Exception e ) { Debug . logError ( e , module ) ; } }
public void addImportedFiles ( File xmlFile ) { if ( xmlFile . exists ( ) ) { importedFiles . add ( xmlFile ) ; } else { importedFiles . add ( new File ( STRING + xmlFile ) ) ; } }
public static Transaction roundTripTransaction ( NetworkParameters params , Transaction tx ) throws IOException , ProtocolException { BitcoinSerializer bs = new BitcoinSerializer ( params ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( ByteBuffer . wrap ( bos . toByteArray ( ) ) ) ; }
public static Transaction roundTripTransaction ( NetworkParameters params , Transaction tx ) throws IOException , ProtocolException { BitcoinSerializer bs = new BitcoinSerializer ( params ) ; ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; bs . serialize ( tx , bos ) ; return ( Transaction ) bs . deserialize ( ByteBuffer . wrap ( bos . toByteArray ( ) ) ) ; }
private static void fill ( DTSweepContext tcx , AdvancingFrontNode node ) { DelaunayTriangle triangle = new DelaunayTriangle ( node . prev . point , node . point , node . next . point ) ; triangle . markNeighbor ( node . prev . triangle ) ; triangle . markNeighbor ( node . triangle ) ; tcx . addToList ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . removeNode ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . mapTriangleToNodes ( triangle ) ; } }
private static void fill ( DTSweepContext tcx , AdvancingFrontNode node ) { DelaunayTriangle triangle = new DelaunayTriangle ( node . prev . point , node . point , node . next . point ) ; triangle . markNeighbor ( node . prev . triangle ) ; triangle . markNeighbor ( node . triangle ) ; tcx . addToList ( triangle ) ; node . prev . next = node . next ; node . next . prev = node . prev ; tcx . removeNode ( node ) ; if ( ! legalize ( tcx , triangle ) ) { tcx . mapTriangleToNodes ( triangle ) ; } }
public IntStreamEx remove ( IntPredicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public IntStreamEx remove ( IntPredicate predicate ) { return filter ( predicate . negate ( ) ) ; }
public static String extractHostId ( String hostId ) { AssertUtil . assertNotNull ( hostId , STRING ) ; int idx = hostId . indexOf ( HOST_ID_TENANT_SEPARATOR ) ; String id = hostId ; if ( idx != - _NUM ) { id = hostId . substring ( idx + HOST_ID_TENANT_SEPARATOR . length ( ) ) ; } return id ; }
public void remove ( Predicate filter ) { for ( IntIterator ii = rows ( filter ) ; ii . hasNext ( ) ; ) removeRow ( ii . nextInt ( ) ) ; }
public void remove ( Predicate filter ) { for ( IntIterator ii = rows ( filter ) ; ii . hasNext ( ) ; ) removeRow ( ii . nextInt ( ) ) ; }
public void hasValidAnnotations ( ) { assertThatAnnotatedClassHasValidI18n ( ) ; assertThatAnnotatedClassHasAnnotatedMethods ( ) ; assertThatAllSchemasAreValid ( ) ; }
public void hasValidAnnotations ( ) { assertThatAnnotatedClassHasValidI18n ( ) ; assertThatAnnotatedClassHasAnnotatedMethods ( ) ; assertThatAllSchemasAreValid ( ) ; }
public void hasValidAnnotations ( ) { assertThatAnnotatedClassHasValidI18n ( ) ; assertThatAnnotatedClassHasAnnotatedMethods ( ) ; assertThatAllSchemasAreValid ( ) ; }
public void hasValidAnnotations ( ) { assertThatAnnotatedClassHasValidI18n ( ) ; assertThatAnnotatedClassHasAnnotatedMethods ( ) ; assertThatAllSchemasAreValid ( ) ; }
private ClassSignature loadClassFromJigsaw ( String classname ) throws IOException { if ( method_Class_getModule == null || method_Module_getName == null ) { return null ; } final Class < ? > clazz ; final String moduleName ; try { clazz = Class . forName ( classname , _BOOL , loader ) ; final Object module = method_Class_getModule . invoke ( clazz ) ; moduleName = ( String ) method_Module_getName . invoke ( module ) ; } catch ( Exception e ) { return null ; } return new ClassSignature ( clazz , AsmUtils . isRuntimeModule ( moduleName ) ) ; }
public final V updateAndGet ( UnaryOperator < V > updateFunction ) { V prev , next ; do { prev = get ( ) ; next = updateFunction . apply ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final V updateAndGet ( UnaryOperator < V > updateFunction ) { V prev , next ; do { prev = get ( ) ; next = updateFunction . apply ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final V updateAndGet ( UnaryOperator < V > updateFunction ) { V prev , next ; do { prev = get ( ) ; next = updateFunction . apply ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
public final V updateAndGet ( UnaryOperator < V > updateFunction ) { V prev , next ; do { prev = get ( ) ; next = updateFunction . apply ( prev ) ; } while ( ! compareAndSet ( prev , next ) ) ; return next ; }
protected void updatePorts ( ) { if ( ! isChanging ) { isChanging = _BOOL ; boolean first = _BOOL ; T foundDisconnected = null ; Iterator < T > i = managedPorts . iterator ( ) ; while ( i . hasNext ( ) ) { T port = i . next ( ) ; if ( ! port . isConnected ( ) && ! port . isLocked ( ) ) { if ( first ) { foundDisconnected = port ; first = _BOOL ; } else { if ( minNumber == _NUM ) { deletePort ( port ) ; i . remove ( ) ; } } } } if ( ( foundDisconnected == null ) || ( managedPorts . size ( ) < minNumber ) ) { do { managedPorts . add ( createPort ( ) ) ; } while ( managedPorts . size ( ) < minNumber ) ; } else { if ( minNumber == _NUM ) { managedPorts . remove ( foundDisconnected ) ; managedPorts . add ( foundDisconnected ) ; ports . pushDown ( foundDisconnected ) ; } } fixNames ( ) ; isChanging = _BOOL ; } }
void addToEmebeddedCSS ( CSSElement cssElement ) { if ( embeddedCSS == null ) { embeddedCSS = new Vector ( ) ; } embeddedCSS . addElement ( cssElement ) ; }
void addToEmebeddedCSS ( CSSElement cssElement ) { if ( embeddedCSS == null ) { embeddedCSS = new Vector ( ) ; } embeddedCSS . addElement ( cssElement ) ; }
void addToEmebeddedCSS ( CSSElement cssElement ) { if ( embeddedCSS == null ) { embeddedCSS = new Vector ( ) ; } embeddedCSS . addElement ( cssElement ) ; }
String binaryToInternalClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
String binaryToInternalClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
String binaryToInternalClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
String binaryToInternalClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
String binaryToInternalClassName ( String className ) { if ( className == null ) { return null ; } else { return className . replace ( STRING , STRING ) ; } }
protected void processViewEvents ( SourcePrinter printer ) { processHistoryChangedEvt ( printer ) ; processClosingEvt ( printer ) ; processCloseEvt ( printer ) ; processResizedEvt ( printer ) ; processLoadEvt ( printer ) ; processUnloadEvt ( printer ) ; processActivateEvt ( printer ) ; processDeactivateEvt ( printer ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public void interrupt ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) { t . interrupt ( ) ; } m_threadVar . clear ( ) ; }
public static SearchPattern createOrPattern ( SearchPattern leftPattern , SearchPattern rightPattern ) { return new OrPattern ( leftPattern , rightPattern ) ; }
public static SearchPattern createOrPattern ( SearchPattern leftPattern , SearchPattern rightPattern ) { return new OrPattern ( leftPattern , rightPattern ) ; }
@ Override public void endCDATA ( ) throws IOException { closeStartIfNecessary ( ) ; writer . write ( STRING ) ; writingCdata = _BOOL ; }
private static byte [ ] expand ( byte [ ] d ) { Inflater inflater = new Inflater ( ) ; inflater . setInput ( d ) ; ByteArrayOutputStream out = new ByteArrayOutputStream ( d . length ) ; byte [ ] buffer = new byte [ _NUM ] ; try { while ( ! inflater . finished ( ) ) { int count = inflater . inflate ( buffer ) ; out . write ( buffer , _NUM , count ) ; } inflater . end ( ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( e ) ; } return out . toByteArray ( ) ; }
public void clearMovingPoints ( ) { movingPoints . clear ( ) ; spriteCountLabel . setText ( Integer . toString ( movingPoints . size ( ) ) ) ; doPrepare ( ) ; stopTimer ( ) ; }
public void removeLegend ( ) { remove ( plotLegend ) ; }
public void test_encode_decode_0bits_stress ( ) { final Random r = new Random ( ) ; final TermIdEncoder encoder = new TermIdEncoder ( _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { final long v0 = r . nextLong ( ) ; if ( v0 == _NUM ) { continue ; } final long v1 = encoder . encode ( v0 ) ; final long v2 = encoder . encode2 ( v0 ) ; assertTrue ( v1 == v2 ) ; if ( v0 != v1 ) fail ( encoder , v0 , v1 ) ; } }
public static String stripPrefix ( String str , String prefix ) { return str . startsWith ( prefix ) ? str . substring ( prefix . length ( ) ) : null ; }
public static ProcessBuilder rtlSdrSnif ( String dir , String frequency , String gain , String samplerate ) { ProcessBuilder pb = new ProcessBuilder ( STRING , STRING , frequency , STRING , gain , frequency + STRING , STRING , samplerate ) ; pb . directory ( new File ( dir ) ) ; return pb ; }
public static ProcessBuilder rtlSdrSnif ( String dir , String frequency , String gain , String samplerate ) { ProcessBuilder pb = new ProcessBuilder ( STRING , STRING , frequency , STRING , gain , frequency + STRING , STRING , samplerate ) ; pb . directory ( new File ( dir ) ) ; return pb ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public String reverseWords ( String s ) { if ( s == null || s . length ( ) == _NUM ) return STRING ; String res = STRING ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { char c = s . charAt ( i ) ; if ( c == STRING ) continue ; else { StringBuilder word = new StringBuilder ( ) ; while ( i < s . length ( ) ) { c = s . charAt ( i ) ; if ( c == STRING ) break ; word . append ( c ) ; i ++ ; } res = res . length ( ) == _NUM ? word . toString ( ) : word . toString ( ) + STRING + res ; i -- ; } } return res ; }
public static boolean boolValue ( String propName , boolean dflt ) { String sysProp = getProperty ( propName ) ; return ( sysProp != null && ! sysProp . isEmpty ( ) ) ? Boolean . getBoolean ( sysProp ) : dflt ; }
public static String after ( String s , String token ) { if ( s == null ) { return null ; } int i = s . indexOf ( token ) ; if ( i == - _NUM ) { return s ; } return s . substring ( i + token . length ( ) ) ; }
public static FileFooter convertFileFooter ( List < BlockletInfoColumnar > infoList , int numCols , int [ ] cardinalities , List < ColumnSchema > columnSchemaList , SegmentProperties segmentProperties ) throws IOException { SegmentInfo segmentInfo = new SegmentInfo ( ) ; segmentInfo . setNum_cols ( columnSchemaList . size ( ) ) ; segmentInfo . setColumn_cardinalities ( CarbonUtil . convertToIntegerList ( cardinalities ) ) ; FileFooter footer = new FileFooter ( ) ; footer . setNum_rows ( getTotalNumberOfRows ( infoList ) ) ; footer . setSegment_info ( segmentInfo ) ; for ( BlockletInfoColumnar info : infoList ) { footer . addToBlocklet_index_list ( getBlockletIndex ( info ) ) ; } footer . setTable_columns ( columnSchemaList ) ; for ( BlockletInfoColumnar info : infoList ) { footer . addToBlocklet_info_list ( getBlockletInfo ( info , columnSchemaList , segmentProperties ) ) ; } return footer ; }
public static FileFooter convertFileFooter ( List < BlockletInfoColumnar > infoList , int numCols , int [ ] cardinalities , List < ColumnSchema > columnSchemaList , SegmentProperties segmentProperties ) throws IOException { SegmentInfo segmentInfo = new SegmentInfo ( ) ; segmentInfo . setNum_cols ( columnSchemaList . size ( ) ) ; segmentInfo . setColumn_cardinalities ( CarbonUtil . convertToIntegerList ( cardinalities ) ) ; FileFooter footer = new FileFooter ( ) ; footer . setNum_rows ( getTotalNumberOfRows ( infoList ) ) ; footer . setSegment_info ( segmentInfo ) ; for ( BlockletInfoColumnar info : infoList ) { footer . addToBlocklet_index_list ( getBlockletIndex ( info ) ) ; } footer . setTable_columns ( columnSchemaList ) ; for ( BlockletInfoColumnar info : infoList ) { footer . addToBlocklet_info_list ( getBlockletInfo ( info , columnSchemaList , segmentProperties ) ) ; } return footer ; }
@ Override public ConnectionProtocol newConnection ( ConnectionTcp connTcp ) { return new ConnectionHttp ( this , connTcp , _sequence . incrementAndGet ( ) ) ; }
public void checkCanBuildList ( ) { if ( listeners . isEmpty ( ) ) { if ( sysNameList != null ) { deregister ( ) ; sysNameList = null ; } canBuildList = _BOOL ; } }
public void checkCanBuildList ( ) { if ( listeners . isEmpty ( ) ) { if ( sysNameList != null ) { deregister ( ) ; sysNameList = null ; } canBuildList = _BOOL ; } }
public void checkCanBuildList ( ) { if ( listeners . isEmpty ( ) ) { if ( sysNameList != null ) { deregister ( ) ; sysNameList = null ; } canBuildList = _BOOL ; } }
public void checkCanBuildList ( ) { if ( listeners . isEmpty ( ) ) { if ( sysNameList != null ) { deregister ( ) ; sysNameList = null ; } canBuildList = _BOOL ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
public void initialize ( ) { loadHelpers = new LinkedList < ClassLoadHelper > ( ) ; loadHelpers . add ( new LoadingLoaderClassLoadHelper ( ) ) ; loadHelpers . add ( new SimpleClassLoadHelper ( ) ) ; loadHelpers . add ( new ThreadContextClassLoadHelper ( ) ) ; loadHelpers . add ( new InitThreadContextClassLoadHelper ( ) ) ; for ( ClassLoadHelper loadHelper : loadHelpers ) { loadHelper . initialize ( ) ; } }
private void writeDelay ( ) { try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { fail ( STRING ) ; } }
private void writeDelay ( ) { try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { fail ( STRING ) ; } }
private void writeDelay ( ) { try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { fail ( STRING ) ; } }
private static void recordCompilation ( byte compiler , int BCLength , int MCLength , double compTime ) { totalMethods [ compiler ] ++ ; totalMCLength [ compiler ] += MCLength ; totalCompTime [ compiler ] += compTime ; if ( compiler != JNI_COMPILER ) { totalBCLength [ compiler ] += BCLength ; double rate = BCLength / compTime ; if ( VM . fullyBooted ) { totalLogOfRates [ compiler ] += Math . log ( rate ) ; totalLogValueMethods [ compiler ] ++ ; } } }
int addVert ( float x , float y , float z ) { int i = nvert ; if ( i >= maxvert ) { if ( vert == null ) { maxvert = _NUM ; vert = new float [ maxvert * _NUM ] ; } else { maxvert *= _NUM ; float nv [ ] = new float [ maxvert * _NUM ] ; System . arraycopy ( vert , _NUM , nv , _NUM , vert . length ) ; vert = nv ; } } i *= _NUM ; vert [ i ] = x ; vert [ i + _NUM ] = y ; vert [ i + _NUM ] = z ; return nvert ++ ; }
protected void paintCell ( Graphics g , int row , Rectangle rowBounds , ListCellRenderer cellRenderer , ListModel dataModel , ListSelectionModel selModel , int leadIndex ) { Object value = dataModel . getElementAt ( row ) ; boolean cellHasFocus = list . hasFocus ( ) && ( row == leadIndex ) ; boolean isSelected = selModel . isSelectedIndex ( row ) ; Component rendererComponent = cellRenderer . getListCellRendererComponent ( list , value , row , isSelected , cellHasFocus ) ; int cx = rowBounds . x ; int cy = rowBounds . y ; int cw = rowBounds . width ; int ch = rowBounds . height ; if ( isFileList ) { int w = Math . min ( cw , rendererComponent . getPreferredSize ( ) . width + _NUM ) ; if ( ! isLeftToRight ) { cx += ( cw - w ) ; } cw = w ; } rendererPane . paintComponent ( g , rendererComponent , list , cx , cy , cw , ch , _BOOL ) ; }
protected void paintCell ( Graphics g , int row , Rectangle rowBounds , ListCellRenderer cellRenderer , ListModel dataModel , ListSelectionModel selModel , int leadIndex ) { Object value = dataModel . getElementAt ( row ) ; boolean cellHasFocus = list . hasFocus ( ) && ( row == leadIndex ) ; boolean isSelected = selModel . isSelectedIndex ( row ) ; Component rendererComponent = cellRenderer . getListCellRendererComponent ( list , value , row , isSelected , cellHasFocus ) ; int cx = rowBounds . x ; int cy = rowBounds . y ; int cw = rowBounds . width ; int ch = rowBounds . height ; if ( isFileList ) { int w = Math . min ( cw , rendererComponent . getPreferredSize ( ) . width + _NUM ) ; if ( ! isLeftToRight ) { cx += ( cw - w ) ; } cw = w ; } rendererPane . paintComponent ( g , rendererComponent , list , cx , cy , cw , ch , _BOOL ) ; }
protected void paintCell ( Graphics g , int row , Rectangle rowBounds , ListCellRenderer cellRenderer , ListModel dataModel , ListSelectionModel selModel , int leadIndex ) { Object value = dataModel . getElementAt ( row ) ; boolean cellHasFocus = list . hasFocus ( ) && ( row == leadIndex ) ; boolean isSelected = selModel . isSelectedIndex ( row ) ; Component rendererComponent = cellRenderer . getListCellRendererComponent ( list , value , row , isSelected , cellHasFocus ) ; int cx = rowBounds . x ; int cy = rowBounds . y ; int cw = rowBounds . width ; int ch = rowBounds . height ; if ( isFileList ) { int w = Math . min ( cw , rendererComponent . getPreferredSize ( ) . width + _NUM ) ; if ( ! isLeftToRight ) { cx += ( cw - w ) ; } cw = w ; } rendererPane . paintComponent ( g , rendererComponent , list , cx , cy , cw , ch , _BOOL ) ; }
protected void paintCell ( Graphics g , int row , Rectangle rowBounds , ListCellRenderer cellRenderer , ListModel dataModel , ListSelectionModel selModel , int leadIndex ) { Object value = dataModel . getElementAt ( row ) ; boolean cellHasFocus = list . hasFocus ( ) && ( row == leadIndex ) ; boolean isSelected = selModel . isSelectedIndex ( row ) ; Component rendererComponent = cellRenderer . getListCellRendererComponent ( list , value , row , isSelected , cellHasFocus ) ; int cx = rowBounds . x ; int cy = rowBounds . y ; int cw = rowBounds . width ; int ch = rowBounds . height ; if ( isFileList ) { int w = Math . min ( cw , rendererComponent . getPreferredSize ( ) . width + _NUM ) ; if ( ! isLeftToRight ) { cx += ( cw - w ) ; } cw = w ; } rendererPane . paintComponent ( g , rendererComponent , list , cx , cy , cw , ch , _BOOL ) ; }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { super . handleSpecialSubstitution ( replace , replaceWith , startPos , description ) ; if ( replace . equals ( STRING ) ) { if ( replaceWith . charAt ( _NUM ) == STRING ) { error ( STRING , startPos , description ) ; } dictionaryExpression = replaceWith ; dictionaryChars = CharSet . parseString ( replaceWith ) ; } }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { super . handleSpecialSubstitution ( replace , replaceWith , startPos , description ) ; if ( replace . equals ( STRING ) ) { if ( replaceWith . charAt ( _NUM ) == STRING ) { error ( STRING , startPos , description ) ; } dictionaryExpression = replaceWith ; dictionaryChars = CharSet . parseString ( replaceWith ) ; } }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { super . handleSpecialSubstitution ( replace , replaceWith , startPos , description ) ; if ( replace . equals ( STRING ) ) { if ( replaceWith . charAt ( _NUM ) == STRING ) { error ( STRING , startPos , description ) ; } dictionaryExpression = replaceWith ; dictionaryChars = CharSet . parseString ( replaceWith ) ; } }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { super . handleSpecialSubstitution ( replace , replaceWith , startPos , description ) ; if ( replace . equals ( STRING ) ) { if ( replaceWith . charAt ( _NUM ) == STRING ) { error ( STRING , startPos , description ) ; } dictionaryExpression = replaceWith ; dictionaryChars = CharSet . parseString ( replaceWith ) ; } }
protected void handleSpecialSubstitution ( String replace , String replaceWith , int startPos , String description ) { super . handleSpecialSubstitution ( replace , replaceWith , startPos , description ) ; if ( replace . equals ( STRING ) ) { if ( replaceWith . charAt ( _NUM ) == STRING ) { error ( STRING , startPos , description ) ; } dictionaryExpression = replaceWith ; dictionaryChars = CharSet . parseString ( replaceWith ) ; } }
private void rMoveTo ( float dx , float dy ) { dx += mLastX ; dy += mLastY ; mPath . moveTo ( mLastX = dx , mLastY = dy ) ; }
private void rMoveTo ( float dx , float dy ) { dx += mLastX ; dy += mLastY ; mPath . moveTo ( mLastX = dx , mLastY = dy ) ; }
public ParameterTypeVariable2 makeDeclaredParameterTypeVariable ( IMethodBinding methodBinding , int parameterIndex , ICompilationUnit cu ) { if ( methodBinding == null ) return null ; ParameterTypeVariable2 cv = makeParameterTypeVariable ( methodBinding , parameterIndex ) ; if ( cv == null ) return null ; cv . setCompilationUnit ( cu ) ; return cv ; }
public ParameterTypeVariable2 makeDeclaredParameterTypeVariable ( IMethodBinding methodBinding , int parameterIndex , ICompilationUnit cu ) { if ( methodBinding == null ) return null ; ParameterTypeVariable2 cv = makeParameterTypeVariable ( methodBinding , parameterIndex ) ; if ( cv == null ) return null ; cv . setCompilationUnit ( cu ) ; return cv ; }
public ParameterTypeVariable2 makeDeclaredParameterTypeVariable ( IMethodBinding methodBinding , int parameterIndex , ICompilationUnit cu ) { if ( methodBinding == null ) return null ; ParameterTypeVariable2 cv = makeParameterTypeVariable ( methodBinding , parameterIndex ) ; if ( cv == null ) return null ; cv . setCompilationUnit ( cu ) ; return cv ; }
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STRING ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignored ) { } } return baos . toByteArray ( ) ; }
public static byte [ ] gzip ( String input ) { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; GZIPOutputStream gzos = null ; try { gzos = new GZIPOutputStream ( baos ) ; gzos . write ( input . getBytes ( STRING ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( gzos != null ) try { gzos . close ( ) ; } catch ( IOException ignored ) { } } return baos . toByteArray ( ) ; }
public static void ensureOSXCompatible ( ) { File nnnAAAAA = new File ( DCIM , STRING ) ; if ( ! ( nnnAAAAA . exists ( ) || nnnAAAAA . mkdirs ( ) ) ) { Log . e ( TAG , STRING + nnnAAAAA . getPath ( ) ) ; } }
public static void ensureOSXCompatible ( ) { File nnnAAAAA = new File ( DCIM , STRING ) ; if ( ! ( nnnAAAAA . exists ( ) || nnnAAAAA . mkdirs ( ) ) ) { Log . e ( TAG , STRING + nnnAAAAA . getPath ( ) ) ; } }
public boolean onInterceptTouchEvent ( MotionEvent ev ) { @ SuppressWarnings ( STRING ) final boolean debug = _BOOL ; if ( debug ) { Log . d ( Launcher . TAG , STRING + ev + STRING + mDragging ) ; } if ( mIsAccessibleDrag ) { return _BOOL ; } acquireVelocityTrackerAndAddMovement ( ev ) ; final int action = ev . getAction ( ) ; final int [ ] dragLayerPos = getClampedDragLayerPos ( ev . getX ( ) , ev . getY ( ) ) ; final int dragLayerX = dragLayerPos [ _NUM ] ; final int dragLayerY = dragLayerPos [ _NUM ] ; switch ( action ) { case MotionEvent . ACTION_MOVE : break ; case MotionEvent . ACTION_DOWN : mMotionDownX = dragLayerX ; mMotionDownY = dragLayerY ; mLastDropTarget = null ; break ; case MotionEvent . ACTION_UP : mLastTouchUpTime = System . currentTimeMillis ( ) ; if ( mDragging ) { PointF vec = isFlingingToDelete ( mDragObject . dragSource ) ; if ( ! DeleteDropTarget . supportsDrop ( mDragObject . dragInfo ) ) { vec = null ; } if ( vec != null ) { dropOnFlingToDeleteTarget ( dragLayerX , dragLayerY , vec ) ; } else { drop ( dragLayerX , dragLayerY ) ; } } endDrag ( ) ; break ; case MotionEvent . ACTION_CANCEL : cancelDrag ( ) ; break ; } return mDragging ; }
private static int indexOfSegmentName ( String filename ) { int idx = filename . indexOf ( STRING , _NUM ) ; if ( idx == - _NUM ) { idx = filename . indexOf ( STRING ) ; } return idx ; }
public void checkIsAllocated ( ) { int originalBits = AddressableMemoryManager . readIntVolatile ( this . memoryAddress + REF_COUNT_OFFSET ) ; if ( ( originalBits & MAGIC_MASK ) != MAGIC_NUMBER ) { throw new IllegalStateException ( STRING + Integer . toHexString ( originalBits ) ) ; } }
public long fileSize ( String path ) throws IllegalStateException , IOException , FTPIllegalReplyException , FTPException { synchronized ( lock ) { if ( ! connected ) { throw new IllegalStateException ( STRING ) ; } if ( ! authenticated ) { throw new IllegalStateException ( STRING ) ; } communication . sendFTPCommand ( STRING ) ; FTPReply r = communication . readFTPReply ( ) ; touchAutoNoopTimer ( ) ; if ( ! r . isSuccessCode ( ) ) { throw new FTPException ( r ) ; } communication . sendFTPCommand ( STRING + path ) ; r = communication . readFTPReply ( ) ; touchAutoNoopTimer ( ) ; if ( ! r . isSuccessCode ( ) ) { throw new FTPException ( r ) ; } String [ ] messages = r . getMessages ( ) ; if ( messages . length != _NUM ) { throw new FTPIllegalReplyException ( ) ; } else { try { return Long . parseLong ( messages [ _NUM ] ) ; } catch ( Throwable t ) { throw new FTPIllegalReplyException ( ) ; } } } }
public boolean isRunning ( ) { return running ; }
public boolean isRunning ( ) { return running ; }
public static void checkForRemainingOptions ( String [ ] options ) throws Exception { int illegalOptionsFound = _NUM ; StringBuffer text = new StringBuffer ( ) ; if ( options == null ) { return ; } for ( String option : options ) { if ( option . length ( ) > _NUM ) { illegalOptionsFound ++ ; text . append ( option + STRING ) ; } } if ( illegalOptionsFound > _NUM ) { throw new Exception ( STRING + text ) ; } }
public static void checkForRemainingOptions ( String [ ] options ) throws Exception { int illegalOptionsFound = _NUM ; StringBuffer text = new StringBuffer ( ) ; if ( options == null ) { return ; } for ( String option : options ) { if ( option . length ( ) > _NUM ) { illegalOptionsFound ++ ; text . append ( option + STRING ) ; } } if ( illegalOptionsFound > _NUM ) { throw new Exception ( STRING + text ) ; } }
public boolean remove ( Change change ) { Assert . isNotNull ( change ) ; boolean result = fChanges . remove ( change ) ; if ( result ) { change . setParent ( null ) ; } return result ; }
protected BooleanVal ( boolean b ) { this . b = b ; }
protected BooleanVal ( boolean b ) { this . b = b ; }
protected BooleanVal ( boolean b ) { this . b = b ; }
public boolean isParent ( File folder , File file ) { if ( folder == null || file == null ) { return _BOOL ; } else if ( folder instanceof ShellFolder ) { File parent = file . getParentFile ( ) ; if ( parent != null && parent . equals ( folder ) ) { return _BOOL ; } File [ ] children = getFiles ( folder , _BOOL ) ; for ( File child : children ) { if ( file . equals ( child ) ) { return _BOOL ; } } return _BOOL ; } else { return folder . equals ( file . getParentFile ( ) ) ; } }
public void removePositions ( Collection < Integer > positions ) { ArrayList < Integer > positionsList = new ArrayList < Integer > ( positions ) ; Collections . sort ( positionsList ) ; Collections . reverse ( positionsList ) ; for ( int position : positionsList ) { mItems . remove ( position ) ; } notifyDataSetChanged ( ) ; }
public HttpJsonPostRequest ( final SerializableEntity entity ) { this ( JsonSerializer . serializeToJson ( entity ) ) ; }
public static XmlAttribute toXmlAttribute ( Class < ? > clazz , Field field ) { JMap jMap = field . getAnnotation ( JMap . class ) ; SimplyAttribute [ ] targetAttributes = toTargetAttributes ( jMap . attributes ( ) ) ; String get = null , set = null ; JMapAccessor jMapAccessor = Annotation . getFieldAccessors ( clazz , field ) ; if ( ! isNull ( jMapAccessor ) ) { get = jMapAccessor . get ( ) ; set = jMapAccessor . set ( ) ; } return toXmlAttribute ( field . getName ( ) , new Value ( jMap . value ( ) ) , get , set , targetAttributes , jMap . classes ( ) ) ; }
public static final String longToHexString ( long a ) { StringBuffer sb = new StringBuffer ( _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) sb . append ( NIBBLE [ ( int ) ( a > > > ( _NUM - _NUM * i ) ) & _NUM ] ) ; return sb . toString ( ) ; }
public void makeImmutable ( ) { mutable = _BOOL ; if ( authnContextClassRef != null ) { authnContextClassRef = Collections . unmodifiableList ( authnContextClassRef ) ; } if ( authnContextDeclRef != null ) { authnContextDeclRef = Collections . unmodifiableList ( authnContextDeclRef ) ; } return ; }
protected int [ ] dummyColorInscribedDataCircleFromYuvImage ( ImageProxy img , int subsample ) { logWrapper ( STRING ) ; int w = img . getWidth ( ) / subsample ; int h = img . getHeight ( ) / subsample ; int r = inscribedCircleRadius ( w , h ) ; int len = r * r * _NUM ; int [ ] colors = new int [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { int x = i % ( _NUM * r ) ; int y = i / ( _NUM * r ) ; colors [ i ] = ( _NUM << _NUM ) | ( ( x & _NUM ) << _NUM ) | ( ( y & _NUM ) << _NUM ) ; } return colors ; }
protected int [ ] dummyColorInscribedDataCircleFromYuvImage ( ImageProxy img , int subsample ) { logWrapper ( STRING ) ; int w = img . getWidth ( ) / subsample ; int h = img . getHeight ( ) / subsample ; int r = inscribedCircleRadius ( w , h ) ; int len = r * r * _NUM ; int [ ] colors = new int [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { int x = i % ( _NUM * r ) ; int y = i / ( _NUM * r ) ; colors [ i ] = ( _NUM << _NUM ) | ( ( x & _NUM ) << _NUM ) | ( ( y & _NUM ) << _NUM ) ; } return colors ; }
protected int [ ] dummyColorInscribedDataCircleFromYuvImage ( ImageProxy img , int subsample ) { logWrapper ( STRING ) ; int w = img . getWidth ( ) / subsample ; int h = img . getHeight ( ) / subsample ; int r = inscribedCircleRadius ( w , h ) ; int len = r * r * _NUM ; int [ ] colors = new int [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { int x = i % ( _NUM * r ) ; int y = i / ( _NUM * r ) ; colors [ i ] = ( _NUM << _NUM ) | ( ( x & _NUM ) << _NUM ) | ( ( y & _NUM ) << _NUM ) ; } return colors ; }
protected int [ ] dummyColorInscribedDataCircleFromYuvImage ( ImageProxy img , int subsample ) { logWrapper ( STRING ) ; int w = img . getWidth ( ) / subsample ; int h = img . getHeight ( ) / subsample ; int r = inscribedCircleRadius ( w , h ) ; int len = r * r * _NUM ; int [ ] colors = new int [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { int x = i % ( _NUM * r ) ; int y = i / ( _NUM * r ) ; colors [ i ] = ( _NUM << _NUM ) | ( ( x & _NUM ) << _NUM ) | ( ( y & _NUM ) << _NUM ) ; } return colors ; }
protected int [ ] dummyColorInscribedDataCircleFromYuvImage ( ImageProxy img , int subsample ) { logWrapper ( STRING ) ; int w = img . getWidth ( ) / subsample ; int h = img . getHeight ( ) / subsample ; int r = inscribedCircleRadius ( w , h ) ; int len = r * r * _NUM ; int [ ] colors = new int [ len ] ; for ( int i = _NUM ; i < len ; i ++ ) { int x = i % ( _NUM * r ) ; int y = i / ( _NUM * r ) ; colors [ i ] = ( _NUM << _NUM ) | ( ( x & _NUM ) << _NUM ) | ( ( y & _NUM ) << _NUM ) ; } return colors ; }
@ Override public void removePropertyChangeListener ( PropertyChangeListener pcl ) { m_pcSupport . removePropertyChangeListener ( pcl ) ; }
public void rm ( String fileOrDir ) { StringBuilder buf = new StringBuilder ( ) ; String command = String . format ( ImageServerDialogProperties . getString ( STRING ) , fileOrDir ) ; sendWaitFor ( command , defaultTimeout , prompts , buf ) ; log . debug ( buf . toString ( ) ) ; }
public void rm ( String fileOrDir ) { StringBuilder buf = new StringBuilder ( ) ; String command = String . format ( ImageServerDialogProperties . getString ( STRING ) , fileOrDir ) ; sendWaitFor ( command , defaultTimeout , prompts , buf ) ; log . debug ( buf . toString ( ) ) ; }
public static String [ ] toRole ( Object oRoles ) throws PageException { if ( oRoles instanceof String ) { oRoles = ListUtil . listToArrayRemoveEmpty ( oRoles . toString ( ) , STRING ) ; } if ( oRoles instanceof Array ) { Array arrRoles = ( Array ) oRoles ; String [ ] roles = new String [ arrRoles . size ( ) ] ; for ( int i = _NUM ; i < roles . length ; i ++ ) { roles [ i ] = Caster . toString ( arrRoles . get ( i + _NUM , STRING ) ) ; } return roles ; } throw new ApplicationException ( STRING ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return MAP_FIELD ; default : return null ; } }
private static boolean isAncestor ( ClassLoader first , ClassLoader second ) { ClassLoader acl = first ; do { acl = acl . getParent ( ) ; if ( second == acl ) { return _BOOL ; } } while ( acl != null ) ; return _BOOL ; }
private static boolean isAncestor ( ClassLoader first , ClassLoader second ) { ClassLoader acl = first ; do { acl = acl . getParent ( ) ; if ( second == acl ) { return _BOOL ; } } while ( acl != null ) ; return _BOOL ; }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public void removeNotify ( ) { synchronized ( getTreeLock ( ) ) { ListPeer peer = ( ListPeer ) this . peer ; if ( peer != null ) { selected = peer . getSelectedIndexes ( ) ; } super . removeNotify ( ) ; } }
public JHexView ( ) { for ( int i = _NUM ; i < m_coloredRanges . length ; i ++ ) { m_coloredRanges [ i ] = new ColoredRangeManager ( ) ; } setFocusable ( _BOOL ) ; setLayout ( new BorderLayout ( ) ) ; setFont ( m_font ) ; initListeners ( ) ; initHotkeys ( ) ; initScrollbar ( ) ; img = new BufferedImage ( ( getWidth ( ) + _NUM ) - m_scrollbar . getWidth ( ) , ( getHeight ( ) + _NUM ) - m_horizontalScrollbar . getHeight ( ) , BufferedImage . TYPE_INT_RGB ) ; bufferGraphics = img . getGraphics ( ) ; updateOffsetViewWidth ( ) ; setEnabled ( _BOOL ) ; }
public void text ( String str , float x , float y ) { if ( textFont == null ) { defaultFontOrDeath ( STRING ) ; } int length = str . length ( ) ; if ( length > textBuffer . length ) { textBuffer = new char [ length + _NUM ] ; } str . getChars ( _NUM , length , textBuffer , _NUM ) ; float high = _NUM ; for ( int i = _NUM ; i < length ; i ++ ) { if ( textBuffer [ i ] == STRING ) { high += textLeading ; } } if ( textAlignY == CENTER ) { y += ( textAscent ( ) - high ) / _NUM ; } else if ( textAlignY == TOP ) { y += textAscent ( ) ; } else if ( textAlignY == BOTTOM ) { y -= textDescent ( ) + high ; } int start = _NUM ; int index = _NUM ; while ( index < length ) { if ( textBuffer [ index ] == STRING ) { textLineAlignImpl ( textBuffer , start , index , x , y ) ; start = index + _NUM ; y += textLeading ; } index ++ ; } if ( start < length ) { textLineAlignImpl ( textBuffer , start , index , x , y ) ; } }
public DViewCertCsrPem ( JFrame parent , String title , X509Certificate cert ) throws CryptoException { super ( parent , title , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . cert = cert ; initComponents ( ) ; }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
protected void load_raw_characters ( StringBuilder sb ) throws IOException { int c = read_char ( ) ; for ( ; ; ) { c = read_char ( ) ; switch ( c ) { case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_1 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_2 : case CharacterSequence . CHAR_SEQ_ESCAPED_NEWLINE_SEQUENCE_3 : continue ; case - _NUM : return ; default : if ( ! IonTokenConstsX . is7bitValue ( c ) ) { c = read_large_char_sequence ( c ) ; } } if ( IonUTF8 . needsSurrogateEncoding ( c ) ) { sb . append ( IonUTF8 . highSurrogate ( c ) ) ; c = IonUTF8 . lowSurrogate ( c ) ; } sb . append ( ( char ) c ) ; } }
public static GradientPaint makeRedPaint ( final double width , final double height ) { return new GradientPaint ( _NUM , _NUM , new Color ( _NUM , _NUM , _NUM ) , ( float ) width / _NUM , ( float ) height / _NUM , new Color ( _NUM , _NUM , _NUM ) , _BOOL ) ; }
@ Nullable private static String readXmlFile ( @ Nullable URL url ) { String xmlFileContent = null ; if ( url != null ) { try { xmlFileContent = UrlUtil . loadText ( url ) ; } catch ( IOException e ) { LOG . error ( e ) ; } } return xmlFileContent ; }
@ Nullable private static String readXmlFile ( @ Nullable URL url ) { String xmlFileContent = null ; if ( url != null ) { try { xmlFileContent = UrlUtil . loadText ( url ) ; } catch ( IOException e ) { LOG . error ( e ) ; } } return xmlFileContent ; }
public void removeEventListener ( RcsServiceRegistrationListener listener ) throws RcsServiceNotAvailableException , RcsGenericException { if ( mApi == null ) { throw new RcsServiceNotAvailableException ( ) ; } try { WeakReference < IRcsServiceRegistrationListener > weakRef = mRegistrationListeners . remove ( listener ) ; if ( weakRef == null ) { return ; } IRcsServiceRegistrationListener rcsListener = weakRef . get ( ) ; if ( rcsListener != null ) { callApiMethod ( STRING , rcsListener , IRcsServiceRegistrationListener . class ) ; } } catch ( Exception e ) { throw new RcsGenericException ( e ) ; } }
private void selectFile ( int titleMsg , int buttonMsg , String settingsName , String defaultDir , int dialog , int result ) { setAutoMode ( AutoMode . OFF ) ; String action = STRING ; Intent i = new Intent ( action ) ; String currentFile = settings . getString ( settingsName , STRING ) ; String sep = File . separator ; if ( ! currentFile . contains ( sep ) ) currentFile = Environment . getExternalStorageDirectory ( ) + sep + defaultDir + sep + currentFile ; i . setData ( Uri . fromFile ( new File ( currentFile ) ) ) ; i . putExtra ( STRING , getString ( titleMsg ) ) ; i . putExtra ( STRING , getString ( buttonMsg ) ) ; try { startActivityForResult ( i , result ) ; } catch ( ActivityNotFoundException e ) { removeDialog ( dialog ) ; showDialog ( dialog ) ; } }
public static InsertIntoClause create ( String streamName , String [ ] columns , StreamSelector streamSelector ) { if ( streamSelector == StreamSelector . RSTREAM_ISTREAM_BOTH ) { throw new IllegalArgumentException ( STRING ) ; } return new InsertIntoClause ( streamName , Arrays . asList ( columns ) , streamSelector ) ; }
public static String normalizePath ( String path ) { return path . replace ( File . separatorChar , STRING ) ; }
public void deleteSelection ( ArrayList < Integer > nodes ) { for ( int i = _NUM ; i < nodes . size ( ) ; i ++ ) { for ( int j = i + _NUM ; j < nodes . size ( ) ; j ++ ) { if ( nodes . get ( i ) > nodes . get ( j ) ) { int h = nodes . get ( i ) ; nodes . set ( i , nodes . get ( j ) ) ; nodes . set ( j , h ) ; } } } if ( m_bNeedsUndoAction ) { addUndoAction ( new DeleteSelectionAction ( nodes ) ) ; } boolean bNeedsUndoAction = m_bNeedsUndoAction ; m_bNeedsUndoAction = _BOOL ; try { for ( int iNode = nodes . size ( ) - _NUM ; iNode >= _NUM ; iNode -- ) { deleteNode ( nodes . get ( iNode ) ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } m_bNeedsUndoAction = bNeedsUndoAction ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public void addUpdateListener ( AnimatorUpdateListener listener ) { if ( mUpdateListeners == null ) { mUpdateListeners = new ArrayList < AnimatorUpdateListener > ( ) ; } mUpdateListeners . add ( listener ) ; }
public static String grabName ( String signature ) { Matcher matcher = sigRE . matcher ( signature ) ; boolean b = matcher . matches ( ) ; if ( ! b && matcher . groupCount ( ) != _NUM ) logger . error ( STRING , signature ) ; return matcher . group ( _NUM ) ; }
public static Calendar createCalendarInstance ( Date date ) { Calendar calendar = new GregorianCalendar ( ) ; calendar . setTime ( date ) ; clearTimeOfDay ( calendar ) ; return calendar ; }
public JSONArray add ( String value ) { values . add ( JSON . value ( value ) ) ; return this ; }
public static int nextSetBit ( long v , int start ) { if ( start >= Long . SIZE ) { return - _NUM ; } long cur = v & ( LONG_ALL_BITS << start ) ; if ( cur == _NUM ) { return - _NUM ; } return Long . numberOfTrailingZeros ( cur ) ; }
public static void doFakeEntityExplosion ( EntityPlayer entityplayer ) { World world = entityplayer . worldObj ; world . spawnParticle ( STRING , entityplayer . posX , entityplayer . posY , entityplayer . posZ , _NUM , _NUM , _NUM ) ; world . playSoundAtEntity ( entityplayer , STRING , _NUM , _NUM ) ; }
public static void doFakeEntityExplosion ( EntityPlayer entityplayer ) { World world = entityplayer . worldObj ; world . spawnParticle ( STRING , entityplayer . posX , entityplayer . posY , entityplayer . posZ , _NUM , _NUM , _NUM ) ; world . playSoundAtEntity ( entityplayer , STRING , _NUM , _NUM ) ; }
public static void doFakeEntityExplosion ( EntityPlayer entityplayer ) { World world = entityplayer . worldObj ; world . spawnParticle ( STRING , entityplayer . posX , entityplayer . posY , entityplayer . posZ , _NUM , _NUM , _NUM ) ; world . playSoundAtEntity ( entityplayer , STRING , _NUM , _NUM ) ; }
public WeakTable ( ) { if ( DEBUG != null ) DEBUG . println ( STRING ) ; table = new HashMap ( ) ; refQueue = new ReferenceQueue ( ) ; }
public String dump ( ) { StringBuilder buffer = new StringBuilder ( ) ; for ( int row = _NUM ; row < getRowCount ( ) ; row ++ ) { buffer . append ( timestamps [ row ] ) ; buffer . append ( STRING ) ; for ( int dsIndex = _NUM ; dsIndex < getColumnCount ( ) ; dsIndex ++ ) { buffer . append ( Util . formatDouble ( values [ dsIndex ] [ row ] , _BOOL ) ) ; buffer . append ( STRING ) ; } buffer . append ( STRING ) ; } return buffer . toString ( ) ; }
public boolean containsInstruction ( InstructionHandle handle ) { Iterator < InstructionHandle > i = instructionIterator ( ) ; while ( i . hasNext ( ) ) { if ( i . next ( ) == handle ) { return _BOOL ; } } return _BOOL ; }
public boolean containsInstruction ( InstructionHandle handle ) { Iterator < InstructionHandle > i = instructionIterator ( ) ; while ( i . hasNext ( ) ) { if ( i . next ( ) == handle ) { return _BOOL ; } } return _BOOL ; }
public static void skipFully ( InputStream in , long skip ) throws IOException { try { while ( skip > _NUM ) { long skipped = in . skip ( skip ) ; if ( skipped <= _NUM ) { throw new EOFException ( ) ; } skip -= skipped ; } } catch ( Exception e ) { throw DbException . convertToIOException ( e ) ; } }
private byte [ ] decode ( DerInputStream in ) throws IOException { DerValue val = in . getDerValue ( ) ; byte [ ] derEncoding = val . toByteArray ( ) ; derEncoding [ _NUM ] = DerValue . tag_SetOf ; DerInputStream derIn = new DerInputStream ( derEncoding ) ; DerValue [ ] derVals = derIn . getSet ( _NUM , _BOOL ) ; PKCS9Attribute attrib ; ObjectIdentifier oid ; boolean reuseEncoding = _BOOL ; for ( int i = _NUM ; i < derVals . length ; i ++ ) { try { attrib = new PKCS9Attribute ( derVals [ i ] ) ; } catch ( ParsingException e ) { if ( ignoreUnsupportedAttributes ) { reuseEncoding = _BOOL ; continue ; } else { throw e ; } } oid = attrib . getOID ( ) ; if ( attributes . get ( oid ) != null ) throw new IOException ( STRING + oid ) ; if ( permittedAttributes != null && ! permittedAttributes . containsKey ( oid ) ) throw new IOException ( STRING + oid + STRING ) ; attributes . put ( oid , attrib ) ; } return reuseEncoding ? derEncoding : generateDerEncoding ( ) ; }
public int attributesSize ( ) { return attributes . size ( ) ; }
public boolean createBookmarkRollbackStep ( String stepId ) { WorkflowStepCompleter . stepExecuting ( stepId ) ; _log . info ( String . format ( STRING , stepId ) ) ; WorkflowStepCompleter . stepSucceded ( stepId ) ; return _BOOL ; }
public boolean createBookmarkRollbackStep ( String stepId ) { WorkflowStepCompleter . stepExecuting ( stepId ) ; _log . info ( String . format ( STRING , stepId ) ) ; WorkflowStepCompleter . stepSucceded ( stepId ) ; return _BOOL ; }
public boolean createBookmarkRollbackStep ( String stepId ) { WorkflowStepCompleter . stepExecuting ( stepId ) ; _log . info ( String . format ( STRING , stepId ) ) ; WorkflowStepCompleter . stepSucceded ( stepId ) ; return _BOOL ; }
public synchronized void removeIncrementalClassifierListener ( IncrementalClassifierListener cl ) { m_incrementalClassifierListeners . remove ( cl ) ; }
void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; }
void unexecuteNSDecls ( TransformerImpl transformer ) throws TransformerException { unexecuteNSDecls ( transformer , null ) ; }
public static OutputStream leftShift ( OutputStream self , InputStream in ) throws IOException { byte [ ] buf = new byte [ _NUM ] ; while ( _BOOL ) { int count = in . read ( buf , _NUM , buf . length ) ; if ( count == - _NUM ) break ; if ( count == _NUM ) { Thread . yield ( ) ; continue ; } self . write ( buf , _NUM , count ) ; } self . flush ( ) ; return self ; }
private void addExcludeClassNode ( DocumentNode inlineDocumentNode , Node componentRoot ) { MetaDataNode inlineExcludeNode = new MetaDataNode ( componentRoot . getNamespace ( ) , componentRoot . getLocalPart ( ) , _NUM ) ; inlineExcludeNode . image = componentRoot . image ; CDATANode excludeTextNode = new CDATANode ( ) ; excludeTextNode . image = STRING ; inlineExcludeNode . addChild ( excludeTextNode ) ; inlineDocumentNode . addChild ( inlineExcludeNode ) ; }
private void assignClusterNums ( int [ ] cl_num ) throws Exception { if ( m_children != null && m_children . size ( ) < _NUM ) { throw new Exception ( STRING ) ; } m_clusterNum = cl_num [ _NUM ] ; cl_num [ _NUM ] ++ ; if ( m_children != null ) { for ( int i = _NUM ; i < m_children . size ( ) ; i ++ ) { CNode child = m_children . get ( i ) ; child . assignClusterNums ( cl_num ) ; } } }
public View create ( Element elem ) { Document doc = elem . getDocument ( ) ; Object i18nFlag = doc . getProperty ( STRING ) ; if ( ( i18nFlag != null ) && i18nFlag . equals ( Boolean . TRUE ) ) { return createI18N ( elem ) ; } else { return new WrappedPlainView ( elem ) ; } }
public void add ( final Extension < ? , ? > extension ) { if ( extension . getExtensionType ( ) != Extension . ExtensionType . IMMUTABLE && extension . getExtensionType ( ) != Extension . ExtensionType . MUTABLE ) { return ; } add ( newExtensionInfo ( extension ) , extension . getExtensionType ( ) ) ; }
final void sendHelp ( ) { ArrayList < String > help = help ( ) ; if ( help . isEmpty ( ) ) { return ; } XmppMsg msg = new XmppMsg ( ) ; msg . addStringArray ( help . toArray ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
final void sendHelp ( ) { ArrayList < String > help = help ( ) ; if ( help . isEmpty ( ) ) { return ; } XmppMsg msg = new XmppMsg ( ) ; msg . addStringArray ( help . toArray ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
final void sendHelp ( ) { ArrayList < String > help = help ( ) ; if ( help . isEmpty ( ) ) { return ; } XmppMsg msg = new XmppMsg ( ) ; msg . addStringArray ( help . toArray ( new String [ help . size ( ) ] ) ) ; send ( msg ) ; }
public void addMemoryListener ( final IMemoryListener listener ) { Preconditions . checkNotNull ( listener , STRING ) ; m_listeners . add ( listener ) ; }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
private synchronized void writeToOutputStream ( int oneByte ) { if ( mClosed ) { return ; } try { mOutputStream . write ( oneByte ) ; reportDecodedSizeIfApplicable ( ) ; } catch ( IOException e ) { handleIOExceptionWritingToStream ( e ) ; } }
public void addCriteria ( Criteria otherCriteria ) { if ( otherCriteria instanceof AdvancedCriteria || otherCriteria instanceof Criterion ) { throw new IllegalArgumentException ( STRING + STRING ) ; } Map otherMap = otherCriteria . getValues ( ) ; Set otherKeys = otherMap . keySet ( ) ; for ( Iterator i = otherKeys . iterator ( ) ; i . hasNext ( ) ; ) { String field = ( String ) i . next ( ) ; Object value = otherMap . get ( field ) ; JSOHelper . setAttribute ( jsObj , field , value ) ; } }
protected boolean updateAttachmentPoint ( ) { boolean moved = _BOOL ; this . oldAPs = attachmentPoints ; if ( attachmentPoints == null || attachmentPoints . isEmpty ( ) ) return _BOOL ; List < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; if ( attachmentPoints != null ) apList . addAll ( attachmentPoints ) ; Map < Long , AttachmentPoint > newMap = getAPMap ( apList ) ; if ( newMap == null || newMap . size ( ) != apList . size ( ) ) { moved = _BOOL ; } if ( moved ) { log . info ( STRING , attachmentPoints , newMap ) ; List < AttachmentPoint > newAPList = new ArrayList < AttachmentPoint > ( ) ; if ( newMap != null ) newAPList . addAll ( newMap . values ( ) ) ; this . attachmentPoints = newAPList ; } return moved ; }
protected boolean updateAttachmentPoint ( ) { boolean moved = _BOOL ; this . oldAPs = attachmentPoints ; if ( attachmentPoints == null || attachmentPoints . isEmpty ( ) ) return _BOOL ; List < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; if ( attachmentPoints != null ) apList . addAll ( attachmentPoints ) ; Map < Long , AttachmentPoint > newMap = getAPMap ( apList ) ; if ( newMap == null || newMap . size ( ) != apList . size ( ) ) { moved = _BOOL ; } if ( moved ) { log . info ( STRING , attachmentPoints , newMap ) ; List < AttachmentPoint > newAPList = new ArrayList < AttachmentPoint > ( ) ; if ( newMap != null ) newAPList . addAll ( newMap . values ( ) ) ; this . attachmentPoints = newAPList ; } return moved ; }
protected boolean updateAttachmentPoint ( ) { boolean moved = _BOOL ; this . oldAPs = attachmentPoints ; if ( attachmentPoints == null || attachmentPoints . isEmpty ( ) ) return _BOOL ; List < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; if ( attachmentPoints != null ) apList . addAll ( attachmentPoints ) ; Map < Long , AttachmentPoint > newMap = getAPMap ( apList ) ; if ( newMap == null || newMap . size ( ) != apList . size ( ) ) { moved = _BOOL ; } if ( moved ) { log . info ( STRING , attachmentPoints , newMap ) ; List < AttachmentPoint > newAPList = new ArrayList < AttachmentPoint > ( ) ; if ( newMap != null ) newAPList . addAll ( newMap . values ( ) ) ; this . attachmentPoints = newAPList ; } return moved ; }
protected boolean updateAttachmentPoint ( ) { boolean moved = _BOOL ; this . oldAPs = attachmentPoints ; if ( attachmentPoints == null || attachmentPoints . isEmpty ( ) ) return _BOOL ; List < AttachmentPoint > apList = new ArrayList < AttachmentPoint > ( ) ; if ( attachmentPoints != null ) apList . addAll ( attachmentPoints ) ; Map < Long , AttachmentPoint > newMap = getAPMap ( apList ) ; if ( newMap == null || newMap . size ( ) != apList . size ( ) ) { moved = _BOOL ; } if ( moved ) { log . info ( STRING , attachmentPoints , newMap ) ; List < AttachmentPoint > newAPList = new ArrayList < AttachmentPoint > ( ) ; if ( newMap != null ) newAPList . addAll ( newMap . values ( ) ) ; this . attachmentPoints = newAPList ; } return moved ; }
@ Override public Iterator < JdbcRow > iterator ( ) { return _rowList . iterator ( ) ; }
@ Override public Iterator < JdbcRow > iterator ( ) { return _rowList . iterator ( ) ; }
public boolean moveToNext ( ) { try { return rs . next ( ) ; } catch ( SQLException e ) { LOG . warn ( STRING , e ) ; } return _BOOL ; }
public boolean moveToNext ( ) { try { return rs . next ( ) ; } catch ( SQLException e ) { LOG . warn ( STRING , e ) ; } return _BOOL ; }
private void addInternalHeaderFields ( String name , String value ) { String key = name . toUpperCase ( ) ; Vector < String > v = getHeaders ( key ) ; if ( v == null ) { v = new Vector < > ( ) ; mHeaderFields . put ( key , v ) ; } if ( value != null ) { v . add ( value ) ; } else { mHeaderFields . remove ( key ) ; } }
public void addChild ( BaseAssemblyNode childNode ) { childNode . parentNode = this ; childNodes . add ( childNode ) ; }
@ Override public void write ( DataOutput out ) throws IOException { out . writeLong ( duration ) ; out . writeInt ( getLength ( ) ) ; for ( int i = _NUM ; i < quantizedCoeffs . length ; i ++ ) { out . writeShort ( quantizedCoeffs [ i ] ) ; } out . write ( quantizedResidual ) ; }
public void addFirmwareUpdateCallback ( OneSheeldFirmwareUpdateCallback firmwareUpdateCallback ) { if ( firmwareUpdateCallback != null && ! firmwareUpdateCallbacks . contains ( firmwareUpdateCallback ) ) firmwareUpdateCallbacks . add ( firmwareUpdateCallback ) ; }
double percentToAproxY ( Rectangle2D . Double area ) { return percentY * area . getHeight ( ) ; }
public void write ( String record ) throws IOException { Chunk ch = currentChunk ( ) ; boolean hasNewLine = record . endsWith ( STRING ) ; int rawBytesToWrite = record . length ( ) ; if ( ! hasNewLine ) { rawBytesToWrite += _NUM ; } if ( ( ch . rawBytes + rawBytesToWrite ) > chunkThreshold ) { finishChunk ( ) ; initChunkWriter ( ) ; Chunk newCh = new Chunk ( ) ; newCh . firstOffset = ch . firstOffset + ch . numRecords ; newCh . byteOffset = ch . byteOffset + ch . compressedByteLength ; chunks . add ( newCh ) ; ch = newCh ; } writer . append ( record ) ; if ( ! hasNewLine ) { writer . newLine ( ) ; } ch . rawBytes += rawBytesToWrite ; ch . numRecords ++ ; }
public void write ( String record ) throws IOException { Chunk ch = currentChunk ( ) ; boolean hasNewLine = record . endsWith ( STRING ) ; int rawBytesToWrite = record . length ( ) ; if ( ! hasNewLine ) { rawBytesToWrite += _NUM ; } if ( ( ch . rawBytes + rawBytesToWrite ) > chunkThreshold ) { finishChunk ( ) ; initChunkWriter ( ) ; Chunk newCh = new Chunk ( ) ; newCh . firstOffset = ch . firstOffset + ch . numRecords ; newCh . byteOffset = ch . byteOffset + ch . compressedByteLength ; chunks . add ( newCh ) ; ch = newCh ; } writer . append ( record ) ; if ( ! hasNewLine ) { writer . newLine ( ) ; } ch . rawBytes += rawBytesToWrite ; ch . numRecords ++ ; }
public static String format ( Date date ) { DateFormat dateFormat = new SimpleDateFormat ( DateField . FORMAT ) ; return date == null ? null : dateFormat . format ( date ) ; }
public int size ( ) { return m_map . size ( ) ; }
public int size ( ) { return m_map . size ( ) ; }
public int size ( ) { return m_map . size ( ) ; }
public int size ( ) { return m_map . size ( ) ; }
public int size ( ) { return m_map . size ( ) ; }
public int size ( ) { return m_map . size ( ) ; }
public CloseableAnimatedBitmap ( List < Bitmap > bitmaps , List < Integer > durations , ResourceReleaser < Bitmap > resourceReleaser ) { Preconditions . checkNotNull ( bitmaps ) ; Preconditions . checkState ( bitmaps . size ( ) >= _NUM , STRING ) ; mBitmaps = new ArrayList < > ( bitmaps . size ( ) ) ; mBitmapReferences = new ArrayList < > ( bitmaps . size ( ) ) ; for ( Bitmap bitmap : bitmaps ) { mBitmapReferences . add ( CloseableReference . of ( bitmap , resourceReleaser ) ) ; mBitmaps . add ( bitmap ) ; } mDurations = Preconditions . checkNotNull ( durations ) ; Preconditions . checkState ( mDurations . size ( ) == mBitmaps . size ( ) , STRING ) ; }
private Map < Byte , LongList > pickTopSocialProofs ( SmallArrayBasedLongToDoubleMap [ ] socialProofs , byte [ ] validSocialProofs , int maxSocialProofSize ) { Map < Byte , LongList > results = new HashMap < Byte , LongList > ( ) ; int length = validSocialProofs . length ; for ( int i = _NUM ; i < length ; i ++ ) { SmallArrayBasedLongToDoubleMap socialProof = socialProofs [ validSocialProofs [ i ] ] ; if ( socialProof != null ) { if ( socialProof . size ( ) > _NUM ) { socialProof . sort ( ) ; } socialProof . trim ( maxSocialProofSize ) ; results . put ( ( byte ) i , new LongArrayList ( socialProof . keys ( ) ) ) ; } } return results ; }
private void addNeurons ( ) { double number = Utils . doubleParsable ( numNeurons ) ; if ( ! Double . isNaN ( number ) ) { number = ( int ) number ; Network net = networkPanel . getNetwork ( ) ; for ( int i = _NUM ; i < number ; i ++ ) { addedNeurons . add ( new Neuron ( net , baseNeuron ) ) ; } networkPanel . addNeuronsToPanel ( addedNeurons , selectLayout . getCurrentLayout ( ) ) ; } }
private void validateNames ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . getNames ( ) ; String name = parameter . getName ( ) ; if ( ! contains ( options , name ) ) { String require = label . getName ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } } } }
private void validateNames ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . getNames ( ) ; String name = parameter . getName ( ) ; if ( ! contains ( options , name ) ) { String require = label . getName ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } } } }
private void validateNames ( Label label , Parameter parameter ) throws Exception { String [ ] options = label . getNames ( ) ; String name = parameter . getName ( ) ; if ( ! contains ( options , name ) ) { String require = label . getName ( ) ; if ( name != require ) { if ( name == null || require == null ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } if ( ! name . equals ( require ) ) { throw new ConstructorException ( STRING , label , name , parameter ) ; } } } }
private void clearDictionaryCache ( ) { Map < String , Dictionary > dictionaryCaches = surrogateKeyGen . getDictionaryCaches ( ) ; List < Dictionary > reverseDictionaries = new ArrayList < > ( dictionaryCaches . values ( ) ) ; for ( int i = _NUM ; i < reverseDictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverseDictionaries . get ( i ) ; dictionary . clear ( ) ; } }
private void clearDictionaryCache ( ) { Map < String , Dictionary > dictionaryCaches = surrogateKeyGen . getDictionaryCaches ( ) ; List < Dictionary > reverseDictionaries = new ArrayList < > ( dictionaryCaches . values ( ) ) ; for ( int i = _NUM ; i < reverseDictionaries . size ( ) ; i ++ ) { Dictionary dictionary = reverseDictionaries . get ( i ) ; dictionary . clear ( ) ; } }
public boolean endsWith ( final String str ) { if ( str == null ) { return _BOOL ; } final int len = str . length ( ) ; if ( len == _NUM ) { return _BOOL ; } if ( len > size ) { return _BOOL ; } int pos = size - len ; for ( int i = _NUM ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public boolean endsWith ( final String str ) { if ( str == null ) { return _BOOL ; } final int len = str . length ( ) ; if ( len == _NUM ) { return _BOOL ; } if ( len > size ) { return _BOOL ; } int pos = size - len ; for ( int i = _NUM ; i < len ; i ++ , pos ++ ) { if ( buffer [ pos ] != str . charAt ( i ) ) { return _BOOL ; } } return _BOOL ; }
public int [ ] valueArray ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , _NUM , array , _NUM , count ) ; return array ; }
public int [ ] valueArray ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , _NUM , array , _NUM , count ) ; return array ; }
public int [ ] valueArray ( int [ ] array ) { if ( array == null || array . length != size ( ) ) { array = new int [ count ] ; } System . arraycopy ( values , _NUM , array , _NUM , count ) ; return array ; }
public Object apply ( String source , int lineNo , int columnNo , Object funcBody , Vector paramNames , Vector arguments ) throws BSFException { Object object = eval ( source , lineNo , columnNo , funcBody ) ; if ( object instanceof Closure ) { Closure closure = ( Closure ) object ; return closure . call ( arguments . toArray ( ) ) ; } return object ; }
@ Override public void onDraw ( Canvas canvas ) { mLastDrawTimeMs = System . currentTimeMillis ( ) ; super . onDraw ( canvas ) ; }
@ Override public void onDraw ( Canvas canvas ) { mLastDrawTimeMs = System . currentTimeMillis ( ) ; super . onDraw ( canvas ) ; }
@ Override public PartitionKeyGroup deletePartitionKeyGroup ( PartitionKeyGroupKey partitionKeyGroupKey ) { partitionKeyGroupHelper . validatePartitionKeyGroupKey ( partitionKeyGroupKey ) ; PartitionKeyGroupEntity partitionKeyGroupEntity = partitionKeyGroupDaoHelper . getPartitionKeyGroupEntity ( partitionKeyGroupKey ) ; if ( businessObjectFormatDao . getBusinessObjectFormatCount ( partitionKeyGroupEntity ) > _NUM ) { throw new IllegalArgumentException ( String . format ( STRING , partitionKeyGroupKey . getPartitionKeyGroupName ( ) ) ) ; } partitionKeyGroupDao . delete ( partitionKeyGroupEntity ) ; return createPartitionKeyGroupFromEntity ( partitionKeyGroupEntity ) ; }
private boolean evict ( ) { while ( isOverflow ( ) ) { Node < K , V > node = sentinel . getNext ( ) ; if ( node == sentinel ) { return _BOOL ; } else if ( policy . onEvict ( this , node ) ) { if ( data . remove ( node . getKey ( ) , new Identity ( node ) ) ) { length . decrementAndGet ( ) ; node . remove ( ) ; listener . onEviction ( node . getKey ( ) , node . getValue ( ) ) ; return _BOOL ; } } } return _BOOL ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public ZoneOffsetTransition nextTransition ( Instant instant ) { if ( savingsInstantTransitions . length == _NUM ) { return null ; } long epochSec = instant . getEpochSecond ( ) ; if ( epochSec >= savingsInstantTransitions [ savingsInstantTransitions . length - _NUM ] ) { if ( lastRules . length == _NUM ) { return null ; } int year = findYear ( epochSec , wallOffsets [ wallOffsets . length - _NUM ] ) ; ZoneOffsetTransition [ ] transArray = findTransitionArray ( year ) ; for ( ZoneOffsetTransition trans : transArray ) { if ( epochSec < trans . toEpochSecond ( ) ) { return trans ; } } if ( year < Year . MAX_VALUE ) { transArray = findTransitionArray ( year + _NUM ) ; return transArray [ _NUM ] ; } return null ; } int index = Arrays . binarySearch ( savingsInstantTransitions , epochSec ) ; if ( index < _NUM ) { index = - index - _NUM ; } else { index += _NUM ; } return new ZoneOffsetTransition ( savingsInstantTransitions [ index ] , wallOffsets [ index ] , wallOffsets [ index + _NUM ] ) ; }
public boolean ignoreUserProfile ( ) { String profile = null ; try { profile = ssoToken . getProperty ( ISAuthConstants . USER_PROFILE ) ; } catch ( SSOException e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( ISAuthConstants . IGNORE ) ) ; }
public boolean ignoreUserProfile ( ) { String profile = null ; try { profile = ssoToken . getProperty ( ISAuthConstants . USER_PROFILE ) ; } catch ( SSOException e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( ISAuthConstants . IGNORE ) ) ; }
public boolean ignoreUserProfile ( ) { String profile = null ; try { profile = ssoToken . getProperty ( ISAuthConstants . USER_PROFILE ) ; } catch ( SSOException e ) { debug . warning ( STRING , e ) ; } return ( ( profile != null ) && profile . equals ( ISAuthConstants . IGNORE ) ) ; }
public void addEntry ( Entry e , int dataSetIndex ) { if ( mDataSets . size ( ) > dataSetIndex && dataSetIndex >= _NUM ) { float val = e . getVal ( ) ; mYValCount += _NUM ; mYValueSum += val ; if ( mYMax < val ) mYMax = val ; if ( mYMin > val ) mYMin = val ; T set = mDataSets . get ( dataSetIndex ) ; if ( set != null ) { if ( set . getAxisDependency ( ) == AxisDependency . LEFT ) { if ( mLeftAxisMax < e . getVal ( ) ) mLeftAxisMax = e . getVal ( ) ; if ( mLeftAxisMin > e . getVal ( ) ) mLeftAxisMin = e . getVal ( ) ; } else { if ( mRightAxisMax < e . getVal ( ) ) mRightAxisMax = e . getVal ( ) ; if ( mRightAxisMin > e . getVal ( ) ) mRightAxisMin = e . getVal ( ) ; } handleEmptyAxis ( getFirstLeft ( ) , getFirstRight ( ) ) ; set . addEntry ( e ) ; } } else { Log . e ( STRING , STRING ) ; } }
public void addEntry ( Entry e , int dataSetIndex ) { if ( mDataSets . size ( ) > dataSetIndex && dataSetIndex >= _NUM ) { float val = e . getVal ( ) ; mYValCount += _NUM ; mYValueSum += val ; if ( mYMax < val ) mYMax = val ; if ( mYMin > val ) mYMin = val ; T set = mDataSets . get ( dataSetIndex ) ; if ( set != null ) { if ( set . getAxisDependency ( ) == AxisDependency . LEFT ) { if ( mLeftAxisMax < e . getVal ( ) ) mLeftAxisMax = e . getVal ( ) ; if ( mLeftAxisMin > e . getVal ( ) ) mLeftAxisMin = e . getVal ( ) ; } else { if ( mRightAxisMax < e . getVal ( ) ) mRightAxisMax = e . getVal ( ) ; if ( mRightAxisMin > e . getVal ( ) ) mRightAxisMin = e . getVal ( ) ; } handleEmptyAxis ( getFirstLeft ( ) , getFirstRight ( ) ) ; set . addEntry ( e ) ; } } else { Log . e ( STRING , STRING ) ; } }
@ Override default CompletableFuture < OptionalDouble > averageInt ( final ToIntFunction < ? super T > fn ) { return CompletableFuture . supplyAsync ( null , getExec ( ) ) ; }
public static String removeFormatting ( String line ) { int length = line . length ( ) ; StringBuilder buffer = new StringBuilder ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char ch = line . charAt ( i ) ; if ( ch != STRING && ch != STRING && ch != STRING && ch != STRING ) buffer . append ( ch ) ; } return buffer . toString ( ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
public static Request newUploadVideoRequest ( Session session , File file , Callback callback ) throws FileNotFoundException { ParcelFileDescriptor descriptor = ParcelFileDescriptor . open ( file , ParcelFileDescriptor . MODE_READ_ONLY ) ; Bundle parameters = new Bundle ( _NUM ) ; parameters . putParcelable ( file . getName ( ) , descriptor ) ; return new Request ( session , MY_VIDEOS , parameters , HttpMethod . POST , callback ) ; }
private void removeOMADownloadFromSharedPrefs ( long downloadId ) { Set < String > omaDownloads = getStoredDownloadInfo ( PENDING_OMA_DOWNLOADS ) ; for ( String omaDownload : omaDownloads ) { OMAEntry entry = OMAEntry . parseOMAEntry ( omaDownload ) ; if ( entry . mDownloadId == downloadId ) { omaDownloads . remove ( omaDownload ) ; storeDownloadInfo ( PENDING_OMA_DOWNLOADS , omaDownloads ) ; return ; } } }
public static void writeStatistics ( TDoubleObjectHashMap < DescriptiveStatistics > statsMap , String keyLabel , String file ) throws IOException { double [ ] keys = statsMap . keys ( ) ; Arrays . sort ( keys ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( keyLabel ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . newLine ( ) ; for ( double key : keys ) { DescriptiveStatistics stats = statsMap . get ( key ) ; writer . write ( String . valueOf ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getPercentile ( _NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMin ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMax ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getN ( ) ) ) ; writer . newLine ( ) ; } writer . close ( ) ; }
public static void writeStatistics ( TDoubleObjectHashMap < DescriptiveStatistics > statsMap , String keyLabel , String file ) throws IOException { double [ ] keys = statsMap . keys ( ) ; Arrays . sort ( keys ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( keyLabel ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . newLine ( ) ; for ( double key : keys ) { DescriptiveStatistics stats = statsMap . get ( key ) ; writer . write ( String . valueOf ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getPercentile ( _NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMin ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMax ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getN ( ) ) ) ; writer . newLine ( ) ; } writer . close ( ) ; }
public static void writeStatistics ( TDoubleObjectHashMap < DescriptiveStatistics > statsMap , String keyLabel , String file ) throws IOException { double [ ] keys = statsMap . keys ( ) ; Arrays . sort ( keys ) ; BufferedWriter writer = new BufferedWriter ( new FileWriter ( file ) ) ; writer . write ( keyLabel ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . write ( TAB ) ; writer . write ( STRING ) ; writer . newLine ( ) ; for ( double key : keys ) { DescriptiveStatistics stats = statsMap . get ( key ) ; writer . write ( String . valueOf ( key ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMean ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getPercentile ( _NUM ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMin ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getMax ( ) ) ) ; writer . write ( TAB ) ; writer . write ( String . valueOf ( stats . getN ( ) ) ) ; writer . newLine ( ) ; } writer . close ( ) ; }
public ClassFileReader ( ClassAnalysisStats analysisStats ) { this . analysisStats = analysisStats ; }
public void debugPrint ( String name , PrintStream out ) throws AdeException { if ( name != null ) { out . println ( STRING + name + STRING + getLLMax ( ) ) ; } if ( m_pointScores != null && ! m_pointScores . isEmpty ( ) ) { for ( Entry < Integer , Double > pointScore : m_pointScores . entrySet ( ) ) { out . println ( STRING + pointScore . getKey ( ) + STRING + pointScore . getValue ( ) ) ; } out . println ( STRING + - m_logHalf ) ; } }
public static byte [ ] decode ( String s ) throws java . io . IOException { return decode ( s , NO_OPTIONS ) ; }
@ Override public ClientSocket openIfLive ( ) { if ( _state . isClosed ( ) ) { return null ; } ClientSocket stream = openRecycle ( ) ; if ( stream != null ) return stream ; long now = CurrentTime . currentTime ( ) ; if ( isFailed ( now ) ) return null ; else if ( _state == State . FAIL && _startingCount . get ( ) > _NUM ) { return null ; } return connect ( ) ; }
public void initWithoutJUnitForFixture ( Class fixture , Method method ) { this . testClass = fixture ; this . testMethodName = method . getName ( ) ; }
public void initWithoutJUnitForFixture ( Class fixture , Method method ) { this . testClass = fixture ; this . testMethodName = method . getName ( ) ; }
public void initWithoutJUnitForFixture ( Class fixture , Method method ) { this . testClass = fixture ; this . testMethodName = method . getName ( ) ; }
private static boolean hasAttr ( SvcReg reg , EntryClass eclass , int fldidx , Object value ) { EntryRep [ ] sets = reg . item . attributeSets ; for ( int i = sets . length ; -- i >= _NUM ; ) { EntryRep set = sets [ i ] ; if ( eclass . isAssignableFrom ( set . eclass ) && ( ( value == null && set . fields [ fldidx ] == null ) || ( value != null && value . equals ( set . fields [ fldidx ] ) ) ) ) return _BOOL ; } return _BOOL ; }
private static boolean hasAttr ( SvcReg reg , EntryClass eclass , int fldidx , Object value ) { EntryRep [ ] sets = reg . item . attributeSets ; for ( int i = sets . length ; -- i >= _NUM ; ) { EntryRep set = sets [ i ] ; if ( eclass . isAssignableFrom ( set . eclass ) && ( ( value == null && set . fields [ fldidx ] == null ) || ( value != null && value . equals ( set . fields [ fldidx ] ) ) ) ) return _BOOL ; } return _BOOL ; }
private RrdEntry requestEmpty ( String path ) throws InterruptedException , IOException { RrdEntry ref = waitEmpty ( path ) ; ref . count = _NUM ; return ref ; }
public void delete ( int ... indices ) { int [ ] idx2 = indices . clone ( ) ; if ( idx2 . length > _NUM ) { Arrays . sort ( idx2 ) ; for ( int i = idx2 . length - _NUM ; i >= _NUM ; i -- ) { items . remove ( idx2 [ i ] ) ; } fireTableRowsDeleted ( idx2 [ _NUM ] , idx2 [ idx2 . length - _NUM ] ) ; } }
public void auditCallhome ( OperationTypeEnum auditType , String operationalStatus , String description , Object ... descparams ) { _auditMgr . recordAuditLog ( null , null , EVENT_SERVICE_TYPE , auditType , System . currentTimeMillis ( ) , operationalStatus , description , descparams ) ; }
private void insertUsedContextPrefixes ( ) { int unknownPrefixesCount = unknownPrefixesInXMLLiteral . size ( ) ; if ( unknownPrefixesCount > _NUM ) { StringBuilder contextPrefixes = new StringBuilder ( _NUM ) ; ElementInfo topElement = peekStack ( ) ; for ( int i = _NUM ; i < unknownPrefixesCount ; i ++ ) { String prefix = unknownPrefixesInXMLLiteral . get ( i ) ; String namespace = topElement . getNamespace ( prefix ) ; if ( namespace != null ) { appendNamespaceDecl ( contextPrefixes , prefix , namespace ) ; } } int endOfFirstStartTag = charBuf . indexOf ( STRING ) ; charBuf . insert ( endOfFirstStartTag , contextPrefixes . toString ( ) ) ; } unknownPrefixesInXMLLiteral . clear ( ) ; }
private void insertUsedContextPrefixes ( ) { int unknownPrefixesCount = unknownPrefixesInXMLLiteral . size ( ) ; if ( unknownPrefixesCount > _NUM ) { StringBuilder contextPrefixes = new StringBuilder ( _NUM ) ; ElementInfo topElement = peekStack ( ) ; for ( int i = _NUM ; i < unknownPrefixesCount ; i ++ ) { String prefix = unknownPrefixesInXMLLiteral . get ( i ) ; String namespace = topElement . getNamespace ( prefix ) ; if ( namespace != null ) { appendNamespaceDecl ( contextPrefixes , prefix , namespace ) ; } } int endOfFirstStartTag = charBuf . indexOf ( STRING ) ; charBuf . insert ( endOfFirstStartTag , contextPrefixes . toString ( ) ) ; } unknownPrefixesInXMLLiteral . clear ( ) ; }
public static NumberFormat makeNumberFormat ( int digits ) { switch ( digits ) { case _NUM : return NF0 ; case _NUM : return NF2 ; case _NUM : return NF3 ; case _NUM : return NF4 ; case _NUM : return NF6 ; case _NUM : return NF8 ; } final NumberFormat nf = NumberFormat . getInstance ( Locale . US ) ; nf . setMaximumFractionDigits ( digits ) ; nf . setMinimumFractionDigits ( digits ) ; nf . setGroupingUsed ( _BOOL ) ; return nf ; }
private Map < Long , Pair < String , Long > > recoverPendingLargeMessages ( ) throws Exception { Map < Long , Pair < String , Long > > largeMessages = new HashMap < > ( ) ; List < String > filenames = largeMessagesFactory . listFiles ( STRING ) ; List < Long > idList = new ArrayList < > ( ) ; for ( String filename : filenames ) { Long id = getLargeMessageIdFromFilename ( filename ) ; if ( ! largeMessagesToDelete . contains ( id ) ) { idList . add ( id ) ; SequentialFile seqFile = largeMessagesFactory . createSequentialFile ( filename ) ; long size = seqFile . size ( ) ; largeMessages . put ( id , new Pair < > ( filename , size ) ) ; } } return largeMessages ; }
public TrieNode find ( String word ) { return ( word . length ( ) < _NUM ? null : find ( word , root , _NUM ) ) ; }
public TrieNode find ( String word ) { return ( word . length ( ) < _NUM ? null : find ( word , root , _NUM ) ) ; }
public TrieNode find ( String word ) { return ( word . length ( ) < _NUM ? null : find ( word , root , _NUM ) ) ; }
private void putParametersFromS3 ( String s3BucketName , String s3ObjectKey , Map < String , Object > parameters ) { if ( s3BucketName != null && s3ObjectKey != null ) { S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto = storageHelper . getS3FileTransferRequestParamsDto ( ) ; Properties properties = s3Dao . getProperties ( s3BucketName , s3ObjectKey , s3FileTransferRequestParamsDto ) ; parameters . putAll ( javaPropertiesHelper . toMap ( properties ) ) ; } }
private void putParametersFromS3 ( String s3BucketName , String s3ObjectKey , Map < String , Object > parameters ) { if ( s3BucketName != null && s3ObjectKey != null ) { S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto = storageHelper . getS3FileTransferRequestParamsDto ( ) ; Properties properties = s3Dao . getProperties ( s3BucketName , s3ObjectKey , s3FileTransferRequestParamsDto ) ; parameters . putAll ( javaPropertiesHelper . toMap ( properties ) ) ; } }
private void putParametersFromS3 ( String s3BucketName , String s3ObjectKey , Map < String , Object > parameters ) { if ( s3BucketName != null && s3ObjectKey != null ) { S3FileTransferRequestParamsDto s3FileTransferRequestParamsDto = storageHelper . getS3FileTransferRequestParamsDto ( ) ; Properties properties = s3Dao . getProperties ( s3BucketName , s3ObjectKey , s3FileTransferRequestParamsDto ) ; parameters . putAll ( javaPropertiesHelper . toMap ( properties ) ) ; } }
protected void addScalarDimension ( int i ) { for ( Dimension dimension : dimensionList ) { if ( dimension . getDimension ( ) == i ) { return ; } } dimensionList . add ( new Dimension ( i ) ) ; }
public static String obtainLock ( EntityManager em , long expiration , long type , String note ) { EntityTransaction tx = null ; try { long now = System . currentTimeMillis ( ) ; tx = em . getTransaction ( ) ; tx . begin ( ) ; GlobalInterlock lock = _findAndRefreshLock ( em , type ) ; if ( lock != null && now - lock . lockTime > expiration ) { em . remove ( lock ) ; em . flush ( ) ; } tx . commit ( ) ; } catch ( Exception ex ) { LOGGER . warn ( STRING , type , ex . getMessage ( ) ) ; LOGGER . debug ( ex . getMessage ( ) , ex ) ; if ( tx != null && tx . isActive ( ) ) { tx . rollback ( ) ; } } try { tx = em . getTransaction ( ) ; tx . begin ( ) ; GlobalInterlock lock = em . merge ( new GlobalInterlock ( type , note ) ) ; em . flush ( ) ; tx . commit ( ) ; return Long . toHexString ( lock . lockTime ) ; } catch ( Exception ex ) { throw new GlobalInterlockException ( STRING + type + STRING , ex ) ; } finally { if ( tx != null && tx . isActive ( ) ) { tx . rollback ( ) ; } } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public void projectionChanged ( ProjectionEvent e ) { Projection newProj = e . getProjection ( ) ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( newProj != null ? newProj . toString ( ) : STRING ) ; } if ( newProj != null && ( projection == null || ( ! projection . equals ( newProj ) ) ) ) { setProjection ( ( Projection ) newProj . makeClone ( ) ) ; Object source = e . getSource ( ) ; if ( source instanceof Component ) { projComponent = ( Component ) source ; } } }
public void projectionChanged ( ProjectionEvent e ) { Projection newProj = e . getProjection ( ) ; if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( newProj != null ? newProj . toString ( ) : STRING ) ; } if ( newProj != null && ( projection == null || ( ! projection . equals ( newProj ) ) ) ) { setProjection ( ( Projection ) newProj . makeClone ( ) ) ; Object source = e . getSource ( ) ; if ( source instanceof Component ) { projComponent = ( Component ) source ; } } }
public static String BinToChar ( String bin ) { char value [ ] = new char [ bin . length ( ) / _NUM ] ; int binLength = value . length ; for ( int i = _NUM ; i < binLength ; i ++ ) value [ i ] = ( char ) Integer . parseInt ( bin . substring ( _NUM * i , _NUM * i + _NUM ) , _NUM ) ; return new String ( value ) ; }
public static String BinToChar ( String bin ) { char value [ ] = new char [ bin . length ( ) / _NUM ] ; int binLength = value . length ; for ( int i = _NUM ; i < binLength ; i ++ ) value [ i ] = ( char ) Integer . parseInt ( bin . substring ( _NUM * i , _NUM * i + _NUM ) , _NUM ) ; return new String ( value ) ; }
public void onRestoreInstanceState ( Bundle savedInstanceState ) { mSelectedPositions . addAll ( savedInstanceState . getIntegerArrayList ( TAG ) ) ; Log . d ( TAG , STRING + mSelectedPositions ) ; }
public boolean isAdjacent ( Cell c ) { if ( equals ( c ) ) return _BOOL ; if ( col == c . col ) { return ( Math . abs ( row - c . row ) == _NUM ) ; } if ( row == c . row ) { return ( Math . abs ( col - c . col ) == _NUM ) ; } return _BOOL ; }
public boolean isAdjacent ( Cell c ) { if ( equals ( c ) ) return _BOOL ; if ( col == c . col ) { return ( Math . abs ( row - c . row ) == _NUM ) ; } if ( row == c . row ) { return ( Math . abs ( col - c . col ) == _NUM ) ; } return _BOOL ; }
private boolean yy_refill ( ) throws java . io . IOException { if ( yy_reader == null ) return _BOOL ; if ( yy_startRead > _NUM ) { System . arraycopy ( yy_buffer , yy_startRead , yy_buffer , _NUM , yy_endRead - yy_startRead ) ; yy_endRead -= yy_startRead ; yy_currentPos -= yy_startRead ; yy_markedPos -= yy_startRead ; yy_pushbackPos -= yy_startRead ; yy_startRead = _NUM ; } if ( yy_currentPos >= yy_buffer . length ) { char newBuffer [ ] = new char [ yy_currentPos * _NUM ] ; System . arraycopy ( yy_buffer , _NUM , newBuffer , _NUM , yy_buffer . length ) ; yy_buffer = newBuffer ; } int numRead = yy_reader . read ( yy_buffer , yy_endRead , yy_buffer . length - yy_endRead ) ; if ( numRead < _NUM ) { return _BOOL ; } else { yy_endRead += numRead ; return _BOOL ; } }
private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH_MODE_IDLE ; boolean commitChange = ev . getAction ( ) == MotionEvent . ACTION_UP && isEnabled ( ) ; cancelSuperTouch ( ev ) ; if ( commitChange ) { boolean newState ; mVelocityTracker . computeCurrentVelocity ( _NUM ) ; float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = xvel > _NUM ; } else { newState = getTargetCheckedState ( ) ; } animateThumbToCheckedState ( newState ) ; } else { animateThumbToCheckedState ( isChecked ( ) ) ; } }
private void stopDrag ( MotionEvent ev ) { mTouchMode = TOUCH_MODE_IDLE ; boolean commitChange = ev . getAction ( ) == MotionEvent . ACTION_UP && isEnabled ( ) ; cancelSuperTouch ( ev ) ; if ( commitChange ) { boolean newState ; mVelocityTracker . computeCurrentVelocity ( _NUM ) ; float xvel = mVelocityTracker . getXVelocity ( ) ; if ( Math . abs ( xvel ) > mMinFlingVelocity ) { newState = xvel > _NUM ; } else { newState = getTargetCheckedState ( ) ; } animateThumbToCheckedState ( newState ) ; } else { animateThumbToCheckedState ( isChecked ( ) ) ; } }
public final Entry addEntry ( Position inputPosition , Position outputPosition ) { Entry entry = new Entry ( inputPosition , outputPosition ) ; entries . add ( entry ) ; return entry ; }
public final Entry addEntry ( Position inputPosition , Position outputPosition ) { Entry entry = new Entry ( inputPosition , outputPosition ) ; entries . add ( entry ) ; return entry ; }
public static int findURISplitIndex ( String uri ) { int uriLength = uri . length ( ) ; int i = uriLength - _NUM ; while ( i >= _NUM ) { char c = uri . charAt ( i ) ; if ( c == STRING || c == STRING || ! XMLUtil . isNCNameChar ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uriLength ) { char c = uri . charAt ( i ) ; if ( c == STRING || XMLUtil . isLetter ( c ) ) { break ; } i ++ ; } if ( i == uriLength ) { i = - _NUM ; } return i ; }
public static int findURISplitIndex ( String uri ) { int uriLength = uri . length ( ) ; int i = uriLength - _NUM ; while ( i >= _NUM ) { char c = uri . charAt ( i ) ; if ( c == STRING || c == STRING || ! XMLUtil . isNCNameChar ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uriLength ) { char c = uri . charAt ( i ) ; if ( c == STRING || XMLUtil . isLetter ( c ) ) { break ; } i ++ ; } if ( i == uriLength ) { i = - _NUM ; } return i ; }
public static int findURISplitIndex ( String uri ) { int uriLength = uri . length ( ) ; int i = uriLength - _NUM ; while ( i >= _NUM ) { char c = uri . charAt ( i ) ; if ( c == STRING || c == STRING || ! XMLUtil . isNCNameChar ( c ) ) { break ; } i -- ; } i ++ ; while ( i < uriLength ) { char c = uri . charAt ( i ) ; if ( c == STRING || XMLUtil . isLetter ( c ) ) { break ; } i ++ ; } if ( i == uriLength ) { i = - _NUM ; } return i ; }
public static String realFormatArray ( final double [ ] x ) { final StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING ) ; for ( int i = _NUM ; i < x . length ; i ++ ) { if ( i > _NUM ) { sb . append ( STRING ) ; } sb . append ( realFormat ( x [ i ] ) ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
private void closeConnection ( Session session , GuacamoleStatus guac_status ) { try { int code = guac_status . getWebSocketCode ( ) ; String message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ; session . close ( new CloseStatus ( code , message ) ) ; } catch ( IOException e ) { logger . debug ( STRING , e ) ; } }
private void closeConnection ( Session session , GuacamoleStatus guac_status ) { try { int code = guac_status . getWebSocketCode ( ) ; String message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ; session . close ( new CloseStatus ( code , message ) ) ; } catch ( IOException e ) { logger . debug ( STRING , e ) ; } }
private void closeConnection ( Session session , GuacamoleStatus guac_status ) { try { int code = guac_status . getWebSocketCode ( ) ; String message = Integer . toString ( guac_status . getGuacamoleStatusCode ( ) ) ; session . close ( new CloseStatus ( code , message ) ) ; } catch ( IOException e ) { logger . debug ( STRING , e ) ; } }
public static String fileNameClean ( String s ) { char [ ] chars = s . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( char c : chars ) { if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . toString ( ) ; }
public static String fileNameClean ( String s ) { char [ ] chars = s . toCharArray ( ) ; StringBuilder sb = new StringBuilder ( ) ; for ( char c : chars ) { if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c == STRING ) ) { sb . append ( c ) ; } else { if ( c == STRING || c == STRING ) { sb . append ( STRING ) ; } else { sb . append ( STRING + ( int ) c + STRING ) ; } } } return sb . toString ( ) ; }
private ChildNodeDescriptor insertType ( final DefaultMutableTreeNode parentNode , final BaseType baseType , final int index ) { final BaseTypeTreeNode newNode = new BaseTypeTreeNode ( baseType ) ; parentNode . insert ( newNode , index ) ; createTypeNodes ( newNode , baseType ) ; return new ChildNodeDescriptor ( newNode , index ) ; }
private ChildNodeDescriptor insertType ( final DefaultMutableTreeNode parentNode , final BaseType baseType , final int index ) { final BaseTypeTreeNode newNode = new BaseTypeTreeNode ( baseType ) ; parentNode . insert ( newNode , index ) ; createTypeNodes ( newNode , baseType ) ; return new ChildNodeDescriptor ( newNode , index ) ; }
private ChildNodeDescriptor insertType ( final DefaultMutableTreeNode parentNode , final BaseType baseType , final int index ) { final BaseTypeTreeNode newNode = new BaseTypeTreeNode ( baseType ) ; parentNode . insert ( newNode , index ) ; createTypeNodes ( newNode , baseType ) ; return new ChildNodeDescriptor ( newNode , index ) ; }
public synchronized void add ( Result result , Object payload , String suffix ) { Date date ; date = new Date ( ) ; m_Results . put ( date , result ) ; m_Payloads . put ( date , payload ) ; m_Suffixes . put ( date , suffix ) ; m_Ordered . add ( date ) ; }
private void checkState ( ) throws IllegalStateException { if ( consonants == null ) { throw new IllegalStateException ( STRING ) ; } if ( vowels == null ) { throw new IllegalStateException ( STRING ) ; } if ( consonants . size ( ) == _NUM ) { throw new IllegalStateException ( STRING ) ; } if ( vowels . size ( ) == _NUM ) { throw new IllegalStateException ( STRING ) ; } }
private void checkState ( ) throws IllegalStateException { if ( consonants == null ) { throw new IllegalStateException ( STRING ) ; } if ( vowels == null ) { throw new IllegalStateException ( STRING ) ; } if ( consonants . size ( ) == _NUM ) { throw new IllegalStateException ( STRING ) ; } if ( vowels . size ( ) == _NUM ) { throw new IllegalStateException ( STRING ) ; } }
public void addVolumesToConsistencyGroup ( String cgName , List < String > virtualVolumeNames ) throws VPlexApiException { s_logger . info ( STRING , _baseURI ) ; _cgMgr . addVolumesToConsistencyGroup ( cgName , virtualVolumeNames ) ; }
protected void selectRenderables ( DrawContext dc ) { ArrayList < GraticuleTile > tileList = getVisibleTiles ( dc ) ; if ( tileList . size ( ) > _NUM ) { for ( GraticuleTile gz : tileList ) { gz . selectRenderables ( dc ) ; } } }
public void reset ( ) { localDeque . clear ( ) ; localDeque . push ( new FramePath ( ) ) ; }
public void reset ( ) { localDeque . clear ( ) ; localDeque . push ( new FramePath ( ) ) ; }
public static Explanation noMatch ( String description , Explanation ... details ) { return new Explanation ( _BOOL , _NUM , description , Arrays . asList ( details ) ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
public static String unqualify ( String qualifiedName , char separator ) { return qualifiedName . substring ( qualifiedName . lastIndexOf ( separator ) + _NUM ) ; }
public String replace ( final Map < String , String > params ) { final StringBuilder r = new StringBuilder ( ) ; for ( final Format f : patternOps ) { f . format ( r , params ) ; } return r . toString ( ) ; }
boolean configuring ( ) { return configuring > _NUM ; }
boolean configuring ( ) { return configuring > _NUM ; }
boolean configuring ( ) { return configuring > _NUM ; }
@ Override public List refreshTicks ( Graphics2D g2 , AxisState state , Rectangle2D dataArea , RectangleEdge edge ) { List ticks = null ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { ticks = refreshTicksHorizontal ( g2 , dataArea , edge ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { ticks = refreshTicksVertical ( g2 , dataArea , edge ) ; } return ticks ; }
@ Override public List refreshTicks ( Graphics2D g2 , AxisState state , Rectangle2D dataArea , RectangleEdge edge ) { List ticks = null ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { ticks = refreshTicksHorizontal ( g2 , dataArea , edge ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { ticks = refreshTicksVertical ( g2 , dataArea , edge ) ; } return ticks ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public static boolean isRepeatChar ( char ch ) { return null != repeatCharHashTable . get ( STRING + ch ) ; }
public void loadPDF ( final String input ) { if ( input == null ) { return ; } scale = _NUM ; PDFfile = input ; fileLoc . setText ( PDFfile ) ; if ( input . startsWith ( STRING ) ) { openFile ( null , input , _BOOL ) ; } else { openFile ( new File ( input ) , null , _BOOL ) ; } }
public void loadPDF ( final String input ) { if ( input == null ) { return ; } scale = _NUM ; PDFfile = input ; fileLoc . setText ( PDFfile ) ; if ( input . startsWith ( STRING ) ) { openFile ( null , input , _BOOL ) ; } else { openFile ( new File ( input ) , null , _BOOL ) ; } }
public Artifact ( final String group , final String artifact , final String version ) { if ( group == null || group . isEmpty ( ) ) throw new IllegalArgumentException ( STRING ) ; if ( artifact == null || artifact . isEmpty ( ) ) throw new IllegalArgumentException ( STRING ) ; if ( version == null || version . isEmpty ( ) ) throw new IllegalArgumentException ( STRING ) ; this . group = group ; this . artifact = artifact ; this . version = version ; }
public static double loss ( double pred , double y , double c ) { final double x = y - pred ; if ( Math . abs ( x ) <= c ) return x * x * _NUM ; else return c * ( Math . abs ( x ) - c / _NUM ) ; }
private void addOneLineOfTLA ( String line ) { if ( tlacode . size ( ) != mappingVector . size ( ) ) { PcalDebug . ReportBug ( STRING ) ; } endCurrentLineOfTLA ( ) ; if ( line . length ( ) == _NUM ) { mappingVector . addElement ( new Vector ( _NUM ) ) ; tlacode . addElement ( STRING ) ; return ; } addOneTokenToTLA ( line ) ; endCurrentLineOfTLA ( ) ; }
public TMessage readMessageBegin ( ) throws TException { byte protocolId = readByte ( ) ; if ( protocolId != PROTOCOL_ID ) { throw new TProtocolException ( STRING + Integer . toHexString ( PROTOCOL_ID ) + STRING + Integer . toHexString ( protocolId ) ) ; } byte versionAndType = readByte ( ) ; byte version = ( byte ) ( versionAndType & VERSION_MASK ) ; if ( version != VERSION ) { throw new TProtocolException ( STRING + VERSION + STRING + version ) ; } byte type = ( byte ) ( ( versionAndType > > TYPE_SHIFT_AMOUNT ) & TYPE_BITS ) ; int seqid = readVarint32 ( ) ; String messageName = readString ( ) ; return new TMessage ( messageName , type , seqid ) ; }
private void doubleCapacity ( ) { int p = head ; int n = elements . length ; int r = n - p ; int newCapacity = n << _NUM ; if ( newCapacity < _NUM ) throw new IllegalStateException ( STRING ) ; Object [ ] a = new Object [ newCapacity ] ; System . arraycopy ( elements , p , a , _NUM , r ) ; System . arraycopy ( elements , _NUM , a , r , p ) ; elements = a ; head = _NUM ; tail = n ; }
public void addElement ( E element ) { int index = delegate . size ( ) ; delegate . addElement ( element ) ; fireIntervalAdded ( this , index , index ) ; }
public String removeReferenceHeaderFromBlastMatch ( String blastText ) { int index = blastText . indexOf ( STRING ) ; if ( index == - _NUM ) index = blastText . indexOf ( STRING ) ; if ( index > _NUM ) return blastText . substring ( index ) ; else return blastText ; }
public static Element find ( Node parent , String name ) { NodeList list = parent . getChildNodes ( ) ; for ( int i = _NUM ; i < list . getLength ( ) ; i ++ ) { Node n = list . item ( i ) ; if ( n instanceof Element ) { Element e = ( Element ) n ; if ( name . equals ( e . getAttribute ( STRING ) ) ) { return e ; } } Element r = find ( n , name ) ; if ( r != null ) { return r ; } } return null ; }
public void addMethod ( MappedMember mm ) { methods . add ( mm ) ; }
public void addMethod ( MappedMember mm ) { methods . add ( mm ) ; }
public void removeChangeListener ( ChangeListener cl ) { listeners . remove ( cl ) ; }
public Macro ( File file ) throws EOFException , FileNotFoundException , IOException { DocumentBuilderFactory dbf = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder db = null ; Document doc = null ; try { db = dbf . newDocumentBuilder ( ) ; InputSource is = new InputSource ( new UnicodeReader ( new FileInputStream ( file ) , FILE_ENCODING ) ) ; is . setEncoding ( FILE_ENCODING ) ; doc = db . parse ( is ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; String desc = e . getMessage ( ) ; if ( desc == null ) { desc = e . toString ( ) ; } throw new IOException ( STRING + desc ) ; } macroRecords = new ArrayList ( ) ; boolean parsedOK = initializeFromXMLFile ( doc . getDocumentElement ( ) ) ; if ( parsedOK == _BOOL ) { name = null ; macroRecords . clear ( ) ; macroRecords = null ; throw new IOException ( STRING ) ; } }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
public static Path createTempFileInSameDir ( String fileName ) throws IOException { Path target = Paths . get ( fileName ) ; Path parentPath = target . getParent ( ) ; return DefaultFilepaths . createTempFile ( parentPath , null , null ) ; }
protected void checkBugInstance ( BugInstance bugInstance ) { for ( Iterator < BugAnnotation > i = bugInstance . annotationIterator ( ) ; i . hasNext ( ) ; ) { BugAnnotation bugAnnotation = i . next ( ) ; if ( bugAnnotation instanceof PackageMemberAnnotation ) { PackageMemberAnnotation pkgMember = ( PackageMemberAnnotation ) bugAnnotation ; if ( pkgMember . getSourceLines ( ) == null ) { throw new IllegalStateException ( STRING + pkgMember + STRING ) ; } } } }
public void test_filter_001 ( ) throws IOException { final File basefile = File . createTempFile ( getName ( ) , STRING ) ; try { final String basename = basefile . toString ( ) ; final NameAndExtensionFilter logFilter = new NameAndExtensionFilter ( basename , STRING ) ; assertSameFiles ( new File [ ] { } , logFilter . getFiles ( ) ) ; } finally { basefile . delete ( ) ; } }
public void test_filter_001 ( ) throws IOException { final File basefile = File . createTempFile ( getName ( ) , STRING ) ; try { final String basename = basefile . toString ( ) ; final NameAndExtensionFilter logFilter = new NameAndExtensionFilter ( basename , STRING ) ; assertSameFiles ( new File [ ] { } , logFilter . getFiles ( ) ) ; } finally { basefile . delete ( ) ; } }
public void test_filter_001 ( ) throws IOException { final File basefile = File . createTempFile ( getName ( ) , STRING ) ; try { final String basename = basefile . toString ( ) ; final NameAndExtensionFilter logFilter = new NameAndExtensionFilter ( basename , STRING ) ; assertSameFiles ( new File [ ] { } , logFilter . getFiles ( ) ) ; } finally { basefile . delete ( ) ; } }
public static int findNonMarkNorOtherCharacter ( String text , int column ) { if ( column + _NUM >= text . length ( ) ) { return text . length ( ) + _NUM ; } MatchResult match = RegExpUtils . findMatchAfterIndex ( UnicodeUtils . regexpNotMarkOrOtherExcludingTabAndNewline , text , column ) ; if ( match == null ) { return text . length ( ) + _NUM ; } else { return match . getIndex ( ) ; } }
public char [ ] toCharArray ( ) { if ( size == _NUM ) { return ArrayUtils . EMPTY_CHAR_ARRAY ; } final char chars [ ] = new char [ size ] ; System . arraycopy ( buffer , _NUM , chars , _NUM , size ) ; return chars ; }
public char [ ] toCharArray ( ) { if ( size == _NUM ) { return ArrayUtils . EMPTY_CHAR_ARRAY ; } final char chars [ ] = new char [ size ] ; System . arraycopy ( buffer , _NUM , chars , _NUM , size ) ; return chars ; }
public static BigInt [ ] readArrayOfSizeBigInts ( InputStream in ) throws IOException { Vector A = new Vector ( ) ; int i = _NUM ; try { do { A . addElement ( readSizeBigInt ( in ) ) ; i ++ ; } while ( _BOOL ) ; } catch ( IOException e ) { } BigInt [ ] bA = new BigInt [ i ] ; for ( int j = _NUM ; j < i ; j ++ ) bA [ j ] = ( BigInt ) A . elementAt ( j ) ; return bA ; }
public boolean checkParity ( ) { int len = getNumDataElements ( ) ; int chksum = _NUM ; int loop ; for ( loop = _NUM ; loop < len - _NUM ; loop ++ ) { chksum ^= getElement ( loop ) ; } return ( ( chksum & _NUM ) == getElement ( len - _NUM ) ) ; }
public boolean checkParity ( ) { int len = getNumDataElements ( ) ; int chksum = _NUM ; int loop ; for ( loop = _NUM ; loop < len - _NUM ; loop ++ ) { chksum ^= getElement ( loop ) ; } return ( ( chksum & _NUM ) == getElement ( len - _NUM ) ) ; }
public void add ( double radians [ ] ) { ESRIPoly newPoly = new ESRIPoly . ESRIFloatPoly ( radians ) ; int numParts = polygons . length ; ESRIPoly oldPolys [ ] = polygons ; polygons = new ESRIPoly [ numParts + _NUM ] ; System . arraycopy ( oldPolys , _NUM , polygons , _NUM , numParts ) ; polygons [ numParts ] = newPoly ; int len = radians . length ; for ( int i = _NUM ; i < len ; i += _NUM ) { bounds . addPoint ( ProjMath . radToDeg ( radians [ i + _NUM ] ) , ProjMath . radToDeg ( radians [ i ] ) ) ; } }
public ButtonBubble ( Window owner , String nextDockableKey , AlignedSide preferredAlignment , String i18nKey , String buttonKeyToAttach , boolean addListener , boolean listenToPerspective , JButton [ ] buttonsToAdd , Object ... arguments ) { super ( owner , preferredAlignment , i18nKey , nextDockableKey , buttonsToAdd , arguments ) ; if ( preferredAlignment != AlignedSide . MIDDLE ) { this . buttonKey = buttonKeyToAttach ; this . addListener = addListener ; if ( buttonKey == null || buttonKey . equals ( STRING ) ) { throw new IllegalArgumentException ( STRING ) ; } else { this . button = BubbleWindow . findButton ( buttonKey , owner ) ; } } setAddPerspectiveListener ( listenToPerspective ) ; super . paint ( _BOOL ) ; }
private void addPreferenceOptions ( final List < String > opts , IPreferenceStore store ) { String argStr = store . getString ( CheckerPreferences . PREF_CHECKER_ARGS ) ; List < OptionLine > optionlines = OptionLine . parseOptions ( argStr ) ; for ( final OptionLine optLine : optionlines ) { if ( optLine . isActive ( ) ) { opts . add ( optLine . getArgument ( ) ) ; } } }
private void addPreferenceOptions ( final List < String > opts , IPreferenceStore store ) { String argStr = store . getString ( CheckerPreferences . PREF_CHECKER_ARGS ) ; List < OptionLine > optionlines = OptionLine . parseOptions ( argStr ) ; for ( final OptionLine optLine : optionlines ) { if ( optLine . isActive ( ) ) { opts . add ( optLine . getArgument ( ) ) ; } } }
public String buildUser ( ) { return properties . getProperty ( STRING ) ; }
public static void finishMockSleep ( ) { if ( mockSleepQueue != null ) { mockSleepQueue . offer ( _BOOL ) ; } }
public static void finishMockSleep ( ) { if ( mockSleepQueue != null ) { mockSleepQueue . offer ( _BOOL ) ; } }
public static void finishMockSleep ( ) { if ( mockSleepQueue != null ) { mockSleepQueue . offer ( _BOOL ) ; } }
public static void finishMockSleep ( ) { if ( mockSleepQueue != null ) { mockSleepQueue . offer ( _BOOL ) ; } }
public static final Set < Emoticon > filterByType ( Set < Emoticon > emotes , Emoticon . Type type ) { Set < Emoticon > filtered = new HashSet < > ( ) ; for ( Emoticon emote : emotes ) { if ( emote . type == type ) { filtered . add ( emote ) ; } } return filtered ; }
protected void tearDown ( ) throws Exception { stunStack . removeSocket ( clientAddress ) ; stunStack . removeSocket ( serverAddress ) ; clientSock . close ( ) ; serverSock . close ( ) ; requestCollector = null ; responseCollector = null ; System . setProperty ( StackProperties . PROPAGATE_RECEIVED_RETRANSMISSIONS , STRING ) ; System . setProperty ( StackProperties . KEEP_CRANS_AFTER_A_RESPONSE , STRING ) ; System . setProperty ( StackProperties . MAX_CTRAN_RETRANSMISSIONS , STRING ) ; System . setProperty ( StackProperties . MAX_CTRAN_RETRANS_TIMER , STRING ) ; System . setProperty ( StackProperties . FIRST_CTRAN_RETRANS_AFTER , STRING ) ; super . tearDown ( ) ; }
public void actionPerformed ( ActionEvent ae ) { long currentTime = System . nanoTime ( ) / _NUM ; long totalTime = currentTime - animStartTime ; if ( totalTime > animationDuration ) { animStartTime = currentTime ; } float fraction = ( float ) totalTime / animationDuration ; fraction = Math . min ( _NUM , fraction ) ; int red = ( int ) ( fraction * endColor . getRed ( ) + ( _NUM - fraction ) * startColor . getRed ( ) ) ; int green = ( int ) ( fraction * endColor . getGreen ( ) + ( _NUM - fraction ) * startColor . getGreen ( ) ) ; int blue = ( int ) ( fraction * endColor . getBlue ( ) + ( _NUM - fraction ) * startColor . getBlue ( ) ) ; currentColor = new Color ( red , green , blue ) ; repaint ( ) ; }
public void removeTabStop ( int stop ) { tabstops . remove ( stop ) ; }
public boolean hasNext ( ) { if ( deal > _NUM ) { sc . close ( ) ; } return ( deal <= _NUM ) ; }
public boolean hasNext ( ) { if ( deal > _NUM ) { sc . close ( ) ; } return ( deal <= _NUM ) ; }
public static void writeBinaryFile ( final File file , final byte [ ] data ) throws IOException { try ( FileOutputStream fos = new FileOutputStream ( file ) ) { fos . write ( data ) ; } }
public static DateTime toDateSimple ( String str , short convertingType , boolean alsoMonthString , TimeZone timeZone ) throws PageException { DateTime dt = toDateSimple ( str , convertingType , alsoMonthString , timeZone , null ) ; if ( dt == null ) throw new ExpressionException ( STRING ) ; return dt ; }
public static DateTime toDateSimple ( String str , short convertingType , boolean alsoMonthString , TimeZone timeZone ) throws PageException { DateTime dt = toDateSimple ( str , convertingType , alsoMonthString , timeZone , null ) ; if ( dt == null ) throw new ExpressionException ( STRING ) ; return dt ; }
public void removeSensor ( Sensor sensor ) { data . remove ( sensor ) ; fireTableDataChanged ( ) ; }
public VisorLogFile ( File file ) { this ( file . getAbsolutePath ( ) , file . length ( ) , file . lastModified ( ) ) ; }
public boolean remove ( String toRemove ) { String result = mUsedNames . remove ( toRemove . toLowerCase ( ) ) ; if ( result != null ) { notifyChanged ( ) ; return _BOOL ; } return _BOOL ; }
private IPAddress computeMaskFromNetworkPrefix ( int prefix ) { StringBuilder str = new StringBuilder ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i < prefix ) { str . append ( STRING ) ; } else { str . append ( STRING ) ; } } String decimalString = toDecimalString ( str . toString ( ) ) ; return new IPAddress ( decimalString ) ; }
public void updateThroughput ( long currentTime ) { throughputCalculationLock . lock ( ) ; try { int interval = ( int ) ( currentTime - lastThroughputCalculationTime ) ; long minInterval = getThroughputCalculationIntervalInMillis ( ) ; if ( ( minInterval == _NUM ) || ( interval < minInterval ) ) { return ; } long readBytes = this . readBytes ; long writtenBytes = this . writtenBytes ; long readMessages = this . readMessages ; long writtenMessages = this . writtenMessages ; readBytesThroughput = ( readBytes - lastReadBytes ) * _NUM / interval ; writtenBytesThroughput = ( writtenBytes - lastWrittenBytes ) * _NUM / interval ; readMessagesThroughput = ( readMessages - lastReadMessages ) * _NUM / interval ; writtenMessagesThroughput = ( writtenMessages - lastWrittenMessages ) * _NUM / interval ; if ( readBytesThroughput > largestReadBytesThroughput ) { largestReadBytesThroughput = readBytesThroughput ; } if ( writtenBytesThroughput > largestWrittenBytesThroughput ) { largestWrittenBytesThroughput = writtenBytesThroughput ; } if ( readMessagesThroughput > largestReadMessagesThroughput ) { largestReadMessagesThroughput = readMessagesThroughput ; } if ( writtenMessagesThroughput > largestWrittenMessagesThroughput ) { largestWrittenMessagesThroughput = writtenMessagesThroughput ; } lastReadBytes = readBytes ; lastWrittenBytes = writtenBytes ; lastReadMessages = readMessages ; lastWrittenMessages = writtenMessages ; lastThroughputCalculationTime = currentTime ; } finally { throughputCalculationLock . unlock ( ) ; } }
void stripNonCompiledNodes ( Node n , Set < String > filesToCompile ) { for ( Node child : n . children ( ) ) { if ( ! filesToCompile . contains ( child . getSourceFileName ( ) ) ) { child . detachFromParent ( ) ; } } }
public void sort ( Comparator < ? super LogLine > comparator ) { this . mComparator = comparator ; Collections . sort ( mObjects , comparator ) ; if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
boolean shouldEDTSleep ( ) { Form current = impl . getCurrentForm ( ) ; return ( ( current == null || ( ! current . hasAnimations ( ) ) ) && ( animationQueue == null || animationQueue . size ( ) == _NUM ) && inputEventStackPointer == _NUM && ( ! impl . hasPendingPaints ( ) ) && hasNoSerialCallsPending ( ) && ! keyRepeatCharged && ! longPointerCharged ) || ( isMinimized ( ) && hasNoSerialCallsPending ( ) ) ; }
boolean shouldEDTSleep ( ) { Form current = impl . getCurrentForm ( ) ; return ( ( current == null || ( ! current . hasAnimations ( ) ) ) && ( animationQueue == null || animationQueue . size ( ) == _NUM ) && inputEventStackPointer == _NUM && ( ! impl . hasPendingPaints ( ) ) && hasNoSerialCallsPending ( ) && ! keyRepeatCharged && ! longPointerCharged ) || ( isMinimized ( ) && hasNoSerialCallsPending ( ) ) ; }
public double evaluate ( VectorInstance x , double [ ] y ) throws Exception { double dotProd = x . dotProduct ( y ) ; return Math . pow ( m_gamma * dotProd + m_coef0 , m_degree ) ; }
public void initCombos ( ) { addCombinationValues ( STRING , new Object [ ] { STRING , STRING } ) ; addCombinationValues ( STRING , new Object [ ] { Integer . valueOf ( DeliveryMode . NON_PERSISTENT ) , Integer . valueOf ( DeliveryMode . PERSISTENT ) } ) ; addCombinationValues ( STRING , new Object [ ] { Byte . valueOf ( ActiveMQDestination . QUEUE_TYPE ) } ) ; }
public void initCombos ( ) { addCombinationValues ( STRING , new Object [ ] { STRING , STRING } ) ; addCombinationValues ( STRING , new Object [ ] { Integer . valueOf ( DeliveryMode . NON_PERSISTENT ) , Integer . valueOf ( DeliveryMode . PERSISTENT ) } ) ; addCombinationValues ( STRING , new Object [ ] { Byte . valueOf ( ActiveMQDestination . QUEUE_TYPE ) } ) ; }
public double approximationDistancePAA ( double [ ] ts , int winSize , int paaSize , double normThreshold ) throws Exception { double resDistance = _NUM ; int windowCounter = _NUM ; double pointsPerWindow = ( double ) winSize / ( double ) paaSize ; for ( int i = _NUM ; i < ts . length - winSize + _NUM ; i ++ ) { double [ ] subseries = Arrays . copyOfRange ( ts , i , i + winSize ) ; if ( tsProcessor . stDev ( subseries ) > normThreshold ) { subseries = tsProcessor . znorm ( subseries , normThreshold ) ; } double [ ] paa = tsProcessor . paa ( subseries , paaSize ) ; windowCounter ++ ; double subsequenceDistance = _NUM ; for ( int j = _NUM ; j < subseries . length ; j ++ ) { int paaIdx = ( int ) Math . floor ( ( ( double ) j + _NUM ) / ( double ) pointsPerWindow ) ; if ( paaIdx < _NUM ) { paaIdx = _NUM ; } if ( paaIdx > paa . length ) { paaIdx = paa . length - _NUM ; } subsequenceDistance = subsequenceDistance + ed . distance ( paa [ paaIdx ] , subseries [ j ] ) ; } resDistance = resDistance + subsequenceDistance / subseries . length ; } return resDistance / ( double ) windowCounter ; }
private T cacheMiss ( final NT nt ) { T resource = null ; final AtomicReference < IIndexManager > foundOn = new AtomicReference < IIndexManager > ( ) ; final Properties properties = locateResource ( nt . getName ( ) , nt . getTimestamp ( ) , foundOn ) ; if ( properties == null ) { if ( delegate != null ) { if ( INFO ) { log . info ( STRING + nt ) ; } resource = delegate . locate ( nt . getName ( ) , nt . getTimestamp ( ) ) ; if ( resource != null ) { if ( INFO ) { log . info ( STRING + resource ) ; } return resource ; } } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( properties . toString ( ) ) ; } final String className = properties . getProperty ( RelationSchema . CLASS ) ; if ( className == null ) { return null ; } final Class < ? extends T > cls ; try { cls = ( Class < ? extends T > ) Class . forName ( className ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } if ( log . isDebugEnabled ( ) ) { log . debug ( STRING + cls . getName ( ) ) ; } resource = newInstance ( cls , foundOn . get ( ) , nt , properties ) ; return resource ; }
static public void packInt ( DataOutput out , int value ) throws IOException { int shift = ( value & ~ _NUM ) ; if ( shift != _NUM ) { shift = _NUM - Integer . numberOfLeadingZeros ( value ) ; shift -= shift % _NUM ; while ( shift != _NUM ) { out . writeByte ( ( byte ) ( ( value > > > shift ) & _NUM ) ) ; shift -= _NUM ; } } out . writeByte ( ( byte ) ( ( value & _NUM ) | _NUM ) ) ; }
static public void packInt ( DataOutput out , int value ) throws IOException { int shift = ( value & ~ _NUM ) ; if ( shift != _NUM ) { shift = _NUM - Integer . numberOfLeadingZeros ( value ) ; shift -= shift % _NUM ; while ( shift != _NUM ) { out . writeByte ( ( byte ) ( ( value > > > shift ) & _NUM ) ) ; shift -= _NUM ; } } out . writeByte ( ( byte ) ( ( value & _NUM ) | _NUM ) ) ; }
static public void packInt ( DataOutput out , int value ) throws IOException { int shift = ( value & ~ _NUM ) ; if ( shift != _NUM ) { shift = _NUM - Integer . numberOfLeadingZeros ( value ) ; shift -= shift % _NUM ; while ( shift != _NUM ) { out . writeByte ( ( byte ) ( ( value > > > shift ) & _NUM ) ) ; shift -= _NUM ; } } out . writeByte ( ( byte ) ( ( value & _NUM ) | _NUM ) ) ; }
private void printArguments ( List < Expression > args , Object arg ) { printer . print ( STRING ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . hasNext ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . hasNext ( ) ) { printer . print ( STRING ) ; } } } printer . print ( STRING ) ; }
private void printArguments ( List < Expression > args , Object arg ) { printer . print ( STRING ) ; if ( args != null ) { for ( Iterator < Expression > i = args . iterator ( ) ; i . hasNext ( ) ; ) { Expression e = i . next ( ) ; e . accept ( this , arg ) ; if ( i . hasNext ( ) ) { printer . print ( STRING ) ; } } } printer . print ( STRING ) ; }
public SectionModel vendSection ( int page ) { PagedMockLoader . SectionModel sectionModel = new PagedMockLoader . SectionModel ( STRING + Integer . toString ( page ) ) ; for ( int j = _NUM ; j < _NUM ; j ++ ) { sectionModel . addItem ( new PagedMockLoader . ItemModel ( STRING + Integer . toString ( j ) ) ) ; } return sectionModel ; }
public SectionModel vendSection ( int page ) { PagedMockLoader . SectionModel sectionModel = new PagedMockLoader . SectionModel ( STRING + Integer . toString ( page ) ) ; for ( int j = _NUM ; j < _NUM ; j ++ ) { sectionModel . addItem ( new PagedMockLoader . ItemModel ( STRING + Integer . toString ( j ) ) ) ; } return sectionModel ; }
public final static < T > Stream < T > completableFutureToStream ( final CompletableFuture < T > future ) { return Stream . of ( future . join ( ) ) ; }
public static boolean deleteFilesAndDirsRecursive ( final String file ) { if ( TextUtils . isEmpty ( file ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } return deleteFilesAndDirsRecursive ( new File ( file ) ) ; }
public static boolean deleteFilesAndDirsRecursive ( final String file ) { if ( TextUtils . isEmpty ( file ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } return deleteFilesAndDirsRecursive ( new File ( file ) ) ; }
public static boolean deleteFilesAndDirsRecursive ( final String file ) { if ( TextUtils . isEmpty ( file ) ) { Log . e ( FileUtils . class , STRING ) ; return _BOOL ; } return deleteFilesAndDirsRecursive ( new File ( file ) ) ; }
public void test_concurrent_modification_update ( ) { final BTree btree ; { btree = BTree . create ( new SimpleMemoryRawStore ( ) , new IndexMetadata ( UUID . randomUUID ( ) ) ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; } { ITupleCursor2 < String > cursor = newCursor ( btree ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . seek ( _NUM ) ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( _NUM , STRING ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; } }
public void test_concurrent_modification_update ( ) { final BTree btree ; { btree = BTree . create ( new SimpleMemoryRawStore ( ) , new IndexMetadata ( UUID . randomUUID ( ) ) ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; } { ITupleCursor2 < String > cursor = newCursor ( btree ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . seek ( _NUM ) ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( _NUM , STRING ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; } }
public void test_concurrent_modification_update ( ) { final BTree btree ; { btree = BTree . create ( new SimpleMemoryRawStore ( ) , new IndexMetadata ( UUID . randomUUID ( ) ) ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; btree . insert ( _NUM , STRING ) ; } { ITupleCursor2 < String > cursor = newCursor ( btree ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . seek ( _NUM ) ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; btree . insert ( _NUM , STRING ) ; assertEquals ( new TestTuple < String > ( _NUM , STRING ) , cursor . tuple ( ) ) ; } }
private File createTempFile ( String suffix ) throws IOException { String prefix = STRING ; if ( ! Strings . isNullOrEmpty ( getName ( ) ) ) { prefix += getName ( ) + STRING ; } File tmp = File . createTempFile ( prefix , suffix ) ; toCleanup . add ( tmp ) ; return tmp ; }
private File createTempFile ( String suffix ) throws IOException { String prefix = STRING ; if ( ! Strings . isNullOrEmpty ( getName ( ) ) ) { prefix += getName ( ) + STRING ; } File tmp = File . createTempFile ( prefix , suffix ) ; toCleanup . add ( tmp ) ; return tmp ; }
private File createTempFile ( String suffix ) throws IOException { String prefix = STRING ; if ( ! Strings . isNullOrEmpty ( getName ( ) ) ) { prefix += getName ( ) + STRING ; } File tmp = File . createTempFile ( prefix , suffix ) ; toCleanup . add ( tmp ) ; return tmp ; }
public static int visit ( int x ) { lastVisited = x ; return x ; }
private void addRegistrationReq ( SocketChannel sockCh ) { offerBalanced ( new NioOperationFuture ( sockCh ) ) ; }
private void addRegistrationReq ( SocketChannel sockCh ) { offerBalanced ( new NioOperationFuture ( sockCh ) ) ; }
private void addRegistrationReq ( SocketChannel sockCh ) { offerBalanced ( new NioOperationFuture ( sockCh ) ) ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
@ Nullable E awaitMatch ( int start ) { for ( int step = _NUM , totalSpins = _NUM ; ( step < ARENA_LENGTH ) && ( totalSpins < SPINS ) ; step ++ ) { int index = ( start + step ) & ARENA_MASK ; AtomicReference < Object > slot = arena [ index ] ; Object found = slot . get ( ) ; if ( found == FREE ) { if ( slot . compareAndSet ( FREE , WAITER ) ) { int slotSpins = _NUM ; for ( ; ; ) { found = slot . get ( ) ; if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } else if ( ( slotSpins >= SPINS_PER_STEP ) && ( found == WAITER ) && ( slot . compareAndSet ( WAITER , FREE ) ) ) { totalSpins += slotSpins ; break ; } slotSpins ++ ; } } } else if ( ( found != WAITER ) && slot . compareAndSet ( found , FREE ) ) { @ SuppressWarnings ( STRING ) E e = ( E ) found ; return e ; } } return null ; }
public static final String hashKeyForDisk ( final String key ) { String cacheKey ; try { final MessageDigest digest = MessageDigest . getInstance ( STRING ) ; digest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( digest . digest ( ) ) ; } catch ( final NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
public static final String hashKeyForDisk ( final String key ) { String cacheKey ; try { final MessageDigest digest = MessageDigest . getInstance ( STRING ) ; digest . update ( key . getBytes ( ) ) ; cacheKey = bytesToHexString ( digest . digest ( ) ) ; } catch ( final NoSuchAlgorithmException e ) { cacheKey = String . valueOf ( key . hashCode ( ) ) ; } return cacheKey ; }
public void sendRequestVoteRequest ( boolean isPrevote ) throws GondolaException { if ( ! enabled || masterId >= _NUM ) { return ; } if ( ! isPrevote ) { currentTerm ++ ; votedFor = - _NUM ; save ( currentTerm , memberId ) ; votedFor = memberId ; } prevotesOnly = isPrevote ; Message message = pool . checkout ( ) ; try { saveQueue . getLatest ( savedRid ) ; message . requestVoteRequest ( memberId , currentTerm , isPrevote , savedRid ) ; peers . forEach ( null ) ; } finally { message . release ( ) ; } prevoteTs = clock . now ( ) + ( long ) ( ( Math . random ( ) * prevotePeriod ) ) ; if ( ! isPrevote ) { prevoteTs += electionTimeout ; } }
public ClientPropertiesBuilder withProxyHostName ( String proxyHostName ) { properties . setProperty ( CLIENT_SERVICE_PROXY_HOST_NAME , proxyHostName ) ; return this ; }
public ClientPropertiesBuilder withProxyHostName ( String proxyHostName ) { properties . setProperty ( CLIENT_SERVICE_PROXY_HOST_NAME , proxyHostName ) ; return this ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
public SpecificationRunnerBuilder sections ( String [ ] paramSections ) { Collections . addAll ( this . sections , paramSections ) ; return this ; }
private void showPopupMenu ( final MouseEvent event ) { final IconNode selectedNode = ( IconNode ) TreeHelpers . getNodeAt ( referencesTable , event . getX ( ) , event . getY ( ) ) ; if ( selectedNode != null ) { final JPopupMenu menu = createPopupMenu ( selectedNode ) ; if ( menu != null ) { menu . show ( referencesTable , event . getX ( ) , event . getY ( ) ) ; } } }
public HTMLStripCharFilterFactory ( Map < String , String > args ) { super ( args ) ; escapedTags = getSet ( args , STRING ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + args ) ; } }
public static long currentTime ( ) { if ( _testTime > _NUM ) return _testTime ; else return System . currentTimeMillis ( ) ; }
public void onCallBack ( Bundle bundle ) { Message msg = mHandler . obtainMessage ( bundle . getInt ( FmRadioListener . CALLBACK_FLAG ) ) ; msg . setData ( bundle ) ; mHandler . sendMessage ( msg ) ; }
public static ShoppingCart makeShoppingListCart ( LocalDispatcher dispatcher , GenericValue shoppingList , Locale locale ) { return makeShoppingListCart ( null , dispatcher , shoppingList , locale ) ; }
private StringBuilder createIndent ( int indent ) { StringBuilder oneIndent = createIndent ( ) ; StringBuilder ret = new StringBuilder ( ) ; while ( indent -- > _NUM ) { ret . append ( oneIndent ) ; } return ret ; }
private StringBuilder createIndent ( int indent ) { StringBuilder oneIndent = createIndent ( ) ; StringBuilder ret = new StringBuilder ( ) ; while ( indent -- > _NUM ) { ret . append ( oneIndent ) ; } return ret ; }
private StringBuilder createIndent ( int indent ) { StringBuilder oneIndent = createIndent ( ) ; StringBuilder ret = new StringBuilder ( ) ; while ( indent -- > _NUM ) { ret . append ( oneIndent ) ; } return ret ; }
public static LowMemoryWatcher register ( @ NotNull Runnable runnable ) { return new LowMemoryWatcher ( runnable ) ; }
@ Transactional ( readOnly = _BOOL ) public BagCount [ ] checkFilteredBagCounts ( String filterText ) { TypedQuery < BagCount > query = myEM . createNamedQuery ( STRING , BagCount . class ) ; query . setParameter ( STRING , filterText ) ; List < BagCount > results = query . getResultList ( ) ; return results . toArray ( new BagCount [ results . size ( ) ] ) ; }
@ Transactional ( readOnly = _BOOL ) public BagCount [ ] checkFilteredBagCounts ( String filterText ) { TypedQuery < BagCount > query = myEM . createNamedQuery ( STRING , BagCount . class ) ; query . setParameter ( STRING , filterText ) ; List < BagCount > results = query . getResultList ( ) ; return results . toArray ( new BagCount [ results . size ( ) ] ) ; }
public void dup2X1 ( ) { mv . visitInsn ( Opcodes . DUP2_X1 ) ; }
@ Override public boolean hasDelta ( ) { return isDirty ; }
@ Override public boolean hasDelta ( ) { return isDirty ; }
public static double abs1 ( Z z ) { return Math . abs ( z . re ) + Math . abs ( z . im ) ; }
public static int readBytes ( InputStream in , byte [ ] byteArray ) throws IOException { int totalBytesRead = _NUM ; int bytesRead = in . read ( byteArray ) ; while ( bytesRead >= _NUM ) { totalBytesRead += bytesRead ; if ( totalBytesRead == byteArray . length ) { break ; } bytesRead = in . read ( byteArray , totalBytesRead , byteArray . length - totalBytesRead ) ; } return totalBytesRead ; }
public static int readBytes ( InputStream in , byte [ ] byteArray ) throws IOException { int totalBytesRead = _NUM ; int bytesRead = in . read ( byteArray ) ; while ( bytesRead >= _NUM ) { totalBytesRead += bytesRead ; if ( totalBytesRead == byteArray . length ) { break ; } bytesRead = in . read ( byteArray , totalBytesRead , byteArray . length - totalBytesRead ) ; } return totalBytesRead ; }
public static int readBytes ( InputStream in , byte [ ] byteArray ) throws IOException { int totalBytesRead = _NUM ; int bytesRead = in . read ( byteArray ) ; while ( bytesRead >= _NUM ) { totalBytesRead += bytesRead ; if ( totalBytesRead == byteArray . length ) { break ; } bytesRead = in . read ( byteArray , totalBytesRead , byteArray . length - totalBytesRead ) ; } return totalBytesRead ; }
public static int readBytes ( InputStream in , byte [ ] byteArray ) throws IOException { int totalBytesRead = _NUM ; int bytesRead = in . read ( byteArray ) ; while ( bytesRead >= _NUM ) { totalBytesRead += bytesRead ; if ( totalBytesRead == byteArray . length ) { break ; } bytesRead = in . read ( byteArray , totalBytesRead , byteArray . length - totalBytesRead ) ; } return totalBytesRead ; }
public static int readBytes ( InputStream in , byte [ ] byteArray ) throws IOException { int totalBytesRead = _NUM ; int bytesRead = in . read ( byteArray ) ; while ( bytesRead >= _NUM ) { totalBytesRead += bytesRead ; if ( totalBytesRead == byteArray . length ) { break ; } bytesRead = in . read ( byteArray , totalBytesRead , byteArray . length - totalBytesRead ) ; } return totalBytesRead ; }
public static Object constraint ( SLayout ... flags ) { EnumSet < SLayout > obj = EnumSet . noneOf ( SLayout . class ) ; for ( SLayout flag : flags ) { obj . add ( flag ) ; } return obj ; }
public static int color ( Color c ) { return c . getRGB ( ) ; }
public SelectionBuilder reset ( ) { mTable = null ; mGroupBy = null ; mHaving = null ; mSelection . setLength ( _NUM ) ; mSelectionArgs . clear ( ) ; return this ; }
public Vec sortedCopy ( ) { double [ ] arrayCopy = arrayCopy ( ) ; Arrays . sort ( arrayCopy ) ; return new DenseVector ( arrayCopy ) ; }
public Vec sortedCopy ( ) { double [ ] arrayCopy = arrayCopy ( ) ; Arrays . sort ( arrayCopy ) ; return new DenseVector ( arrayCopy ) ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public boolean isStandardModule ( String moduleName ) { return _BOOL ; }
public CFunctionSelectionTree ( final IDatabase database , final IActionProvider actionProvider ) { Preconditions . checkNotNull ( database , STRING ) ; Preconditions . checkNotNull ( actionProvider , STRING ) ; final DefaultTreeModel model = new DefaultTreeModel ( null ) ; setModel ( model ) ; setRootVisible ( _BOOL ) ; model . setRoot ( new CRootNode ( database , model , actionProvider ) ) ; setCellRenderer ( new IconNodeRenderer ( ) ) ; addMouseListener ( new InternalMouseListener ( ) ) ; }
public static Long toLong ( char c ) { return Long . valueOf ( toLongValue ( c ) ) ; }
protected void closeChannel ( SocketChannel channel ) { if ( channel == null ) return ; Socket socket = channel . socket ( ) ; try { socket . shutdownInput ( ) ; socket . shutdownOutput ( ) ; socket . close ( ) ; } catch ( IOException ex ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING , ex ) ; } } finally { try { channel . close ( ) ; } catch ( IOException ex ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING , ex ) ; } } } }
public void clear ( ) { cartItemMap . clear ( ) ; totalPrice = BigDecimal . ZERO ; totalQuantity = _NUM ; }
public static int sendChar ( byte txChar ) throws IOException { log . trace ( String . format ( STRING , ( byte ) txChar ) ) ; int result = sendChar ( serialPortDescriptor , ( char ) txChar ) ; if ( result < _NUM ) { throw new IOException ( String . format ( STRING , result ) ) ; } return result ; }
protected static final int inchAsPixel ( double in , int dpi ) { return ( int ) Math . round ( dpi * in ) ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STRING , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STRING , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STRING , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STRING , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public Future < SyncReply > sendRequest ( int xid , SyncMessage request ) throws RemoteStoreException { ensureConnected ( ) ; RemoteSyncFuture future = new RemoteSyncFuture ( xid , connectionGeneration ) ; futureMap . put ( Integer . valueOf ( xid ) , future ) ; if ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { synchronized ( futureNotify ) { while ( futureMap . size ( ) > MAX_PENDING_REQUESTS ) { try { futureNotify . wait ( ) ; } catch ( InterruptedException e ) { throw new RemoteStoreException ( STRING , e ) ; } } } } channel . writeAndFlush ( request ) ; return future ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public RespokeClient createClient ( Context appContext ) { context = appContext ; RespokeClient newClient = new RespokeClient ( ) ; instances . add ( newClient ) ; return newClient ; }
public void reset ( ) { if ( myWatcher != null ) { myWatcher . stop ( ) ; } initialize ( ) ; }
public void reset ( ) { if ( myWatcher != null ) { myWatcher . stop ( ) ; } initialize ( ) ; }
public void reset ( ) { if ( myWatcher != null ) { myWatcher . stop ( ) ; } initialize ( ) ; }
private void sleepPastRefreshInterval ( ) throws Exception { logger . debug ( STRING + REFRESH_INTERVAL_SECS + STRING ) ; Thread . sleep ( REFRESH_INTERVAL_SECS * _NUM ) ; }
private void sleepPastRefreshInterval ( ) throws Exception { logger . debug ( STRING + REFRESH_INTERVAL_SECS + STRING ) ; Thread . sleep ( REFRESH_INTERVAL_SECS * _NUM ) ; }
@ Override public void onClick ( DialogInterface dialog , int which ) { mListener . onNewSequenceDialogAccept ( editText . getText ( ) ) ; }
@ Override protected void openVisibleInstances ( Instances insts ) throws Exception { super . openVisibleInstances ( insts ) ; setROCString ( STRING + Utils . doubleToString ( ThresholdCurve . getROCArea ( insts ) , _NUM ) + STRING ) ; setBorderText ( ) ; }
private void doDelete ( ScriptStep step ) { if ( aggregatorEditor . isAggregator ( step ) ) { ScriptStep stepPair = aggregatorEditor . getAggregatorPair ( step ) ; steps . remove ( stepPair ) ; searchBean . removeFromSearchMatch ( stepPair ) ; } steps . remove ( step ) ; searchBean . removeFromSearchMatch ( step ) ; reindexScriptSteps ( ) ; }
protected boolean isWhitespace ( char ch ) { return ( ( ch == STRING ) || Character . isSpaceChar ( ch ) ) ; }
protected boolean isWhitespace ( char ch ) { return ( ( ch == STRING ) || Character . isSpaceChar ( ch ) ) ; }
protected boolean isWhitespace ( char ch ) { return ( ( ch == STRING ) || Character . isSpaceChar ( ch ) ) ; }
protected boolean isWhitespace ( char ch ) { return ( ( ch == STRING ) || Character . isSpaceChar ( ch ) ) ; }
protected boolean isWhitespace ( char ch ) { return ( ( ch == STRING ) || Character . isSpaceChar ( ch ) ) ; }
public void writeToFile ( File filename ) throws IOException { FileUtils . stringToFile ( mText . toString ( ) , filename ) ; }
public static String findEditTable ( String tables ) { if ( ! SqlUtils . isEmpty ( tables ) ) { int spacepos = tables . indexOf ( STRING ) ; int commapos = tables . indexOf ( STRING ) ; if ( spacepos > _NUM && ( spacepos < commapos || commapos < _NUM ) ) { return tables . substring ( _NUM , spacepos ) ; } else if ( commapos > _NUM && ( commapos < spacepos || spacepos < _NUM ) ) { return tables . substring ( _NUM , commapos ) ; } return tables ; } else { throw new IllegalStateException ( STRING ) ; } }
private byte [ ] updateNoDictionaryStartAndEndKey ( byte [ ] key ) { if ( key . length == _NUM ) { return key ; } ByteBuffer buffer = ByteBuffer . wrap ( key , _NUM , key . length - _NUM ) ; ByteBuffer output = ByteBuffer . allocate ( key . length - _NUM ) ; short numberOfByteToStorLength = _NUM ; for ( int i = _NUM ; i < numberOfNoDictionaryColumn ; i ++ ) { output . putShort ( ( short ) ( buffer . getShort ( ) - numberOfByteToStorLength ) ) ; } while ( buffer . hasRemaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }
private byte [ ] updateNoDictionaryStartAndEndKey ( byte [ ] key ) { if ( key . length == _NUM ) { return key ; } ByteBuffer buffer = ByteBuffer . wrap ( key , _NUM , key . length - _NUM ) ; ByteBuffer output = ByteBuffer . allocate ( key . length - _NUM ) ; short numberOfByteToStorLength = _NUM ; for ( int i = _NUM ; i < numberOfNoDictionaryColumn ; i ++ ) { output . putShort ( ( short ) ( buffer . getShort ( ) - numberOfByteToStorLength ) ) ; } while ( buffer . hasRemaining ( ) ) { output . put ( buffer . get ( ) ) ; } output . rewind ( ) ; return output . array ( ) ; }
public void testFileDirectory ( ) throws Exception { Properties properties = loadProperties ( STRING ) ; assertEquals ( STRING , properties . getProperty ( STRING ) ) ; }
public void addTables ( Collection < Table > tables ) { for ( Iterator < Table > it = tables . iterator ( ) ; it . hasNext ( ) ; ) { addTable ( ( Table ) it . next ( ) ) ; } }
private void computeDefaultFilters ( File indicatorFile , JsonObject jsonObj ) { defaultFilters = new ArrayList < Filter > ( ) ; JsonArray filterArray = Utils . getFieldValueAsArray ( jsonObj , STRING ) ; if ( filterArray != null ) { Set < String > filterFields = Utils . getAllFilterFields ( jsonObj ) ; for ( int i = _NUM ; i < filterArray . size ( ) ; i ++ ) { JsonElement filterElt = filterArray . get ( i ) ; Filter filter ; try { filter = Filter . parse ( filterElt , filterFields ) ; defaultFilters . add ( filter ) ; } catch ( FilterParseException e ) { String title = STRING ; String msg = STRING + indicatorFile ; DroidsafePluginUtilities . showError ( title , msg , e ) ; ; e . printStackTrace ( ) ; } } } }
public void record ( int time_sec ) { this . count ++ ; this . total_time_sec += time_sec ; if ( this . min_time_sec < _NUM ) this . min_time_sec = time_sec ; else this . min_time_sec = Math . min ( this . min_time_sec , time_sec ) ; this . max_time_sec = Math . max ( this . max_time_sec , time_sec ) ; }
public void record ( int time_sec ) { this . count ++ ; this . total_time_sec += time_sec ; if ( this . min_time_sec < _NUM ) this . min_time_sec = time_sec ; else this . min_time_sec = Math . min ( this . min_time_sec , time_sec ) ; this . max_time_sec = Math . max ( this . max_time_sec , time_sec ) ; }
public void testToBigIntegerPos1 ( ) { String a = STRING ; BigInteger bNumber = new BigInteger ( STRING ) ; BigDecimal aNumber = new BigDecimal ( a ) ; BigInteger result = aNumber . toBigInteger ( ) ; assertTrue ( STRING , result . equals ( bNumber ) ) ; }
public void testNumberToStringLocale ( ) { Locale defaultLocale = Locale . getDefault ( ) ; Locale . setDefault ( Locale . US ) ; NumberConverter converter = makeConverter ( ) ; converter . setUseLocaleFormat ( _BOOL ) ; assertEquals ( STRING + numbers [ _NUM ] , STRING , converter . convert ( String . class , numbers [ _NUM ] ) ) ; assertEquals ( STRING + numbers [ _NUM ] , STRING , converter . convert ( String . class , numbers [ _NUM ] ) ) ; converter . setLocale ( Locale . GERMAN ) ; assertEquals ( STRING + numbers [ _NUM ] , STRING , converter . convert ( String . class , numbers [ _NUM ] ) ) ; assertEquals ( STRING + numbers [ _NUM ] , STRING , converter . convert ( String . class , numbers [ _NUM ] ) ) ; Locale . setDefault ( defaultLocale ) ; }
public MersenneTwister ( ) { mt = new int [ N ] ; setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
public MersenneTwister ( ) { mt = new int [ N ] ; setSeed ( System . currentTimeMillis ( ) + System . identityHashCode ( this ) ) ; }
public void beginDisplay ( DisplayEvent event ) throws ModelControlException { super . beginDisplay ( event ) ; ServerSiteModel model = ( ServerSiteModel ) getModel ( ) ; String serverName = ( String ) getPageSessionAttribute ( PG_ATTR_SERVER_NAME ) ; Object [ ] param = { serverName } ; ptModel . setPageTitleText ( MessageFormat . format ( model . getLocalizedString ( STRING ) , param ) ) ; setDisplayFieldValue ( STRING , MessageFormat . format ( model . getLocalizedString ( STRING ) , param ) ) ; }
public static void reconcileExportGroupsHLUs ( DbClient dbClient , ExportGroup exportGroup ) { List < String > egVolumesWithoutHLUs = findVolumesWithoutHLUs ( exportGroup ) ; if ( ! egVolumesWithoutHLUs . isEmpty ( ) ) { for ( ExportMask thisMask : ExportMaskUtils . getExportMasks ( dbClient , exportGroup ) ) { Iterator < String > volumeIter = egVolumesWithoutHLUs . iterator ( ) ; while ( volumeIter . hasNext ( ) ) { URI volumeURI = URI . create ( volumeIter . next ( ) ) ; if ( thisMask . hasVolume ( volumeURI ) ) { String hlu = thisMask . returnVolumeHLU ( volumeURI ) ; if ( hlu != ExportGroup . LUN_UNASSIGNED_DECIMAL_STR ) { _log . info ( String . format ( STRING , exportGroup . getLabel ( ) , exportGroup . getId ( ) , volumeURI , hlu ) ) ; exportGroup . addVolume ( volumeURI , Integer . valueOf ( hlu ) ) ; volumeIter . remove ( ) ; } } } } } }
public static void reconcileExportGroupsHLUs ( DbClient dbClient , ExportGroup exportGroup ) { List < String > egVolumesWithoutHLUs = findVolumesWithoutHLUs ( exportGroup ) ; if ( ! egVolumesWithoutHLUs . isEmpty ( ) ) { for ( ExportMask thisMask : ExportMaskUtils . getExportMasks ( dbClient , exportGroup ) ) { Iterator < String > volumeIter = egVolumesWithoutHLUs . iterator ( ) ; while ( volumeIter . hasNext ( ) ) { URI volumeURI = URI . create ( volumeIter . next ( ) ) ; if ( thisMask . hasVolume ( volumeURI ) ) { String hlu = thisMask . returnVolumeHLU ( volumeURI ) ; if ( hlu != ExportGroup . LUN_UNASSIGNED_DECIMAL_STR ) { _log . info ( String . format ( STRING , exportGroup . getLabel ( ) , exportGroup . getId ( ) , volumeURI , hlu ) ) ; exportGroup . addVolume ( volumeURI , Integer . valueOf ( hlu ) ) ; volumeIter . remove ( ) ; } } } } } }
public static void reconcileExportGroupsHLUs ( DbClient dbClient , ExportGroup exportGroup ) { List < String > egVolumesWithoutHLUs = findVolumesWithoutHLUs ( exportGroup ) ; if ( ! egVolumesWithoutHLUs . isEmpty ( ) ) { for ( ExportMask thisMask : ExportMaskUtils . getExportMasks ( dbClient , exportGroup ) ) { Iterator < String > volumeIter = egVolumesWithoutHLUs . iterator ( ) ; while ( volumeIter . hasNext ( ) ) { URI volumeURI = URI . create ( volumeIter . next ( ) ) ; if ( thisMask . hasVolume ( volumeURI ) ) { String hlu = thisMask . returnVolumeHLU ( volumeURI ) ; if ( hlu != ExportGroup . LUN_UNASSIGNED_DECIMAL_STR ) { _log . info ( String . format ( STRING , exportGroup . getLabel ( ) , exportGroup . getId ( ) , volumeURI , hlu ) ) ; exportGroup . addVolume ( volumeURI , Integer . valueOf ( hlu ) ) ; volumeIter . remove ( ) ; } } } } } }
private Object executeStellar ( String expression ) { Object result = null ; try { result = executor . execute ( expression ) ; } catch ( Throwable t ) { writeLine ( ERROR_PROMPT + t . getMessage ( ) ) ; t . printStackTrace ( ) ; } return result ; }
protected KeyFactory ( KeyFactorySpi keyFacSpi , Provider provider , String algorithm ) { this . spi = keyFacSpi ; this . provider = provider ; this . algorithm = algorithm ; }
private static QueryTask buildRegistryQueryByGroup ( String tenantLink ) { Query groupClause = QueryUtil . addTenantGroupAndUserClause ( tenantLink ) ; return buildRegistryQuery ( groupClause ) ; }
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = _NUM ; w = width ; h = height ; } else { if ( x < _NUM ) { w += x ; x = _NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < _NUM ) { h += y ; y = _NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= _NUM || h <= _NUM ) && ! framenotify ) { return ; } Enumeration enum_ = theConsumers . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { ImageConsumer ic = ( ImageConsumer ) enum_ . nextElement ( ) ; if ( w > _NUM && h > _NUM ) { sendPixels ( ic , x , y , w , h ) ; } if ( framenotify && isConsumer ( ic ) ) { ic . imageComplete ( ImageConsumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = _NUM ; w = width ; h = height ; } else { if ( x < _NUM ) { w += x ; x = _NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < _NUM ) { h += y ; y = _NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= _NUM || h <= _NUM ) && ! framenotify ) { return ; } Enumeration enum_ = theConsumers . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { ImageConsumer ic = ( ImageConsumer ) enum_ . nextElement ( ) ; if ( w > _NUM && h > _NUM ) { sendPixels ( ic , x , y , w , h ) ; } if ( framenotify && isConsumer ( ic ) ) { ic . imageComplete ( ImageConsumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = _NUM ; w = width ; h = height ; } else { if ( x < _NUM ) { w += x ; x = _NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < _NUM ) { h += y ; y = _NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= _NUM || h <= _NUM ) && ! framenotify ) { return ; } Enumeration enum_ = theConsumers . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { ImageConsumer ic = ( ImageConsumer ) enum_ . nextElement ( ) ; if ( w > _NUM && h > _NUM ) { sendPixels ( ic , x , y , w , h ) ; } if ( framenotify && isConsumer ( ic ) ) { ic . imageComplete ( ImageConsumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = _NUM ; w = width ; h = height ; } else { if ( x < _NUM ) { w += x ; x = _NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < _NUM ) { h += y ; y = _NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= _NUM || h <= _NUM ) && ! framenotify ) { return ; } Enumeration enum_ = theConsumers . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { ImageConsumer ic = ( ImageConsumer ) enum_ . nextElement ( ) ; if ( w > _NUM && h > _NUM ) { sendPixels ( ic , x , y , w , h ) ; } if ( framenotify && isConsumer ( ic ) ) { ic . imageComplete ( ImageConsumer . SINGLEFRAMEDONE ) ; } } } }
public synchronized void newPixels ( int x , int y , int w , int h , boolean framenotify ) { if ( animating ) { if ( fullbuffers ) { x = y = _NUM ; w = width ; h = height ; } else { if ( x < _NUM ) { w += x ; x = _NUM ; } if ( x + w > width ) { w = width - x ; } if ( y < _NUM ) { h += y ; y = _NUM ; } if ( y + h > height ) { h = height - y ; } } if ( ( w <= _NUM || h <= _NUM ) && ! framenotify ) { return ; } Enumeration enum_ = theConsumers . elements ( ) ; while ( enum_ . hasMoreElements ( ) ) { ImageConsumer ic = ( ImageConsumer ) enum_ . nextElement ( ) ; if ( w > _NUM && h > _NUM ) { sendPixels ( ic , x , y , w , h ) ; } if ( framenotify && isConsumer ( ic ) ) { ic . imageComplete ( ImageConsumer . SINGLEFRAMEDONE ) ; } } } }
public float length ( int u , int v ) { if ( u == v ) return _NUM ; else return _NUM / ( v - u ) ; }
public float length ( int u , int v ) { if ( u == v ) return _NUM ; else return _NUM / ( v - u ) ; }
@ Override public String toString ( ) { return MessageFormat . format ( STRING + STRING + STRING , getLDAPFilter ( ) , StringUtils . join ( requestedAttributes , STRING ) ) ; }
private void addErrorMessage ( String message ) { if ( message != null ) { m_errorMessages . append ( message ) ; } m_errorMessages . append ( STRING ) ; }
static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > _NUM ) ? _BOOL : _BOOL ; }
static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > _NUM ) ? _BOOL : _BOOL ; }
static boolean analyzePredicate ( Compiler compiler , int opPos , int stepType ) throws javax . xml . transform . TransformerException { int argLen ; switch ( stepType ) { case OpCodes . OP_VARIABLE : case OpCodes . OP_EXTFUNCTION : case OpCodes . OP_FUNCTION : case OpCodes . OP_GROUP : argLen = compiler . getArgLength ( opPos ) ; break ; default : argLen = compiler . getArgLengthOfStep ( opPos ) ; } int pos = compiler . getFirstPredicateOpPos ( opPos ) ; int nPredicates = compiler . countPredicates ( pos ) ; return ( nPredicates > _NUM ) ? _BOOL : _BOOL ; }
public static int indexOfThatStartsWith ( List < String > list , String startsWith , int startIndex ) { for ( int i = startIndex ; i < list . size ( ) ; i ++ ) { String curStr = list . get ( i ) ; if ( curStr != null && curStr . startsWith ( startsWith ) ) { return i ; } } return - _NUM ; }
public TypeName ( String fullName , String nickname , String pattern , TypeName ... innerTypeNames ) { this . topLevelAlias = TypeAlias . create ( fullName , nickname ) ; this . pattern = pattern ; this . innerTypeNames = Arrays . asList ( innerTypeNames ) ; }
public TypeName ( String fullName , String nickname , String pattern , TypeName ... innerTypeNames ) { this . topLevelAlias = TypeAlias . create ( fullName , nickname ) ; this . pattern = pattern ; this . innerTypeNames = Arrays . asList ( innerTypeNames ) ; }
public static Color parseColorFromProperties ( Properties p , String propName , String dfault ) throws NumberFormatException { String colorString = p . getProperty ( propName , dfault ) ; return parseColor ( colorString , _BOOL ) ; }
private List < Entity > listNetwork ( Entity e , boolean planned ) { List < Entity > novaNetworkMembers = new LinkedList < Entity > ( ) ; List < Entity > novaUnits = getMyNovaUnits ( ) ; for ( Entity ent : novaUnits ) { if ( planned ) { if ( ent . getNewRoundNovaNetworkString ( ) == e . getNewRoundNovaNetworkString ( ) ) { novaNetworkMembers . add ( ent ) ; } } else { if ( ent . getC3NetId ( ) == e . getC3NetId ( ) ) { novaNetworkMembers . add ( ent ) ; } } } return novaNetworkMembers ; }
public RDFXMLWriter ( OutputStream out ) { this ( new OutputStreamWriter ( out , Charset . forName ( STRING ) ) ) ; }
final boolean nonfairTryAcquire ( int acquires ) { final Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c == _NUM ) { if ( compareAndSetState ( _NUM , acquires ) ) { setExclusiveOwnerThread ( current ) ; return _BOOL ; } } else if ( current == getExclusiveOwnerThread ( ) ) { int nextc = c + acquires ; if ( nextc < _NUM ) throw new Error ( STRING ) ; setState ( nextc ) ; return _BOOL ; } return _BOOL ; }
final boolean nonfairTryAcquire ( int acquires ) { final Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c == _NUM ) { if ( compareAndSetState ( _NUM , acquires ) ) { setExclusiveOwnerThread ( current ) ; return _BOOL ; } } else if ( current == getExclusiveOwnerThread ( ) ) { int nextc = c + acquires ; if ( nextc < _NUM ) throw new Error ( STRING ) ; setState ( nextc ) ; return _BOOL ; } return _BOOL ; }
final boolean nonfairTryAcquire ( int acquires ) { final Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c == _NUM ) { if ( compareAndSetState ( _NUM , acquires ) ) { setExclusiveOwnerThread ( current ) ; return _BOOL ; } } else if ( current == getExclusiveOwnerThread ( ) ) { int nextc = c + acquires ; if ( nextc < _NUM ) throw new Error ( STRING ) ; setState ( nextc ) ; return _BOOL ; } return _BOOL ; }
final boolean nonfairTryAcquire ( int acquires ) { final Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c == _NUM ) { if ( compareAndSetState ( _NUM , acquires ) ) { setExclusiveOwnerThread ( current ) ; return _BOOL ; } } else if ( current == getExclusiveOwnerThread ( ) ) { int nextc = c + acquires ; if ( nextc < _NUM ) throw new Error ( STRING ) ; setState ( nextc ) ; return _BOOL ; } return _BOOL ; }
public static void d ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_DEBUG ) { return ; } if ( args . length > _NUM ) { msg = String . format ( msg , args ) ; } Log . d ( tag , msg ) ; }
public long nextActionMillis ( long now , long nextRetryTimeMillis ) { for ( FileDownloadInfo info : downloads ) { long individualRetryTimeMillis = getNextActionMillisFor ( now , info ) ; nextRetryTimeMillis = Math . min ( individualRetryTimeMillis , nextRetryTimeMillis ) ; } return nextRetryTimeMillis ; }
private final boolean validateClientPacket ( ByteBuffer buf ) { return buf . getShort ( _NUM ) == ~ buf . getShort ( _NUM ) && buf . get ( _NUM ) == staticClientPacketCode ; }
private boolean checkValidation ( final SourceDataTag currentSourceDataTag , final ValueUpdate update ) { if ( ! isTimestampValid ( currentSourceDataTag , update ) ) { return _BOOL ; } if ( ! isConvertible ( currentSourceDataTag , update ) ) { return _BOOL ; } if ( isNumber ( currentSourceDataTag . getDataType ( ) ) && ! isInRange ( currentSourceDataTag , update ) ) { return _BOOL ; } return _BOOL ; }
private boolean checkValidation ( final SourceDataTag currentSourceDataTag , final ValueUpdate update ) { if ( ! isTimestampValid ( currentSourceDataTag , update ) ) { return _BOOL ; } if ( ! isConvertible ( currentSourceDataTag , update ) ) { return _BOOL ; } if ( isNumber ( currentSourceDataTag . getDataType ( ) ) && ! isInRange ( currentSourceDataTag , update ) ) { return _BOOL ; } return _BOOL ; }
protected void initialize ( ) { List < AddUserFields . AttributeSpec > specs = m_filter . getAttributeSpecs ( ) ; m_listModel = new DefaultListModel ( ) ; m_list . setModel ( m_listModel ) ; if ( specs . size ( ) > _NUM ) { m_upBut . setEnabled ( _BOOL ) ; m_downBut . setEnabled ( _BOOL ) ; for ( AddUserFields . AttributeSpec s : specs ) { AddUserFields . AttributeSpec specCopy = new AddUserFields . AttributeSpec ( s . toStringInternal ( ) ) ; m_listModel . addElement ( specCopy ) ; } m_list . repaint ( ) ; } else { m_nameField . setEnabled ( _BOOL ) ; m_typeField . setEnabled ( _BOOL ) ; m_dateFormatField . setEnabled ( _BOOL ) ; m_valueField . setEnabled ( _BOOL ) ; } }
public static BshClassManager createClassManager ( Interpreter interpreter ) { BshClassManager manager ; if ( Capabilities . classExists ( STRING ) && Capabilities . classExists ( STRING ) && Capabilities . classExists ( STRING ) ) try { Class clas = Class . forName ( STRING ) ; manager = ( BshClassManager ) clas . newInstance ( ) ; } catch ( Exception e ) { throw new InterpreterError ( STRING + e ) ; } else manager = new BshClassManager ( ) ; if ( interpreter == null ) interpreter = new Interpreter ( ) ; manager . declaringInterpreter = interpreter ; return manager ; }
public static BshClassManager createClassManager ( Interpreter interpreter ) { BshClassManager manager ; if ( Capabilities . classExists ( STRING ) && Capabilities . classExists ( STRING ) && Capabilities . classExists ( STRING ) ) try { Class clas = Class . forName ( STRING ) ; manager = ( BshClassManager ) clas . newInstance ( ) ; } catch ( Exception e ) { throw new InterpreterError ( STRING + e ) ; } else manager = new BshClassManager ( ) ; if ( interpreter == null ) interpreter = new Interpreter ( ) ; manager . declaringInterpreter = interpreter ; return manager ; }
@ PostConstruct public void init ( ) { Iterator < ValidatorFactory > iterator = validatorFactoryInstance . iterator ( ) ; if ( iterator . hasNext ( ) ) { this . validatorFactory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validatorFactory = Validation . buildDefaultValidatorFactory ( ) ; } }
@ PostConstruct public void init ( ) { Iterator < ValidatorFactory > iterator = validatorFactoryInstance . iterator ( ) ; if ( iterator . hasNext ( ) ) { this . validatorFactory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validatorFactory = Validation . buildDefaultValidatorFactory ( ) ; } }
@ PostConstruct public void init ( ) { Iterator < ValidatorFactory > iterator = validatorFactoryInstance . iterator ( ) ; if ( iterator . hasNext ( ) ) { this . validatorFactory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validatorFactory = Validation . buildDefaultValidatorFactory ( ) ; } }
@ PostConstruct public void init ( ) { Iterator < ValidatorFactory > iterator = validatorFactoryInstance . iterator ( ) ; if ( iterator . hasNext ( ) ) { this . validatorFactory = iterator . next ( ) ; } else { log . warning ( STRING ) ; this . validatorFactory = Validation . buildDefaultValidatorFactory ( ) ; } }
public static String join ( String separator , Iterable < ? > elements ) { StringBuilder sb = new StringBuilder ( ) ; for ( Iterator < ? > i = elements . iterator ( ) ; i . hasNext ( ) ; ) { sb . append ( i . next ( ) ) ; if ( i . hasNext ( ) && separator != null ) { sb . append ( separator ) ; } } return sb . toString ( ) ; }
private void emitTriggerIfAllBlocksReceived ( FileMetadata fileMetadata , Map < Long , BlockMetadata . FileBlockMetadata > receivedBlocksMetadata ) { String filePath = fileMetadata . getFilePath ( ) ; if ( receivedBlocksMetadata . size ( ) != fileMetadata . getNumberOfBlocks ( ) ) { fileMetadataMap . put ( filePath , fileMetadata ) ; } else { Set < Long > receivedBlocks = receivedBlocksMetadata . keySet ( ) ; boolean blockMissing = _BOOL ; if ( ! fileMetadata . isDirectory ( ) ) { for ( long blockId : fileMetadata . getBlockIds ( ) ) { if ( ! receivedBlocks . contains ( blockId ) ) { blockMissing = _BOOL ; } } } if ( ! blockMissing ) { long fileProcessingTime = System . currentTimeMillis ( ) - fileMetadata . getDiscoverTime ( ) ; List < StitchBlock > outputBlocks = constructOutputBlockMetadataList ( fileMetadata ) ; OutputFileMetadata outputFileMetadata = new OutputFileMetadata ( fileMetadata , outputBlocks ) ; trigger . emit ( outputFileMetadata ) ; LOG . debug ( STRING , fileMetadata . getFilePath ( ) , fileProcessingTime ) ; fileMetadataMap . remove ( filePath ) ; } } }
public long timeMillis ( ) { return ( ( _perf . highResCounter ( ) * TO_MILLISECONDS ) / TICKS_PER_SECOND ) ; }
public static boolean isInJail ( final Player inmate ) { final StendhalRPZone zone = inmate . getZone ( ) ; if ( ( zone != null ) && zone . equals ( jailzone ) ) { for ( final Rectangle cellBlock : cellBlocks ) { if ( cellBlock . contains ( inmate . getX ( ) , inmate . getY ( ) ) ) { return _BOOL ; } } } return _BOOL ; }
public static boolean isInJail ( final Player inmate ) { final StendhalRPZone zone = inmate . getZone ( ) ; if ( ( zone != null ) && zone . equals ( jailzone ) ) { for ( final Rectangle cellBlock : cellBlocks ) { if ( cellBlock . contains ( inmate . getX ( ) , inmate . getY ( ) ) ) { return _BOOL ; } } } return _BOOL ; }
public static String [ ] parseDelimitedList ( String list , char delimiter ) { String delim = STRING + delimiter ; StringTokenizer st = new StringTokenizer ( list + delim + STRING , delim , _BOOL ) ; ArrayList < String > v = new ArrayList < String > ( ) ; String lastToken = STRING ; String word = STRING ; while ( st . hasMoreTokens ( ) ) { String tok = st . nextToken ( ) ; if ( lastToken != null ) { if ( tok . equals ( delim ) ) { word = word + lastToken ; if ( lastToken . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( STRING ) ) v . add ( word ) ; word = STRING ; } } lastToken = tok ; } return v . toArray ( new String [ _NUM ] ) ; }
public static String [ ] parseDelimitedList ( String list , char delimiter ) { String delim = STRING + delimiter ; StringTokenizer st = new StringTokenizer ( list + delim + STRING , delim , _BOOL ) ; ArrayList < String > v = new ArrayList < String > ( ) ; String lastToken = STRING ; String word = STRING ; while ( st . hasMoreTokens ( ) ) { String tok = st . nextToken ( ) ; if ( lastToken != null ) { if ( tok . equals ( delim ) ) { word = word + lastToken ; if ( lastToken . equals ( delim ) ) tok = null ; } else { if ( ! word . equals ( STRING ) ) v . add ( word ) ; word = STRING ; } } lastToken = tok ; } return v . toArray ( new String [ _NUM ] ) ; }
public String defaultValueAsString ( ) { Object defaultValue = defaultValue ( ) ; return defaultValue != null ? defaultValue . toString ( ) : null ; }
public static void expandLetters ( String letters , WordRelation wordRelation , Item tokenItem ) { letters = letters . toLowerCase ( ) ; char c ; for ( int i = _NUM ; i < letters . length ( ) ; i ++ ) { c = letters . charAt ( i ) ; if ( isDigit ( c ) ) { wordRelation . addWord ( tokenItem , digit2num [ c - STRING ] ) ; } else if ( letters . equals ( STRING ) ) { wordRelation . addWord ( tokenItem , STRING ) ; } else { wordRelation . addWord ( tokenItem , String . valueOf ( c ) ) ; } } }
public void addTransform ( DataTransform transform ) { transformSource . add ( transform ) ; }
public void addTransform ( DataTransform transform ) { transformSource . add ( transform ) ; }
public void addTransform ( DataTransform transform ) { transformSource . add ( transform ) ; }
public void addTransform ( DataTransform transform ) { transformSource . add ( transform ) ; }
@ SuppressWarnings ( STRING ) private Object toReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularToReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularToReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object toReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularToReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularToReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object toReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularToReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularToReflectionType ( value ) ; } }
@ SuppressWarnings ( STRING ) private Object toReflectionType ( final Object value ) { FieldDescriptor descriptor = getDescriptor ( ) ; if ( descriptor . isRepeated ( ) ) { if ( descriptor . getJavaType ( ) == FieldDescriptor . JavaType . ENUM ) { final List result = new ArrayList ( ) ; for ( final Object element : ( List ) value ) { result . add ( singularToReflectionType ( element ) ) ; } return result ; } else { return value ; } } else { return singularToReflectionType ( value ) ; } }
List < IsilonEvent > filterEvents ( List < IsilonEvent > events ) { long mostRecentTimestamp = _latestTimeThreshold ; List < IsilonEvent > filteredEvents = new ArrayList < IsilonEvent > ( ) ; for ( IsilonEvent event : events ) { long latestTime = event . getLatestTime ( ) ; if ( latestTime > _latestTimeThreshold ) { filteredEvents . add ( event ) ; if ( latestTime > mostRecentTimestamp ) { mostRecentTimestamp = latestTime ; } } } _mostRecentTimestampInPollingCycle = mostRecentTimestamp ; return filteredEvents ; }
public LinkedHashSet ( Collection < ? extends E > c ) { super ( Math . max ( _NUM * c . size ( ) , _NUM ) , _NUM , _BOOL ) ; addAll ( c ) ; }
protected void replace ( final String paramText , final String newText ) { int loc = builder . indexOf ( paramText ) ; while ( loc >= _NUM ) { builder . replace ( loc , loc + paramText . length ( ) , newText ) ; loc = builder . indexOf ( paramText ) ; } }
public void test_copyStream_nearlyFullBlock ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE - _NUM ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
public void test_copyStream_nearlyFullBlock ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE - _NUM ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
public void mergePreCondition ( ) { if ( preCondition != null && conditionBlock != null ) { List < InsnNode > condInsns = conditionBlock . getInstructions ( ) ; List < InsnNode > preCondInsns = preCondition . getInstructions ( ) ; preCondInsns . addAll ( condInsns ) ; condInsns . clear ( ) ; condInsns . addAll ( preCondInsns ) ; preCondInsns . clear ( ) ; preCondition = null ; } }
public void mergePreCondition ( ) { if ( preCondition != null && conditionBlock != null ) { List < InsnNode > condInsns = conditionBlock . getInstructions ( ) ; List < InsnNode > preCondInsns = preCondition . getInstructions ( ) ; preCondInsns . addAll ( condInsns ) ; condInsns . clear ( ) ; condInsns . addAll ( preCondInsns ) ; preCondInsns . clear ( ) ; preCondition = null ; } }
private void enlageIfNeeded ( int i ) { while ( end + i > array . length ) array = Arrays . copyOf ( array , Math . max ( array . length * _NUM , _NUM ) ) ; }
public void start ( ) { Thread thread = new Thread ( this ) ; if ( m_pi != null ) thread . setName ( m_pi . getTitle ( ) + STRING + m_pi . getAD_PInstance_ID ( ) ) ; thread . start ( ) ; }
public void start ( ) { Thread thread = new Thread ( this ) ; if ( m_pi != null ) thread . setName ( m_pi . getTitle ( ) + STRING + m_pi . getAD_PInstance_ID ( ) ) ; thread . start ( ) ; }
protected Transferable createTransferable ( JComponent comp ) { exportComp = ( JTextComponent ) comp ; shouldRemove = _BOOL ; p0 = exportComp . getSelectionStart ( ) ; p1 = exportComp . getSelectionEnd ( ) ; return ( p0 != p1 ) ? ( new TextTransferable ( exportComp , p0 , p1 ) ) : null ; }
public void addCommunicationListener ( FTPCommunicationListener listener ) { synchronized ( lock ) { communicationListeners . add ( listener ) ; if ( communication != null ) { communication . addCommunicationListener ( listener ) ; } } }
public void addEntitlement ( EntitlementEntity entitlement ) { entitlements . add ( entitlement ) ; }
public void registerInput ( String varName , MLMatrix df ) throws DMLRuntimeException { registerInput ( varName , MLMatrix . getRDDLazily ( df ) , df . mc ) ; }
public void registerInput ( String varName , MLMatrix df ) throws DMLRuntimeException { registerInput ( varName , MLMatrix . getRDDLazily ( df ) , df . mc ) ; }
public void registerInput ( String varName , MLMatrix df ) throws DMLRuntimeException { registerInput ( varName , MLMatrix . getRDDLazily ( df ) , df . mc ) ; }
public void error ( Level level , String messageId , String data [ ] , Object session , Map props ) throws LogException { if ( isErrorLoggable ( level ) ) { LogRecord lr = new LogRecord ( level , formatMessage ( messageId , data , session ) ) ; errorLogger . log ( lr ) ; } }
public void error ( Level level , String messageId , String data [ ] , Object session , Map props ) throws LogException { if ( isErrorLoggable ( level ) ) { LogRecord lr = new LogRecord ( level , formatMessage ( messageId , data , session ) ) ; errorLogger . log ( lr ) ; } }
public Set < P > generateCloud ( int N ) { Set < P > samples = new LinkedHashSet < P > ( ) ; Integer [ ] indexes = new Integer [ N ] ; for ( int i = _NUM ; i < N ; i ++ ) { samples . add ( map . randomPose ( ) ) ; indexes [ i ] = i ; } sampleIndexes = new RandVar ( SAMPLE_INDEXES_NAME , new FiniteIntegerDomain ( indexes ) ) ; return samples ; }
public Set < P > generateCloud ( int N ) { Set < P > samples = new LinkedHashSet < P > ( ) ; Integer [ ] indexes = new Integer [ N ] ; for ( int i = _NUM ; i < N ; i ++ ) { samples . add ( map . randomPose ( ) ) ; indexes [ i ] = i ; } sampleIndexes = new RandVar ( SAMPLE_INDEXES_NAME , new FiniteIntegerDomain ( indexes ) ) ; return samples ; }
private void updatePreview ( ) { Color newColor = chooser . getColor ( ) ; if ( type == FOREGROUND ) { preview . update ( newColor , secondaryColor ) ; } else { preview . update ( secondaryColor , newColor ) ; } }
private void navigateToChild ( String startsWith ) { TreePath currentPath = tree . getSelectionPath ( ) ; DefaultMutableTreeNode dumpNode = ( DefaultMutableTreeNode ) currentPath . getLastPathComponent ( ) ; Enumeration childs = dumpNode . children ( ) ; TreePath searchPath = null ; while ( ( searchPath == null ) && childs . hasMoreElements ( ) ) { DefaultMutableTreeNode child = ( DefaultMutableTreeNode ) childs . nextElement ( ) ; String name = child . toString ( ) ; if ( name != null && name . startsWith ( startsWith ) ) { searchPath = new TreePath ( child . getPath ( ) ) ; } } if ( searchPath != null ) { tree . makeVisible ( searchPath ) ; tree . setSelectionPath ( searchPath ) ; tree . scrollPathToVisible ( searchPath ) ; } }
protected void saveLanguage ( String language ) { fLanguageScope . push ( fDepth ) ; fLanguageStack . push ( language ) ; }
private boolean localEquals ( Abstraction other ) { if ( sourceContext == null ) { if ( other . sourceContext != null ) return _BOOL ; } else if ( ! sourceContext . equals ( other . sourceContext ) ) return _BOOL ; if ( activationUnit == null ) { if ( other . activationUnit != null ) return _BOOL ; } else if ( ! activationUnit . equals ( other . activationUnit ) ) return _BOOL ; if ( this . exceptionThrown != other . exceptionThrown ) return _BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return _BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return _BOOL ; if ( this . dependsOnCutAP != other . dependsOnCutAP ) return _BOOL ; if ( this . isImplicit != other . isImplicit ) return _BOOL ; return _BOOL ; }
private boolean localEquals ( Abstraction other ) { if ( sourceContext == null ) { if ( other . sourceContext != null ) return _BOOL ; } else if ( ! sourceContext . equals ( other . sourceContext ) ) return _BOOL ; if ( activationUnit == null ) { if ( other . activationUnit != null ) return _BOOL ; } else if ( ! activationUnit . equals ( other . activationUnit ) ) return _BOOL ; if ( this . exceptionThrown != other . exceptionThrown ) return _BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return _BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return _BOOL ; if ( this . dependsOnCutAP != other . dependsOnCutAP ) return _BOOL ; if ( this . isImplicit != other . isImplicit ) return _BOOL ; return _BOOL ; }
private boolean localEquals ( Abstraction other ) { if ( sourceContext == null ) { if ( other . sourceContext != null ) return _BOOL ; } else if ( ! sourceContext . equals ( other . sourceContext ) ) return _BOOL ; if ( activationUnit == null ) { if ( other . activationUnit != null ) return _BOOL ; } else if ( ! activationUnit . equals ( other . activationUnit ) ) return _BOOL ; if ( this . exceptionThrown != other . exceptionThrown ) return _BOOL ; if ( postdominators == null ) { if ( other . postdominators != null ) return _BOOL ; } else if ( ! postdominators . equals ( other . postdominators ) ) return _BOOL ; if ( this . dependsOnCutAP != other . dependsOnCutAP ) return _BOOL ; if ( this . isImplicit != other . isImplicit ) return _BOOL ; return _BOOL ; }
protected void collapseParentListItem ( ParentWrapper parentWrapper , int parentIndex , boolean collapseTriggeredByListItemClick ) { if ( parentWrapper . isExpanded ( ) ) { parentWrapper . setExpanded ( _BOOL ) ; List < ? > childItemList = parentWrapper . getChildItemList ( ) ; if ( childItemList != null ) { int childListItemCount = childItemList . size ( ) ; for ( int i = childListItemCount - _NUM ; i >= _NUM ; i -- ) { mItemList . remove ( parentIndex + i + _NUM ) ; } notifyItemRangeRemoved ( parentIndex + _NUM , childListItemCount ) ; } if ( collapseTriggeredByListItemClick && mExpandCollapseListener != null ) { int expandedCountBeforePosition = getExpandedItemCount ( parentIndex ) ; mExpandCollapseListener . onListItemCollapsed ( parentIndex - expandedCountBeforePosition ) ; } } }
protected void collapseParentListItem ( ParentWrapper parentWrapper , int parentIndex , boolean collapseTriggeredByListItemClick ) { if ( parentWrapper . isExpanded ( ) ) { parentWrapper . setExpanded ( _BOOL ) ; List < ? > childItemList = parentWrapper . getChildItemList ( ) ; if ( childItemList != null ) { int childListItemCount = childItemList . size ( ) ; for ( int i = childListItemCount - _NUM ; i >= _NUM ; i -- ) { mItemList . remove ( parentIndex + i + _NUM ) ; } notifyItemRangeRemoved ( parentIndex + _NUM , childListItemCount ) ; } if ( collapseTriggeredByListItemClick && mExpandCollapseListener != null ) { int expandedCountBeforePosition = getExpandedItemCount ( parentIndex ) ; mExpandCollapseListener . onListItemCollapsed ( parentIndex - expandedCountBeforePosition ) ; } } }
protected void collapseParentListItem ( ParentWrapper parentWrapper , int parentIndex , boolean collapseTriggeredByListItemClick ) { if ( parentWrapper . isExpanded ( ) ) { parentWrapper . setExpanded ( _BOOL ) ; List < ? > childItemList = parentWrapper . getChildItemList ( ) ; if ( childItemList != null ) { int childListItemCount = childItemList . size ( ) ; for ( int i = childListItemCount - _NUM ; i >= _NUM ; i -- ) { mItemList . remove ( parentIndex + i + _NUM ) ; } notifyItemRangeRemoved ( parentIndex + _NUM , childListItemCount ) ; } if ( collapseTriggeredByListItemClick && mExpandCollapseListener != null ) { int expandedCountBeforePosition = getExpandedItemCount ( parentIndex ) ; mExpandCollapseListener . onListItemCollapsed ( parentIndex - expandedCountBeforePosition ) ; } } }
public static byte [ ] concat ( final byte [ ] ... arrays ) { int len = _NUM ; for ( final byte [ ] arr : arrays ) { len += arr . length ; } final byte [ ] result = new byte [ len ] ; int pos = _NUM ; for ( final byte [ ] arr : arrays ) { System . arraycopy ( arr , _NUM , result , pos , arr . length ) ; pos += arr . length ; } return result ; }
private static String [ ] selectFileCommand ( File file ) { String path = null ; try { path = file . getCanonicalPath ( ) ; } catch ( IOException err ) { path = file . getAbsolutePath ( ) ; } String [ ] command = new String [ ] { STRING , STRING , STRING + path + STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; return command ; }
private static String [ ] selectFileCommand ( File file ) { String path = null ; try { path = file . getCanonicalPath ( ) ; } catch ( IOException err ) { path = file . getAbsolutePath ( ) ; } String [ ] command = new String [ ] { STRING , STRING , STRING + path + STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; return command ; }
public void add ( T item ) { items . add ( item ) ; }
public PopupImage ( final String image , final String title , final String caption ) { put ( Actions . ACTION , Actions . LOOK_CLOSELY ) ; this . image = image ; if ( ! image . startsWith ( STRING ) && ! image . startsWith ( STRING ) ) { this . image = STRING + image ; } this . title = title ; this . caption = caption ; }
public HostMultipathInfoLogicalUnitPolicy createMultipathPolicy ( String name ) { if ( StringUtils . equalsIgnoreCase ( name , VMW_PSP_FIXED ) ) { HostMultipathInfoFixedLogicalUnitPolicy policy = new HostMultipathInfoFixedLogicalUnitPolicy ( ) ; policy . setPolicy ( name ) ; policy . setPrefer ( STRING ) ; return policy ; } else { HostMultipathInfoLogicalUnitPolicy policy = new HostMultipathInfoLogicalUnitPolicy ( ) ; policy . setPolicy ( name ) ; return policy ; } }
protected void newLine ( PrintWriter file ) { file . println ( BLANK_LINE ) ; }
private void try_correct_net ( BrdItem p_item ) { if ( ! ( p_item instanceof BrdTracep ) ) return ; BrdTracep curr_trace = ( BrdTracep ) p_item ; Set < BrdItem > contacts = curr_trace . get_normal_contacts ( curr_trace . corner_first ( ) , _BOOL ) ; contacts . addAll ( curr_trace . get_normal_contacts ( curr_trace . corner_last ( ) , _BOOL ) ) ; int corrected_net_no = _NUM ; for ( BrdItem curr_contact : contacts ) { if ( curr_contact . net_count ( ) == _NUM ) { corrected_net_no = curr_contact . get_net_no ( _NUM ) ; break ; } } if ( corrected_net_no != _NUM ) { p_item . set_net_no ( corrected_net_no ) ; } }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STRING + hmacString + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STRING + hmacString + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STRING + hmacString + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STRING + hmacString + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static byte [ ] unwrapVCF ( File sourceFile , File tmpFile ) throws FileNotFoundException , IOException { ZipArchiveInputStream in = null ; FileOutputStream fos = null ; String hmacString = null ; try { in = new ZipArchiveInputStream ( new FileInputStream ( sourceFile ) ) ; ArchiveEntry entry ; in . getNextEntry ( ) ; fos = new FileOutputStream ( tmpFile ) ; IOUtils . copy ( in , fos ) ; entry = in . getNextEntry ( ) ; hmacString = entry . getName ( ) ; return Utils . hexToBytes ( hmacString ) ; } catch ( StringIndexOutOfBoundsException e ) { logger . error ( STRING + hmacString + STRING , e ) ; throw e ; } catch ( Exception e ) { logger . error ( STRING , e ) ; throw e ; } finally { if ( fos != null ) { fos . flush ( ) ; fos . close ( ) ; } if ( in != null ) { in . close ( ) ; } } }
public static String toHexString ( byte [ ] bytes ) { if ( bytes == null ) return STRING ; int i ; String ret = STRING ; String tmp ; for ( i = _NUM ; i < bytes . length ; i ++ ) { if ( i > _NUM ) ret += STRING ; tmp = Integer . toHexString ( U8 . f ( bytes [ i ] ) ) ; if ( tmp . length ( ) == _NUM ) ret += STRING ; ret += tmp ; } return ret ; }
public void addDirectorySet ( Context context , String path ) { TinyDB tinydb = new TinyDB ( context ) ; ArrayList < String > file = tinydb . getListString ( STRING ) ; file . add ( path ) ; tinydb . putListString ( STRING , file ) ; }
public void addDirectorySet ( Context context , String path ) { TinyDB tinydb = new TinyDB ( context ) ; ArrayList < String > file = tinydb . getListString ( STRING ) ; file . add ( path ) ; tinydb . putListString ( STRING , file ) ; }
public HeldLocksToken refresh ( long expirationDateMs ) { return new HeldLocksToken ( tokenId , client , creationDateMs , expirationDateMs , lockMap , lockTimeout , versionId ) ; }
public HeldLocksToken refresh ( long expirationDateMs ) { return new HeldLocksToken ( tokenId , client , creationDateMs , expirationDateMs , lockMap , lockTimeout , versionId ) ; }
public HeldLocksToken refresh ( long expirationDateMs ) { return new HeldLocksToken ( tokenId , client , creationDateMs , expirationDateMs , lockMap , lockTimeout , versionId ) ; }
private static synchronized String formatAndParse ( SimpleDateFormat formatDate , SimpleDateFormat parseDate , String text ) { try { Date date = parseDate . parse ( text ) ; String result = formatDate . format ( date ) ; return result ; } catch ( ParseException e ) { logger . warning ( STRING + text ) ; } return STRING ; }
public void writeLEChar ( int c ) throws IOException { out . write ( c & _NUM ) ; out . write ( ( c > > > _NUM ) & _NUM ) ; written += _NUM ; }
public void writeLEChar ( int c ) throws IOException { out . write ( c & _NUM ) ; out . write ( ( c > > > _NUM ) & _NUM ) ; written += _NUM ; }
public void curveTo ( float c0X , float c0Y , float c1X , float c1Y , float x , float y ) { mPoints . add ( PathPoint . curveTo ( c0X , c0Y , c1X , c1Y , x , y ) ) ; }
public void curveTo ( float c0X , float c0Y , float c1X , float c1Y , float x , float y ) { mPoints . add ( PathPoint . curveTo ( c0X , c0Y , c1X , c1Y , x , y ) ) ; }
public void curveTo ( float c0X , float c0Y , float c1X , float c1Y , float x , float y ) { mPoints . add ( PathPoint . curveTo ( c0X , c0Y , c1X , c1Y , x , y ) ) ; }
public void curveTo ( float c0X , float c0Y , float c1X , float c1Y , float x , float y ) { mPoints . add ( PathPoint . curveTo ( c0X , c0Y , c1X , c1Y , x , y ) ) ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( eventName . equals ( STRING ) && m_listenees . containsKey ( eventName ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( eventName . equals ( STRING ) && m_listenees . containsKey ( eventName ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean connectionAllowed ( String eventName ) { if ( eventName . equals ( STRING ) && m_listenees . containsKey ( eventName ) ) { return _BOOL ; } return _BOOL ; }
public void end ( String namespace , String name ) { UIComponent uic = ( UIComponent ) digester . peek ( ) ; if ( uic instanceof UIForm ) { root = ( UIComponent ) digester . peek ( digester . getCount ( ) - _NUM ) ; } }
public static terminal find ( int indx ) { Integer the_indx = new Integer ( indx ) ; return ( terminal ) _all_by_index . get ( the_indx ) ; }
public AddressLookup ( String serverUrl , String serialNo , String password ) { this . serverUrl = serverUrl . trim ( ) ; this . clientID = serialNo . trim ( ) ; this . accessCode = password . trim ( ) ; }
public void sendLoadGame ( File f ) { precognition . resetGame ( ) ; super . sendLoadGame ( f ) ; }
private void downloadUpdateProp ( final boolean initialDownload ) { if ( bootProp != null ) { serverFolder = bootProp . getProperty ( STRING , ClientGameConfiguration . get ( STRING ) ) + STRING ; String updatePropertiesFile = bootProp . getProperty ( STRING , serverFolder + STRING ) ; final HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STRING ) ) { return ; } } String updatePropertiesFile = ClientGameConfiguration . get ( STRING ) + STRING ; HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STRING ) ) { return ; } updatePropertiesFile = ClientGameConfiguration . get ( STRING ) + STRING ; httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; }
private void downloadUpdateProp ( final boolean initialDownload ) { if ( bootProp != null ) { serverFolder = bootProp . getProperty ( STRING , ClientGameConfiguration . get ( STRING ) ) + STRING ; String updatePropertiesFile = bootProp . getProperty ( STRING , serverFolder + STRING ) ; final HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STRING ) ) { return ; } } String updatePropertiesFile = ClientGameConfiguration . get ( STRING ) + STRING ; HttpClient httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; if ( updateProp != null && updateProp . containsKey ( STRING ) ) { return ; } updatePropertiesFile = ClientGameConfiguration . get ( STRING ) + STRING ; httpClient = new HttpClient ( updatePropertiesFile , initialDownload ) ; updateProp = httpClient . fetchProperties ( ) ; }
ListBasedTokenStream ( AttributeSource attributeSource , List < AttributeSource > tokens ) { super ( attributeSource . getAttributeFactory ( ) ) ; this . tokens = tokens ; addAttributes ( attributeSource ) ; }
ListBasedTokenStream ( AttributeSource attributeSource , List < AttributeSource > tokens ) { super ( attributeSource . getAttributeFactory ( ) ) ; this . tokens = tokens ; addAttributes ( attributeSource ) ; }
ListBasedTokenStream ( AttributeSource attributeSource , List < AttributeSource > tokens ) { super ( attributeSource . getAttributeFactory ( ) ) ; this . tokens = tokens ; addAttributes ( attributeSource ) ; }
public static CipherParameters makePBEMacParameters ( BCPBEKey pbeKey , AlgorithmParameterSpec spec ) { if ( ( spec == null ) || ! ( spec instanceof PBEParameterSpec ) ) { throw new IllegalArgumentException ( STRING ) ; } PBEParameterSpec pbeParam = ( PBEParameterSpec ) spec ; PBEParametersGenerator generator = makePBEGenerator ( pbeKey . getType ( ) , pbeKey . getDigest ( ) ) ; byte [ ] key = pbeKey . getEncoded ( ) ; CipherParameters param ; if ( pbeKey . shouldTryWrongPKCS12 ( ) ) { key = new byte [ _NUM ] ; } generator . init ( key , pbeParam . getSalt ( ) , pbeParam . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( pbeKey . getKeySize ( ) ) ; for ( int i = _NUM ; i != key . length ; i ++ ) { key [ i ] = _NUM ; } return param ; }
public static CipherParameters makePBEMacParameters ( BCPBEKey pbeKey , AlgorithmParameterSpec spec ) { if ( ( spec == null ) || ! ( spec instanceof PBEParameterSpec ) ) { throw new IllegalArgumentException ( STRING ) ; } PBEParameterSpec pbeParam = ( PBEParameterSpec ) spec ; PBEParametersGenerator generator = makePBEGenerator ( pbeKey . getType ( ) , pbeKey . getDigest ( ) ) ; byte [ ] key = pbeKey . getEncoded ( ) ; CipherParameters param ; if ( pbeKey . shouldTryWrongPKCS12 ( ) ) { key = new byte [ _NUM ] ; } generator . init ( key , pbeParam . getSalt ( ) , pbeParam . getIterationCount ( ) ) ; param = generator . generateDerivedMacParameters ( pbeKey . getKeySize ( ) ) ; for ( int i = _NUM ; i != key . length ; i ++ ) { key [ i ] = _NUM ; } return param ; }
public XMLDocument addToProlog ( ConcreteElement element ) { prolog . addElement ( element ) ; return ( this ) ; }
public XMLDocument addToProlog ( ConcreteElement element ) { prolog . addElement ( element ) ; return ( this ) ; }
@ Override public Map < String , Set < URI > > findExportMasks ( StorageSystem storage , List < String > initiatorNames , boolean mustHaveAllPorts ) throws DeviceControllerException { _log . info ( STRING , storage . getLabel ( ) ) ; Map < String , Set < URI > > result = new HashMap < String , Set < URI > > ( ) ; List < Initiator > initiators = new ArrayList < Initiator > ( ) ; for ( String name : initiatorNames ) { initiators . add ( ExportUtils . getInitiator ( Initiator . toPortNetworkId ( name ) , _dbClient ) ) ; } if ( _restAPIHelper . isClusteredHost ( storage , initiators ) ) { _log . debug ( STRING , storage . getLabel ( ) ) ; result = _restAPIHelper . findRESTExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } else { _log . debug ( STRING , storage . getLabel ( ) ) ; result = findSMISExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } _log . info ( STRING , storage . getLabel ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > findExportMasks ( StorageSystem storage , List < String > initiatorNames , boolean mustHaveAllPorts ) throws DeviceControllerException { _log . info ( STRING , storage . getLabel ( ) ) ; Map < String , Set < URI > > result = new HashMap < String , Set < URI > > ( ) ; List < Initiator > initiators = new ArrayList < Initiator > ( ) ; for ( String name : initiatorNames ) { initiators . add ( ExportUtils . getInitiator ( Initiator . toPortNetworkId ( name ) , _dbClient ) ) ; } if ( _restAPIHelper . isClusteredHost ( storage , initiators ) ) { _log . debug ( STRING , storage . getLabel ( ) ) ; result = _restAPIHelper . findRESTExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } else { _log . debug ( STRING , storage . getLabel ( ) ) ; result = findSMISExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } _log . info ( STRING , storage . getLabel ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > findExportMasks ( StorageSystem storage , List < String > initiatorNames , boolean mustHaveAllPorts ) throws DeviceControllerException { _log . info ( STRING , storage . getLabel ( ) ) ; Map < String , Set < URI > > result = new HashMap < String , Set < URI > > ( ) ; List < Initiator > initiators = new ArrayList < Initiator > ( ) ; for ( String name : initiatorNames ) { initiators . add ( ExportUtils . getInitiator ( Initiator . toPortNetworkId ( name ) , _dbClient ) ) ; } if ( _restAPIHelper . isClusteredHost ( storage , initiators ) ) { _log . debug ( STRING , storage . getLabel ( ) ) ; result = _restAPIHelper . findRESTExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } else { _log . debug ( STRING , storage . getLabel ( ) ) ; result = findSMISExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } _log . info ( STRING , storage . getLabel ( ) ) ; return result ; }
@ Override public Map < String , Set < URI > > findExportMasks ( StorageSystem storage , List < String > initiatorNames , boolean mustHaveAllPorts ) throws DeviceControllerException { _log . info ( STRING , storage . getLabel ( ) ) ; Map < String , Set < URI > > result = new HashMap < String , Set < URI > > ( ) ; List < Initiator > initiators = new ArrayList < Initiator > ( ) ; for ( String name : initiatorNames ) { initiators . add ( ExportUtils . getInitiator ( Initiator . toPortNetworkId ( name ) , _dbClient ) ) ; } if ( _restAPIHelper . isClusteredHost ( storage , initiators ) ) { _log . debug ( STRING , storage . getLabel ( ) ) ; result = _restAPIHelper . findRESTExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } else { _log . debug ( STRING , storage . getLabel ( ) ) ; result = findSMISExportMasks ( storage , initiatorNames , mustHaveAllPorts ) ; } _log . info ( STRING , storage . getLabel ( ) ) ; return result ; }
private EnvironmentVariableManager ( ) { populate ( ) ; }
public static void writeFile ( IFile file , final FileOutput output , IProgressMonitor monitor ) throws CoreException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; output . writeFile ( bos ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; if ( ! file . exists ( ) ) { mkdirs ( file , monitor ) ; file . create ( bis , _BOOL , monitor ) ; } else { file . setContents ( bis , _BOOL , _BOOL , monitor ) ; } } catch ( IOException e ) { IStatus status = FindbugsPlugin . createErrorStatus ( STRING + output . getTaskDescription ( ) , e ) ; throw new CoreException ( status ) ; } }
public static void writeFile ( IFile file , final FileOutput output , IProgressMonitor monitor ) throws CoreException { try { ByteArrayOutputStream bos = new ByteArrayOutputStream ( ) ; output . writeFile ( bos ) ; ByteArrayInputStream bis = new ByteArrayInputStream ( bos . toByteArray ( ) ) ; if ( ! file . exists ( ) ) { mkdirs ( file , monitor ) ; file . create ( bis , _BOOL , monitor ) ; } else { file . setContents ( bis , _BOOL , _BOOL , monitor ) ; } } catch ( IOException e ) { IStatus status = FindbugsPlugin . createErrorStatus ( STRING + output . getTaskDescription ( ) , e ) ; throw new CoreException ( status ) ; } }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
private boolean line_outside_update_box ( PlaPointFloat p_1 , PlaPointFloat p_2 , double p_update_offset , ShapeTileBox p_update_box ) { if ( p_1 == null || p_2 == null ) { return _BOOL ; } if ( Math . max ( p_1 . v_x , p_2 . v_x ) < p_update_box . box_ll . v_x - p_update_offset ) { return _BOOL ; } if ( Math . max ( p_1 . v_y , p_2 . v_y ) < p_update_box . box_ll . v_y - p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_x , p_2 . v_x ) > p_update_box . box_ur . v_x + p_update_offset ) { return _BOOL ; } if ( Math . min ( p_1 . v_y , p_2 . v_y ) > p_update_box . box_ur . v_y + p_update_offset ) { return _BOOL ; } return _BOOL ; }
@ Override public String toString ( ) { return text . toString ( ) ; }
private void recursiveDelete ( final File f ) { if ( f . isDirectory ( ) ) { final File [ ] children = f . listFiles ( ) ; for ( int i = _NUM ; i < children . length ; i ++ ) { recursiveDelete ( children [ i ] ) ; } } if ( log . isInfoEnabled ( ) ) log . info ( STRING + f ) ; if ( f . exists ( ) && ! f . delete ( ) ) { log . warn ( STRING + f ) ; } }
protected StringBuilder siblings ( EntryHierarchyData sibling , boolean isPopup ) throws IOException { StringBuilder siblings = new StringBuilder ( ) ; final SimpleEntry includedEntry = entryDataMatched ( sibling ) ; if ( includedEntry != null ) { appendEntry ( includedEntry , siblings , isPopup ) ; } siblings . append ( children ( sibling ) ) ; if ( includedEntry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected StringBuilder siblings ( EntryHierarchyData sibling , boolean isPopup ) throws IOException { StringBuilder siblings = new StringBuilder ( ) ; final SimpleEntry includedEntry = entryDataMatched ( sibling ) ; if ( includedEntry != null ) { appendEntry ( includedEntry , siblings , isPopup ) ; } siblings . append ( children ( sibling ) ) ; if ( includedEntry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected StringBuilder siblings ( EntryHierarchyData sibling , boolean isPopup ) throws IOException { StringBuilder siblings = new StringBuilder ( ) ; final SimpleEntry includedEntry = entryDataMatched ( sibling ) ; if ( includedEntry != null ) { appendEntry ( includedEntry , siblings , isPopup ) ; } siblings . append ( children ( sibling ) ) ; if ( includedEntry != null ) { siblings . append ( STRING ) ; } return siblings ; }
protected StringBuilder siblings ( EntryHierarchyData sibling , boolean isPopup ) throws IOException { StringBuilder siblings = new StringBuilder ( ) ; final SimpleEntry includedEntry = entryDataMatched ( sibling ) ; if ( includedEntry != null ) { appendEntry ( includedEntry , siblings , isPopup ) ; } siblings . append ( children ( sibling ) ) ; if ( includedEntry != null ) { siblings . append ( STRING ) ; } return siblings ; }
public static int compare ( Date left , boolean right ) { return compare ( left , right ? _NUM : _NUM ) ; }
@ Override public void doRunKeys ( int run ) throws Exception { Object [ ] template = determineTemplate ( run ) ; String [ ] newKey = new String [ template . length - _NUM ] ; System . arraycopy ( template , _NUM , newKey , _NUM , m_KeyIndex ) ; System . arraycopy ( template , m_KeyIndex + _NUM , newKey , m_KeyIndex , template . length - m_KeyIndex - _NUM ) ; m_ResultListener . acceptResult ( this , newKey , null ) ; }
public int countArray ( String [ ] array ) { return array . length ; }
public void send ( byte [ ] data , int id ) { boolean isFirstPacket = ( packets . size ( ) == _NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( isFirstPacket ) { scheduleSendTask ( _BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public void send ( byte [ ] data , int id ) { boolean isFirstPacket = ( packets . size ( ) == _NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( isFirstPacket ) { scheduleSendTask ( _BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public void send ( byte [ ] data , int id ) { boolean isFirstPacket = ( packets . size ( ) == _NUM ) ; packets . add ( data ) ; ids . add ( id ) ; if ( isFirstPacket ) { scheduleSendTask ( _BOOL ) ; } Log . d ( TAG , STRING + id + STRING + packets . size ( ) + STRING ) ; }
public StrBuilder replace ( int startIndex , int endIndex , String replaceStr ) { endIndex = validateRange ( startIndex , endIndex ) ; int insertLen = ( replaceStr == null ? _NUM : replaceStr . length ( ) ) ; replaceImpl ( startIndex , endIndex , endIndex - startIndex , replaceStr , insertLen ) ; return this ; }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( STRING ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public String extract_classname ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
public String extract_classname ( String fullname ) { return fullname . replaceFirst ( STRING , STRING ) ; }
public void append ( CharSequence s ) { text . append ( s ) ; }
public PdfArray ( PdfObject obj ) { this ( ) ; list . add ( obj ) ; }
public PdfArray ( PdfObject obj ) { this ( ) ; list . add ( obj ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return ID ; case _NUM : return UID ; default : return null ; } }
public static boolean isRightMouseButton ( MouseEvent anEvent ) { return ( ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON3_DOWN_MASK ) != _NUM || anEvent . getButton ( ) == MouseEvent . BUTTON3 ) ; }
public static boolean isRightMouseButton ( MouseEvent anEvent ) { return ( ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON3_DOWN_MASK ) != _NUM || anEvent . getButton ( ) == MouseEvent . BUTTON3 ) ; }
public void flush ( ) throws IOException { if ( out == null ) { out . flush ( ) ; } }
public Validator addSubmitButtons ( Component ... cmp ) { boolean isV = isValid ( ) ; for ( Component c : cmp ) { submitButtons . add ( c ) ; c . setEnabled ( isV ) ; } return this ; }
public Validator addSubmitButtons ( Component ... cmp ) { boolean isV = isValid ( ) ; for ( Component c : cmp ) { submitButtons . add ( c ) ; c . setEnabled ( isV ) ; } return this ; }
public Validator addSubmitButtons ( Component ... cmp ) { boolean isV = isValid ( ) ; for ( Component c : cmp ) { submitButtons . add ( c ) ; c . setEnabled ( isV ) ; } return this ; }
public Validator addSubmitButtons ( Component ... cmp ) { boolean isV = isValid ( ) ; for ( Component c : cmp ) { submitButtons . add ( c ) ; c . setEnabled ( isV ) ; } return this ; }
public Validator addSubmitButtons ( Component ... cmp ) { boolean isV = isValid ( ) ; for ( Component c : cmp ) { submitButtons . add ( c ) ; c . setEnabled ( isV ) ; } return this ; }
private Map < String , FileEntry > readEntries ( byte [ ] segmentID , Directory dir , String entriesFileName ) throws IOException { Map < String , FileEntry > mapping = null ; try ( ChecksumIndexInput entriesStream = dir . openChecksumInput ( entriesFileName , IOContext . READONCE ) ) { Throwable priorE = null ; try { version = CodecUtil . checkIndexHeader ( entriesStream , Lucene50CompoundFormat . ENTRY_CODEC , Lucene50CompoundFormat . VERSION_START , Lucene50CompoundFormat . VERSION_CURRENT , segmentID , STRING ) ; final int numEntries = entriesStream . readVInt ( ) ; mapping = new HashMap < > ( numEntries ) ; for ( int i = _NUM ; i < numEntries ; i ++ ) { final FileEntry fileEntry = new FileEntry ( ) ; final String id = entriesStream . readString ( ) ; FileEntry previous = mapping . put ( id , fileEntry ) ; if ( previous != null ) { throw new CorruptIndexException ( STRING + id + STRING , entriesStream ) ; } fileEntry . offset = entriesStream . readLong ( ) ; fileEntry . length = entriesStream . readLong ( ) ; } } catch ( Throwable exception ) { priorE = exception ; } finally { CodecUtil . checkFooter ( entriesStream , priorE ) ; } } return Collections . unmodifiableMap ( mapping ) ; }
private Map < String , FileEntry > readEntries ( byte [ ] segmentID , Directory dir , String entriesFileName ) throws IOException { Map < String , FileEntry > mapping = null ; try ( ChecksumIndexInput entriesStream = dir . openChecksumInput ( entriesFileName , IOContext . READONCE ) ) { Throwable priorE = null ; try { version = CodecUtil . checkIndexHeader ( entriesStream , Lucene50CompoundFormat . ENTRY_CODEC , Lucene50CompoundFormat . VERSION_START , Lucene50CompoundFormat . VERSION_CURRENT , segmentID , STRING ) ; final int numEntries = entriesStream . readVInt ( ) ; mapping = new HashMap < > ( numEntries ) ; for ( int i = _NUM ; i < numEntries ; i ++ ) { final FileEntry fileEntry = new FileEntry ( ) ; final String id = entriesStream . readString ( ) ; FileEntry previous = mapping . put ( id , fileEntry ) ; if ( previous != null ) { throw new CorruptIndexException ( STRING + id + STRING , entriesStream ) ; } fileEntry . offset = entriesStream . readLong ( ) ; fileEntry . length = entriesStream . readLong ( ) ; } } catch ( Throwable exception ) { priorE = exception ; } finally { CodecUtil . checkFooter ( entriesStream , priorE ) ; } } return Collections . unmodifiableMap ( mapping ) ; }
@ Override public void addAttribute ( String name , float value ) { String str = Float . toString ( value ) ; if ( str . endsWith ( STRING ) ) str = str . substring ( _NUM , str . length ( ) - _NUM ) ; current . setAttribute ( name , str ) ; }
protected abstract void bindItem ( DataBoundViewHolder < T > holder , int position , List < Object > payloads ) ;
public static String wrap ( String s , int n ) { StringBuffer b = new StringBuffer ( ) ; boolean wrapPending = _BOOL ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( i % n == _NUM && i > _NUM ) { wrapPending = _BOOL ; } char c = s . charAt ( i ) ; if ( wrapPending && c == STRING ) { b . append ( STRING ) ; wrapPending = _BOOL ; } else { b . append ( c ) ; } } return b . toString ( ) ; }
public static String wrap ( String s , int n ) { StringBuffer b = new StringBuffer ( ) ; boolean wrapPending = _BOOL ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { if ( i % n == _NUM && i > _NUM ) { wrapPending = _BOOL ; } char c = s . charAt ( i ) ; if ( wrapPending && c == STRING ) { b . append ( STRING ) ; wrapPending = _BOOL ; } else { b . append ( c ) ; } } return b . toString ( ) ; }
public boolean match ( String requestedURL , Collection < String > patterns , boolean wildcard ) throws MalformedURLException { boolean result = _BOOL ; String patternLower ; for ( String pattern : patterns ) { patternLower = pattern . toLowerCase ( ) ; requestedURL = resourceName . canonicalize ( requestedURL ) ; if ( patternLower . startsWith ( STRING ) ) { pattern = resourceName . canonicalize ( pattern ) ; } if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STRING + requestedURL + STRING + pattern ) ; } ResourceMatch res = resourceName . compare ( requestedURL , pattern , wildcard ) ; if ( res == ResourceMatch . WILDCARD_MATCH || res == ResourceMatch . EXACT_MATCH ) { if ( DEBUG . messageEnabled ( ) ) { DEBUG . message ( STRING + requestedURL + STRING + pattern + STRING + res ) ; } result = _BOOL ; break ; } } return result ; }
public static Intent openDirectoryBrowser ( Context context , Uri defaultPath , String title ) { return openDirectoryBrowser ( context , defaultPath , title , _BOOL ) ; }
public static Intent openDirectoryBrowser ( Context context , Uri defaultPath , String title ) { return openDirectoryBrowser ( context , defaultPath , title , _BOOL ) ; }
public ScriptBuilder addChunk ( int index , ScriptChunk chunk ) { chunks . add ( index , chunk ) ; return this ; }
public ScriptBuilder addChunk ( int index , ScriptChunk chunk ) { chunks . add ( index , chunk ) ; return this ; }
public SelectClause add ( Expression expression ) { selectList . add ( new SelectClauseExpression ( expression ) ) ; return this ; }
public static String noQuote ( String input ) { if ( input . contains ( STRING ) ) { throw new IllegalArgumentException ( STRING + input + STRING ) ; } else { return input ; } }
public static String noQuote ( String input ) { if ( input . contains ( STRING ) ) { throw new IllegalArgumentException ( STRING + input + STRING ) ; } else { return input ; } }
private void addArg ( String key , Object value ) { if ( requestArguments == null ) { requestArguments = new Hashtable ( ) ; } if ( value == null || key == null ) { return ; } if ( post ) { setWriteRequest ( _BOOL ) ; } requestArguments . put ( key , value ) ; }
public synchronized String lookupText ( String inputtype , String outputtype , String locale , String voice , String outputparams , String style , String effects , String inputtext ) throws SQLException { if ( inputtype == null || outputtype == null || locale == null || voice == null || inputtext == null ) { throw new NullPointerException ( STRING ) ; } String outputtext = null ; String query = STRING + inputtype + STRING + outputtype + STRING + locale + STRING + voice + STRING + outputparams + STRING + style + STRING + effects + STRING ; PreparedStatement st = connection . prepareStatement ( query ) ; st . setString ( _NUM , inputtext ) ; ResultSet results = st . executeQuery ( ) ; if ( results . next ( ) ) { outputtext = results . getString ( _NUM ) ; } st . close ( ) ; return outputtext ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . add ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . add ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public CCTimer ( Object t , String s , float seconds ) { target = t ; selector = s ; interval = seconds ; elapsed = - _NUM ; try { Class < ? > cls = target . getClass ( ) ; invocation = cls . getMethod ( s , Float . TYPE ) ; } catch ( NoSuchMethodException e ) { e . printStackTrace ( ) ; } }
public int size ( ) { return m_sets . size ( ) ; }
public static String buildScenario ( String url ) { if ( url == null ) { return null ; } StringBuilder strb = new StringBuilder ( ) ; strb . append ( buildHeader ( ) ) ; strb . append ( buildGetStep ( url ) ) ; strb . append ( buildFooter ( ) ) ; return strb . toString ( ) ; }
public void write ( PdfDocument document ) throws IOException { setXfaForm ( this , document ) ; }
public SourceCallChainInfo ( SootMethod m , Stmt s , String type ) { this . type = type ; this . link = STRING ; this . method = m ; this . stmt = s ; calls = _NUM ; if ( type . equals ( STRING ) ) syscalls = _NUM ; }
private void updateTextured ( ) { paintTextured = ( root . getClientProperty ( UNIFIED_TOOLBAR_LOOK ) == Boolean . TRUE ) ; if ( paintTextured && PlatformUtils . isMac ( ) ) { if ( root . isValid ( ) ) { throw new IllegalArgumentException ( STRING ) ; } root . putClientProperty ( STRING , Boolean . TRUE ) ; LookAndFeel . installProperty ( ( JComponent ) root . getContentPane ( ) , STRING , Boolean . FALSE ) ; } else { root . putClientProperty ( STRING , null ) ; } }
@ Override public CompletableFuture < Optional < T > > reduce ( final BinaryOperator < T > accumulator ) { return CompletableFuture . supplyAsync ( null ) ; }
public static String byteArrayToHexString ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= _NUM ) { return STRING ; } final StringBuilder out = new StringBuilder ( in . length * _NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & _NUM ) ; ch = ( byte ) ( ch > > > _NUM ) ; ch = ( byte ) ( ch & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . toString ( ) ; }
public static String byteArrayToHexString ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= _NUM ) { return STRING ; } final StringBuilder out = new StringBuilder ( in . length * _NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & _NUM ) ; ch = ( byte ) ( ch > > > _NUM ) ; ch = ( byte ) ( ch & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . toString ( ) ; }
public static String byteArrayToHexString ( final byte in [ ] ) { final String pseudo [ ] = { STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING } ; if ( in == null || in . length <= _NUM ) { return STRING ; } final StringBuilder out = new StringBuilder ( in . length * _NUM ) ; for ( final byte b : in ) { byte ch = ( byte ) ( b & _NUM ) ; ch = ( byte ) ( ch > > > _NUM ) ; ch = ( byte ) ( ch & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; ch = ( byte ) ( b & _NUM ) ; out . append ( pseudo [ ( int ) ch ] ) ; } return out . toString ( ) ; }
public static void assertLabel ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) findByName ( name ) ; assertBool ( l != null , STRING + text ) ; assertBool ( text == l . getText ( ) || text . equals ( l . getText ( ) ) , name + STRING + text ) ; }
public static void assertLabel ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) findByName ( name ) ; assertBool ( l != null , STRING + text ) ; assertBool ( text == l . getText ( ) || text . equals ( l . getText ( ) ) , name + STRING + text ) ; }
public static void assertLabel ( String name , String text ) { if ( verbose ) { log ( STRING + name + STRING + text + STRING ) ; } Label l = ( Label ) findByName ( name ) ; assertBool ( l != null , STRING + text ) ; assertBool ( text == l . getText ( ) || text . equals ( l . getText ( ) ) , name + STRING + text ) ; }
public void addFocusGroup ( String group , TupleSet tset ) { checkGroupExists ( group ) ; m_focus . put ( group , tset ) ; }
public Creature calculateNextCreature ( final int questLevel ) { final List < Creature > possibleCreaturesToSpawn = new ArrayList < Creature > ( ) ; int lastLevel = _NUM ; for ( final Creature creature : sortedCreatures ) { if ( creature . getLevel ( ) > questLevel ) { break ; } if ( creature . getLevel ( ) > lastLevel ) { possibleCreaturesToSpawn . clear ( ) ; lastLevel = creature . getLevel ( ) ; } possibleCreaturesToSpawn . add ( creature ) ; } Creature creatureToSpawn = null ; if ( possibleCreaturesToSpawn . size ( ) == _NUM ) { creatureToSpawn = sortedCreatures . get ( sortedCreatures . size ( ) - _NUM ) ; } else { Collections . shuffle ( possibleCreaturesToSpawn ) ; creatureToSpawn = possibleCreaturesToSpawn . get ( _NUM ) ; } return creatureToSpawn ; }
private String multipleSelectorString ( int currentNumber , int individualTotal , int totalNumber ) { NumberSequencer tmpSequencer = new NumberSequencer ( totalNumber ) ; tmpSequencer . setCurrentNumber ( currentNumber ) ; StringBuilder selectorString = new StringBuilder ( ) ; for ( int i = _NUM ; i < individualTotal ; i ++ ) { selectorString . append ( singleSelectorString ( tmpSequencer . nextNumber ( ) ) ) ; if ( i > _NUM ) { selectorString . append ( STRING ) ; } } return selectorString . toString ( ) ; }
private String multipleSelectorString ( int currentNumber , int individualTotal , int totalNumber ) { NumberSequencer tmpSequencer = new NumberSequencer ( totalNumber ) ; tmpSequencer . setCurrentNumber ( currentNumber ) ; StringBuilder selectorString = new StringBuilder ( ) ; for ( int i = _NUM ; i < individualTotal ; i ++ ) { selectorString . append ( singleSelectorString ( tmpSequencer . nextNumber ( ) ) ) ; if ( i > _NUM ) { selectorString . append ( STRING ) ; } } return selectorString . toString ( ) ; }
private String multipleSelectorString ( int currentNumber , int individualTotal , int totalNumber ) { NumberSequencer tmpSequencer = new NumberSequencer ( totalNumber ) ; tmpSequencer . setCurrentNumber ( currentNumber ) ; StringBuilder selectorString = new StringBuilder ( ) ; for ( int i = _NUM ; i < individualTotal ; i ++ ) { selectorString . append ( singleSelectorString ( tmpSequencer . nextNumber ( ) ) ) ; if ( i > _NUM ) { selectorString . append ( STRING ) ; } } return selectorString . toString ( ) ; }
protected double calculateBarW0 ( CategoryPlot plot , PlotOrientation orientation , Rectangle2D dataArea , CategoryAxis domainAxis , CategoryItemRendererState state , int row , int column ) { double space ; if ( orientation == PlotOrientation . HORIZONTAL ) { space = dataArea . getHeight ( ) ; } else { space = dataArea . getWidth ( ) ; } double barW0 = domainAxis . getCategoryStart ( column , getColumnCount ( ) , dataArea , plot . getDomainAxisEdge ( ) ) ; int seriesCount = state . getVisibleSeriesCount ( ) >= _NUM ? state . getVisibleSeriesCount ( ) : getRowCount ( ) ; int categoryCount = getColumnCount ( ) ; if ( seriesCount > _NUM ) { double seriesGap = space * getItemMargin ( ) / ( categoryCount * ( seriesCount - _NUM ) ) ; double seriesW = calculateSeriesWidth ( space , domainAxis , categoryCount , seriesCount ) ; barW0 = barW0 + row * ( seriesW + seriesGap ) + ( seriesW / _NUM ) - ( state . getBarWidth ( ) / _NUM ) ; } else { barW0 = domainAxis . getCategoryMiddle ( column , getColumnCount ( ) , dataArea , plot . getDomainAxisEdge ( ) ) - state . getBarWidth ( ) / _NUM ; } return barW0 ; }
public void testGetNamespaceURI2 ( ) throws Throwable { Document doc ; NodeList elementList ; Element testAddr ; Attr addrAttr ; String attrNamespaceURI ; doc = ( Document ) load ( STRING , builder ) ; elementList = doc . getElementsByTagName ( STRING ) ; testAddr = ( Element ) elementList . item ( _NUM ) ; assertNotNull ( STRING , testAddr ) ; addrAttr = testAddr . getAttributeNodeNS ( STRING , STRING ) ; attrNamespaceURI = addrAttr . getNamespaceURI ( ) ; assertEquals ( STRING , STRING , attrNamespaceURI ) ; }
public static int randomInt ( int lowerThan ) { return RANDOM . nextInt ( lowerThan ) ; }
public void addDefaultVersion ( Version newDefault , boolean includeImplied ) { ArrayList < Version > newDefaults = new ArrayList < Version > ( defaultVersions ) ; if ( includeImplied ) { mergeVersions ( newDefaults , newDefault . getImpliedVersions ( ) ) ; } else { mergeVersions ( newDefaults , newDefault ) ; } defaultVersions = Collections . unmodifiableList ( newDefaults ) ; }
public void addDefaultVersion ( Version newDefault , boolean includeImplied ) { ArrayList < Version > newDefaults = new ArrayList < Version > ( defaultVersions ) ; if ( includeImplied ) { mergeVersions ( newDefaults , newDefault . getImpliedVersions ( ) ) ; } else { mergeVersions ( newDefaults , newDefault ) ; } defaultVersions = Collections . unmodifiableList ( newDefaults ) ; }
public void addDefaultVersion ( Version newDefault , boolean includeImplied ) { ArrayList < Version > newDefaults = new ArrayList < Version > ( defaultVersions ) ; if ( includeImplied ) { mergeVersions ( newDefaults , newDefault . getImpliedVersions ( ) ) ; } else { mergeVersions ( newDefaults , newDefault ) ; } defaultVersions = Collections . unmodifiableList ( newDefaults ) ; }
public SearchBuilder filter ( ConditionBuilder < ? , ? > ... builders ) { filter . addAll ( Arrays . asList ( builders ) ) ; return this ; }
public abstract String createQueryString ( Projection p ) ;
public abstract String createQueryString ( Projection p ) ;
public void addPrefix ( String prefix , String namespaceURI ) { log . log ( Level . FINE , STRING , new Object [ ] { prefix , namespaceURI } ) ; if ( prefix == null || namespaceURI == null ) { throw new IllegalArgumentException ( STRING ) ; } prefixToNamespace . put ( prefix , namespaceURI ) ; Set < String > prefixes = namespaceToPrefix . get ( namespaceURI ) ; if ( prefixes == null ) { prefixes = new HashSet < String > ( ) ; } prefixes . add ( prefix ) ; namespaceToPrefix . put ( namespaceURI , prefixes ) ; }
public static void writeHistogram ( TDoubleDoubleHashMap distr , String filename ) throws FileNotFoundException , IOException { BufferedWriter aWriter = IOUtils . getBufferedWriter ( filename ) ; aWriter . write ( STRING ) ; aWriter . newLine ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { aWriter . write ( String . valueOf ( key ) ) ; aWriter . write ( STRING ) ; aWriter . write ( String . valueOf ( distr . get ( key ) ) ) ; aWriter . newLine ( ) ; } aWriter . close ( ) ; }
public static void writeHistogram ( TDoubleDoubleHashMap distr , String filename ) throws FileNotFoundException , IOException { BufferedWriter aWriter = IOUtils . getBufferedWriter ( filename ) ; aWriter . write ( STRING ) ; aWriter . newLine ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { aWriter . write ( String . valueOf ( key ) ) ; aWriter . write ( STRING ) ; aWriter . write ( String . valueOf ( distr . get ( key ) ) ) ; aWriter . newLine ( ) ; } aWriter . close ( ) ; }
public static void writeHistogram ( TDoubleDoubleHashMap distr , String filename ) throws FileNotFoundException , IOException { BufferedWriter aWriter = IOUtils . getBufferedWriter ( filename ) ; aWriter . write ( STRING ) ; aWriter . newLine ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { aWriter . write ( String . valueOf ( key ) ) ; aWriter . write ( STRING ) ; aWriter . write ( String . valueOf ( distr . get ( key ) ) ) ; aWriter . newLine ( ) ; } aWriter . close ( ) ; }
public static void writeHistogram ( TDoubleDoubleHashMap distr , String filename ) throws FileNotFoundException , IOException { BufferedWriter aWriter = IOUtils . getBufferedWriter ( filename ) ; aWriter . write ( STRING ) ; aWriter . newLine ( ) ; double [ ] keys = distr . keys ( ) ; Arrays . sort ( keys ) ; for ( double key : keys ) { aWriter . write ( String . valueOf ( key ) ) ; aWriter . write ( STRING ) ; aWriter . write ( String . valueOf ( distr . get ( key ) ) ) ; aWriter . newLine ( ) ; } aWriter . close ( ) ; }
public void exec ( String description , String [ ] baseCommand ) throws BackupException { exec ( description , baseCommand , null , null , null , _BOOL , _BOOL ) ; }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_BLOCK ) ) { return block ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_UNBLOCK ) ) { return unblock ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ENABLE ) ) { return enable ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DISABLE ) ) { return disable ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ACKNOWLEDGE ) ) { return acknowledge ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_BLOCK ) ) { return block ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_UNBLOCK ) ) { return unblock ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_ENABLE ) ) { return enable ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DISABLE ) ) { return disable ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
public void writeBatch ( ) throws IOException { if ( getRetrieval ( ) == INCREMENTAL ) throw new IOException ( STRING ) ; if ( getInstances ( ) == null ) throw new IOException ( STRING ) ; setRetrieval ( BATCH ) ; if ( m_objectstream == null ) throw new IOException ( STRING ) ; setWriteMode ( WRITE ) ; m_objectstream . writeObject ( getInstances ( ) ) ; m_objectstream . flush ( ) ; m_objectstream . close ( ) ; setWriteMode ( WAIT ) ; resetWriter ( ) ; setWriteMode ( CANCEL ) ; }
VPlexConsistencyGroupInfo findConsistencyGroup ( String cgName , List < VPlexClusterInfo > clusterInfoList , boolean fetchAtts ) throws VPlexApiException { return findConsistencyGroup ( cgName , clusterInfoList , fetchAtts , _BOOL ) ; }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
public void writeExif ( InputStream jpegStream , OutputStream exifOutStream ) throws IOException { if ( jpegStream == null || exifOutStream == null ) { throw new IllegalArgumentException ( NULL_ARGUMENT_STRING ) ; } OutputStream s = getExifWriterStream ( exifOutStream ) ; doExifStreamIO ( jpegStream , s ) ; s . flush ( ) ; }
public void search ( ) { performSearch ( ) ; }
public void search ( ) { performSearch ( ) ; }
public static ClassNode [ ] make ( Class [ ] classes ) { ClassNode [ ] cns = new ClassNode [ classes . length ] ; for ( int i = _NUM ; i < cns . length ; i ++ ) { cns [ i ] = make ( classes [ i ] ) ; } return cns ; }
private void init ( Tuple input ) { profileConfig = ( ProfileConfig ) input . getValueByField ( STRING ) ; measurement = new ProfileMeasurement ( profileConfig . getProfile ( ) , input . getStringByField ( STRING ) , getTimestamp ( ) , periodDurationMillis , TimeUnit . MILLISECONDS ) ; try { JSONObject message = ( JSONObject ) input . getValueByField ( STRING ) ; Map < String , String > expressions = profileConfig . getInit ( ) ; expressions . forEach ( null ) ; } catch ( ParseException e ) { String msg = format ( STRING , e . getMessage ( ) , measurement . getProfileName ( ) , measurement . getEntity ( ) ) ; throw new ParseException ( msg , e ) ; } }
public ConfigurableJtaPlatform ( TransactionManager tm , UserTransaction ut ) { Assert . notNull ( tm , STRING ) ; this . transactionManager = tm ; this . userTransaction = ( ut != null ? ut : new UserTransactionAdapter ( tm ) ) ; }
public String ( byte [ ] data , String encoding ) throws UnsupportedEncodingException { this ( data , _NUM , data . length , encoding ) ; }
public void delete ( JobNotification currentNotification ) { for ( int i = notifications . size ( ) ; -- i >= _NUM ; ) { if ( notifications . get ( i ) == currentNotification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( JobNotification currentNotification ) { for ( int i = notifications . size ( ) ; -- i >= _NUM ; ) { if ( notifications . get ( i ) == currentNotification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( JobNotification currentNotification ) { for ( int i = notifications . size ( ) ; -- i >= _NUM ; ) { if ( notifications . get ( i ) == currentNotification ) { notifications . remove ( i ) ; break ; } } }
public void delete ( JobNotification currentNotification ) { for ( int i = notifications . size ( ) ; -- i >= _NUM ; ) { if ( notifications . get ( i ) == currentNotification ) { notifications . remove ( i ) ; break ; } } }
@ Override public Request < String > logs ( ProjectReference projectReference , long taskId ) { List < DummyBuilderStatus > statuses = availableBuilderStatuses . get ( projectReference . name ( ) ) ; if ( statuses != null && ! statuses . isEmpty ( ) ) { for ( DummyBuilderStatus builderStatus : statuses ) { if ( taskId == builderStatus . taskId ( ) ) { return new DummyRequest < > ( builderStatus . getLog ( ) ) ; } } } return new DummyRequest < > ( null ) ; }
public void checkinConnection ( DBConnectionWrapper conn ) { if ( conn == null ) return ; conn . setCurrentStatement ( null ) ; conn . setInuse ( _BOOL ) ; }
public void checkinConnection ( DBConnectionWrapper conn ) { if ( conn == null ) return ; conn . setCurrentStatement ( null ) ; conn . setInuse ( _BOOL ) ; }
public void consumeIntegers ( String topicName , int count , long timeout , TimeUnit unit , Runnable completion , BiPredicate < String , Integer > consumer ) { AtomicLong readCounter = new AtomicLong ( ) ; consumeIntegers ( continueIfNotExpired ( null , timeout , unit ) , completion , Collections . singleton ( topicName ) , null ) ; }
public void consumeIntegers ( String topicName , int count , long timeout , TimeUnit unit , Runnable completion , BiPredicate < String , Integer > consumer ) { AtomicLong readCounter = new AtomicLong ( ) ; consumeIntegers ( continueIfNotExpired ( null , timeout , unit ) , completion , Collections . singleton ( topicName ) , null ) ; }
public void encode ( DerOutputStream out ) throws IOException { DerOutputStream tagged = new DerOutputStream ( ) ; if ( ( fullName != null ) || ( relativeName != null ) ) { DerOutputStream distributionPoint = new DerOutputStream ( ) ; if ( fullName != null ) { DerOutputStream derOut = new DerOutputStream ( ) ; fullName . encode ( derOut ) ; distributionPoint . writeImplicit ( DerValue . createTag ( DerValue . TAG_CONTEXT , _BOOL , TAG_FULL_NAME ) , derOut ) ; } else if ( relativeName != null ) { DerOutputStream derOut = new DerOutputStream ( ) ; relativeName . encode ( derOut ) ; distributionPoint . writeImplicit ( DerValue . createTag ( DerValue . TAG_CONTEXT , _BOOL , TAG_REL_NAME ) , derOut ) ; } tagged . write ( DerValue . createTag ( DerValue . TAG_CONTEXT , _BOOL , TAG_DIST_PT ) , distributionPoint ) ; } if ( reasonFlags != null ) { DerOutputStream reasons = new DerOutputStream ( ) ; BitArray rf = new BitArray ( reasonFlags ) ; reasons . putTruncatedUnalignedBitString ( rf ) ; tagged . writeImplicit ( DerValue . createTag ( DerValue . TAG_CONTEXT , _BOOL , TAG_REASONS ) , reasons ) ; } if ( crlIssuer != null ) { DerOutputStream issuer = new DerOutputStream ( ) ; crlIssuer . encode ( issuer ) ; tagged . writeImplicit ( DerValue . createTag ( DerValue . TAG_CONTEXT , _BOOL , TAG_ISSUER ) , issuer ) ; } out . write ( DerValue . tag_Sequence , tagged ) ; }
public void test_PreparedPropertiesNotContainOldValues ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( RemoteRepository . OPTION_CREATE_KB_NAMESPACE , namespace ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; final Properties p = m_mgr . getPreparedProperties ( namespace , properties ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; }
public void test_PreparedPropertiesNotContainOldValues ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( RemoteRepository . OPTION_CREATE_KB_NAMESPACE , namespace ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; final Properties p = m_mgr . getPreparedProperties ( namespace , properties ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; }
public void test_PreparedPropertiesNotContainOldValues ( ) throws Exception { String namespace = STRING ; Properties properties = new Properties ( ) ; properties . put ( RemoteRepository . OPTION_CREATE_KB_NAMESPACE , namespace ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; properties . put ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING , STRING ) ; final Properties p = m_mgr . getPreparedProperties ( namespace , properties ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; assertFalse ( p . containsKey ( STRING + RemoteRepository . DEFAULT_NAMESPACE + STRING ) ) ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
private GridCacheVersion minVersion ( Iterable < IgniteTxEntry > entries , GridCacheVersion min , IgniteInternalTx tx ) { for ( IgniteTxEntry txEntry : entries ) { GridCacheEntryEx cached = txEntry . cached ( ) ; assert txEntry . isRead ( ) || ! cached . obsolete ( tx . xidVersion ( ) ) : STRING + cached + STRING + tx + STRING ; for ( GridCacheMvccCandidate cand : cached . remoteMvccSnapshot ( ) ) if ( min == null || cand . version ( ) . isLess ( min ) ) min = cand . version ( ) ; } return min ; }
public void addCertificate ( BurpCertificate burpCertificate ) { rootNode . add ( new DefaultMutableTreeNode ( burpCertificate ) ) ; }
public LdapUserToken ( Authentication auth , String defaultAuthority ) { this ( auth , new GrantedAuthorityImpl ( defaultAuthority ) ) ; }
protected static String resolveSnapshotName ( Snapshot snapshot ) { String persistedName = resolveName ( snapshot , null ) ; if ( persistedName != null ) return persistedName ; File file = snapshot . getFile ( ) ; if ( file == null ) return snapshot . toString ( ) ; String fileName = file . getName ( ) ; SnapshotCategory category = snapshot . getCategory ( ) ; String name = STRING + category . getPrefix ( ) + STRING + fileName ; if ( category . isSnapshot ( file ) ) { String timeStamp = category . getTimeStamp ( fileName ) ; if ( timeStamp != null ) name = STRING + category . getPrefix ( ) + STRING + timeStamp ; } return name ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
private void initHandler ( ContentHandler ch ) throws SAXException { if ( locator != null ) ch . setDocumentLocator ( locator ) ; ch . startDocument ( ) ; for ( PrefixMapping pm = prefixMapping ; pm != null ; pm = pm . parent ) ch . startPrefixMapping ( pm . prefix , pm . uri ) ; }
public void warning ( SAXParseException exception ) throws SAXException { }
static public BigDecimal convert ( Properties ctx , int C_UOM_ID , int C_UOM_To_ID , BigDecimal qty ) { if ( qty == null || qty . compareTo ( Env . ZERO ) == _NUM || C_UOM_ID == C_UOM_To_ID ) return qty ; BigDecimal retValue = getRate ( ctx , C_UOM_ID , C_UOM_To_ID ) ; if ( retValue != null ) { MUOM uom = MUOM . get ( ctx , C_UOM_To_ID ) ; if ( uom != null ) return uom . round ( retValue . multiply ( qty ) , _BOOL ) ; return retValue . multiply ( qty ) ; } return null ; }
static public BigDecimal convert ( Properties ctx , int C_UOM_ID , int C_UOM_To_ID , BigDecimal qty ) { if ( qty == null || qty . compareTo ( Env . ZERO ) == _NUM || C_UOM_ID == C_UOM_To_ID ) return qty ; BigDecimal retValue = getRate ( ctx , C_UOM_ID , C_UOM_To_ID ) ; if ( retValue != null ) { MUOM uom = MUOM . get ( ctx , C_UOM_To_ID ) ; if ( uom != null ) return uom . round ( retValue . multiply ( qty ) , _BOOL ) ; return retValue . multiply ( qty ) ; } return null ; }
public boolean addValue ( Value v ) { return values . add ( v ) ; }
private static byte [ ] toByteArray ( InputStream inputStream ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; byte buffer [ ] = new byte [ _NUM ] ; while ( _BOOL ) { int read = inputStream . read ( buffer ) ; if ( read == - _NUM ) { break ; } baos . write ( buffer , _NUM , read ) ; } return baos . toByteArray ( ) ; }
public InfocardInvocation ( OpenIDTokenType tokenType ) { _requiredClaims . add ( OpenIDTokenType . OPENID_CLAIM ) ; _tokenType = tokenType ; if ( DEBUG ) _log . debug ( STRING + _tokenType + STRING ) ; }
protected Mac ( MacSpi macSpi , Provider provider , String algorithm ) { this . spi = macSpi ; this . provider = provider ; this . algorithm = algorithm ; serviceIterator = null ; lock = null ; }
public static InputStream toInputStream ( CharSequence input ) { return toInputStream ( input . toString ( ) ) ; }
public static InputStream toInputStream ( CharSequence input ) { return toInputStream ( input . toString ( ) ) ; }
public void register ( Automation automation ) { Integer oldSize = Integer . valueOf ( _automationHashTable . size ( ) ) ; _automationHashTable . put ( automation . getId ( ) , automation ) ; int id = Integer . parseInt ( automation . getId ( ) ) ; if ( id > _id ) { _id = id ; } setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _automationHashTable . size ( ) ) ) ; }
public void register ( Automation automation ) { Integer oldSize = Integer . valueOf ( _automationHashTable . size ( ) ) ; _automationHashTable . put ( automation . getId ( ) , automation ) ; int id = Integer . parseInt ( automation . getId ( ) ) ; if ( id > _id ) { _id = id ; } setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _automationHashTable . size ( ) ) ) ; }
public void register ( Automation automation ) { Integer oldSize = Integer . valueOf ( _automationHashTable . size ( ) ) ; _automationHashTable . put ( automation . getId ( ) , automation ) ; int id = Integer . parseInt ( automation . getId ( ) ) ; if ( id > _id ) { _id = id ; } setDirtyAndFirePropertyChange ( LISTLENGTH_CHANGED_PROPERTY , oldSize , Integer . valueOf ( _automationHashTable . size ( ) ) ) ; }
private void updateStateView ( int itCount , Collection < Individual < Double > > gen ) { Platform . runLater ( null ) ; simPaneCtrl . waitAfterStep ( ) ; }
private void updateStateView ( int itCount , Collection < Individual < Double > > gen ) { Platform . runLater ( null ) ; simPaneCtrl . waitAfterStep ( ) ; }
public void install ( JEditorPane c ) { c . addCaretListener ( inputAttributeUpdater ) ; c . addPropertyChangeListener ( inputAttributeUpdater ) ; Caret caret = c . getCaret ( ) ; if ( caret != null ) { inputAttributeUpdater . updateInputAttributes ( caret . getDot ( ) , caret . getMark ( ) , c ) ; } }
public Name join ( Name rhs ) { List < NamePiece > newPieceList = new ArrayList < > ( ) ; newPieceList . addAll ( namePieces ) ; newPieceList . addAll ( rhs . namePieces ) ; return new Name ( newPieceList ) ; }
public Name join ( Name rhs ) { List < NamePiece > newPieceList = new ArrayList < > ( ) ; newPieceList . addAll ( namePieces ) ; newPieceList . addAll ( rhs . namePieces ) ; return new Name ( newPieceList ) ; }
public Object remove ( Object key ) { processQueue ( ) ; return map . remove ( Key . create ( key , null ) ) ; }
protected static PropertyDescriptor [ ] introspect ( Class clazz ) { BeanInfo beanInfo ; try { beanInfo = Introspector . getBeanInfo ( clazz ) ; } catch ( IntrospectionException e ) { return ( new PropertyDescriptor [ _NUM ] ) ; } return beanInfo . getPropertyDescriptors ( ) ; }
protected static PropertyDescriptor [ ] introspect ( Class clazz ) { BeanInfo beanInfo ; try { beanInfo = Introspector . getBeanInfo ( clazz ) ; } catch ( IntrospectionException e ) { return ( new PropertyDescriptor [ _NUM ] ) ; } return beanInfo . getPropertyDescriptors ( ) ; }
protected static PropertyDescriptor [ ] introspect ( Class clazz ) { BeanInfo beanInfo ; try { beanInfo = Introspector . getBeanInfo ( clazz ) ; } catch ( IntrospectionException e ) { return ( new PropertyDescriptor [ _NUM ] ) ; } return beanInfo . getPropertyDescriptors ( ) ; }
public static long scaleLargeTimestamp ( long timestamp , long multiplier , long divisor ) { if ( divisor >= multiplier && ( divisor % multiplier ) == _NUM ) { long divisionFactor = divisor / multiplier ; return timestamp / divisionFactor ; } else if ( divisor < multiplier && ( multiplier % divisor ) == _NUM ) { long multiplicationFactor = multiplier / divisor ; return timestamp * multiplicationFactor ; } else { double multiplicationFactor = ( double ) multiplier / divisor ; return ( long ) ( timestamp * multiplicationFactor ) ; } }
public static long scaleLargeTimestamp ( long timestamp , long multiplier , long divisor ) { if ( divisor >= multiplier && ( divisor % multiplier ) == _NUM ) { long divisionFactor = divisor / multiplier ; return timestamp / divisionFactor ; } else if ( divisor < multiplier && ( multiplier % divisor ) == _NUM ) { long multiplicationFactor = multiplier / divisor ; return timestamp * multiplicationFactor ; } else { double multiplicationFactor = ( double ) multiplier / divisor ; return ( long ) ( timestamp * multiplicationFactor ) ; } }
public void addMetadataEntry ( String value ) { metadata . add ( value . replaceAll ( STRING , STRING ) ) ; }
public void onReady ( Runnable runnable ) { runnable . run ( ) ; }
public void onReady ( Runnable runnable ) { runnable . run ( ) ; }
public void onReady ( Runnable runnable ) { runnable . run ( ) ; }
public static < I , M , E extends Exception > Set < M > transformSet ( final Collection < I > values , final Function < I , M , E > mapper ) throws E { Reject . ifNull ( values , mapper ) ; final Set < M > newSet = new HashSet < M > ( values . size ( ) ) ; for ( I value : values ) { newSet . add ( mapper . apply ( value ) ) ; } return newSet ; }
public static List < Entry > loadEntriesFromFile ( String path ) { File sdcard = Environment . getExternalStorageDirectory ( ) ; File file = new File ( sdcard , path ) ; List < Entry > entries = new ArrayList < Entry > ( ) ; try { @ SuppressWarnings ( STRING ) BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] split = line . split ( STRING ) ; if ( split . length <= _NUM ) { entries . add ( new Entry ( Float . parseFloat ( split [ _NUM ] ) , Integer . parseInt ( split [ _NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - _NUM ] ; for ( int i = _NUM ; i < vals . length ; i ++ ) { vals [ i ] = Float . parseFloat ( split [ i ] ) ; } entries . add ( new BarEntry ( Integer . parseInt ( split [ split . length - _NUM ] ) , vals ) ) ; } } } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } return entries ; }
public static String escapeQuotedSwitch ( String value ) { return value . replaceAll ( STRING , STRING ) ; }
public static String escapeQuotedSwitch ( String value ) { return value . replaceAll ( STRING , STRING ) ; }
public static String escapeQuotedSwitch ( String value ) { return value . replaceAll ( STRING , STRING ) ; }
public QueryFailedException ( Connection connection , DN dn , Filter filter , Throwable cause ) { super ( MessageFormat . format ( STRING + STRING + STRING + STRING , dn , connection , filter ) , cause ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public Rectangle ( Double x , Double y , Double width , Double height ) { this ( ( int ) Math . round ( x ) , ( int ) Math . round ( y ) , ( int ) Math . round ( width ) , ( int ) Math . round ( height ) ) ; }
public static ConnectionFactory newFailoverConnectionPool ( Set < LDAPURL > servers , String username , char [ ] password , int maxSize , int heartBeatInterval , String heartBeatTimeUnit , Options ldapOptions ) { List < ConnectionFactory > factories = new ArrayList < ConnectionFactory > ( servers . size ( ) ) ; for ( LDAPURL ldapurl : servers ) { ConnectionFactory cf = Connections . newFixedConnectionPool ( newConnectionFactory ( ldapurl , username , password , heartBeatInterval , heartBeatTimeUnit , ldapOptions ) , maxSize ) ; factories . add ( cf ) ; } return loadBalanceFactories ( factories ) ; }
public static String timeUntil ( final int seconds , final boolean forceSeconds ) { final StringBuilder sbuf = new StringBuilder ( ) ; timeUntil ( sbuf , seconds , forceSeconds ) ; return sbuf . toString ( ) ; }
public static String timeUntil ( final int seconds , final boolean forceSeconds ) { final StringBuilder sbuf = new StringBuilder ( ) ; timeUntil ( sbuf , seconds , forceSeconds ) ; return sbuf . toString ( ) ; }
public static String timeUntil ( final int seconds , final boolean forceSeconds ) { final StringBuilder sbuf = new StringBuilder ( ) ; timeUntil ( sbuf , seconds , forceSeconds ) ; return sbuf . toString ( ) ; }
private List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { final List < Resource > imports = new ArrayList < Resource > ( ) ; final String css = cssContent ; final List < String > foundImports = findImports ( css ) ; for ( final String importUrl : foundImports ) { final Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; if ( imports . contains ( importedResource ) ) { LOG . debug ( STRING , importedResource ) ; } else { imports . add ( importedResource ) ; onImportDetected ( importedResource . getUri ( ) ) ; } } return imports ; }
private List < Resource > findImportedResources ( final String resourceUri , final String cssContent ) throws IOException { final List < Resource > imports = new ArrayList < Resource > ( ) ; final String css = cssContent ; final List < String > foundImports = findImports ( css ) ; for ( final String importUrl : foundImports ) { final Resource importedResource = createImportedResource ( resourceUri , importUrl ) ; if ( imports . contains ( importedResource ) ) { LOG . debug ( STRING , importedResource ) ; } else { imports . add ( importedResource ) ; onImportDetected ( importedResource . getUri ( ) ) ; } } return imports ; }
public long time ( ) { return System . currentTimeMillis ( ) ; }
int boundedIndexOf ( String string , char search , int start , int end ) { int retValue = string . indexOf ( search , start ) ; if ( retValue >= end ) { return - _NUM ; } return retValue ; }
int boundedIndexOf ( String string , char search , int start , int end ) { int retValue = string . indexOf ( search , start ) ; if ( retValue >= end ) { return - _NUM ; } return retValue ; }
int boundedIndexOf ( String string , char search , int start , int end ) { int retValue = string . indexOf ( search , start ) ; if ( retValue >= end ) { return - _NUM ; } return retValue ; }
public byte [ ] calculateHMAC_SHA256 ( byte [ ] input , byte [ ] key , int length ) { byte [ ] output = null ; try { hmacSHA256 . init ( new SecretKeySpec ( key , _NUM , length , STRING ) ) ; output = hmacSHA256 . doFinal ( input ) ; } catch ( InvalidKeyException e ) { log . error ( STRING , e ) ; } return output ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public void test_ConstructorLjava_lang_StringLjava_text_DecimalFormatSymbols ( ) { try { DecimalFormatSymbols dfs = new DecimalFormatSymbols ( Locale . CANADA ) ; DecimalFormat format1 = new DecimalFormat ( STRING , dfs ) ; DecimalFormat format2 = new DecimalFormat ( ) ; format2 . applyPattern ( STRING ) ; format2 . setDecimalFormatSymbols ( dfs ) ; assertTrue ( STRING , format2 . equals ( format1 ) ) ; assertTrue ( STRING , ! format1 . equals ( new DecimalFormat ( STRING , new DecimalFormatSymbols ( Locale . CHINA ) ) ) ) ; try { new DecimalFormat ( STRING , ( DecimalFormatSymbols ) null ) ; fail ( STRING ) ; } catch ( NullPointerException e ) { } try { new DecimalFormat ( null , new DecimalFormatSymbols ( ) ) ; fail ( STRING ) ; } catch ( NullPointerException e ) { } try { new DecimalFormat ( null , ( DecimalFormatSymbols ) null ) ; fail ( STRING ) ; } catch ( NullPointerException e ) { } try { new DecimalFormat ( STRING , new DecimalFormatSymbols ( ) ) ; fail ( STRING ) ; } catch ( IllegalArgumentException e ) { } } catch ( Exception e ) { fail ( STRING + e . toString ( ) ) ; } }
public final < V extends Enum < V > & PaginationFilterProperty > boolean test ( T object , Class < V > enumType ) { if ( StringUtils . isBlank ( filter ) ) { return _BOOL ; } else if ( filter . contains ( SEPARATOR ) ) { if ( StringUtils . containsNone ( StringUtils . substringBefore ( filter , SEPARATOR ) , DELIMITER ) ) { return testFields ( object , enumType ) ; } return testFields ( object , enumType ) && testFulltext ( object , enumType ) ; } return testFulltext ( object , enumType ) ; }
public void add ( double value ) { if ( Double . isNaN ( value ) ) { return ; } int index = findInsertIndex ( value ) ; if ( index == - _NUM ) { values . add ( value ) ; } else { values . add ( index , value ) ; } }
public static long parseLong ( java . lang . String s ) throws java . lang . NumberFormatException { return parseLong ( s , _NUM ) ; }
public static long parseLong ( java . lang . String s ) throws java . lang . NumberFormatException { return parseLong ( s , _NUM ) ; }
public static long parseLong ( java . lang . String s ) throws java . lang . NumberFormatException { return parseLong ( s , _NUM ) ; }
public static void registerDefaultResolvers ( ) { synchronized ( resolverList ) { resolverList . add ( new ResourceResolver ( new ResolverFragment ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverLocalFilesystem ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverXPointer ( ) ) ) ; resolverList . add ( new ResourceResolver ( new ResolverDirectHTTP ( ) ) ) ; } }
protected static Long convertTimepointToBucketingLong ( Date timepointToBeConverted ) { if ( timepointToBeConverted == null ) { return null ; } Long toReturn = timepointToBeConverted . getTime ( ) - PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MIN ; if ( toReturn < _NUM ) { return _NUM ; } else if ( toReturn > PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ) { return PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ; } else { return toReturn ; } }
protected static Long convertTimepointToBucketingLong ( Date timepointToBeConverted ) { if ( timepointToBeConverted == null ) { return null ; } Long toReturn = timepointToBeConverted . getTime ( ) - PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MIN ; if ( toReturn < _NUM ) { return _NUM ; } else if ( toReturn > PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ) { return PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ; } else { return toReturn ; } }
protected static Long convertTimepointToBucketingLong ( Date timepointToBeConverted ) { if ( timepointToBeConverted == null ) { return null ; } Long toReturn = timepointToBeConverted . getTime ( ) - PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MIN ; if ( toReturn < _NUM ) { return _NUM ; } else if ( toReturn > PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ) { return PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ; } else { return toReturn ; } }
protected static Long convertTimepointToBucketingLong ( Date timepointToBeConverted ) { if ( timepointToBeConverted == null ) { return null ; } Long toReturn = timepointToBeConverted . getTime ( ) - PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MIN ; if ( toReturn < _NUM ) { return _NUM ; } else if ( toReturn > PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ) { return PrimaryIndexBucketGeneratorImpl . TIMEPOINT_MAX ; } else { return toReturn ; } }
@ Override public String run ( String [ ] args ) { if ( args . length == _NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > _NUM ) { String cmd = args [ _NUM ] ; if ( cmd == STRING ) { if ( args . length > _NUM ) { int id = Integer . parseInt ( args [ _NUM ] ) ; return strListNetwork ( id , _BOOL ) ; } else { return strListNetworks ( _BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > _NUM ) { int id1 = Integer . parseInt ( args [ _NUM ] ) ; int id2 = Integer . parseInt ( args [ _NUM ] ) ; int id3 = Integer . parseInt ( args [ _NUM ] ) ; return strLink3 ( id1 , id2 , id3 ) ; } else if ( args . length > _NUM ) { int id1 = Integer . parseInt ( args [ _NUM ] ) ; int id2 = Integer . parseInt ( args [ _NUM ] ) ; return strLink2 ( id1 , id2 ) ; } } else if ( cmd == STRING ) { if ( args . length > _NUM ) { int id = Integer . parseInt ( args [ _NUM ] ) ; return strUnlinkID ( id ) ; } else { return strUnlinkAll ( ) ; } } return STRING ; } } catch ( NumberFormatException nfe ) { } catch ( NullPointerException npe ) { } catch ( IndexOutOfBoundsException ioobe ) { } return STRING ; }
@ Override public String run ( String [ ] args ) { if ( args . length == _NUM ) { String help = STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; help += STRING ; return help ; } try { if ( args . length > _NUM ) { String cmd = args [ _NUM ] ; if ( cmd == STRING ) { if ( args . length > _NUM ) { int id = Integer . parseInt ( args [ _NUM ] ) ; return strListNetwork ( id , _BOOL ) ; } else { return strListNetworks ( _BOOL ) ; } } else if ( cmd == STRING ) { if ( args . length > _NUM ) { int id1 = Integer . parseInt ( args [ _NUM ] ) ; int id2 = Integer . parseInt ( args [ _NUM ] ) ; int id3 = Integer . parseInt ( args [ _NUM ] ) ; return strLink3 ( id1 , id2 , id3 ) ; } else if ( args . length > _NUM ) { int id1 = Integer . parseInt ( args [ _NUM ] ) ; int id2 = Integer . parseInt ( args [ _NUM ] ) ; return strLink2 ( id1 , id2 ) ; } } else if ( cmd == STRING ) { if ( args . length > _NUM ) { int id = Integer . parseInt ( args [ _NUM ] ) ; return strUnlinkID ( id ) ; } else { return strUnlinkAll ( ) ; } } return STRING ; } } catch ( NumberFormatException nfe ) { } catch ( NullPointerException npe ) { } catch ( IndexOutOfBoundsException ioobe ) { } return STRING ; }
public long readUBits ( int numBits ) throws IOException { if ( numBits == _NUM ) { return _NUM ; } int bitsLeft = numBits ; long result = _NUM ; if ( bitPos == _NUM ) { bitBuf = in . read ( ) ; bitPos = _NUM ; bytesRead ++ ; } while ( _BOOL ) { int shift = bitsLeft - bitPos ; if ( shift > _NUM ) { result |= bitBuf << shift ; bitsLeft -= bitPos ; bitBuf = in . read ( ) ; bitPos = _NUM ; bytesRead ++ ; } else { result |= bitBuf > > - shift ; bitPos -= bitsLeft ; bitBuf &= _NUM > > ( _NUM - bitPos ) ; return result ; } } }
void sendMessageToHandlerWithControllerReset ( List < OFMessage > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; sendMessageToHandlerNoControllerReset ( messages ) ; }
void sendMessageToHandlerWithControllerReset ( List < OFMessage > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; sendMessageToHandlerNoControllerReset ( messages ) ; }
void sendMessageToHandlerWithControllerReset ( List < OFMessage > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; sendMessageToHandlerNoControllerReset ( messages ) ; }
void sendMessageToHandlerWithControllerReset ( List < OFMessage > messages ) throws Exception { verify ( controller ) ; reset ( controller ) ; sendMessageToHandlerNoControllerReset ( messages ) ; }
public void readMoments ( InputStream missionStream ) throws MissionParseException { MissionParser . parseMission ( missionStream , this ) ; }
public void readMoments ( InputStream missionStream ) throws MissionParseException { MissionParser . parseMission ( missionStream , this ) ; }
public void readMoments ( InputStream missionStream ) throws MissionParseException { MissionParser . parseMission ( missionStream , this ) ; }
private void ensureTupleArray ( int row ) { int nrows = Math . max ( m_table . getRowCount ( ) , row + _NUM ) ; if ( m_tuples == null ) { m_tuples = new TableTuple [ nrows ] ; } else if ( m_tuples . length < nrows ) { int capacity = Math . max ( ( _NUM * m_tuples . length ) / _NUM + _NUM , nrows ) ; TableTuple [ ] tuples = new TableTuple [ capacity ] ; System . arraycopy ( m_tuples , _NUM , tuples , _NUM , m_tuples . length ) ; m_tuples = tuples ; } }
private void loadBinary ( DataInputStream dis ) throws IOException { int size ; if ( dis . readInt ( ) != MAGIC ) { throw new Error ( STRING ) ; } if ( dis . readInt ( ) != VERSION ) { throw new Error ( STRING ) ; } sampleRate = dis . readInt ( ) ; numChannels = dis . readInt ( ) ; lpcMin = dis . readFloat ( ) ; lpcRange = dis . readFloat ( ) ; size = dis . readInt ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { Diphone diphone = Diphone . loadBinary ( dis ) ; add ( diphone ) ; } }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public static Optional < Object [ ] > remove ( final String keyToRemove , final Object ... keyValues ) { return ElementHelper . remove ( ( Object ) keyToRemove , keyValues ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speedLimiter . applyAsDouble ( magnitude ) * SQRT_OF_TWO ; double dirInRad = ( direction + _NUM ) * Math . PI / _NUM ; double cosD = Math . cos ( dirInRad ) ; double sinD = Math . sin ( dirInRad ) ; double wheelSpeeds [ ] = new double [ NUMBER_OF_MOTORS ] ; wheelSpeeds [ LEFT_FRONT ] = ( sinD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_FRONT ] = ( cosD * magnitude - rotation ) ; wheelSpeeds [ LEFT_REAR ] = ( cosD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_REAR ] = ( sinD * magnitude - rotation ) ; normalize ( wheelSpeeds ) ; scale ( wheelSpeeds , OUTPUT_SCALE_FACTOR ) ; leftFront . setSpeed ( wheelSpeeds [ LEFT_FRONT ] ) ; leftRear . setSpeed ( wheelSpeeds [ LEFT_REAR ] ) ; rightFront . setSpeed ( wheelSpeeds [ RIGHT_FRONT ] ) ; rightRear . setSpeed ( wheelSpeeds [ RIGHT_REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speedLimiter . applyAsDouble ( magnitude ) * SQRT_OF_TWO ; double dirInRad = ( direction + _NUM ) * Math . PI / _NUM ; double cosD = Math . cos ( dirInRad ) ; double sinD = Math . sin ( dirInRad ) ; double wheelSpeeds [ ] = new double [ NUMBER_OF_MOTORS ] ; wheelSpeeds [ LEFT_FRONT ] = ( sinD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_FRONT ] = ( cosD * magnitude - rotation ) ; wheelSpeeds [ LEFT_REAR ] = ( cosD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_REAR ] = ( sinD * magnitude - rotation ) ; normalize ( wheelSpeeds ) ; scale ( wheelSpeeds , OUTPUT_SCALE_FACTOR ) ; leftFront . setSpeed ( wheelSpeeds [ LEFT_FRONT ] ) ; leftRear . setSpeed ( wheelSpeeds [ LEFT_REAR ] ) ; rightFront . setSpeed ( wheelSpeeds [ RIGHT_FRONT ] ) ; rightRear . setSpeed ( wheelSpeeds [ RIGHT_REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speedLimiter . applyAsDouble ( magnitude ) * SQRT_OF_TWO ; double dirInRad = ( direction + _NUM ) * Math . PI / _NUM ; double cosD = Math . cos ( dirInRad ) ; double sinD = Math . sin ( dirInRad ) ; double wheelSpeeds [ ] = new double [ NUMBER_OF_MOTORS ] ; wheelSpeeds [ LEFT_FRONT ] = ( sinD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_FRONT ] = ( cosD * magnitude - rotation ) ; wheelSpeeds [ LEFT_REAR ] = ( cosD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_REAR ] = ( sinD * magnitude - rotation ) ; normalize ( wheelSpeeds ) ; scale ( wheelSpeeds , OUTPUT_SCALE_FACTOR ) ; leftFront . setSpeed ( wheelSpeeds [ LEFT_FRONT ] ) ; leftRear . setSpeed ( wheelSpeeds [ LEFT_REAR ] ) ; rightFront . setSpeed ( wheelSpeeds [ RIGHT_FRONT ] ) ; rightRear . setSpeed ( wheelSpeeds [ RIGHT_REAR ] ) ; }
public void polar ( double magnitude , double direction , double rotation ) { magnitude = speedLimiter . applyAsDouble ( magnitude ) * SQRT_OF_TWO ; double dirInRad = ( direction + _NUM ) * Math . PI / _NUM ; double cosD = Math . cos ( dirInRad ) ; double sinD = Math . sin ( dirInRad ) ; double wheelSpeeds [ ] = new double [ NUMBER_OF_MOTORS ] ; wheelSpeeds [ LEFT_FRONT ] = ( sinD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_FRONT ] = ( cosD * magnitude - rotation ) ; wheelSpeeds [ LEFT_REAR ] = ( cosD * magnitude + rotation ) ; wheelSpeeds [ RIGHT_REAR ] = ( sinD * magnitude - rotation ) ; normalize ( wheelSpeeds ) ; scale ( wheelSpeeds , OUTPUT_SCALE_FACTOR ) ; leftFront . setSpeed ( wheelSpeeds [ LEFT_FRONT ] ) ; leftRear . setSpeed ( wheelSpeeds [ LEFT_REAR ] ) ; rightFront . setSpeed ( wheelSpeeds [ RIGHT_FRONT ] ) ; rightRear . setSpeed ( wheelSpeeds [ RIGHT_REAR ] ) ; }
public void addConnection ( Connection connection ) { if ( connection == null ) throw new IllegalArgumentException ( STRING ) ; synchronized ( connectionsLock ) { Connection [ ] newConnections = new Connection [ connections . length + _NUM ] ; newConnections [ _NUM ] = connection ; System . arraycopy ( connections , _NUM , newConnections , _NUM , connections . length ) ; connections = newConnections ; } connection . addListener ( invokeListener ) ; if ( TRACE ) trace ( STRING , STRING + connection ) ; }
public synchronized void waitForSubmittedTasks ( ) throws InterruptedException { while ( currentTaskCount . get ( ) > _NUM ) { waitForSingleTask ( ) ; } }
public synchronized void waitForSubmittedTasks ( ) throws InterruptedException { while ( currentTaskCount . get ( ) > _NUM ) { waitForSingleTask ( ) ; } }
@ SuppressWarnings ( STRING ) void removeBox ( ValueBox vb ) { if ( vb == null ) return ; if ( boxes == vb ) { boxes = null ; } else if ( boxes instanceof List ) { List < ValueBox > list = ( List < ValueBox > ) boxes ; list . remove ( vb ) ; } }
public void reset ( ) { Metamodel . resetModuleManager ( ) ; }
public void reset ( ) { Metamodel . resetModuleManager ( ) ; }
public void reset ( ) { Metamodel . resetModuleManager ( ) ; }
public Shape screenToChartShape ( Shape s ) { GeneralPath p = new GeneralPath ( ) ; Transform t = Transform . makeIdentity ( ) ; if ( currentTransform != null ) { t . concatenate ( currentTransform . getInverse ( ) ) ; } t . translate ( - getAbsoluteX ( ) , - getAbsoluteY ( ) ) ; p . append ( s . getPathIterator ( t ) , _BOOL ) ; return p ; }
public Shape screenToChartShape ( Shape s ) { GeneralPath p = new GeneralPath ( ) ; Transform t = Transform . makeIdentity ( ) ; if ( currentTransform != null ) { t . concatenate ( currentTransform . getInverse ( ) ) ; } t . translate ( - getAbsoluteX ( ) , - getAbsoluteY ( ) ) ; p . append ( s . getPathIterator ( t ) , _BOOL ) ; return p ; }
public void write ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getWidth ( null ) * _NUM / _NUM + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= prFirst ) { page . drawImage ( c , x , y , c . getWidth ( null ) * _NUM / _NUM , c . getHeight ( null ) * _NUM / _NUM , null ) ; } }
public void testDivisionKnuthOneDigitByOneDigit ( ) { byte aBytes [ ] = { _NUM , - _NUM , _NUM , - _NUM } ; byte bBytes [ ] = { _NUM , - _NUM , - _NUM , - _NUM } ; int aSign = _NUM ; int bSign = - _NUM ; byte rBytes [ ] = { - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , result . signum ( ) ) ; }
public void testDivisionKnuthOneDigitByOneDigit ( ) { byte aBytes [ ] = { _NUM , - _NUM , _NUM , - _NUM } ; byte bBytes [ ] = { _NUM , - _NUM , - _NUM , - _NUM } ; int aSign = _NUM ; int bSign = - _NUM ; byte rBytes [ ] = { - _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . divide ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , result . signum ( ) ) ; }
private static void throwBounds ( ) { throw new IndexOutOfBoundsException ( STRING ) ; }
private static void throwBounds ( ) { throw new IndexOutOfBoundsException ( STRING ) ; }
private static void createAndShowGUI ( ) { JFrame frame = new JFrame ( STRING ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( new ToolBarDemo2 ( ) ) ; frame . pack ( ) ; frame . setVisible ( _BOOL ) ; }
private static void createAndShowGUI ( ) { JFrame frame = new JFrame ( STRING ) ; frame . setDefaultCloseOperation ( JFrame . EXIT_ON_CLOSE ) ; frame . add ( new ToolBarDemo2 ( ) ) ; frame . pack ( ) ; frame . setVisible ( _BOOL ) ; }
static void writeUTF ( OutputStream out , String str ) throws IOException { for ( int i = _NUM , len = str . length ( ) ; i < len ; i ++ ) { int c = str . charAt ( i ) ; if ( ( c >= _NUM ) && ( c <= _NUM ) ) { out . write ( c ) ; } else { if ( c > _NUM ) { out . write ( _NUM | ( ( c > > _NUM ) & _NUM ) ) ; out . write ( _NUM | ( ( c > > _NUM ) & _NUM ) ) ; out . write ( _NUM | ( ( c > > _NUM ) & _NUM ) ) ; } else { out . write ( _NUM | ( ( c > > _NUM ) & _NUM ) ) ; out . write ( _NUM | ( ( c > > _NUM ) & _NUM ) ) ; } } } }
DateTimeFormatter toFormatter ( ResolverStyle resolverStyle , Chronology chrono ) { return toFormatter ( Locale . getDefault ( Locale . Category . FORMAT ) , resolverStyle , chrono ) ; }
DateTimeFormatter toFormatter ( ResolverStyle resolverStyle , Chronology chrono ) { return toFormatter ( Locale . getDefault ( Locale . Category . FORMAT ) , resolverStyle , chrono ) ; }
DateTimeFormatter toFormatter ( ResolverStyle resolverStyle , Chronology chrono ) { return toFormatter ( Locale . getDefault ( Locale . Category . FORMAT ) , resolverStyle , chrono ) ; }
public Integer toInteger ( ) { return Integer . valueOf ( intValue ( ) ) ; }
public boolean equals ( Object o ) { return map . equals ( o ) ; }
protected void populateClient ( String clientName , Properties props ) throws InvalidPropertiesFormatException { String name = props . getProperty ( clientName + NAME_SUFFIX ) ; String attrList = props . getProperty ( clientName + ATTRIBUTE_SUFFIX ) ; StringTokenizer st = new StringTokenizer ( attrList , COMMA ) ; Map attributes = new HashMap ( ) ; Set attributeValues = null ; while ( st . hasMoreTokens ( ) ) { attributeValues = new HashSet ( ) ; String entry = st . nextToken ( ) ; String attrName = entry . substring ( _NUM , entry . indexOf ( EQUALS ) ) ; String attrValue = entry . substring ( entry . indexOf ( EQUALS ) + _NUM ) ; attributeValues . add ( attrValue ) ; attributes . put ( attrName , attributeValues ) ; } clients . put ( name , new Client ( name , attributes ) ) ; clientsData . put ( name , attributes ) ; }
public void reset ( ) throws SecurityException { checkPermission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initializedGlobalHandlers = _BOOL ; } for ( LoggerContext cx : contexts ( ) ) { Enumeration < String > enum_ = cx . getLoggerNames ( ) ; while ( enum_ . hasMoreElements ( ) ) { String name = enum_ . nextElement ( ) ; Logger logger = cx . findLogger ( name ) ; if ( logger != null ) { resetLogger ( logger ) ; } } } }
public void reset ( ) throws SecurityException { checkPermission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initializedGlobalHandlers = _BOOL ; } for ( LoggerContext cx : contexts ( ) ) { Enumeration < String > enum_ = cx . getLoggerNames ( ) ; while ( enum_ . hasMoreElements ( ) ) { String name = enum_ . nextElement ( ) ; Logger logger = cx . findLogger ( name ) ; if ( logger != null ) { resetLogger ( logger ) ; } } } }
public void reset ( ) throws SecurityException { checkPermission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initializedGlobalHandlers = _BOOL ; } for ( LoggerContext cx : contexts ( ) ) { Enumeration < String > enum_ = cx . getLoggerNames ( ) ; while ( enum_ . hasMoreElements ( ) ) { String name = enum_ . nextElement ( ) ; Logger logger = cx . findLogger ( name ) ; if ( logger != null ) { resetLogger ( logger ) ; } } } }
public void reset ( ) throws SecurityException { checkPermission ( ) ; synchronized ( this ) { props = new Properties ( ) ; initializedGlobalHandlers = _BOOL ; } for ( LoggerContext cx : contexts ( ) ) { Enumeration < String > enum_ = cx . getLoggerNames ( ) ; while ( enum_ . hasMoreElements ( ) ) { String name = enum_ . nextElement ( ) ; Logger logger = cx . findLogger ( name ) ; if ( logger != null ) { resetLogger ( logger ) ; } } } }
public void onDrawerClosed ( View view ) { super . onDrawerClosed ( view ) ; updateActionBarTitleAndHomeButton ( null ) ; invalidateOptionsMenu ( ) ; }
public void onDrawerClosed ( View view ) { super . onDrawerClosed ( view ) ; updateActionBarTitleAndHomeButton ( null ) ; invalidateOptionsMenu ( ) ; }
public void onDrawerClosed ( View view ) { super . onDrawerClosed ( view ) ; updateActionBarTitleAndHomeButton ( null ) ; invalidateOptionsMenu ( ) ; }
public static EventBean [ ] flatten ( ArrayDeque < EventBean [ ] > eventVector ) { if ( eventVector . isEmpty ( ) ) { return null ; } if ( eventVector . size ( ) == _NUM ) { return eventVector . getFirst ( ) ; } int totalElements = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { totalElements += arr . length ; } } if ( totalElements == _NUM ) { return null ; } EventBean [ ] result = new EventBean [ totalElements ] ; int destPos = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { System . arraycopy ( arr , _NUM , result , destPos , arr . length ) ; destPos += arr . length ; } } return result ; }
public static EventBean [ ] flatten ( ArrayDeque < EventBean [ ] > eventVector ) { if ( eventVector . isEmpty ( ) ) { return null ; } if ( eventVector . size ( ) == _NUM ) { return eventVector . getFirst ( ) ; } int totalElements = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { totalElements += arr . length ; } } if ( totalElements == _NUM ) { return null ; } EventBean [ ] result = new EventBean [ totalElements ] ; int destPos = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { System . arraycopy ( arr , _NUM , result , destPos , arr . length ) ; destPos += arr . length ; } } return result ; }
public static EventBean [ ] flatten ( ArrayDeque < EventBean [ ] > eventVector ) { if ( eventVector . isEmpty ( ) ) { return null ; } if ( eventVector . size ( ) == _NUM ) { return eventVector . getFirst ( ) ; } int totalElements = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { totalElements += arr . length ; } } if ( totalElements == _NUM ) { return null ; } EventBean [ ] result = new EventBean [ totalElements ] ; int destPos = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { System . arraycopy ( arr , _NUM , result , destPos , arr . length ) ; destPos += arr . length ; } } return result ; }
public static EventBean [ ] flatten ( ArrayDeque < EventBean [ ] > eventVector ) { if ( eventVector . isEmpty ( ) ) { return null ; } if ( eventVector . size ( ) == _NUM ) { return eventVector . getFirst ( ) ; } int totalElements = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { totalElements += arr . length ; } } if ( totalElements == _NUM ) { return null ; } EventBean [ ] result = new EventBean [ totalElements ] ; int destPos = _NUM ; for ( EventBean [ ] arr : eventVector ) { if ( arr != null ) { System . arraycopy ( arr , _NUM , result , destPos , arr . length ) ; destPos += arr . length ; } } return result ; }
public void insert ( EventBean theEvent ) { events . add ( theEvent ) ; EventBean [ ] oldEvents = null ; if ( events . size ( ) > depth ) { oldEvents = new EventBean [ ] { events . remove ( _NUM ) } ; } for ( View child : childViews ) { child . update ( new EventBean [ ] { theEvent } , oldEvents ) ; } }
protected void drawAxisLine ( Graphics2D g2 , double cursor , Rectangle2D dataArea , RectangleEdge edge ) { Line2D axisLine = null ; double x = dataArea . getX ( ) ; double y = dataArea . getY ( ) ; if ( edge == RectangleEdge . TOP ) { axisLine = new Line2D . Double ( x , cursor , dataArea . getMaxX ( ) , cursor ) ; } else if ( edge == RectangleEdge . BOTTOM ) { axisLine = new Line2D . Double ( x , cursor , dataArea . getMaxX ( ) , cursor ) ; } else if ( edge == RectangleEdge . LEFT ) { axisLine = new Line2D . Double ( cursor , y , cursor , dataArea . getMaxY ( ) ) ; } else if ( edge == RectangleEdge . RIGHT ) { axisLine = new Line2D . Double ( cursor , y , cursor , dataArea . getMaxY ( ) ) ; } g2 . setPaint ( this . axisLinePaint ) ; g2 . setStroke ( this . axisLineStroke ) ; Object saved = g2 . getRenderingHint ( RenderingHints . KEY_STROKE_CONTROL ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_NORMALIZE ) ; g2 . draw ( axisLine ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , saved ) ; }
protected void drawAxisLine ( Graphics2D g2 , double cursor , Rectangle2D dataArea , RectangleEdge edge ) { Line2D axisLine = null ; double x = dataArea . getX ( ) ; double y = dataArea . getY ( ) ; if ( edge == RectangleEdge . TOP ) { axisLine = new Line2D . Double ( x , cursor , dataArea . getMaxX ( ) , cursor ) ; } else if ( edge == RectangleEdge . BOTTOM ) { axisLine = new Line2D . Double ( x , cursor , dataArea . getMaxX ( ) , cursor ) ; } else if ( edge == RectangleEdge . LEFT ) { axisLine = new Line2D . Double ( cursor , y , cursor , dataArea . getMaxY ( ) ) ; } else if ( edge == RectangleEdge . RIGHT ) { axisLine = new Line2D . Double ( cursor , y , cursor , dataArea . getMaxY ( ) ) ; } g2 . setPaint ( this . axisLinePaint ) ; g2 . setStroke ( this . axisLineStroke ) ; Object saved = g2 . getRenderingHint ( RenderingHints . KEY_STROKE_CONTROL ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_NORMALIZE ) ; g2 . draw ( axisLine ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , saved ) ; }
@ Override public Calendar next ( ) { if ( spot . equals ( endFinal ) ) { throw new NoSuchElementException ( ) ; } spot . add ( Calendar . DATE , _NUM ) ; return ( Calendar ) spot . clone ( ) ; }
public Object eval ( final String script ) throws ScriptException { return eval ( script , getContext ( ) ) ; }
public Object eval ( final String script ) throws ScriptException { return eval ( script , getContext ( ) ) ; }
public Object eval ( final String script ) throws ScriptException { return eval ( script , getContext ( ) ) ; }
public void removeStatement ( String statementName ) { rwLock . acquireWriteLock ( ) ; try { removedStatementNames . add ( statementName ) ; if ( removedStatementNames . size ( ) > _NUM ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( removedStatementNames . contains ( statementNames [ i ] ) ) { statementNames [ i ] = null ; } } removedStatementNames . clear ( ) ; } } finally { rwLock . releaseWriteLock ( ) ; } }
public void removeStatement ( String statementName ) { rwLock . acquireWriteLock ( ) ; try { removedStatementNames . add ( statementName ) ; if ( removedStatementNames . size ( ) > _NUM ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( removedStatementNames . contains ( statementNames [ i ] ) ) { statementNames [ i ] = null ; } } removedStatementNames . clear ( ) ; } } finally { rwLock . releaseWriteLock ( ) ; } }
public static String byteArrayToJsonString ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( bytes . length * _NUM ) ; for ( byte b : bytes ) { if ( b >= _NUM && b < _NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . toString ( ) ; }
public static String byteArrayToJsonString ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( bytes . length * _NUM ) ; for ( byte b : bytes ) { if ( b >= _NUM && b < _NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . toString ( ) ; }
public static String byteArrayToJsonString ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( bytes . length * _NUM ) ; for ( byte b : bytes ) { if ( b >= _NUM && b < _NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . toString ( ) ; }
public static String byteArrayToJsonString ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( bytes . length * _NUM ) ; for ( byte b : bytes ) { if ( b >= _NUM && b < _NUM ) { char c = ( char ) b ; if ( c != STRING && c != STRING && c != STRING ) { sb . append ( c ) ; continue ; } } sb . append ( String . format ( STRING , b ) ) ; } return sb . toString ( ) ; }
public static RichText rich ( String format , Object ... params ) { Validate . notNull ( format , STRING ) ; Validate . notNull ( params , STRING ) ; return rich ( String . format ( format , params ) ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public String popAndEncode ( boolean fromOnlineEvent ) { synchronized ( this ) { if ( activeBridgeMode == null ) { return null ; } activeBridgeMode . notifyOfFlush ( this , fromOnlineEvent ) ; if ( queue . isEmpty ( ) ) { return null ; } int totalPayloadLen = _NUM ; int numMessagesToSend = _NUM ; for ( JsMessage message : queue ) { int messageSize = calculatePackedMessageLength ( message ) ; if ( numMessagesToSend > _NUM && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > _NUM ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += _NUM ; } StringBuilder sb = new StringBuilder ( totalPayloadLen ) ; for ( int i = _NUM ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; packMessage ( message , sb ) ; } if ( ! queue . isEmpty ( ) ) { sb . append ( STRING ) ; } String ret = sb . toString ( ) ; return ret ; } }
protected synchronized void onSendRejected ( RecordBuffer < R > buffer ) { logger . trace ( STRING , name ( ) , buffer ) ; totalRejectedSendTasks . incrementAndGet ( ) ; throttler . onSendRejected ( ) ; queueBufferForRetry ( buffer ) ; }
protected synchronized void onSendRejected ( RecordBuffer < R > buffer ) { logger . trace ( STRING , name ( ) , buffer ) ; totalRejectedSendTasks . incrementAndGet ( ) ; throttler . onSendRejected ( ) ; queueBufferForRetry ( buffer ) ; }
public void addChild ( TreeStructure treeStruct ) { Util . notNull ( STRING , treeStruct ) ; if ( children == null ) { children = new ArrayList < TreeStructure > ( ) ; } children . add ( treeStruct ) ; }
public void addChild ( TreeStructure treeStruct ) { Util . notNull ( STRING , treeStruct ) ; if ( children == null ) { children = new ArrayList < TreeStructure > ( ) ; } children . add ( treeStruct ) ; }
public void removeUINodes ( Node ... nodes ) { for ( Node node : nodes ) removeUINode ( node ) ; }
public TimestampValidityState ( DataInput is ) throws IOException { myTimestamp = is . readLong ( ) ; }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new IllegalThreadStateException ( ) ; } if ( threads == null ) { threads = new Thread [ _NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copyOf ( threads , nthreads * _NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; nUnstartedThreads -- ; } }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new IllegalThreadStateException ( ) ; } if ( threads == null ) { threads = new Thread [ _NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copyOf ( threads , nthreads * _NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; nUnstartedThreads -- ; } }
void add ( Thread t ) { synchronized ( this ) { if ( destroyed ) { throw new IllegalThreadStateException ( ) ; } if ( threads == null ) { threads = new Thread [ _NUM ] ; } else if ( nthreads == threads . length ) { threads = Arrays . copyOf ( threads , nthreads * _NUM ) ; } threads [ nthreads ] = t ; nthreads ++ ; nUnstartedThreads -- ; } }
public void addHeader ( String line ) { header . add ( line ) ; }
protected boolean doStart ( ) { if ( ! _lifecycle . isActive ( ) ) { return _BOOL ; } if ( ! isEnable ( ) ) { return _BOOL ; } int startingCount = _startingCount . getAndIncrement ( ) ; int threadCount = _threadCount . get ( ) + startingCount ; if ( _threadMax < threadCount ) { _startingCount . decrementAndGet ( ) ; onThreadMax ( ) ; return _BOOL ; } else if ( isIdleTooLow ( startingCount ) ) { return _BOOL ; } else { _startingCount . decrementAndGet ( ) ; return _BOOL ; } }
protected boolean doStart ( ) { if ( ! _lifecycle . isActive ( ) ) { return _BOOL ; } if ( ! isEnable ( ) ) { return _BOOL ; } int startingCount = _startingCount . getAndIncrement ( ) ; int threadCount = _threadCount . get ( ) + startingCount ; if ( _threadMax < threadCount ) { _startingCount . decrementAndGet ( ) ; onThreadMax ( ) ; return _BOOL ; } else if ( isIdleTooLow ( startingCount ) ) { return _BOOL ; } else { _startingCount . decrementAndGet ( ) ; return _BOOL ; } }
protected void transformPage ( View view , float position ) { int pageWidth = view . getWidth ( ) ; if ( position < - _NUM ) { view . setAlpha ( _NUM ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM ) ; if ( virtualPos > _NUM ) { view . setTranslationX ( pageWidth * - position * _NUM ) ; } else { view . setTranslationX ( _NUM ) ; } float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM - position ) ; view . setTranslationX ( pageWidth * - position ) ; float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else { view . setAlpha ( _NUM ) ; } }
protected void transformPage ( View view , float position ) { int pageWidth = view . getWidth ( ) ; if ( position < - _NUM ) { view . setAlpha ( _NUM ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM ) ; if ( virtualPos > _NUM ) { view . setTranslationX ( pageWidth * - position * _NUM ) ; } else { view . setTranslationX ( _NUM ) ; } float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM - position ) ; view . setTranslationX ( pageWidth * - position ) ; float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else { view . setAlpha ( _NUM ) ; } }
protected void transformPage ( View view , float position ) { int pageWidth = view . getWidth ( ) ; if ( position < - _NUM ) { view . setAlpha ( _NUM ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM ) ; if ( virtualPos > _NUM ) { view . setTranslationX ( pageWidth * - position * _NUM ) ; } else { view . setTranslationX ( _NUM ) ; } float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else if ( position <= _NUM ) { view . setAlpha ( _NUM - position ) ; view . setTranslationX ( pageWidth * - position ) ; float scaleFactor = MIN_SCALE + ( _NUM - MIN_SCALE ) * ( _NUM - Math . abs ( position ) ) ; view . setScaleX ( scaleFactor ) ; view . setScaleY ( scaleFactor ) ; } else { view . setAlpha ( _NUM ) ; } }
public ActionNode ( String nodeId ) { super ( nodeId ) ; actionValues = new HashSet < Value > ( ) ; sampler = new Random ( ) ; actionValues . add ( ValueFactory . none ( ) ) ; }
public ActionNode ( String nodeId ) { super ( nodeId ) ; actionValues = new HashSet < Value > ( ) ; sampler = new Random ( ) ; actionValues . add ( ValueFactory . none ( ) ) ; }
public KeyUri ( String uri , byte [ ] address , int port ) { if ( uri == null ) { throw new NullPointerException ( STRING ) ; } else if ( address == null ) { throw new NullPointerException ( STRING ) ; } else if ( port < _NUM || port > MAX_PORT_NO ) { throw new IllegalArgumentException ( STRING ) ; } else { this . uri = uri ; this . address = address ; this . port = port ; this . hash = ( port * _NUM + uri . hashCode ( ) ) * _NUM + Arrays . hashCode ( address ) ; } }
public static byte [ ] copy ( byte [ ] bytes ) { if ( bytes == null ) return null ; byte [ ] result = new byte [ bytes . length ] ; System . arraycopy ( bytes , _NUM , result , _NUM , bytes . length ) ; return result ; }
public static byte [ ] copy ( byte [ ] bytes ) { if ( bytes == null ) return null ; byte [ ] result = new byte [ bytes . length ] ; System . arraycopy ( bytes , _NUM , result , _NUM , bytes . length ) ; return result ; }
private List < ColumnDictionaryChunk > readDictionaryFile ( long dictionaryStartOffset , int dictionaryChunkCountToBeRead ) throws IOException { List < ColumnDictionaryChunk > dictionaryChunks = new ArrayList < ColumnDictionaryChunk > ( dictionaryChunkCountToBeRead ) ; dictionaryFileReader . setReadOffset ( dictionaryStartOffset ) ; while ( dictionaryFileReader . hasNext ( ) && dictionaryChunks . size ( ) != dictionaryChunkCountToBeRead ) { dictionaryChunks . add ( ( ColumnDictionaryChunk ) dictionaryFileReader . read ( ) ) ; } return dictionaryChunks ; }
private List < ColumnDictionaryChunk > readDictionaryFile ( long dictionaryStartOffset , int dictionaryChunkCountToBeRead ) throws IOException { List < ColumnDictionaryChunk > dictionaryChunks = new ArrayList < ColumnDictionaryChunk > ( dictionaryChunkCountToBeRead ) ; dictionaryFileReader . setReadOffset ( dictionaryStartOffset ) ; while ( dictionaryFileReader . hasNext ( ) && dictionaryChunks . size ( ) != dictionaryChunkCountToBeRead ) { dictionaryChunks . add ( ( ColumnDictionaryChunk ) dictionaryFileReader . read ( ) ) ; } return dictionaryChunks ; }
static void putEntityDescriptor ( String realm , String entityId , EntityDescriptorElement descriptor ) { String cacheKey = buildCacheKey ( realm , entityId ) ; if ( descriptor != null ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } descriptorCache . put ( cacheKey , descriptor ) ; } else { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } descriptorCache . remove ( cacheKey ) ; configCache . remove ( cacheKey ) ; } }
static void putEntityDescriptor ( String realm , String entityId , EntityDescriptorElement descriptor ) { String cacheKey = buildCacheKey ( realm , entityId ) ; if ( descriptor != null ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } descriptorCache . put ( cacheKey , descriptor ) ; } else { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } descriptorCache . remove ( cacheKey ) ; configCache . remove ( cacheKey ) ; } }
static boolean lessEqual ( Object v1 , Object v2 ) { v1 = maybeConvertToString ( v1 ) ; v2 = maybeConvertToString ( v2 ) ; if ( Objects . equals ( v1 , v2 ) ) { return _BOOL ; } return less ( v1 , v2 ) ; }
private String readNfcErrorMsg ( ByteBuffer reply ) throws IOException { int errorType = reply . getInt ( ) ; int errorCode = reply . getInt ( ) ; int msgLen = reply . getInt ( ) ; if ( msgLen == _NUM ) { return STRING ; } ByteBuffer msgBuffer = ByteBuffer . allocate ( msgLen ) ; readFully ( msgBuffer ) ; String errorMsg = new String ( msgBuffer . array ( ) , _NUM , msgLen - _NUM , Charsets . US_ASCII ) ; return String . format ( STRING , errorType , errorCode , errorMsg ) ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input . length - offset < len ) { throw new IllegalArgumentException ( STRING ) ; } engineUpdate ( input , offset , len ) ; state = IN_PROGRESS ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input . length - offset < len ) { throw new IllegalArgumentException ( STRING ) ; } engineUpdate ( input , offset , len ) ; state = IN_PROGRESS ; }
public void update ( byte [ ] input , int offset , int len ) { if ( input == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( input . length - offset < len ) { throw new IllegalArgumentException ( STRING ) ; } engineUpdate ( input , offset , len ) ; state = IN_PROGRESS ; }
private static void edgeSplitPredecessors ( SsaMethod result ) { ArrayList < SsaBasicBlock > blocks = result . getBlocks ( ) ; for ( int i = blocks . size ( ) - _NUM ; i >= _NUM ; i -- ) { SsaBasicBlock block = blocks . get ( i ) ; if ( nodeNeedsUniquePredecessor ( block ) ) { block . insertNewPredecessor ( ) ; } } }
private static void edgeSplitPredecessors ( SsaMethod result ) { ArrayList < SsaBasicBlock > blocks = result . getBlocks ( ) ; for ( int i = blocks . size ( ) - _NUM ; i >= _NUM ; i -- ) { SsaBasicBlock block = blocks . get ( i ) ; if ( nodeNeedsUniquePredecessor ( block ) ) { block . insertNewPredecessor ( ) ; } } }
public static String readFully ( final Reader reader ) throws IOException { try { final StringWriter writer = new StringWriter ( ) ; final char [ ] buffer = new char [ _NUM ] ; int count ; while ( ( count = reader . read ( buffer ) ) != - _NUM ) { writer . write ( buffer , _NUM , count ) ; } return writer . toString ( ) ; } finally { reader . close ( ) ; } }
private static void addId ( final StringBuilder buf , final byte [ ] id ) { buf . append ( STRING ) ; boolean backslash = _BOOL ; for ( final byte b : id ) { buf . append ( ( char ) ( b & _NUM ) ) ; if ( b == STRING && backslash ) { buf . append ( STRING ) ; } else { backslash = b == STRING ; } } buf . append ( STRING ) ; }
public Shape createScrollButtonTogetherDecrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x + w , y ) ; path . lineTo ( x + w , y + h ) ; path . lineTo ( x , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public Shape createScrollButtonTogetherDecrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x + w , y ) ; path . lineTo ( x + w , y + h ) ; path . lineTo ( x , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public Shape createScrollButtonTogetherDecrease ( int x , int y , int w , int h ) { path . reset ( ) ; path . moveTo ( x + w , y ) ; path . lineTo ( x + w , y + h ) ; path . lineTo ( x , y + h ) ; addScrollGapPath ( x , y , w , h , _BOOL ) ; path . closePath ( ) ; return path ; }
public ByteArrayDataProvider ( byte [ ] bytes ) { this . bytes = Arrays . copyOf ( bytes , bytes . length ) ; }
public void put ( int data ) { if ( mBuffer . capacity ( ) < ( mLength + _NUM ) ) { expandBuffer ( mLength + ADDITIONAL_BUFFER_SIZE ) ; } mBuffer . put ( ( byte ) data ) ; ++ mLength ; }
public void put ( int data ) { if ( mBuffer . capacity ( ) < ( mLength + _NUM ) ) { expandBuffer ( mLength + ADDITIONAL_BUFFER_SIZE ) ; } mBuffer . put ( ( byte ) data ) ; ++ mLength ; }
public static void putShort ( ByteBuffer bb , int value ) { bb . putShort ( ( short ) ( value & _NUM ) ) ; }
public static IPackageFragmentRoot addSourceContainer ( IJavaProject jproject , String containerName , IPath [ ] inclusionFilters , IPath [ ] exclusionFilters , String outputLocation ) throws CoreException { IProject project = jproject . getProject ( ) ; IContainer container = null ; if ( containerName == null || containerName . length ( ) == _NUM ) { container = project ; } else { IFolder folder = project . getFolder ( containerName ) ; if ( ! folder . exists ( ) ) { CoreUtility . createFolder ( folder , _BOOL , _BOOL , null ) ; } container = folder ; } IPackageFragmentRoot root = jproject . getPackageFragmentRoot ( container ) ; IPath outputPath = null ; if ( outputLocation != null ) { IFolder folder = project . getFolder ( outputLocation ) ; if ( ! folder . exists ( ) ) { CoreUtility . createFolder ( folder , _BOOL , _BOOL , null ) ; } outputPath = folder . getFullPath ( ) ; } IClasspathEntry cpe = JavaCore . newSourceEntry ( root . getPath ( ) , inclusionFilters , exclusionFilters , outputPath ) ; addToClasspath ( jproject , cpe ) ; return root ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , DataLib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , DataLib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , DataLib . mean ( tuples , field ) ) ; }
public static double deviation ( Iterator tuples , String field ) { return deviation ( tuples , field , DataLib . mean ( tuples , field ) ) ; }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
protected void handleAutoDraw ( ) { if ( isToolItemSelected ( ToolBarItemKey . AUTO_DRAW ) ) { onAutoDraw ( ) ; } }
private void writeObject ( ObjectOutputStream outputStream ) throws IOException { outputStream . defaultWriteObject ( ) ; doWriteObject ( outputStream ) ; }
private void writeObject ( ObjectOutputStream outputStream ) throws IOException { outputStream . defaultWriteObject ( ) ; doWriteObject ( outputStream ) ; }
private void writeObject ( ObjectOutputStream outputStream ) throws IOException { outputStream . defaultWriteObject ( ) ; doWriteObject ( outputStream ) ; }
public void goBack ( ) { ensureWizardIsRunning ( ) ; if ( myPrevSteps . empty ( ) ) { throw new IllegalStateException ( STRING ) ; } ModelWizardStep currStep = mySteps . get ( myCurrIndex ) ; if ( ! currStep . canGoBack ( ) ) { throw new IllegalStateException ( STRING ) ; } myCurrIndex = mySteps . indexOf ( myPrevSteps . pop ( ) ) ; updateNavigationProperties ( ) ; showCurrentStep ( ) ; }
public static void prettyPrintVideos ( List < YouTubeVideo > videos ) { Log . d ( TAG , STRING ) ; Log . d ( TAG , STRING + videos . size ( ) ) ; Log . d ( TAG , STRING ) ; Iterator < YouTubeVideo > playlistEntries = videos . iterator ( ) ; while ( playlistEntries . hasNext ( ) ) { YouTubeVideo playlistItem = playlistEntries . next ( ) ; Log . d ( TAG , STRING + playlistItem . getTitle ( ) ) ; Log . d ( TAG , STRING + playlistItem . getId ( ) ) ; Log . d ( TAG , STRING + playlistItem . getDuration ( ) ) ; Log . d ( TAG , STRING + playlistItem . getThumbnailURL ( ) ) ; Log . d ( TAG , STRING ) ; } }
public Document createDocument ( ) throws ParserConfigurationException { if ( documentBuilder == null ) { documentBuilder = documentBuilderFactory . newDocumentBuilder ( ) ; } return documentBuilder . newDocument ( ) ; }
private void updateChart ( ) { mainPanel . removeAll ( ) ; GridBagConstraints constraints = new GridBagConstraints ( ) ; constraints . fill = GridBagConstraints . BOTH ; constraints . gridx = _NUM ; constraints . gridy = _NUM ; constraints . gridwidth = _NUM ; constraints . weightx = _NUM ; constraints . weighty = _NUM ; constraints . anchor = GridBagConstraints . CENTER ; JPanel chartPanel = createChartPanel ( ) ; chartPanel . setOpaque ( _BOOL ) ; chartPanel . setBackground ( ColorAndFontConstants . BACKGROUND_COLOR ) ; chartPanel . setForeground ( ColorAndFontConstants . TEXT_COLOR ) ; mainPanel . add ( chartPanel , constraints ) ; }
public static void assertSerializationEquals ( final String witness , final Object obj , final int [ ] skip , final int endCompare ) throws Exception { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; assertStreamEquals ( witness , memOut . toByteArray ( ) , skip , endCompare ) ; }
public static void assertSerializationEquals ( final String witness , final Object obj , final int [ ] skip , final int endCompare ) throws Exception { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; assertStreamEquals ( witness , memOut . toByteArray ( ) , skip , endCompare ) ; }
public static void assertSerializationEquals ( final String witness , final Object obj , final int [ ] skip , final int endCompare ) throws Exception { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; assertStreamEquals ( witness , memOut . toByteArray ( ) , skip , endCompare ) ; }
public static void assertSerializationEquals ( final String witness , final Object obj , final int [ ] skip , final int endCompare ) throws Exception { ByteArrayOutputStream memOut = new ByteArrayOutputStream ( ) ; ObjectOutputStream objOut = new ObjectOutputStream ( memOut ) ; objOut . writeObject ( obj ) ; objOut . close ( ) ; assertStreamEquals ( witness , memOut . toByteArray ( ) , skip , endCompare ) ; }
public int compare ( File file1 , File file2 ) { return caseSensitivity . checkCompareTo ( file1 . getPath ( ) , file2 . getPath ( ) ) ; }
protected void newEquation ( DF_LatticeCell lhs , DF_Operator operator , DF_LatticeCell op1 ) { DF_Equation eq = new DF_Equation ( lhs , operator , op1 ) ; equations . addGraphNode ( eq ) ; equations . addGraphNode ( lhs ) ; equations . addGraphNode ( op1 ) ; newEquations . add ( eq ) ; op1 . addUse ( eq ) ; lhs . addDef ( eq ) ; if ( EAGER && eq . evaluate ( ) ) changedCell ( lhs ) ; }
public JComboBox < String > matchingComboBox ( String roadName , String roadNumber , String consistNumber , String eng1Address , String eng2Address , String eng3Address , String eng4Address , String eng5Address , String eng6Address , String id ) { List < NceConsistRosterEntry > l = matchingList ( roadName , roadNumber , consistNumber , eng1Address , eng2Address , eng3Address , eng4Address , eng5Address , eng6Address , id ) ; JComboBox < String > b = new JComboBox < String > ( ) ; for ( int i = _NUM ; i < l . size ( ) ; i ++ ) { NceConsistRosterEntry r = _list . get ( i ) ; b . addItem ( r . titleString ( ) ) ; } return b ; }
public JComboBox < String > matchingComboBox ( String roadName , String roadNumber , String consistNumber , String eng1Address , String eng2Address , String eng3Address , String eng4Address , String eng5Address , String eng6Address , String id ) { List < NceConsistRosterEntry > l = matchingList ( roadName , roadNumber , consistNumber , eng1Address , eng2Address , eng3Address , eng4Address , eng5Address , eng6Address , id ) ; JComboBox < String > b = new JComboBox < String > ( ) ; for ( int i = _NUM ; i < l . size ( ) ; i ++ ) { NceConsistRosterEntry r = _list . get ( i ) ; b . addItem ( r . titleString ( ) ) ; } return b ; }
public JComboBox < String > matchingComboBox ( String roadName , String roadNumber , String consistNumber , String eng1Address , String eng2Address , String eng3Address , String eng4Address , String eng5Address , String eng6Address , String id ) { List < NceConsistRosterEntry > l = matchingList ( roadName , roadNumber , consistNumber , eng1Address , eng2Address , eng3Address , eng4Address , eng5Address , eng6Address , id ) ; JComboBox < String > b = new JComboBox < String > ( ) ; for ( int i = _NUM ; i < l . size ( ) ; i ++ ) { NceConsistRosterEntry r = _list . get ( i ) ; b . addItem ( r . titleString ( ) ) ; } return b ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
public DependencyGraph findLongestCallChain ( ) { int depth = _NUM ; DependencyGraph deepest = null ; for ( Object dep : vertices . keySet ( ) ) { int itsDepth = getDepth ( dep ) ; if ( itsDepth > depth ) { deepest = getSubGraph ( dep ) ; depth = itsDepth ; } } return deepest ; }
private static void scrapeLink ( String episodeURL , int episodeNum , Series series ) { StringBuilder episodeTextBuffer = new StringBuilder ( STRING + episodeNum + STRING ) ; String episodeText ; URL url ; InputStream is = null ; BufferedReader br ; String line ; try { url = new URL ( episodeURL ) ; is = url . openStream ( ) ; br = new BufferedReader ( new InputStreamReader ( is ) ) ; while ( ( line = br . readLine ( ) ) != null ) { episodeTextBuffer . append ( line ) ; episodeTextBuffer . append ( STRING ) ; } } catch ( IOException ioe ) { ioe . printStackTrace ( ) ; } finally { try { if ( is != null ) is . close ( ) ; } catch ( IOException ioe ) { } } episodeText = episodeTextBuffer . toString ( ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replace ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; episodeText = episodeText . replaceAll ( STRING , STRING ) ; saveEpisode ( episodeText , episodeNum , series ) ; }
private void updateActionModeMenu ( boolean doNotCloseActivity ) { if ( mActionModeCallback != null && mActivity != null && ! mActivity . isFinishing ( ) ) { if ( mItems . size ( ) > _NUM && mActionMode == null ) { mActionMode = mActivity . startSupportActionMode ( mActionModeCallback ) ; } if ( mItems . size ( ) == _NUM && mActionMode != null ) { ActionMode actionMode = mActionMode ; mActionMode = null ; actionMode . finish ( ) ; } if ( mActionMode != null ) { mActionMode . invalidate ( ) ; } } }
public static EWMA oneMinuteEWMA ( ) { return new EWMA ( M1_ALPHA , _NUM , TimeUnit . SECONDS ) ; }
public static EWMA oneMinuteEWMA ( ) { return new EWMA ( M1_ALPHA , _NUM , TimeUnit . SECONDS ) ; }
public static List < String > split ( String str , String delim ) { List < String > splitList = null ; StringTokenizer st = null ; if ( str == null ) return splitList ; if ( delim != null ) st = new StringTokenizer ( str , delim ) ; else st = new StringTokenizer ( str ) ; if ( st != null && st . hasMoreTokens ( ) ) { splitList = new LinkedList < String > ( ) ; while ( st . hasMoreTokens ( ) ) splitList . add ( st . nextToken ( ) ) ; } return splitList ; }
public static List < String > split ( String str , String delim ) { List < String > splitList = null ; StringTokenizer st = null ; if ( str == null ) return splitList ; if ( delim != null ) st = new StringTokenizer ( str , delim ) ; else st = new StringTokenizer ( str ) ; if ( st != null && st . hasMoreTokens ( ) ) { splitList = new LinkedList < String > ( ) ; while ( st . hasMoreTokens ( ) ) splitList . add ( st . nextToken ( ) ) ; } return splitList ; }
protected long currentTime ( ) { return System . currentTimeMillis ( ) ; }
private boolean tryQueueCurrentBuffer ( long elapsedWaiting ) { if ( currentBuffer . isEmpty ( ) ) return _BOOL ; if ( isOpen && neverPubQueue . size ( ) < neverPubCapacity ) { neverPubQueue . add ( currentBuffer ) ; totalQueuedRecords . addAndGet ( currentBuffer . sizeRecords ( ) ) ; totalQueuedBuffers . incrementAndGet ( ) ; onQueueBufferSuccess ( currentBuffer , elapsedWaiting ) ; currentBuffer = new RecordBuffer < > ( flow ) ; return _BOOL ; } else if ( elapsedWaiting > _NUM ) { onQueueBufferTimeout ( currentBuffer , elapsedWaiting ) ; return _BOOL ; } else return _BOOL ; }
private boolean tryQueueCurrentBuffer ( long elapsedWaiting ) { if ( currentBuffer . isEmpty ( ) ) return _BOOL ; if ( isOpen && neverPubQueue . size ( ) < neverPubCapacity ) { neverPubQueue . add ( currentBuffer ) ; totalQueuedRecords . addAndGet ( currentBuffer . sizeRecords ( ) ) ; totalQueuedBuffers . incrementAndGet ( ) ; onQueueBufferSuccess ( currentBuffer , elapsedWaiting ) ; currentBuffer = new RecordBuffer < > ( flow ) ; return _BOOL ; } else if ( elapsedWaiting > _NUM ) { onQueueBufferTimeout ( currentBuffer , elapsedWaiting ) ; return _BOOL ; } else return _BOOL ; }
private boolean tryQueueCurrentBuffer ( long elapsedWaiting ) { if ( currentBuffer . isEmpty ( ) ) return _BOOL ; if ( isOpen && neverPubQueue . size ( ) < neverPubCapacity ) { neverPubQueue . add ( currentBuffer ) ; totalQueuedRecords . addAndGet ( currentBuffer . sizeRecords ( ) ) ; totalQueuedBuffers . incrementAndGet ( ) ; onQueueBufferSuccess ( currentBuffer , elapsedWaiting ) ; currentBuffer = new RecordBuffer < > ( flow ) ; return _BOOL ; } else if ( elapsedWaiting > _NUM ) { onQueueBufferTimeout ( currentBuffer , elapsedWaiting ) ; return _BOOL ; } else return _BOOL ; }
public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { long time = System . currentTimeMillis ( ) ; request . getSession ( _BOOL ) ; String url = getTargetURL ( request ) ; if ( ! response . isCommitted ( ) ) response . sendRedirect ( url ) ; response . flushBuffer ( ) ; log . fine ( STRING + url ) ; saveClick ( request , url ) ; log . fine ( url + STRING + ( System . currentTimeMillis ( ) - time ) + STRING ) ; }
public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { long time = System . currentTimeMillis ( ) ; request . getSession ( _BOOL ) ; String url = getTargetURL ( request ) ; if ( ! response . isCommitted ( ) ) response . sendRedirect ( url ) ; response . flushBuffer ( ) ; log . fine ( STRING + url ) ; saveClick ( request , url ) ; log . fine ( url + STRING + ( System . currentTimeMillis ( ) - time ) + STRING ) ; }
public void doGet ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { long time = System . currentTimeMillis ( ) ; request . getSession ( _BOOL ) ; String url = getTargetURL ( request ) ; if ( ! response . isCommitted ( ) ) response . sendRedirect ( url ) ; response . flushBuffer ( ) ; log . fine ( STRING + url ) ; saveClick ( request , url ) ; log . fine ( url + STRING + ( System . currentTimeMillis ( ) - time ) + STRING ) ; }
@ SuppressWarnings ( STRING ) protected final void ensureCapacity ( long targetSize ) { long capacity = capacity ( ) ; if ( targetSize > capacity ) { inflateSpine ( ) ; for ( int i = spineIndex + _NUM ; targetSize > capacity ; i ++ ) { if ( i >= spine . length ) { int newSpineSize = spine . length * _NUM ; spine = Arrays . copyOf ( spine , newSpineSize ) ; priorElementCount = Arrays . copyOf ( priorElementCount , newSpineSize ) ; } int nextChunkSize = chunkSize ( i ) ; spine [ i ] = ( E [ ] ) new Object [ nextChunkSize ] ; priorElementCount [ i ] = priorElementCount [ i - _NUM ] + spine [ i - _NUM ] . length ; capacity += nextChunkSize ; } } }
@ SuppressWarnings ( STRING ) protected final void ensureCapacity ( long targetSize ) { long capacity = capacity ( ) ; if ( targetSize > capacity ) { inflateSpine ( ) ; for ( int i = spineIndex + _NUM ; targetSize > capacity ; i ++ ) { if ( i >= spine . length ) { int newSpineSize = spine . length * _NUM ; spine = Arrays . copyOf ( spine , newSpineSize ) ; priorElementCount = Arrays . copyOf ( priorElementCount , newSpineSize ) ; } int nextChunkSize = chunkSize ( i ) ; spine [ i ] = ( E [ ] ) new Object [ nextChunkSize ] ; priorElementCount [ i ] = priorElementCount [ i - _NUM ] + spine [ i - _NUM ] . length ; capacity += nextChunkSize ; } } }
@ SuppressWarnings ( STRING ) protected final void ensureCapacity ( long targetSize ) { long capacity = capacity ( ) ; if ( targetSize > capacity ) { inflateSpine ( ) ; for ( int i = spineIndex + _NUM ; targetSize > capacity ; i ++ ) { if ( i >= spine . length ) { int newSpineSize = spine . length * _NUM ; spine = Arrays . copyOf ( spine , newSpineSize ) ; priorElementCount = Arrays . copyOf ( priorElementCount , newSpineSize ) ; } int nextChunkSize = chunkSize ( i ) ; spine [ i ] = ( E [ ] ) new Object [ nextChunkSize ] ; priorElementCount [ i ] = priorElementCount [ i - _NUM ] + spine [ i - _NUM ] . length ; capacity += nextChunkSize ; } } }
@ SuppressWarnings ( STRING ) protected final void ensureCapacity ( long targetSize ) { long capacity = capacity ( ) ; if ( targetSize > capacity ) { inflateSpine ( ) ; for ( int i = spineIndex + _NUM ; targetSize > capacity ; i ++ ) { if ( i >= spine . length ) { int newSpineSize = spine . length * _NUM ; spine = Arrays . copyOf ( spine , newSpineSize ) ; priorElementCount = Arrays . copyOf ( priorElementCount , newSpineSize ) ; } int nextChunkSize = chunkSize ( i ) ; spine [ i ] = ( E [ ] ) new Object [ nextChunkSize ] ; priorElementCount [ i ] = priorElementCount [ i - _NUM ] + spine [ i - _NUM ] . length ; capacity += nextChunkSize ; } } }
public Polygon ( PolygonPoint [ ] points ) { this ( Arrays . asList ( points ) ) ; }
public static Zmat uzmat ( int m , int n ) throws JampackException { Zmat zm = new Zmat ( m , n ) ; for ( int i = _NUM ; i < m ; i ++ ) { for ( int j = _NUM ; j < n ; j ++ ) { zm . re [ i ] [ j ] = R . nextDouble ( ) ; zm . im [ i ] [ j ] = R . nextDouble ( ) ; } } return zm ; }
public void updated ( ) { currentColor = HtmlColors . decode ( getSettingValue ( ) ) ; secondaryColor = HtmlColors . decode ( baseColor ) ; Color foregroundColor ; Color backgroundColor ; if ( type == FOREGROUND ) { foregroundColor = currentColor ; backgroundColor = secondaryColor ; } else { foregroundColor = secondaryColor ; backgroundColor = currentColor ; } preview . setForeground ( foregroundColor ) ; preview . setBackground ( backgroundColor ) ; }
public void updated ( ) { currentColor = HtmlColors . decode ( getSettingValue ( ) ) ; secondaryColor = HtmlColors . decode ( baseColor ) ; Color foregroundColor ; Color backgroundColor ; if ( type == FOREGROUND ) { foregroundColor = currentColor ; backgroundColor = secondaryColor ; } else { foregroundColor = secondaryColor ; backgroundColor = currentColor ; } preview . setForeground ( foregroundColor ) ; preview . setBackground ( backgroundColor ) ; }
public void addAll ( JsonArray array ) { elements . addAll ( array . elements ) ; }
@ Override protected void deleteLast ( final byte [ ] key ) { final Lock lock = writeLock ( ) ; lock . lock ( ) ; try { super . deleteLast ( key ) ; } finally { unlock ( lock ) ; } }
@ Override protected void deleteLast ( final byte [ ] key ) { final Lock lock = writeLock ( ) ; lock . lock ( ) ; try { super . deleteLast ( key ) ; } finally { unlock ( lock ) ; } }
public int size ( ) { return sentences . size ( ) ; }
public static void printRawLines ( PrintWriter writer , String msg ) { int nl ; while ( ( nl = msg . indexOf ( STRING ) ) != - _NUM ) { writer . println ( msg . substring ( _NUM , nl ) ) ; msg = msg . substring ( nl + _NUM ) ; } if ( msg . length ( ) != _NUM ) writer . println ( msg ) ; }
public float readFloat ( ) throws IOException { return dis . readFloat ( ) ; }
public static String createMangledName ( Source source , String path , boolean strType , Map < String , Object > attrs , String prefix ) { StringBuilder buf = new StringBuilder ( _NUM ) ; if ( prefix != null ) buf . append ( prefix ) ; int hash = attrs . hashCode ( ) ; String mimeType = ( String ) attrs . get ( Transcoder . MIMETYPE ) ; VirtualFile f = null ; if ( path != null ) { buf . append ( path ) ; f = source . resolve ( path ) ; if ( f != null ) hash ^= f . hashCode ( ) ; } else if ( mimeType != null ) { buf . append ( mimeType ) ; } String symbol = ( String ) attrs . get ( Transcoder . SYMBOL ) ; if ( symbol != null ) { buf . append ( STRING ) ; buf . append ( symbol ) ; } if ( strType ) { buf . append ( STRING ) ; } return createMangledName ( buf . toString ( ) , hash ) ; }
public static String createMangledName ( Source source , String path , boolean strType , Map < String , Object > attrs , String prefix ) { StringBuilder buf = new StringBuilder ( _NUM ) ; if ( prefix != null ) buf . append ( prefix ) ; int hash = attrs . hashCode ( ) ; String mimeType = ( String ) attrs . get ( Transcoder . MIMETYPE ) ; VirtualFile f = null ; if ( path != null ) { buf . append ( path ) ; f = source . resolve ( path ) ; if ( f != null ) hash ^= f . hashCode ( ) ; } else if ( mimeType != null ) { buf . append ( mimeType ) ; } String symbol = ( String ) attrs . get ( Transcoder . SYMBOL ) ; if ( symbol != null ) { buf . append ( STRING ) ; buf . append ( symbol ) ; } if ( strType ) { buf . append ( STRING ) ; } return createMangledName ( buf . toString ( ) , hash ) ; }
public void test_parkUntil_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public void test_parkUntil_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public void test_parkUntil_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
protected Stream < Relation > createMeshedRelations ( final JCas jCas , final Interaction interaction , final Collection < Entity > collection ) { final List < Relation > relations = new LinkedList < > ( ) ; List < Entity > entities ; if ( collection instanceof List ) { entities = ( List < Entity > ) collection ; } else { entities = new ArrayList < > ( collection ) ; } final ListIterator < Entity > outer = entities . listIterator ( ) ; while ( outer . hasNext ( ) ) { final Entity source = outer . next ( ) ; final ListIterator < Entity > inner = entities . listIterator ( outer . nextIndex ( ) ) ; while ( inner . hasNext ( ) ) { final Entity target = inner . next ( ) ; relations . add ( createRelation ( jCas , interaction , source , target ) ) ; } } return relations . stream ( ) ; }
protected MessageDigest ( String algorithm ) { this . algorithm = algorithm ; }
public static long currentTimeMillis ( ) { if ( mockTime != null ) return mockTime . getTime ( ) ; else return System . currentTimeMillis ( ) ; }
public void newArray ( final Type type ) { int typ ; switch ( type . getSort ( ) ) { case Type . BOOLEAN : typ = Opcodes . T_BOOLEAN ; break ; case Type . CHAR : typ = Opcodes . T_CHAR ; break ; case Type . BYTE : typ = Opcodes . T_BYTE ; break ; case Type . SHORT : typ = Opcodes . T_SHORT ; break ; case Type . INT : typ = Opcodes . T_INT ; break ; case Type . FLOAT : typ = Opcodes . T_FLOAT ; break ; case Type . LONG : typ = Opcodes . T_LONG ; break ; case Type . DOUBLE : typ = Opcodes . T_DOUBLE ; break ; default : typeInsn ( Opcodes . ANEWARRAY , type ) ; return ; } mv . visitIntInsn ( Opcodes . NEWARRAY , typ ) ; }
public void showTimes ( long overall ) { showTimesShort ( overall ) ; }
public final boolean is_clearance_compensation_used ( ) { return compensated_clearance_class_no > _NUM ; }
public static Map < String , Page > loadPages ( String folderPath ) { Map < String , Page > pageTable = new Hashtable < String , Page > ( ) ; Page currPage ; File [ ] listOfFiles ; wlf = new WikiLinkFinder ( ) ; File folder = new File ( folderPath ) ; if ( folder . exists ( ) && folder . isDirectory ( ) ) { listOfFiles = folder . listFiles ( ) ; } else { return null ; } for ( int i = _NUM ; i < listOfFiles . length ; i ++ ) { File currFile = listOfFiles [ i ] ; if ( currFile . isFile ( ) ) { currPage = wikiPageFromFile ( folder , currFile ) ; pageTable . put ( currPage . getLocation ( ) , currPage ) ; } } return pageTable = determineAllInlinks ( pageTable ) ; }
public static Map < String , Page > loadPages ( String folderPath ) { Map < String , Page > pageTable = new Hashtable < String , Page > ( ) ; Page currPage ; File [ ] listOfFiles ; wlf = new WikiLinkFinder ( ) ; File folder = new File ( folderPath ) ; if ( folder . exists ( ) && folder . isDirectory ( ) ) { listOfFiles = folder . listFiles ( ) ; } else { return null ; } for ( int i = _NUM ; i < listOfFiles . length ; i ++ ) { File currFile = listOfFiles [ i ] ; if ( currFile . isFile ( ) ) { currPage = wikiPageFromFile ( folder , currFile ) ; pageTable . put ( currPage . getLocation ( ) , currPage ) ; } } return pageTable = determineAllInlinks ( pageTable ) ; }
public static Map < String , Page > loadPages ( String folderPath ) { Map < String , Page > pageTable = new Hashtable < String , Page > ( ) ; Page currPage ; File [ ] listOfFiles ; wlf = new WikiLinkFinder ( ) ; File folder = new File ( folderPath ) ; if ( folder . exists ( ) && folder . isDirectory ( ) ) { listOfFiles = folder . listFiles ( ) ; } else { return null ; } for ( int i = _NUM ; i < listOfFiles . length ; i ++ ) { File currFile = listOfFiles [ i ] ; if ( currFile . isFile ( ) ) { currPage = wikiPageFromFile ( folder , currFile ) ; pageTable . put ( currPage . getLocation ( ) , currPage ) ; } } return pageTable = determineAllInlinks ( pageTable ) ; }
public static Map < String , Page > loadPages ( String folderPath ) { Map < String , Page > pageTable = new Hashtable < String , Page > ( ) ; Page currPage ; File [ ] listOfFiles ; wlf = new WikiLinkFinder ( ) ; File folder = new File ( folderPath ) ; if ( folder . exists ( ) && folder . isDirectory ( ) ) { listOfFiles = folder . listFiles ( ) ; } else { return null ; } for ( int i = _NUM ; i < listOfFiles . length ; i ++ ) { File currFile = listOfFiles [ i ] ; if ( currFile . isFile ( ) ) { currPage = wikiPageFromFile ( folder , currFile ) ; pageTable . put ( currPage . getLocation ( ) , currPage ) ; } } return pageTable = determineAllInlinks ( pageTable ) ; }
public void sendFTPCommand ( String command ) throws IOException { writer . writeLine ( command ) ; for ( Iterator iter = communicationListeners . iterator ( ) ; iter . hasNext ( ) ; ) { FTPCommunicationListener l = ( FTPCommunicationListener ) iter . next ( ) ; l . sent ( command ) ; } }
protected void populateBlob ( int id , byte [ ] baseContent , int requiredSize ) throws SQLException { Connection con = getConnectionViaDriverManager ( ) ; CallableStatement cstmt = null ; try { cstmt = con . prepareCall ( EXECUTE_FILL_BINARY_BLOB ) ; cstmt . setInt ( _NUM , id ) ; cstmt . setBytes ( _NUM , baseContent ) ; cstmt . setInt ( _NUM , requiredSize ) ; cstmt . execute ( ) ; } finally { closeQuietly ( cstmt ) ; closeQuietly ( con ) ; } }
public void touch ( ) { touch = System . currentTimeMillis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void touch ( ) { touch = System . currentTimeMillis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void touch ( ) { touch = System . currentTimeMillis ( ) ; if ( worker != null ) { worker . touch ( ) ; } }
public void writeAll ( ResultSet rs , boolean includeColumnNames ) throws SQLException , IOException { if ( includeColumnNames ) { writeColumnNames ( rs ) ; } while ( rs . next ( ) ) { writeNext ( resultService . getColumnValues ( rs ) ) ; } }
protected void shuffleTestAndTrainingSetTogether ( ) { ArrayList lOverall = new ArrayList ( TestFiles . size ( ) + TrainingFiles . size ( ) ) ; lOverall . addAll ( TrainingFiles ) ; lOverall . addAll ( TestFiles ) ; utils . shuffleList ( lOverall ) ; TestFiles . clear ( ) ; TrainingFiles . clear ( ) ; TestFiles . addAll ( lOverall . subList ( _NUM , TestFiles . size ( ) ) ) ; TrainingFiles . addAll ( lOverall . subList ( TestFiles . size ( ) , lOverall . size ( ) ) ) ; }
protected void shuffleTestAndTrainingSetTogether ( ) { ArrayList lOverall = new ArrayList ( TestFiles . size ( ) + TrainingFiles . size ( ) ) ; lOverall . addAll ( TrainingFiles ) ; lOverall . addAll ( TestFiles ) ; utils . shuffleList ( lOverall ) ; TestFiles . clear ( ) ; TrainingFiles . clear ( ) ; TestFiles . addAll ( lOverall . subList ( _NUM , TestFiles . size ( ) ) ) ; TrainingFiles . addAll ( lOverall . subList ( TestFiles . size ( ) , lOverall . size ( ) ) ) ; }
protected void shuffleTestAndTrainingSetTogether ( ) { ArrayList lOverall = new ArrayList ( TestFiles . size ( ) + TrainingFiles . size ( ) ) ; lOverall . addAll ( TrainingFiles ) ; lOverall . addAll ( TestFiles ) ; utils . shuffleList ( lOverall ) ; TestFiles . clear ( ) ; TrainingFiles . clear ( ) ; TestFiles . addAll ( lOverall . subList ( _NUM , TestFiles . size ( ) ) ) ; TrainingFiles . addAll ( lOverall . subList ( TestFiles . size ( ) , lOverall . size ( ) ) ) ; }
protected void shuffleTestAndTrainingSetTogether ( ) { ArrayList lOverall = new ArrayList ( TestFiles . size ( ) + TrainingFiles . size ( ) ) ; lOverall . addAll ( TrainingFiles ) ; lOverall . addAll ( TestFiles ) ; utils . shuffleList ( lOverall ) ; TestFiles . clear ( ) ; TrainingFiles . clear ( ) ; TestFiles . addAll ( lOverall . subList ( _NUM , TestFiles . size ( ) ) ) ; TrainingFiles . addAll ( lOverall . subList ( TestFiles . size ( ) , lOverall . size ( ) ) ) ; }
public Category ( Wikipedia wiki , String pName ) throws WikiApiException { if ( pName == null || pName . length ( ) == _NUM ) { throw new WikiPageNotFoundException ( ) ; } this . wiki = wiki ; catDAO = new CategoryDAO ( wiki ) ; Title catTitle = new Title ( pName ) ; createCategory ( catTitle ) ; }
private double findAngle ( Point originPoint , Point targetPoint ) { int x1 = originPoint . x ; int y1 = originPoint . y ; int x2 = targetPoint . x ; int y2 = targetPoint . y ; double angle = _NUM ; double offset = _NUM ; double sideA = x2 - x1 ; double sideB = _NUM ; if ( y1 >= y2 ) { sideB = y1 - y2 ; offset = Math . toRadians ( - _NUM ) ; } else { sideB = - ( y2 - y1 ) ; offset = Math . toRadians ( _NUM ) ; } if ( sideB == _NUM ) { return angle ; } angle = Math . atan ( sideA / sideB ) ; return angle + offset ; }
@ Override public final Object put ( String key , Object value ) { return set ( key , value ) ; }
public void onAccuracyChanged ( Sensor sensor , int accuracy ) { if ( sensor . getType ( ) != Sensor . TYPE_ACCELEROMETER ) { return ; } if ( this . status == AccelListener . STOPPED ) { return ; } this . accuracy = accuracy ; }
private BufferedImage toBufferedImage ( final Image image ) { if ( image instanceof BufferedImage ) { return ( BufferedImage ) image ; } if ( image instanceof VolatileImage ) { VolatileImage volatileImage = ( VolatileImage ) image ; return volatileImage . getSnapshot ( ) ; } GraphicsEnvironment graphicsEnvironment = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice graphicsDevice = graphicsEnvironment . getDefaultScreenDevice ( ) ; GraphicsConfiguration graphicsConfiguration = graphicsDevice . getDefaultConfiguration ( ) ; BufferedImage bufferedImage = graphicsConfiguration . createCompatibleImage ( image . getWidth ( null ) , image . getHeight ( null ) ) ; Graphics2D g = bufferedImage . createGraphics ( ) ; g . drawImage ( image , _NUM , _NUM , null ) ; g . dispose ( ) ; return bufferedImage ; }
public long [ ] readLongArray ( final int items , final JBBPByteOrder byteOrder ) throws IOException { int pos = _NUM ; if ( items < _NUM ) { long [ ] buffer = new long [ INITIAL_ARRAY_BUFFER_SIZE ] ; while ( hasAvailableData ( ) ) { final long next = readLong ( byteOrder ) ; if ( buffer . length == pos ) { final long [ ] newbuffer = new long [ buffer . length << _NUM ] ; System . arraycopy ( buffer , _NUM , newbuffer , _NUM , buffer . length ) ; buffer = newbuffer ; } buffer [ pos ++ ] = next ; } if ( buffer . length == pos ) { return buffer ; } final long [ ] result = new long [ pos ] ; System . arraycopy ( buffer , _NUM , result , _NUM , pos ) ; return result ; } else { final long [ ] buffer = new long [ items ] ; for ( int i = _NUM ; i < items ; i ++ ) { buffer [ i ] = readLong ( byteOrder ) ; } return buffer ; } }
public static String extractFullStackTrace ( Throwable e ) { StringWriter stringWriter = new StringWriter ( ) ; PrintWriter printWriter = new PrintWriter ( stringWriter ) ; e . printStackTrace ( printWriter ) ; return stringWriter . toString ( ) ; }
public ByteBandedRaster ( SampleModel sampleModel , DataBuffer dataBuffer , Point origin ) { this ( sampleModel , dataBuffer , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
private void checkAlterPartialConverters ( ) throws SecurityException { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING ) ) ; } }
@ Override public boolean isModified ( ) { if ( _dependencyList . isModified ( ) ) { return _BOOL ; } synchronized ( _pathList ) { _newPathList . clear ( ) ; loadPaths ( _newPathList ) ; Collections . sort ( _newPathList ) ; return ! _newPathList . equals ( _pathList ) ; } }
@ Override public boolean isModified ( ) { if ( _dependencyList . isModified ( ) ) { return _BOOL ; } synchronized ( _pathList ) { _newPathList . clear ( ) ; loadPaths ( _newPathList ) ; Collections . sort ( _newPathList ) ; return ! _newPathList . equals ( _pathList ) ; } }
@ Override public boolean isModified ( ) { if ( _dependencyList . isModified ( ) ) { return _BOOL ; } synchronized ( _pathList ) { _newPathList . clear ( ) ; loadPaths ( _newPathList ) ; Collections . sort ( _newPathList ) ; return ! _newPathList . equals ( _pathList ) ; } }
private void initVocoder ( int mcep_order , int mcep_vsize , HMMData htsData ) { stage = htsData . getStage ( ) ; gamma = htsData . getGamma ( ) ; use_log_gain = htsData . getUseLogGain ( ) ; fprd = htsData . getFperiod ( ) ; rate = htsData . getRate ( ) ; rand = new Random ( SEED ) ; C = new double [ mcep_order ] ; CC = new double [ mcep_order ] ; CINC = new double [ mcep_order ] ; if ( stage == _NUM ) { int vector_size = ( mcep_vsize * ( _NUM + PADEORDER ) + _NUM * PADEORDER + _NUM ) - ( _NUM * ( mcep_order ) ) ; D1 = new double [ vector_size ] ; pt2 = ( _NUM * ( PADEORDER + _NUM ) ) + ( PADEORDER * ( mcep_order + _NUM ) ) ; for ( int i = PADEORDER ; i >= _NUM ; i -- ) pt3 [ i ] = ( _NUM * ( PADEORDER + _NUM ) ) + ( ( i - _NUM ) * ( mcep_order + _NUM ) ) ; } else { int vector_size = ( ( mcep_vsize + _NUM ) * ( stage + _NUM ) ) - ( _NUM * ( mcep_order ) ) ; D1 = new double [ vector_size ] ; } p1 = - _NUM ; pc = _NUM ; }
public void scrollToOpen ( ) { if ( currentInnerStatus == InnerStatus . OPENED ) { return ; } if ( maxOffset == minOffset ) { return ; } int dy = - getScrollY ( ) - maxOffset ; if ( dy == _NUM ) { return ; } currentInnerStatus = InnerStatus . SCROLLING ; int duration = MIN_SCROLL_DURATION + Math . abs ( ( MAX_SCROLL_DURATION - MIN_SCROLL_DURATION ) * dy / ( maxOffset - minOffset ) ) ; scroller . startScroll ( _NUM , getScrollY ( ) , _NUM , dy , duration ) ; invalidate ( ) ; }
public static double [ ] concatenate ( double [ ] [ ] vectors ) { int numVectors = vectors . length ; int length = vectors [ _NUM ] . length ; double [ ] concat = new double [ numVectors * length ] ; for ( int i = _NUM ; i < vectors . length ; i ++ ) { System . arraycopy ( vectors [ i ] , _NUM , concat , i * length , length ) ; } return concat ; }
public synchronized void pushLayerEvent ( int layerEventType , Layer [ ] layers ) { if ( synchronous ) { fireLayer ( layerEventType , layers ) ; } else { events . add ( new SetLayerRunnable ( layerEventType , layers ) ) ; if ( t == null || ! t . isAlive ( ) ) { SetLayerRunnable runnable = popLayerEvent ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void pushLayerEvent ( int layerEventType , Layer [ ] layers ) { if ( synchronous ) { fireLayer ( layerEventType , layers ) ; } else { events . add ( new SetLayerRunnable ( layerEventType , layers ) ) ; if ( t == null || ! t . isAlive ( ) ) { SetLayerRunnable runnable = popLayerEvent ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void pushLayerEvent ( int layerEventType , Layer [ ] layers ) { if ( synchronous ) { fireLayer ( layerEventType , layers ) ; } else { events . add ( new SetLayerRunnable ( layerEventType , layers ) ) ; if ( t == null || ! t . isAlive ( ) ) { SetLayerRunnable runnable = popLayerEvent ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void pushLayerEvent ( int layerEventType , Layer [ ] layers ) { if ( synchronous ) { fireLayer ( layerEventType , layers ) ; } else { events . add ( new SetLayerRunnable ( layerEventType , layers ) ) ; if ( t == null || ! t . isAlive ( ) ) { SetLayerRunnable runnable = popLayerEvent ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public synchronized void pushLayerEvent ( int layerEventType , Layer [ ] layers ) { if ( synchronous ) { fireLayer ( layerEventType , layers ) ; } else { events . add ( new SetLayerRunnable ( layerEventType , layers ) ) ; if ( t == null || ! t . isAlive ( ) ) { SetLayerRunnable runnable = popLayerEvent ( ) ; if ( runnable != null ) { t = new Thread ( runnable ) ; t . start ( ) ; } } } }
public static void writePaddedInteger ( Writer out , long value , int size ) throws IOException { int intValue = ( int ) value ; if ( intValue == value ) { writePaddedInteger ( out , intValue , size ) ; } else if ( size <= _NUM ) { out . write ( Long . toString ( value ) ) ; } else { if ( value < _NUM ) { out . write ( STRING ) ; if ( value != Long . MIN_VALUE ) { value = - value ; } else { for ( ; size > _NUM ; size -- ) { out . write ( STRING ) ; } out . write ( STRING ) ; return ; } } int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + _NUM ; for ( ; size > digits ; size -- ) { out . write ( STRING ) ; } out . write ( Long . toString ( value ) ) ; } }
public void removeNodesFromPartition ( List < IGroupMemberNode > nodesToRemove ) { for ( final IGroupMemberNode nodeToRemove : nodesToRemove ) { if ( nodeToRemove != null ) { if ( ! nonOptionalNonMinusNodes . remove ( nodeToRemove ) ) { if ( nodeToRemove . equals ( optionalOrMinus ) ) { optionalOrMinus = null ; } } } } recomputeDefinitelyProduced ( ) ; }
public void removeNodesFromPartition ( List < IGroupMemberNode > nodesToRemove ) { for ( final IGroupMemberNode nodeToRemove : nodesToRemove ) { if ( nodeToRemove != null ) { if ( ! nonOptionalNonMinusNodes . remove ( nodeToRemove ) ) { if ( nodeToRemove . equals ( optionalOrMinus ) ) { optionalOrMinus = null ; } } } } recomputeDefinitelyProduced ( ) ; }
public static String typeName ( String clsName ) { int packageEnd = clsName . lastIndexOf ( STRING ) ; if ( packageEnd >= _NUM && packageEnd < clsName . length ( ) - _NUM ) clsName = clsName . substring ( packageEnd + _NUM ) ; if ( clsName . endsWith ( STRING ) ) { clsName = clsName . substring ( _NUM , clsName . length ( ) - _NUM ) + STRING ; } int parentEnd = clsName . lastIndexOf ( STRING ) ; if ( parentEnd >= _NUM ) clsName = clsName . substring ( parentEnd + _NUM ) ; return clsName ; }
public static String typeName ( String clsName ) { int packageEnd = clsName . lastIndexOf ( STRING ) ; if ( packageEnd >= _NUM && packageEnd < clsName . length ( ) - _NUM ) clsName = clsName . substring ( packageEnd + _NUM ) ; if ( clsName . endsWith ( STRING ) ) { clsName = clsName . substring ( _NUM , clsName . length ( ) - _NUM ) + STRING ; } int parentEnd = clsName . lastIndexOf ( STRING ) ; if ( parentEnd >= _NUM ) clsName = clsName . substring ( parentEnd + _NUM ) ; return clsName ; }
public Utf8Constant addUTF8 ( String value ) { Utf8Constant entry = getUTF8 ( value ) ; if ( entry != null ) return entry ; entry = new Utf8Constant ( this , _entries . size ( ) , value ) ; addConstant ( entry ) ; return entry ; }
public static URL [ ] findResourceBases ( String baseResource , ClassLoader loader ) { ArrayList < URL > list = new ArrayList < URL > ( ) ; try { Enumeration < URL > urls = loader . getResources ( baseResource ) ; while ( urls . hasMoreElements ( ) ) { URL url = urls . nextElement ( ) ; list . add ( findResourceBase ( url , baseResource ) ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return list . toArray ( new URL [ list . size ( ) ] ) ; }
@ Override public Image createAcceleratedImage ( Component target , int width , int height ) { ColorModel model = getColorModel ( Transparency . OPAQUE ) ; WritableRaster wr = model . createCompatibleWritableRaster ( width , height ) ; return new OffScreenImage ( target , model , wr , model . isAlphaPremultiplied ( ) ) ; }
public final Sequence extend ( TypedOperation operation , Variable ... inputs ) { return extend ( operation , Arrays . asList ( inputs ) ) ; }
public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; }
public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; }
public boolean isEmpty ( ) { return nodes . isEmpty ( ) ; }
public final ParallelFlux < T > doOnComplete ( Runnable onComplete ) { Objects . requireNonNull ( onComplete , STRING ) ; return doOnSignal ( this , null , null , null , onComplete , null , null , null , null ) ; }
public final ParallelFlux < T > doOnComplete ( Runnable onComplete ) { Objects . requireNonNull ( onComplete , STRING ) ; return doOnSignal ( this , null , null , null , onComplete , null , null , null , null ) ; }
static < T > LazyFutureStream < T > of ( final T value ) { return lazyFutureStream ( ( Stream ) Seq . of ( value ) ) ; }
static < T > LazyFutureStream < T > of ( final T value ) { return lazyFutureStream ( ( Stream ) Seq . of ( value ) ) ; }
static < T > LazyFutureStream < T > of ( final T value ) { return lazyFutureStream ( ( Stream ) Seq . of ( value ) ) ; }
public int size ( ) { return rules . size ( ) ; }
public void addEmail ( NgnEmail . EmailType type , String value , String description ) { mEmails . add ( new NgnEmail ( type , value , description ) ) ; }
public Element makeElement ( Document document ) { Element elem = SVGUtil . svgElement ( document , SVGConstants . SVG_PATH_TAG ) ; elem . setAttribute ( SVGConstants . SVG_D_ATTRIBUTE , buf . toString ( ) ) ; return elem ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public Analyzer saveAnalysis ( File file ) throws IOException { PrintStream ps = null ; try { ps = new PrintStream ( new BufferedOutputStream ( new FileOutputStream ( file ) ) ) ; printAnalysis ( ps ) ; } finally { if ( ps != null ) { ps . close ( ) ; } } return this ; }
public static String toMatchValue ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return toMatchValue ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return toMatchValue ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return toMatchValue ( ( Enum < ? > ) value ) ; } else { return value . toString ( ) ; } }
public static String toMatchValue ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return toMatchValue ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return toMatchValue ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return toMatchValue ( ( Enum < ? > ) value ) ; } else { return value . toString ( ) ; } }
public static String toMatchValue ( Object value ) { if ( value == null ) { return null ; } else if ( value instanceof String ) { return ( String ) value ; } else if ( value instanceof Boolean ) { return toMatchValue ( ( boolean ) value ) ; } else if ( value instanceof URI ) { return toMatchValue ( ( URI ) value ) ; } else if ( value instanceof Enum ) { return toMatchValue ( ( Enum < ? > ) value ) ; } else { return value . toString ( ) ; } }
public void write ( String filename ) { logger . info ( STRING ) ; try { openFile ( filename ) ; writeXmlHead ( ) ; startCarriers ( this . writer ) ; for ( Carrier carrier : carriers ) { startCarrier ( carrier , this . writer ) ; writeVehiclesAndTheirTypes ( carrier , this . writer ) ; writeShipments ( carrier , this . writer ) ; writeServices ( carrier , this . writer ) ; writePlans ( carrier , this . writer ) ; endCarrier ( this . writer ) ; } endCarriers ( this . writer ) ; close ( ) ; logger . info ( STRING ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; logger . error ( e ) ; System . exit ( _NUM ) ; } }
String checksum ( byte [ ] filebytes ) ;
public Feature ( ) { id = random . nextLong ( ) ; }
@ Override public void validate ( final Cookie cookie , final CookieOrigin origin ) throws MalformedCookieException { if ( cookie == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( origin == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( cookie instanceof Cookie2 ) { final Cookie2 cookie2 = ( Cookie2 ) cookie ; final int port = origin . getPort ( ) ; if ( cookie2 . isPortAttributeSpecified ( ) ) { if ( ! portMatch ( port , cookie2 . getPorts ( ) ) ) { throw new MalformedCookieException ( STRING + STRING ) ; } } } }
@ Override public void validate ( final Cookie cookie , final CookieOrigin origin ) throws MalformedCookieException { if ( cookie == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( origin == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( cookie instanceof Cookie2 ) { final Cookie2 cookie2 = ( Cookie2 ) cookie ; final int port = origin . getPort ( ) ; if ( cookie2 . isPortAttributeSpecified ( ) ) { if ( ! portMatch ( port , cookie2 . getPorts ( ) ) ) { throw new MalformedCookieException ( STRING + STRING ) ; } } } }
public List < GsmServiceParameter > createProcessParameterForOrganization ( Integer orgId ) { initGraph ( orgId ) ; List < CnATreeElement > rightElementList = getRightHandElements ( orgId ) ; List < CnATreeElement > leftElementList = getLeftHandElements ( orgId ) ; if ( LOG . isInfoEnabled ( ) ) { LOG . info ( rightElementList . size ( ) + STRING ) ; LOG . info ( leftElementList . size ( ) + STRING ) ; } List < GsmServiceParameter > allParameterList = new LinkedList < GsmServiceParameter > ( ) ; for ( CnATreeElement controlGroup : rightElementList ) { for ( CnATreeElement leftElement : leftElementList ) { List < ExecutionImpl > processList = findProcesses ( leftElement , controlGroup ) ; if ( processList != null && ! processList . isEmpty ( ) ) { deleteProcesses ( processList ) ; } List < GsmServiceParameter > parameterList = createParameter ( leftElement , controlGroup ) ; String uuidOrg = loadOrgUuid ( orgId ) ; for ( GsmServiceParameter parameter : parameterList ) { parameter . setUuidOrg ( uuidOrg ) ; allParameterList . add ( parameter ) ; } } } if ( LOG . isInfoEnabled ( ) ) { LOG . info ( allParameterList . size ( ) + STRING ) ; } return allParameterList ; }
public static boolean isValid ( Timestamp validFrom , Timestamp validTo , Timestamp testDate ) { if ( testDate == null ) return _BOOL ; if ( validFrom == null && validTo == null ) return _BOOL ; if ( validFrom != null && validFrom . after ( testDate ) ) return _BOOL ; if ( validTo != null && validTo . before ( testDate ) ) return _BOOL ; return _BOOL ; }
private List < Rule > readRules ( Reader reader ) throws IOException , IllegalArgumentException { BufferedReader in = new BufferedReader ( reader ) ; List < Rule > rules = new ArrayList < Rule > ( ) ; String line ; while ( ( line = in . readLine ( ) ) != null ) { if ( line . length ( ) == _NUM ) { continue ; } line = line . trim ( ) ; char first = line . charAt ( _NUM ) ; boolean sign = _BOOL ; switch ( first ) { case STRING : sign = _BOOL ; break ; case STRING : sign = _BOOL ; break ; case STRING : case STRING : case STRING : continue ; default : throw new IOException ( STRING + line ) ; } String regex = line . substring ( _NUM ) ; if ( LOG . isTraceEnabled ( ) ) { LOG . trace ( STRING + regex + STRING ) ; } Rule rule = createRule ( sign , regex ) ; rules . add ( rule ) ; } return rules ; }
public static final String toString ( String str ) { if ( str == null ) return STRING ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
public static final String toString ( String str ) { if ( str == null ) return STRING ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
public static final String toString ( String str ) { if ( str == null ) return STRING ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
public static final String toString ( String str ) { if ( str == null ) return STRING ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
public static final String toString ( String str ) { if ( str == null ) return STRING ; ByteArrayOutputStream buffer = new ByteArrayOutputStream ( ) ; toByteArray ( buffer , str ) ; return buffer . toString ( ) ; }
private void update ( final AliveTimer aliveTimer ) { aliveTimer . setActive ( _BOOL ) ; aliveTimer . setLastUpdate ( System . currentTimeMillis ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) { StringBuffer str = new StringBuffer ( STRING ) ; str . append ( AliveTimer . ALIVE_TYPE_PROCESS + STRING ) ; str . append ( aliveTimer . getRelatedName ( ) ) ; str . append ( STRING ) ; LOGGER . debug ( str . toString ( ) ) ; } }
private void update ( final AliveTimer aliveTimer ) { aliveTimer . setActive ( _BOOL ) ; aliveTimer . setLastUpdate ( System . currentTimeMillis ( ) ) ; if ( LOGGER . isDebugEnabled ( ) ) { StringBuffer str = new StringBuffer ( STRING ) ; str . append ( AliveTimer . ALIVE_TYPE_PROCESS + STRING ) ; str . append ( aliveTimer . getRelatedName ( ) ) ; str . append ( STRING ) ; LOGGER . debug ( str . toString ( ) ) ; } }
private EditMode ( final String name , final String cursorName ) { Toolkit toolkit = Toolkit . getDefaultToolkit ( ) ; Image image = ResourceManager . getImage ( cursorName ) ; if ( name . equals ( STRING ) ) { this . cursor = Cursor . getDefaultCursor ( ) ; } else { this . cursor = toolkit . createCustomCursor ( image , CENTER_POINT , name ) ; } }
public void addRow ( WorkspaceComponent component ) { data . add ( component ) ; fireTableStructureChanged ( ) ; }
public CanProt ( ) { for ( int i = _NUM ; i < getMsgParameters ( ) . length ; i ++ ) { int convId = getMsgParameters ( ) [ i ] [ FLD_ID_CONV ] ; Integer paramId = Integer . valueOf ( i ) ; Integer canId = getMsgParameters ( ) [ i ] [ FLD_ID_CANID ] ; Vector < Integer > paramList = canMsgMap . get ( canId ) ; if ( paramList == null ) paramList = new Vector < Integer > ( ) ; paramList . add ( paramId ) ; canMsgMap . put ( canId , paramList ) ; EcuDataPv pidData = new EcuDataPv ( ) ; pidData . put ( EcuDataPv . FID_PID , paramId ) ; pidData . put ( EcuDataPv . FID_DESCRIPT , getMsgDescriptors ( ) [ i ] ) ; pidData . put ( EcuDataPv . FID_UNITS , Conversions . getUnits ( convId ) ) ; pidData . put ( EcuDataPv . FID_VALUE , Float . valueOf ( _NUM ) ) ; pidData . put ( EcuDataPv . FID_FORMAT , STRING + getMsgParameters ( ) [ i ] [ FLD_ID_DECIMALS ] + STRING ) ; pidData . put ( EcuDataPv . FID_CNVID , Integer . valueOf ( getMsgParameters ( ) [ i ] [ FLD_ID_CONV ] ) ) ; CanPvs . put ( paramId , pidData ) ; } }
private void initializeFunction ( StellarFunction function , String functionName ) { try { if ( ! function . isInitialized ( ) ) { function . initialize ( context ) ; } } catch ( Throwable t ) { String error = format ( STRING , functionName ) ; throw new ParseException ( error , t ) ; } }
public static double similarity ( String s1 , String s2 ) { String longer = s1 , shorter = s2 ; if ( s1 . length ( ) < s2 . length ( ) ) { longer = s2 ; shorter = s1 ; } int longerLength = longer . length ( ) ; if ( longerLength == _NUM ) { return _NUM ; } return ( longerLength - editDistance ( longer , shorter ) ) / ( double ) longerLength ; }
byte dirTypeForward ( ) { lastChar = text . charAt ( charIndex ) ; if ( Character . isHighSurrogate ( lastChar ) ) { int codePoint = Character . codePointAt ( text , charIndex ) ; charIndex += Character . charCount ( codePoint ) ; return Character . getDirectionality ( codePoint ) ; } charIndex ++ ; byte dirType = getCachedDirectionality ( lastChar ) ; if ( isHtml ) { if ( lastChar == STRING ) { dirType = skipTagForward ( ) ; } else if ( lastChar == STRING ) { dirType = skipEntityForward ( ) ; } } return dirType ; }
byte dirTypeForward ( ) { lastChar = text . charAt ( charIndex ) ; if ( Character . isHighSurrogate ( lastChar ) ) { int codePoint = Character . codePointAt ( text , charIndex ) ; charIndex += Character . charCount ( codePoint ) ; return Character . getDirectionality ( codePoint ) ; } charIndex ++ ; byte dirType = getCachedDirectionality ( lastChar ) ; if ( isHtml ) { if ( lastChar == STRING ) { dirType = skipTagForward ( ) ; } else if ( lastChar == STRING ) { dirType = skipEntityForward ( ) ; } } return dirType ; }
public static KeyPair createECKeyPair ( String name ) throws IOException { try { ECGenParameterSpec ecSpec = new ECGenParameterSpec ( name ) ; KeyPairGenerator keyGen = KeyPairGenerator . getInstance ( STRING ) ; keyGen . initialize ( ecSpec , new SecureRandom ( ) ) ; return keyGen . generateKeyPair ( ) ; } catch ( NoSuchAlgorithmException | InvalidAlgorithmParameterException ex ) { throw new IOException ( ex ) ; } }
private void init ( ) throws AdeException { dbPropertiesInitialized = _BOOL ; final Properties prop = new Properties ( ) ; try ( FileInputStream fis = new FileInputStream ( propertiesFileName ) ) { prop . load ( fis ) ; dbURL = prop . getProperty ( DATABASE_URL_PARAM ) ; dbDriver = prop . getProperty ( DATABASE_DRIVER_PARAM ) ; dbUserName = prop . getProperty ( DATABASE_USER_PARAM ) ; dbUserPassword = prop . getProperty ( DATABASE_PASSWORD_PARAM ) ; if ( dbURL != null ) { dbPropertiesInitialized = _BOOL ; dbURL = dbURL . trim ( ) ; dbName = parseDBName ( ) ; } if ( dbDriver != null ) { dbDriver = dbDriver . trim ( ) ; } else { dbPropertiesInitialized = _BOOL ; } if ( dbUserName != null ) { dbUserName = dbUserName . trim ( ) ; } if ( dbUserPassword != null ) { dbUserPassword = dbUserPassword . trim ( ) ; } } catch ( FileNotFoundException e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } catch ( IOException e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } catch ( Exception e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } }
public static boolean maybeEmtpy ( RegExp re ) { RegExp2 r ; switch ( re . type ) { case sym . BAR : { r = ( RegExp2 ) re ; return maybeEmtpy ( r . r1 ) || maybeEmtpy ( r . r2 ) ; } case sym . CONCAT : { r = ( RegExp2 ) re ; return maybeEmtpy ( r . r1 ) && maybeEmtpy ( r . r2 ) ; } case sym . STAR : case sym . QUESTION : return _BOOL ; case sym . PLUS : { RegExp1 r1 = ( RegExp1 ) re ; return maybeEmtpy ( ( RegExp ) r1 . content ) ; } case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR_I : return _BOOL ; case sym . STRING : case sym . STRING_I : { String content = ( String ) ( ( RegExp1 ) re ) . content ; return content . length ( ) == _NUM ; } case sym . TILDE : return _BOOL ; case sym . BANG : { RegExp1 r1 = ( RegExp1 ) re ; return ! maybeEmtpy ( ( RegExp ) r1 . content ) ; } case sym . MACROUSE : return maybeEmtpy ( macros . getDefinition ( ( String ) ( ( RegExp1 ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }
public static boolean maybeEmtpy ( RegExp re ) { RegExp2 r ; switch ( re . type ) { case sym . BAR : { r = ( RegExp2 ) re ; return maybeEmtpy ( r . r1 ) || maybeEmtpy ( r . r2 ) ; } case sym . CONCAT : { r = ( RegExp2 ) re ; return maybeEmtpy ( r . r1 ) && maybeEmtpy ( r . r2 ) ; } case sym . STAR : case sym . QUESTION : return _BOOL ; case sym . PLUS : { RegExp1 r1 = ( RegExp1 ) re ; return maybeEmtpy ( ( RegExp ) r1 . content ) ; } case sym . CCLASS : case sym . CCLASSNOT : case sym . CHAR : case sym . CHAR_I : return _BOOL ; case sym . STRING : case sym . STRING_I : { String content = ( String ) ( ( RegExp1 ) re ) . content ; return content . length ( ) == _NUM ; } case sym . TILDE : return _BOOL ; case sym . BANG : { RegExp1 r1 = ( RegExp1 ) re ; return ! maybeEmtpy ( ( RegExp ) r1 . content ) ; } case sym . MACROUSE : return maybeEmtpy ( macros . getDefinition ( ( String ) ( ( RegExp1 ) re ) . content ) ) ; } throw new Error ( STRING + re . type + STRING + re ) ; }
public synchronized void addPropertyChangeListener ( PropertyChangeListener l ) { pcs . addPropertyChangeListener ( l ) ; }
public synchronized void addPropertyChangeListener ( PropertyChangeListener l ) { pcs . addPropertyChangeListener ( l ) ; }
private void calculateWindowProportions ( final int slots ) { int width = ( int ) Math . sqrt ( slots ) ; while ( slots % width != _NUM ) { width -- ; if ( width <= _NUM ) { logger . error ( STRING + slots ) ; width = _NUM ; } } slotWindowWidth = width ; slotWindowHeight = slots / width ; }
default TypeDeclaration asType ( ) { throw new UnsupportedOperationException ( String . format ( STRING , this ) ) ; }
public BoxRenderer ( String url , int width ) { this ( url , url , width , NO_HEIGHT ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return BONK ; default : return null ; } }
public void close ( ) { if ( null != inputStreamReader ) { CarbonUtil . closeStreams ( inputStreamReader ) ; } }
public void close ( ) { if ( null != inputStreamReader ) { CarbonUtil . closeStreams ( inputStreamReader ) ; } }
protected static boolean networkMonitorExist ( String nwMonName ) { String classMethod = STRING ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STRING + nwMonName ) ; } if ( ( nwMonName == null ) || ( nwMonName . length ( ) == _NUM ) ) { if ( debug . warningEnabled ( ) ) { debug . warning ( classMethod + STRING ) ; } return _BOOL ; } Set < String > ntwStats = NetworkMonitor . getInstanceNames ( ) ; String ss = nwMonName . toLowerCase ( ) ; if ( ntwStats . contains ( ss ) ) { return _BOOL ; } else { return _BOOL ; } }
protected static boolean networkMonitorExist ( String nwMonName ) { String classMethod = STRING ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STRING + nwMonName ) ; } if ( ( nwMonName == null ) || ( nwMonName . length ( ) == _NUM ) ) { if ( debug . warningEnabled ( ) ) { debug . warning ( classMethod + STRING ) ; } return _BOOL ; } Set < String > ntwStats = NetworkMonitor . getInstanceNames ( ) ; String ss = nwMonName . toLowerCase ( ) ; if ( ntwStats . contains ( ss ) ) { return _BOOL ; } else { return _BOOL ; } }
protected static boolean networkMonitorExist ( String nwMonName ) { String classMethod = STRING ; if ( debug . messageEnabled ( ) ) { debug . message ( classMethod + STRING + nwMonName ) ; } if ( ( nwMonName == null ) || ( nwMonName . length ( ) == _NUM ) ) { if ( debug . warningEnabled ( ) ) { debug . warning ( classMethod + STRING ) ; } return _BOOL ; } Set < String > ntwStats = NetworkMonitor . getInstanceNames ( ) ; String ss = nwMonName . toLowerCase ( ) ; if ( ntwStats . contains ( ss ) ) { return _BOOL ; } else { return _BOOL ; } }
protected String deStress ( String phone ) { String retPhone = phone ; if ( isStressed ( phone ) ) { retPhone = phone . substring ( _NUM , phone . length ( ) - _NUM ) ; } return retPhone ; }
protected String deStress ( String phone ) { String retPhone = phone ; if ( isStressed ( phone ) ) { retPhone = phone . substring ( _NUM , phone . length ( ) - _NUM ) ; } return retPhone ; }
protected String deStress ( String phone ) { String retPhone = phone ; if ( isStressed ( phone ) ) { retPhone = phone . substring ( _NUM , phone . length ( ) - _NUM ) ; } return retPhone ; }
public Builder delay ( long duration , TimeUnit timeUnit ) { this . delay = timeUnit . toSeconds ( duration ) ; return this ; }
public Builder delay ( long duration , TimeUnit timeUnit ) { this . delay = timeUnit . toSeconds ( duration ) ; return this ; }
public SmsMmsMessage shouldNotify ( ) { SmsMmsMessage message ; for ( int i = _NUM ; i < messages . size ( ) ; i ++ ) { message = messages . get ( i ) ; if ( message . shouldNotify ( ) ) { return message ; } } return null ; }
public void addAssociation ( int node , int endpoint ) { if ( isAssociated ( node , endpoint ) ) { return ; } ZWaveAssociation newAssociation = new ZWaveAssociation ( node , endpoint ) ; associations . add ( newAssociation ) ; }
public static XMLTableDefinition load ( Element definition ) { XMLTableDefinition answer = new XMLTableDefinition ( ) ; answer . setRowExpression ( definition . attributeValue ( STRING ) ) ; for ( Iterator < Element > iter = definition . elementIterator ( STRING ) ; iter . hasNext ( ) ; ) { Element element = iter . next ( ) ; String expression = element . attributeValue ( STRING ) ; String name = element . getText ( ) ; String typeName = element . attributeValue ( STRING , STRING ) ; String columnXPath = element . attributeValue ( STRING ) ; int type = XMLTableColumnDefinition . parseType ( typeName ) ; if ( columnXPath != null ) { answer . addColumnWithXPathName ( columnXPath , expression , type ) ; } else { answer . addColumn ( name , expression , type ) ; } } return answer ; }
public static XMLTableDefinition load ( Element definition ) { XMLTableDefinition answer = new XMLTableDefinition ( ) ; answer . setRowExpression ( definition . attributeValue ( STRING ) ) ; for ( Iterator < Element > iter = definition . elementIterator ( STRING ) ; iter . hasNext ( ) ; ) { Element element = iter . next ( ) ; String expression = element . attributeValue ( STRING ) ; String name = element . getText ( ) ; String typeName = element . attributeValue ( STRING , STRING ) ; String columnXPath = element . attributeValue ( STRING ) ; int type = XMLTableColumnDefinition . parseType ( typeName ) ; if ( columnXPath != null ) { answer . addColumnWithXPathName ( columnXPath , expression , type ) ; } else { answer . addColumn ( name , expression , type ) ; } } return answer ; }
private void showTagUserFragment ( String wallId , String wallUserId , String tagCount ) { if ( isAttached ( ) ) { final Intent tagUserActivityIntent = new Intent ( getActivity ( ) , TagUserActivity . class ) ; tagUserActivityIntent . putExtra ( AppConstants . Keys . WALL_ID , wallId ) ; tagUserActivityIntent . putExtra ( AppConstants . Keys . USER_ID , wallUserId ) ; tagUserActivityIntent . putExtra ( AppConstants . Keys . TAG_USER_COUNT , Integer . parseInt ( tagCount ) ) ; startActivity ( tagUserActivityIntent ) ; } }
public static boolean isValidTemplate ( String template ) { template = template . trim ( ) ; if ( template . indexOf ( STRING ) == - _NUM ) { return _BOOL ; } String s = template . trim ( ) ; if ( s . lastIndexOf ( STRING ) != s . length ( ) - _NUM ) { return _BOOL ; } if ( getMethodSignature ( template ) == null ) { return _BOOL ; } if ( getMethodBody ( template ) == null ) { return _BOOL ; } return _BOOL ; }
static UnixStream < String > echo ( final String input ) { Objects . requireNonNull ( input , STRING ) ; return new UnixStreamImpl < > ( Stream . of ( input ) ) ; }
static UnixStream < String > echo ( final String input ) { Objects . requireNonNull ( input , STRING ) ; return new UnixStreamImpl < > ( Stream . of ( input ) ) ; }
private List < String > checkConfigList ( Configuration config , String name ) { String peerIPs = config . getConfig ( name ) ; ArrayList < String > peers = new ArrayList < String > ( ) ; if ( peerIPs != null ) { for ( String ip : StringUtils . split ( peerIPs , STRING ) ) { peers . add ( ip ) ; } } return peers ; }
public static int makeWord ( int hibyte , int lowbyte ) { int hi = _NUM & hibyte ; int low = _NUM & lowbyte ; return ( ( hi << _NUM ) | low ) ; }
private void warning ( String msg , Throwable th ) { warning ( msg ) ; th . printStackTrace ( ) ; }
public K auth ( Activity act , String type , String account ) { if ( android . os . Build . VERSION . SDK_INT >= _NUM && type . startsWith ( STRING ) ) { ah = new GoogleHandle ( act , type , account ) ; } return self ( ) ; }
public K auth ( Activity act , String type , String account ) { if ( android . os . Build . VERSION . SDK_INT >= _NUM && type . startsWith ( STRING ) ) { ah = new GoogleHandle ( act , type , account ) ; } return self ( ) ; }
public void refreshStorage ( List < HostSystem > hosts ) { if ( ! hosts . isEmpty ( ) ) { execute ( new RefreshStorage ( hosts ) ) ; } }
public void sync ( ) { try { file . force ( _BOOL ) ; } catch ( IOException e ) { closeFileSilently ( ) ; throw DbException . convertIOException ( e , name ) ; } }
public void sync ( ) { try { file . force ( _BOOL ) ; } catch ( IOException e ) { closeFileSilently ( ) ; throw DbException . convertIOException ( e , name ) ; } }
public void sync ( ) { try { file . force ( _BOOL ) ; } catch ( IOException e ) { closeFileSilently ( ) ; throw DbException . convertIOException ( e , name ) ; } }
public int hashCode ( ) { if ( myhash == - _NUM ) { if ( timestamp == null ) { myhash = signerCertPath . hashCode ( ) ; } else { myhash = signerCertPath . hashCode ( ) + timestamp . hashCode ( ) ; } } return myhash ; }
@ AfterClass public void stopJetty ( ) throws Exception { server . stop ( ) ; }
@ AfterClass public void stopJetty ( ) throws Exception { server . stop ( ) ; }
private AFTPClient actionRemove ( ) throws IOException , PageException { required ( STRING , item ) ; AFTPClient client = getClient ( ) ; client . deleteFile ( item ) ; writeCfftp ( client ) ; return client ; }
public DOpenPkcs11KeyStore ( JFrame parent ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
protected String escapeAttributeEntities ( String text ) { char quote = format . getAttributeQuoteCharacter ( ) ; char [ ] block = null ; int i ; int last = _NUM ; int size = text . length ( ) ; for ( i = _NUM ; i < size ; i ++ ) { String entity = null ; char c = text . charAt ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < _NUM ) || shouldEncodeChar ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + _NUM ; } } if ( last == _NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; return answer ; }
protected String escapeAttributeEntities ( String text ) { char quote = format . getAttributeQuoteCharacter ( ) ; char [ ] block = null ; int i ; int last = _NUM ; int size = text . length ( ) ; for ( i = _NUM ; i < size ; i ++ ) { String entity = null ; char c = text . charAt ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < _NUM ) || shouldEncodeChar ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + _NUM ; } } if ( last == _NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; return answer ; }
protected String escapeAttributeEntities ( String text ) { char quote = format . getAttributeQuoteCharacter ( ) ; char [ ] block = null ; int i ; int last = _NUM ; int size = text . length ( ) ; for ( i = _NUM ; i < size ; i ++ ) { String entity = null ; char c = text . charAt ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < _NUM ) || shouldEncodeChar ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + _NUM ; } } if ( last == _NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; return answer ; }
protected String escapeAttributeEntities ( String text ) { char quote = format . getAttributeQuoteCharacter ( ) ; char [ ] block = null ; int i ; int last = _NUM ; int size = text . length ( ) ; for ( i = _NUM ; i < size ; i ++ ) { String entity = null ; char c = text . charAt ( i ) ; switch ( c ) { case STRING : entity = STRING ; break ; case STRING : entity = STRING ; break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : if ( quote == STRING ) { entity = STRING ; } break ; case STRING : entity = STRING ; break ; case STRING : case STRING : case STRING : break ; default : if ( ( c < _NUM ) || shouldEncodeChar ( c ) ) { entity = STRING + ( int ) c + STRING ; } break ; } if ( entity != null ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; buffer . append ( entity ) ; last = i + _NUM ; } } if ( last == _NUM ) { return text ; } if ( last < size ) { if ( block == null ) { block = text . toCharArray ( ) ; } buffer . append ( block , last , i - last ) ; } String answer = buffer . toString ( ) ; buffer . setLength ( _NUM ) ; return answer ; }
private void prependDecrement ( BasicBlock bb , IR ir ) { if ( DEBUG ) VM . sysWrite ( STRING + bb + STRING ) ; RegisterOperand use = cbsReg . copyRO ( ) ; RegisterOperand def = use . copyU2D ( ) ; Instruction inc = Binary . create ( INT_ADD , def , use , IRTools . IC ( - _NUM ) ) ; bb . prependInstruction ( inc ) ; }
void addIndifferentAlgorithm ( String algorithm ) { indifferentAlgorithms . add ( algorithm ) ; }
private boolean coordIsCalendarCell ( float y ) { return y > cellHeight ; }
public OCSPNoCheckExtension ( Boolean critical , Object value ) throws IOException { this . extensionId = PKIXExtensions . OCSPNoCheck_Id ; this . critical = critical . booleanValue ( ) ; this . extensionValue = new byte [ _NUM ] ; }
private static Shape generateDonut ( double x , double y , double innerRadius , double outerRadius ) { Area a1 = new Area ( new Ellipse2D . Double ( x , y , outerRadius , outerRadius ) ) ; double innerOffset = ( outerRadius - innerRadius ) / _NUM ; Area a2 = new Area ( new Ellipse2D . Double ( x + innerOffset , y + innerOffset , innerRadius , innerRadius ) ) ; a1 . subtract ( a2 ) ; return a1 ; }
private static Shape generateDonut ( double x , double y , double innerRadius , double outerRadius ) { Area a1 = new Area ( new Ellipse2D . Double ( x , y , outerRadius , outerRadius ) ) ; double innerOffset = ( outerRadius - innerRadius ) / _NUM ; Area a2 = new Area ( new Ellipse2D . Double ( x + innerOffset , y + innerOffset , innerRadius , innerRadius ) ) ; a1 . subtract ( a2 ) ; return a1 ; }
protected String fetchNativeId ( String nativeGuid ) { String [ ] token = nativeGuid . split ( VNXFileConstants . PLUS_SEPERATOR ) ; return token [ token . length - _NUM ] ; }
public static void writeAsPNG ( Drawable drawable , int w , int h , File file ) throws FileNotFoundException , IOException { BufferedImage image = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D g2 = image . createGraphics ( ) ; drawable . draw ( g2 , new Rectangle ( w , h ) ) ; OutputStream out = new BufferedOutputStream ( new FileOutputStream ( file ) ) ; try { ImageIO . write ( image , STRING , out ) ; } finally { out . close ( ) ; } }
private void calculateSizes ( ) { this . prefferedSize = new Dimension ( ) ; final BufferedImage image = new BufferedImage ( _NUM , _NUM , BufferedImage . TYPE_INT_RGB ) ; final Graphics2D g2d = image . createGraphics ( ) ; g2d . setFont ( font ) ; final FontMetrics metrics = g2d . getFontMetrics ( ) ; this . lineHeight = metrics . getHeight ( ) ; this . prefferedSize . height = this . lineHeight * _NUM ; for ( String s : text ) { prefferedSize . width = Math . max ( prefferedSize . width , metrics . stringWidth ( s ) ) ; } this . prefferedSize . width = prefferedSize . width + _NUM * metrics . stringWidth ( STRING ) ; }
private static List < String > extractTextItems ( ) { List < String > retList = new ArrayList < String > ( ) ; SFileChooser chooser = new SFileChooser ( getDictionaryDirectory ( ) , STRING , STRING ) ; chooser . addExtension ( STRING ) ; File theFile = chooser . showOpenDialog ( ) ; if ( theFile != null ) { Scanner scanner ; try { scanner = new Scanner ( new FileReader ( theFile ) ) ; try { while ( scanner . hasNextLine ( ) ) { Scanner lineScan = new Scanner ( scanner . nextLine ( ) ) ; while ( lineScan . hasNext ( ) ) { String word = lineScan . next ( ) ; retList . add ( word ) ; } } } finally { scanner . close ( ) ; setDictionaryDirectory ( chooser . getCurrentLocation ( ) ) ; } } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } } return retList ; }
public static void removePermissionRecursive ( Path path , PosixFilePermission permission ) throws IOException { changePermissionsRecursive ( path , PermissionChange . REMOVE , Collections . singleton ( permission ) ) ; }
protected void doValidateZeroLongFile ( String path , String filename , long size , boolean checkContents ) { File inFile = new File ( path , filename ) ; DataInputStream inStream = null ; Log . i ( LOG_TAG , STRING + filename + STRING + path ) ; try { inStream = new DataInputStream ( new FileInputStream ( inFile ) ) ; if ( checkContents ) { for ( long i = _NUM ; i < size ; ++ i ) { if ( inStream . readLong ( ) != _NUM ) { fail ( STRING + filename ) ; } } } if ( inStream != null ) { inStream . close ( ) ; } Log . i ( LOG_TAG , STRING + filename + STRING + size + STRING ) ; } catch ( IOException e ) { fail ( STRING + inFile + STRING + e . toString ( ) ) ; } }
@ CallerSensitive public static final void clearCache ( ) { clearCache ( getLoader ( Reflection . getCallerClass ( ) ) ) ; }
private void splitCurrentLabel ( Label alternateSuccessor , List < Label > catchLabels ) { Label newLabel = new Label ( ) ; adopt ( newLabel ) ; currentLabel . primarySuccessor = newLabel ; currentLabel . alternateSuccessor = alternateSuccessor ; currentLabel . catchLabels = catchLabels ; currentLabel = newLabel ; currentLabel . marked = _BOOL ; }
public boolean remove ( Object o ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( TenantQueue q : qs . values ( ) ) { if ( q . remove ( o ) ) return _BOOL ; } return _BOOL ; } finally { lock . unlock ( ) ; } }
public PcalSymTab ( AST ast ) throws PcalSymTabException { symtab = new Vector ( ) ; iPC = null ; disambiguateReport = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; errorReport = STRING ; InsertSym ( GLOBAL , STRING , STRING , STRING , _NUM , _NUM ) ; ExtractSym ( ast , STRING ) ; if ( errorReport . length ( ) > _NUM ) throw new PcalSymTabException ( errorReport ) ; }
public PcalSymTab ( AST ast ) throws PcalSymTabException { symtab = new Vector ( ) ; iPC = null ; disambiguateReport = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; errorReport = STRING ; InsertSym ( GLOBAL , STRING , STRING , STRING , _NUM , _NUM ) ; ExtractSym ( ast , STRING ) ; if ( errorReport . length ( ) > _NUM ) throw new PcalSymTabException ( errorReport ) ; }
public PcalSymTab ( AST ast ) throws PcalSymTabException { symtab = new Vector ( ) ; iPC = null ; disambiguateReport = new Vector ( ) ; procs = new Vector ( ) ; processes = new Vector ( ) ; errorReport = STRING ; InsertSym ( GLOBAL , STRING , STRING , STRING , _NUM , _NUM ) ; ExtractSym ( ast , STRING ) ; if ( errorReport . length ( ) > _NUM ) throw new PcalSymTabException ( errorReport ) ; }
public static int inetAddressToInt ( InetAddress inetAddr ) throws IllegalArgumentException { byte [ ] addr = inetAddr . getAddress ( ) ; if ( addr . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } return ( ( addr [ _NUM ] & _NUM ) << _NUM ) | ( ( addr [ _NUM ] & _NUM ) << _NUM ) | ( ( addr [ _NUM ] & _NUM ) << _NUM ) | ( addr [ _NUM ] & _NUM ) ; }
public static Object extractTypeChecked ( List < Object > args , int i , Class clazz , Function < List < Object > , Object > extractFunc ) { if ( args . size ( ) < i + _NUM ) { return null ; } else if ( clazz . isInstance ( args . get ( i ) ) ) { return extractFunc . apply ( args ) ; } else { return null ; } }
@ SuppressWarnings ( STRING ) public List < Boundary > populateArea ( final Long wardId ) { HierarchyType hType = heirarchyTypeService . getHierarchyTypeByName ( hierarchyTypeName ) ; ; List < Boundary > areaList = new LinkedList < Boundary > ( ) ; final BoundaryType childBoundaryType = boundaryTypeService . getBoundaryTypeByNameAndHierarchyType ( STRING , hType ) ; final Boundary parentBoundary = boundaryService . getBoundaryById ( wardId ) ; areaList = new LinkedList ( crossHeirarchyService . getCrossHierarchyChildrens ( parentBoundary , childBoundaryType ) ) ; LOGGER . info ( STRING + areaList . toString ( ) ) ; return areaList ; }
@ SuppressWarnings ( STRING ) public List < Boundary > populateArea ( final Long wardId ) { HierarchyType hType = heirarchyTypeService . getHierarchyTypeByName ( hierarchyTypeName ) ; ; List < Boundary > areaList = new LinkedList < Boundary > ( ) ; final BoundaryType childBoundaryType = boundaryTypeService . getBoundaryTypeByNameAndHierarchyType ( STRING , hType ) ; final Boundary parentBoundary = boundaryService . getBoundaryById ( wardId ) ; areaList = new LinkedList ( crossHeirarchyService . getCrossHierarchyChildrens ( parentBoundary , childBoundaryType ) ) ; LOGGER . info ( STRING + areaList . toString ( ) ) ; return areaList ; }
private static Request newStatusUpdateRequest ( Session session , String message , String placeId , List < String > tagIds , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . putString ( STRING , message ) ; if ( placeId != null ) { parameters . putString ( STRING , placeId ) ; } if ( tagIds != null && tagIds . size ( ) > _NUM ) { String tags = TextUtils . join ( STRING , tagIds ) ; parameters . putString ( STRING , tags ) ; } return new Request ( session , MY_FEED , parameters , HttpMethod . POST , callback ) ; }
private static Request newStatusUpdateRequest ( Session session , String message , String placeId , List < String > tagIds , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . putString ( STRING , message ) ; if ( placeId != null ) { parameters . putString ( STRING , placeId ) ; } if ( tagIds != null && tagIds . size ( ) > _NUM ) { String tags = TextUtils . join ( STRING , tagIds ) ; parameters . putString ( STRING , tags ) ; } return new Request ( session , MY_FEED , parameters , HttpMethod . POST , callback ) ; }
private static Request newStatusUpdateRequest ( Session session , String message , String placeId , List < String > tagIds , Callback callback ) { Bundle parameters = new Bundle ( ) ; parameters . putString ( STRING , message ) ; if ( placeId != null ) { parameters . putString ( STRING , placeId ) ; } if ( tagIds != null && tagIds . size ( ) > _NUM ) { String tags = TextUtils . join ( STRING , tagIds ) ; parameters . putString ( STRING , tags ) ; } return new Request ( session , MY_FEED , parameters , HttpMethod . POST , callback ) ; }
public RouterHandler ( final RouteBuilder builder , final DirectoryMonitor directoryMonitor ) { this . builder = builder ; this . directoryMonitor = directoryMonitor ; ReadWriteLock lock = new ReentrantReadWriteLock ( ) ; this . read = lock . readLock ( ) ; this . write = lock . writeLock ( ) ; }
public RouterHandler ( final RouteBuilder builder , final DirectoryMonitor directoryMonitor ) { this . builder = builder ; this . directoryMonitor = directoryMonitor ; ReadWriteLock lock = new ReentrantReadWriteLock ( ) ; this . read = lock . readLock ( ) ; this . write = lock . writeLock ( ) ; }
public CaseBuilder when ( Object when , Object then ) { if ( ended ) { throw new IllegalStateException ( STRING ) ; } if ( whens == null ) { whens = new ArrayList < > ( ) ; thens = new ArrayList < > ( ) ; } whens . add ( when ) ; thens . add ( then ) ; return this ; }
public static void showImage ( CaptureType captureType , ImageView imageView , Uri fileUri ) { if ( imageView == null ) { throw new RuntimeException ( STRING ) ; } if ( fileUri == null ) { throw new NullPointerException ( STRING ) ; } try { imageView . setImageBitmap ( captureType == CaptureType . CAPTURED_FROM_CAMERA ? getCapturedImageAsBitmap ( fileUri ) : getSelectedImageAsBitmap ( fileUri ) ) ; } catch ( NullPointerException e ) { Log . e ( TAG , STRING ) ; Log . e ( TAG , e . getLocalizedMessage ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
public void addToBlacklist ( HostAddress hostAddress ) { if ( hostAddress != null && ! isExplicitClosed ( ) ) { blacklist . putIfAbsent ( hostAddress , System . nanoTime ( ) ) ; } }
private String generateStoragePortKey ( StorageHADomain vplexDirector , String objectName ) { return String . format ( STRING , vplexDirector . getNativeGuid ( ) , objectName ) ; }
public ConstraintViolationException ( ServerManagedObject < ? > managedObject , LocalizableMessage message ) { this ( managedObject , Collections . singleton ( message ) ) ; }
private void createInfoWindow ( ) { infoWindow = new JWindow ( SwingUtilities . getWindowAncestor ( textField ) ) ; infoLabel = new JLabel ( ) ; infoWindow . add ( infoLabel ) ; JPanel contentPane = ( JPanel ) infoWindow . getContentPane ( ) ; Border border = BorderFactory . createCompoundBorder ( BorderFactory . createLineBorder ( Color . GRAY ) , BorderFactory . createEmptyBorder ( _NUM , _NUM , _NUM , _NUM ) ) ; contentPane . setBorder ( border ) ; contentPane . setBackground ( HtmlColors . decode ( STRING ) ) ; infoLabel . setFont ( textField . getFont ( ) ) ; containingWindow = SwingUtilities . getWindowAncestor ( textField ) ; if ( containingWindow != null ) { containingWindow . addComponentListener ( componentListener ) ; } textField . addComponentListener ( componentListener ) ; }
public static Class toReferenceClass ( Class c ) { if ( c . isPrimitive ( ) ) { if ( c == boolean . class ) return Boolean . class ; if ( c == byte . class ) return Byte . class ; if ( c == short . class ) return Short . class ; if ( c == char . class ) return Character . class ; if ( c == int . class ) return Integer . class ; if ( c == long . class ) return Long . class ; if ( c == float . class ) return Float . class ; if ( c == double . class ) return Double . class ; } return c ; }
public static void writeStringToFile ( File file , String data , Charset encoding , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; IOUtils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public static void writeStringToFile ( File file , String data , Charset encoding , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; IOUtils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public static void writeStringToFile ( File file , String data , Charset encoding , boolean append ) throws IOException { OutputStream out = null ; try { out = openOutputStream ( file , append ) ; IOUtils . write ( data , out , encoding ) ; out . close ( ) ; } finally { IOUtils . closeQuietly ( out ) ; } }
public static List < Response > executeBatchAndWait ( Request ... requests ) { Validate . notNull ( requests , STRING ) ; return executeBatchAndWait ( Arrays . asList ( requests ) ) ; }
public CoreTokenException ( int errorCode , Object [ ] params , int httpStatusCode ) { this . errorCode = errorCode ; this . params = params ; this . httpStatusCode = httpStatusCode ; this . message = getLocalizedMessage ( Locale . getDefault ( ) ) ; }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
public static void gc ( ) { if ( startedGc ) { forceGc = _BOOL ; gcShouldLoop = _BOOL ; } startGCThread ( ) ; synchronized ( LOCK ) { LOCK . notify ( ) ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException er ) { } }
private String applyReplacement ( final BidiMap replacement , String contents ) { for ( Object key : replacement . keySet ( ) ) { String attributeName = ( String ) key ; String attributeInitials = ( String ) replacement . get ( key ) ; contents = contents . replaceAll ( JSONSerialisation . jsonAttributeName ( attributeName ) , JSONSerialisation . jsonAttributeName ( attributeInitials ) ) ; } return contents ; }
public void addListener ( @ NotNull PerspectiveTypeListener listener ) { listeners . add ( listener ) ; }
public void show ( ) { appWindow . setVisible ( _BOOL ) ; if ( IdeFinder . getOS ( ) == OS . MAC_OS_X ) { try { AppleNativeLook . go ( ) ; } catch ( Throwable ignore ) { } } }
public boolean add ( final T item ) { final AdapterTransaction addTransaction = new AddTransaction < > ( this , item ) ; final boolean success = addTransaction . perform ( ) ; mTransactions . offer ( addTransaction ) ; return success ; }
public OSRef ( String ref ) throws IllegalArgumentException { char char1 = ref . charAt ( _NUM ) ; char char2 = ref . charAt ( _NUM ) ; int east = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; int north = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; east += _NUM ; } else if ( char1 == STRING ) { east += _NUM ; } int char2ord = char2 ; if ( char2ord > _NUM ) char2ord -- ; double nx = ( ( char2ord - _NUM ) % _NUM ) * _NUM ; double ny = ( _NUM - Math . floor ( ( char2ord - _NUM ) / _NUM ) ) * _NUM ; easting = east + nx ; northing = north + ny ; }
public OSRef ( String ref ) throws IllegalArgumentException { char char1 = ref . charAt ( _NUM ) ; char char2 = ref . charAt ( _NUM ) ; int east = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; int north = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; east += _NUM ; } else if ( char1 == STRING ) { east += _NUM ; } int char2ord = char2 ; if ( char2ord > _NUM ) char2ord -- ; double nx = ( ( char2ord - _NUM ) % _NUM ) * _NUM ; double ny = ( _NUM - Math . floor ( ( char2ord - _NUM ) / _NUM ) ) * _NUM ; easting = east + nx ; northing = north + ny ; }
public OSRef ( String ref ) throws IllegalArgumentException { char char1 = ref . charAt ( _NUM ) ; char char2 = ref . charAt ( _NUM ) ; int east = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; int north = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; east += _NUM ; } else if ( char1 == STRING ) { east += _NUM ; } int char2ord = char2 ; if ( char2ord > _NUM ) char2ord -- ; double nx = ( ( char2ord - _NUM ) % _NUM ) * _NUM ; double ny = ( _NUM - Math . floor ( ( char2ord - _NUM ) / _NUM ) ) * _NUM ; easting = east + nx ; northing = north + ny ; }
public OSRef ( String ref ) throws IllegalArgumentException { char char1 = ref . charAt ( _NUM ) ; char char2 = ref . charAt ( _NUM ) ; int east = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; int north = Integer . parseInt ( ref . substring ( _NUM , _NUM ) ) * _NUM ; if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; } else if ( char1 == STRING ) { north += _NUM ; east += _NUM ; } else if ( char1 == STRING ) { east += _NUM ; } int char2ord = char2 ; if ( char2ord > _NUM ) char2ord -- ; double nx = ( ( char2ord - _NUM ) % _NUM ) * _NUM ; double ny = ( _NUM - Math . floor ( ( char2ord - _NUM ) / _NUM ) ) * _NUM ; easting = east + nx ; northing = north + ny ; }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + doubleCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
public DoubleBuffer put ( double [ ] src , int srcOffset , int doubleCount ) { Arrays . checkOffsetAndCount ( src . length , srcOffset , doubleCount ) ; if ( doubleCount > remaining ( ) ) { throw new BufferOverflowException ( ) ; } for ( int i = srcOffset ; i < srcOffset + doubleCount ; ++ i ) { put ( src [ i ] ) ; } return this ; }
protected static String quoteSQL ( Object data , int type ) throws SQLException { if ( data == null ) { return STRING ; } switch ( type ) { case Types . BIT : case Types . BOOLEAN : case Types . INTEGER : case Types . BIGINT : case Types . DECIMAL : case Types . DOUBLE : case Types . FLOAT : case Types . NUMERIC : case Types . REAL : case Types . SMALLINT : case Types . TINYINT : return data . toString ( ) ; case Types . DATE : case Types . TIME : case Types . TIMESTAMP : case Types . LONGVARCHAR : case Types . CHAR : case Types . VARCHAR : return quoteString ( data . toString ( ) ) ; case Types . VARBINARY : case Types . LONGVARBINARY : case Types . BINARY : if ( data instanceof UUID ) { return STRING + data . toString ( ) + STRING ; } return STRING + StringUtils . convertBytesToHex ( ( byte [ ] ) data ) + STRING ; case Types . CLOB : case Types . JAVA_OBJECT : case Types . OTHER : case Types . BLOB : case Types . STRUCT : case Types . REF : case Types . NULL : case Types . ARRAY : case Types . DATALINK : case Types . DISTINCT : throw throwException ( STRING + type ) ; default : return STRING ; } }
protected void processMouseEvent ( MouseEvent e ) { if ( myInplaceComponent != null && ( MouseEvent . MOUSE_PRESSED == e . getID ( ) || MouseEvent . MOUSE_RELEASED == e . getID ( ) ) ) { finishEditing ( _BOOL ) ; } super . processMouseEvent ( e ) ; }
protected void processMouseEvent ( MouseEvent e ) { if ( myInplaceComponent != null && ( MouseEvent . MOUSE_PRESSED == e . getID ( ) || MouseEvent . MOUSE_RELEASED == e . getID ( ) ) ) { finishEditing ( _BOOL ) ; } super . processMouseEvent ( e ) ; }
public void rotateZ ( double theta ) { Matrix3D tmp = new Matrix3D ( ) ; double c = Math . cos ( theta ) ; double s = Math . sin ( theta ) ; tmp . set ( _NUM , _NUM , c ) ; tmp . set ( _NUM , _NUM , - s ) ; tmp . set ( _NUM , _NUM , s ) ; tmp . set ( _NUM , _NUM , c ) ; preMultiply ( tmp ) ; }
public int size ( ) { return m_snapshotList . size ( ) ; }
public Table sample ( double proportion ) { int tableCount = ( int ) Math . round ( rowCount ( ) * proportion ) ; Selection table1Selection = new BitmapBackedSelection ( ) ; int [ ] selectedRecords = generateUniformBitmap ( tableCount , rowCount ( ) ) ; for ( int selectedRecord : selectedRecords ) { table1Selection . add ( selectedRecord ) ; } return selectWhere ( table1Selection ) ; }
public void printLenString ( String v ) throws IOException { if ( v == null ) { os . write ( _NUM ) ; os . write ( _NUM ) ; } else { int len = v . length ( ) ; os . write ( len > > _NUM ) ; os . write ( len ) ; printString ( v , _NUM , len ) ; } }
public void addPhoneNumber ( PhoneType type , String number , String description ) { final NgnPhoneNumber phoneNumber = new NgnPhoneNumber ( type , number , description ) ; if ( type == PhoneType . MOBILE ) { mPhoneNumbers . add ( _NUM , phoneNumber ) ; } else { mPhoneNumbers . add ( phoneNumber ) ; } }
public void publish ( final String queueName , final String routingKey , final String message ) { if ( ( mChannel != null ) && mChannel . isOpen ( ) ) { try { mChannel . basicPublish ( queueName , routingKey , null , message . getBytes ( HTTP . UTF_8 ) ) ; } catch ( final UnsupportedEncodingException e ) { e . printStackTrace ( ) ; } catch ( final IOException e ) { e . printStackTrace ( ) ; } } }
protected void addNumericTrainClass ( double classValue , double weight ) { if ( classValue > m_MaxTarget ) { m_MaxTarget = classValue ; } if ( classValue < m_MinTarget ) { m_MinTarget = classValue ; } if ( m_TrainClassVals == null ) { m_TrainClassVals = new double [ _NUM ] ; m_TrainClassWeights = new double [ _NUM ] ; } if ( m_NumTrainClassVals == m_TrainClassVals . length ) { double [ ] temp = new double [ m_TrainClassVals . length * _NUM ] ; System . arraycopy ( m_TrainClassVals , _NUM , temp , _NUM , m_TrainClassVals . length ) ; m_TrainClassVals = temp ; temp = new double [ m_TrainClassWeights . length * _NUM ] ; System . arraycopy ( m_TrainClassWeights , _NUM , temp , _NUM , m_TrainClassWeights . length ) ; m_TrainClassWeights = temp ; } m_TrainClassVals [ m_NumTrainClassVals ] = classValue ; m_TrainClassWeights [ m_NumTrainClassVals ] = weight ; m_NumTrainClassVals ++ ; }
protected void addNumericTrainClass ( double classValue , double weight ) { if ( classValue > m_MaxTarget ) { m_MaxTarget = classValue ; } if ( classValue < m_MinTarget ) { m_MinTarget = classValue ; } if ( m_TrainClassVals == null ) { m_TrainClassVals = new double [ _NUM ] ; m_TrainClassWeights = new double [ _NUM ] ; } if ( m_NumTrainClassVals == m_TrainClassVals . length ) { double [ ] temp = new double [ m_TrainClassVals . length * _NUM ] ; System . arraycopy ( m_TrainClassVals , _NUM , temp , _NUM , m_TrainClassVals . length ) ; m_TrainClassVals = temp ; temp = new double [ m_TrainClassWeights . length * _NUM ] ; System . arraycopy ( m_TrainClassWeights , _NUM , temp , _NUM , m_TrainClassWeights . length ) ; m_TrainClassWeights = temp ; } m_TrainClassVals [ m_NumTrainClassVals ] = classValue ; m_TrainClassWeights [ m_NumTrainClassVals ] = weight ; m_NumTrainClassVals ++ ; }
public JCDiagnostic create ( DiagnosticType kind , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( kind , null , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; }
public JCDiagnostic create ( DiagnosticType kind , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( kind , null , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; }
public JCDiagnostic create ( DiagnosticType kind , DiagnosticSource source , DiagnosticPosition pos , String key , Object ... args ) { return create ( kind , null , EnumSet . noneOf ( DiagnosticFlag . class ) , source , pos , key , args ) ; }
public SelectPlan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = predHistogram ( p . histogram ( ) , pred ) ; }
public SelectPlan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = predHistogram ( p . histogram ( ) , pred ) ; }
public SelectPlan ( Plan p , Predicate pred ) { this . p = p ; this . pred = pred ; hist = predHistogram ( p . histogram ( ) , pred ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return _BOOL ; } if ( ! ( obj instanceof XYStepAreaRenderer ) ) { return _BOOL ; } XYStepAreaRenderer that = ( XYStepAreaRenderer ) obj ; if ( this . showOutline != that . showOutline ) { return _BOOL ; } if ( this . shapesVisible != that . shapesVisible ) { return _BOOL ; } if ( this . shapesFilled != that . shapesFilled ) { return _BOOL ; } if ( this . plotArea != that . plotArea ) { return _BOOL ; } if ( this . rangeBase != that . rangeBase ) { return _BOOL ; } if ( this . stepPoint != that . stepPoint ) { return _BOOL ; } return super . equals ( obj ) ; }
public static double abs ( Z z ) { double are , aim , rho ; are = Math . abs ( z . re ) ; aim = Math . abs ( z . im ) ; if ( are + aim == _NUM ) return _NUM ; if ( are >= aim ) { rho = aim / are ; return are * Math . sqrt ( _NUM + rho * rho ) ; } else { rho = are / aim ; return aim * Math . sqrt ( _NUM + rho * rho ) ; } }
private String canClaimDraw ( Position pos , long [ ] posHashList , int posHashListSize , Move move ) { String drawStr = STRING ; if ( Search . canClaimDraw50 ( pos ) ) { drawStr = STRING ; } else if ( Search . canClaimDrawRep ( pos , posHashList , posHashListSize , posHashListSize ) ) { drawStr = STRING ; } else { String strMove = TextIO . moveToString ( pos , move , _BOOL ) ; posHashList [ posHashListSize ++ ] = pos . zobristHash ( ) ; UndoInfo ui = new UndoInfo ( ) ; pos . makeMove ( move , ui ) ; if ( Search . canClaimDraw50 ( pos ) ) { drawStr = STRING + strMove ; } else if ( Search . canClaimDrawRep ( pos , posHashList , posHashListSize , posHashListSize ) ) { drawStr = STRING + strMove ; } pos . unMakeMove ( move , ui ) ; } return drawStr ; }
private static void replaceAltSpecialInstructions ( ) { fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , andccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , stilmU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , orccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , addspS10SimulationCode ) ) ; }
private static void replaceAltSpecialInstructions ( ) { fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , andccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , stilmU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , orccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , addspS10SimulationCode ) ) ; }
private static void replaceAltSpecialInstructions ( ) { fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , andccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , stilmU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , orccrU8SimulationCode ) ) ; fillInstructionMap ( _NUM , _NUM , new FrInstruction ( InstructionFormat . D , _NUM , _NUM , STRING , STRING , STRING , Instruction . FlowType . NONE , _BOOL , _BOOL , addspS10SimulationCode ) ) ; }
private void createBorderColor ( ) { this . borderColor = new RGB ( Math . min ( this . color . red * _NUM , _NUM ) , Math . min ( this . color . green * _NUM , _NUM ) , Math . min ( this . color . blue * _NUM , _NUM ) ) ; }
public static String encodeUrl ( String url ) { Uri uri = Uri . parse ( url ) ; try { Map < String , List < String > > splitQuery = splitQuery ( uri ) ; StringBuilder encodedQuery = new StringBuilder ( ) ; for ( String key : splitQuery . keySet ( ) ) { for ( String value : splitQuery . get ( key ) ) { if ( encodedQuery . length ( ) > _NUM ) { encodedQuery . append ( STRING ) ; } encodedQuery . append ( key + STRING + URLEncoder . encode ( value , STRING ) ) ; } } String queryString = encodedQuery != null && encodedQuery . length ( ) > _NUM ? STRING + encodedQuery : STRING ; URI baseUri = new URI ( uri . getScheme ( ) , uri . getAuthority ( ) , uri . getPath ( ) , null , uri . getFragment ( ) ) ; return baseUri + queryString ; } catch ( UnsupportedEncodingException ignore ) { } catch ( URISyntaxException ignore ) { } return uri . toString ( ) ; }
public static void sendTempFile ( String filename , HttpServletResponse response ) throws IOException { File file = new File ( System . getProperty ( STRING ) , filename ) ; ServletUtilities . sendTempFile ( file , response ) ; }
private Synchronization localPopSynchronization ( ) { Synchronization ret = null ; if ( ! synchronizations_ . isEmpty ( ) ) ret = synchronizations_ . pop ( ) ; return ret ; }
private Synchronization localPopSynchronization ( ) { Synchronization ret = null ; if ( ! synchronizations_ . isEmpty ( ) ) ret = synchronizations_ . pop ( ) ; return ret ; }
final void invokeSetter ( String name , M setter , Object target , Object arg , Object cookie ) throws MBeanException , ReflectionException , InvalidAttributeValueException { try { invokeM2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( IllegalAccessException e ) { throw new ReflectionException ( e , e . toString ( ) ) ; } catch ( RuntimeException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; throw e ; } catch ( InvocationTargetException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; unwrapInvocationTargetException ( e ) ; } }
final void invokeSetter ( String name , M setter , Object target , Object arg , Object cookie ) throws MBeanException , ReflectionException , InvalidAttributeValueException { try { invokeM2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( IllegalAccessException e ) { throw new ReflectionException ( e , e . toString ( ) ) ; } catch ( RuntimeException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; throw e ; } catch ( InvocationTargetException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; unwrapInvocationTargetException ( e ) ; } }
final void invokeSetter ( String name , M setter , Object target , Object arg , Object cookie ) throws MBeanException , ReflectionException , InvalidAttributeValueException { try { invokeM2 ( setter , target , new Object [ ] { arg } , cookie ) ; } catch ( IllegalAccessException e ) { throw new ReflectionException ( e , e . toString ( ) ) ; } catch ( RuntimeException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; throw e ; } catch ( InvocationTargetException e ) { maybeInvalidParameter ( name , setter , arg , cookie ) ; unwrapInvocationTargetException ( e ) ; } }
public static boolean isFileValid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static boolean isFileValid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static boolean isFileValid ( @ Nullable File file ) { return file != null && file . exists ( ) ; }
public static int readInts ( final File f , final LongIndex a , final long offset , final long addend ) throws IOException { return readInts ( f , _NUM , ( int ) f . length ( ) / _NUM , a , offset , addend ) ; }
public static boolean sameDate ( Calendar cal , Date selectedDate ) { Calendar selectedCal = Calendar . getInstance ( ) ; selectedCal . setTime ( selectedDate ) ; return cal . get ( Calendar . MONTH ) == selectedCal . get ( Calendar . MONTH ) && cal . get ( Calendar . YEAR ) == selectedCal . get ( Calendar . YEAR ) && cal . get ( Calendar . DAY_OF_MONTH ) == selectedCal . get ( Calendar . DAY_OF_MONTH ) ; }
public static boolean sameDate ( Calendar cal , Date selectedDate ) { Calendar selectedCal = Calendar . getInstance ( ) ; selectedCal . setTime ( selectedDate ) ; return cal . get ( Calendar . MONTH ) == selectedCal . get ( Calendar . MONTH ) && cal . get ( Calendar . YEAR ) == selectedCal . get ( Calendar . YEAR ) && cal . get ( Calendar . DAY_OF_MONTH ) == selectedCal . get ( Calendar . DAY_OF_MONTH ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
public static Result sudo ( long timeout , String ... args ) { return sudo ( timeout , null , args ) ; }
protected Point2D calculateRangeMarkerTextAnchorPoint ( Graphics2D g2 , PlotOrientation orientation , Rectangle2D dataArea , Rectangle2D markerArea , RectangleInsets markerOffset , LengthAdjustmentType labelOffsetType , RectangleAnchor anchor ) { Rectangle2D anchorRect = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { anchorRect = markerOffset . createAdjustedRectangle ( markerArea , labelOffsetType , LengthAdjustmentType . CONTRACT ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { anchorRect = markerOffset . createAdjustedRectangle ( markerArea , LengthAdjustmentType . CONTRACT , labelOffsetType ) ; } return RectangleAnchor . coordinates ( anchorRect , anchor ) ; }
void saveAsync ( ColumnEntity entity , Duration ttl , Consumer < ColumnEntity > callBack ) throws ExecuteAsyncQueryException , UnsupportedOperationException ;
private static int findEndOfLabel ( String nTriplesLiteral ) { boolean previousWasBackslash = _BOOL ; for ( int i = _NUM ; i < nTriplesLiteral . length ( ) ; i ++ ) { char c = nTriplesLiteral . charAt ( i ) ; if ( c == STRING && ! previousWasBackslash ) { return i ; } else if ( c == STRING && ! previousWasBackslash ) { previousWasBackslash = _BOOL ; } else if ( previousWasBackslash ) { previousWasBackslash = _BOOL ; } } return - _NUM ; }
private static int findEndOfLabel ( String nTriplesLiteral ) { boolean previousWasBackslash = _BOOL ; for ( int i = _NUM ; i < nTriplesLiteral . length ( ) ; i ++ ) { char c = nTriplesLiteral . charAt ( i ) ; if ( c == STRING && ! previousWasBackslash ) { return i ; } else if ( c == STRING && ! previousWasBackslash ) { previousWasBackslash = _BOOL ; } else if ( previousWasBackslash ) { previousWasBackslash = _BOOL ; } } return - _NUM ; }
public int size ( ) { synchronized ( eventsList ) { return eventsList . size ( ) ; } }
public PrefixFileFilter ( String [ ] prefixes , IOCase caseSensitivity ) { if ( prefixes == null ) { throw new IllegalArgumentException ( STRING ) ; } this . prefixes = new String [ prefixes . length ] ; System . arraycopy ( prefixes , _NUM , this . prefixes , _NUM , prefixes . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
public PrefixFileFilter ( String [ ] prefixes , IOCase caseSensitivity ) { if ( prefixes == null ) { throw new IllegalArgumentException ( STRING ) ; } this . prefixes = new String [ prefixes . length ] ; System . arraycopy ( prefixes , _NUM , this . prefixes , _NUM , prefixes . length ) ; this . caseSensitivity = caseSensitivity == null ? IOCase . SENSITIVE : caseSensitivity ; }
protected void checkColortable ( RpfFrame frame , RpfFrameEntry frameEntry , RpfTocEntry entry , int tocNumber , int entryNumber ) { if ( _BOOL ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; Debug . output ( STRING + entry . Cib ) ; } colortable . setFrom ( frame . getColortable ( ) ) ; colortable . setCib ( entry . Cib ) ; colortable . setATOCIndexes ( tocNumber , entryNumber ) ; colortable . zone = entry . zone ; colortable . seriesCode = entry . info . seriesCode ; } if ( viewAttributes != null ) { colortable . setOpaqueness ( viewAttributes . opaqueness ) ; } }
public void addMissingColumns ( String trxName ) { int total = _NUM ; String sql = STRING + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; try { pstmt = DB . prepareStatement ( sql , trxName ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) total += addMissingColumns ( new MPrintFormat ( m_ctx , rs , trxName ) ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } log . info ( STRING + total ) ; }
public UrlParser ( String url ) throws MalformedURLException { if ( url != null && url . length ( ) > _NUM ) { int ppos = url . indexOf ( STRING ) ; if ( ppos >= _NUM ) { protocol = url . substring ( _NUM , ppos ) ; url = url . substring ( ppos + _NUM ) ; } String hostport ; ppos = url . indexOf ( STRING ) ; if ( ppos >= _NUM ) { hostport = url . substring ( _NUM , ppos ) ; path = url . substring ( ppos + _NUM ) ; } else { hostport = url ; } ppos = hostport . indexOf ( STRING ) ; if ( ppos >= _NUM ) { host = hostport . substring ( _NUM , ppos ) ; String portString = hostport . substring ( ppos + _NUM ) ; try { this . port = Integer . parseInt ( portString ) ; } catch ( NumberFormatException e ) { logger . trace ( STRING , e ) ; throw new MalformedURLException ( STRING + portString ) ; } } else { host = hostport ; } } else { throw new MalformedURLException ( STRING ) ; } }
private JSONArray requestAllFileSystems ( ) throws IOException , JSONException { JSONArray ret = new JSONArray ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . getRootEntry ( ) ) ; } return ret ; }
private JSONArray requestAllFileSystems ( ) throws IOException , JSONException { JSONArray ret = new JSONArray ( ) ; for ( Filesystem fs : filesystems ) { ret . put ( fs . getRootEntry ( ) ) ; } return ret ; }
public synchronized void addSession ( MXSession session ) { mLoginStorage . addCredentials ( session . getHomeserverConfig ( ) ) ; synchronized ( LOG_TAG ) { mMXSessions . add ( session ) ; } }
public static String convertToBox ( String s ) { String temp = s . replaceAll ( STRING , STRING ) ; if ( temp . endsWith ( STRING ) ) { temp = temp . substring ( _NUM , temp . length ( ) - _NUM ) + STRING ; } temp = temp . replaceAll ( STRING , STRING ) ; return WordUtils . capitalizeFully ( temp ) ; }
public List < PdfObject > subList ( int fromIndex , int toIndex ) { return list . subList ( fromIndex , toIndex ) ; }
public List < PdfObject > subList ( int fromIndex , int toIndex ) { return list . subList ( fromIndex , toIndex ) ; }
public boolean isSafeMode ( ) { return this . safeMode ; }
public boolean isSafeMode ( ) { return this . safeMode ; }
public void deleteItem ( int position ) { if ( ! isDataListEmpty ( ) && position >= _NUM && position < mDataList . size ( ) ) { mDataList . remove ( position ) ; notifyItemRemoved ( position ) ; } }
public void deleteItem ( int position ) { if ( ! isDataListEmpty ( ) && position >= _NUM && position < mDataList . size ( ) ) { mDataList . remove ( position ) ; notifyItemRemoved ( position ) ; } }
private AssertionError createComparisonFailure ( String className , String expected , String actual ) throws Exception { Class < ? > clazz = Class . forName ( className ) ; Constructor < ? > constructor = clazz . getConstructor ( String . class , String . class , String . class ) ; return ( AssertionError ) constructor . newInstance ( STRING , expected , actual ) ; }
public TemporalOMScalingIcon ( Object id , int renderType , boolean interpolate , ImageIcon ii , float baseScale ) { this ( id , renderType , interpolate ) ; setWidth ( ii . getIconWidth ( ) ) ; setHeight ( ii . getIconHeight ( ) ) ; setColorModel ( OMRasterObject . COLORMODEL_IMAGEICON ) ; setImage ( ii . getImage ( ) ) ; setBaseScale ( baseScale ) ; }
public void addTag ( final Tag tag , final boolean preSelect ) { if ( ! mDisplayedTags . contains ( tag ) ) { mDisplayedTags . add ( tag ) ; } if ( preSelect && ! mSelectedTags . contains ( tag . id ) ) { mSelectedTags . add ( tag . id ) ; } if ( ! mTagViewMap . containsKey ( tag ) ) { addTagToView ( tag ) ; } }
public Id < DgCrossingNode > convertNodeId2NotExpandedCrossingNodeId ( Id < Node > nodeId ) { String idString = nodeId . toString ( ) ; return idPool . createId ( idString , DgCrossingNode . class ) ; }
public Id < DgCrossingNode > convertNodeId2NotExpandedCrossingNodeId ( Id < Node > nodeId ) { String idString = nodeId . toString ( ) ; return idPool . createId ( idString , DgCrossingNode . class ) ; }
public Id < DgCrossingNode > convertNodeId2NotExpandedCrossingNodeId ( Id < Node > nodeId ) { String idString = nodeId . toString ( ) ; return idPool . createId ( idString , DgCrossingNode . class ) ; }
public Id < DgCrossingNode > convertNodeId2NotExpandedCrossingNodeId ( Id < Node > nodeId ) { String idString = nodeId . toString ( ) ; return idPool . createId ( idString , DgCrossingNode . class ) ; }
@ Override public void updateTextViews ( Recharge recharge ) { unitTypeTextView . setText ( recharge . getUnits ( ) ) ; unitValueTextView . setText ( String . valueOf ( recharge . getCurrentAmount ( ) ) ) ; costTextView . setText ( Currency . localize ( recharge . getCurrentCost ( ) , _BOOL ) ) ; rechargeName . setText ( recharge . getTitle ( ) ) ; confirmationTextView . setText ( STRING + recharge . getCurrentAmount ( ) + STRING + recharge . getUnits ( ) + STRING ) ; if ( recharge . getCurrentAmount ( ) == recharge . getInitialAmount ( ) ) { downArrow . setVisibility ( View . INVISIBLE ) ; } else { downArrow . setVisibility ( View . VISIBLE ) ; } }
@ Override public void updateTextViews ( Recharge recharge ) { unitTypeTextView . setText ( recharge . getUnits ( ) ) ; unitValueTextView . setText ( String . valueOf ( recharge . getCurrentAmount ( ) ) ) ; costTextView . setText ( Currency . localize ( recharge . getCurrentCost ( ) , _BOOL ) ) ; rechargeName . setText ( recharge . getTitle ( ) ) ; confirmationTextView . setText ( STRING + recharge . getCurrentAmount ( ) + STRING + recharge . getUnits ( ) + STRING ) ; if ( recharge . getCurrentAmount ( ) == recharge . getInitialAmount ( ) ) { downArrow . setVisibility ( View . INVISIBLE ) ; } else { downArrow . setVisibility ( View . VISIBLE ) ; } }
@ Override public void updateTextViews ( Recharge recharge ) { unitTypeTextView . setText ( recharge . getUnits ( ) ) ; unitValueTextView . setText ( String . valueOf ( recharge . getCurrentAmount ( ) ) ) ; costTextView . setText ( Currency . localize ( recharge . getCurrentCost ( ) , _BOOL ) ) ; rechargeName . setText ( recharge . getTitle ( ) ) ; confirmationTextView . setText ( STRING + recharge . getCurrentAmount ( ) + STRING + recharge . getUnits ( ) + STRING ) ; if ( recharge . getCurrentAmount ( ) == recharge . getInitialAmount ( ) ) { downArrow . setVisibility ( View . INVISIBLE ) ; } else { downArrow . setVisibility ( View . VISIBLE ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
@ Override public void onIncomingChatRequest ( IncomingChatRequestEvent event ) throws Exception { ReceiveChat chat = event . accept ( ) ; String line ; while ( ( line = chat . readLine ( ) ) != null ) if ( line . equalsIgnoreCase ( STRING ) ) { chat . close ( ) ; break ; } else { int lineLength = line . length ( ) ; chat . sendLine ( STRING + line + STRING + lineLength + STRING ) ; } }
public static boolean checkInRound ( float sx , float sy , float r , float x , float y , float offset ) { return Math . sqrt ( ( sx - x + offset ) * ( sx - x + offset ) + ( sy - y + offset ) * ( sy - y + offset ) ) < r ; }
public static boolean checkInRound ( float sx , float sy , float r , float x , float y , float offset ) { return Math . sqrt ( ( sx - x + offset ) * ( sx - x + offset ) + ( sy - y + offset ) * ( sy - y + offset ) ) < r ; }
protected void addResource ( List defaults , String bundleName ) { ResourceBundle bundle = ResourceBundle . getBundle ( bundleName ) ; for ( Enumeration keys = bundle . getKeys ( ) ; keys . hasMoreElements ( ) ; ) { String key = ( String ) keys . nextElement ( ) ; defaults . add ( key ) ; defaults . add ( bundle . getObject ( key ) ) ; } }
private static boolean intersectsOneOf ( final Rectangle2D r , final Collection < ? extends Shape > shapes ) { if ( shapes . isEmpty ( ) ) { return _BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return _BOOL ; } } return _BOOL ; }
private static boolean intersectsOneOf ( final Rectangle2D r , final Collection < ? extends Shape > shapes ) { if ( shapes . isEmpty ( ) ) { return _BOOL ; } for ( final Shape item : shapes ) { if ( item . intersects ( r ) ) { return _BOOL ; } } return _BOOL ; }
public static Script createMultiSigOutputScript ( int threshold , List < ECKey > pubkeys ) { checkArgument ( threshold > _NUM ) ; checkArgument ( threshold <= pubkeys . size ( ) ) ; checkArgument ( pubkeys . size ( ) <= _NUM ) ; ScriptBuilder builder = new ScriptBuilder ( ) ; builder . smallNum ( threshold ) ; for ( ECKey key : pubkeys ) { builder . data ( key . getPubKey ( ) ) ; } builder . smallNum ( pubkeys . size ( ) ) ; builder . op ( OP_CHECKMULTISIG ) ; return builder . build ( ) ; }
public static Script createMultiSigOutputScript ( int threshold , List < ECKey > pubkeys ) { checkArgument ( threshold > _NUM ) ; checkArgument ( threshold <= pubkeys . size ( ) ) ; checkArgument ( pubkeys . size ( ) <= _NUM ) ; ScriptBuilder builder = new ScriptBuilder ( ) ; builder . smallNum ( threshold ) ; for ( ECKey key : pubkeys ) { builder . data ( key . getPubKey ( ) ) ; } builder . smallNum ( pubkeys . size ( ) ) ; builder . op ( OP_CHECKMULTISIG ) ; return builder . build ( ) ; }
public static Script createMultiSigOutputScript ( int threshold , List < ECKey > pubkeys ) { checkArgument ( threshold > _NUM ) ; checkArgument ( threshold <= pubkeys . size ( ) ) ; checkArgument ( pubkeys . size ( ) <= _NUM ) ; ScriptBuilder builder = new ScriptBuilder ( ) ; builder . smallNum ( threshold ) ; for ( ECKey key : pubkeys ) { builder . data ( key . getPubKey ( ) ) ; } builder . smallNum ( pubkeys . size ( ) ) ; builder . op ( OP_CHECKMULTISIG ) ; return builder . build ( ) ; }
public double distance ( DoubleVector v ) { double deltaX = v . x - x , deltaY = v . y - y , deltaZ = v . z - z ; return Math . sqrt ( deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ ) ; }
@ Override public List < SourceRecord > poll ( ) throws InterruptedException { List < SourceRecord > records = new ArrayList < > ( ) ; MqttMessageProcessor message = mQueue . take ( ) ; log . debug ( STRING , mMqttClientId , mKafkaTopic ) ; Collections . addAll ( records , message . getRecords ( mKafkaTopic ) ) ; return records ; }
@ Override public boolean applyRules ( Map < URI , Map < URI , Integer > > initiatorsToVolumes ) { return applyVolumesToMasksUsingRules ( context . storage , context . exportGroup , context . masksToUpdateWithVolumes , initiatorsToVolumes , context . exportMaskToPolicy , context . masksToUpdateWithInitiators , context . partialMasks , context . token ) ; }
@ Override public boolean applyRules ( Map < URI , Map < URI , Integer > > initiatorsToVolumes ) { return applyVolumesToMasksUsingRules ( context . storage , context . exportGroup , context . masksToUpdateWithVolumes , initiatorsToVolumes , context . exportMaskToPolicy , context . masksToUpdateWithInitiators , context . partialMasks , context . token ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
public static void doWebArtifact ( HttpServletRequest request , HttpServletResponse response , String target ) throws IOException , SAMLException { doSSO ( request , response , target , SAMLConstants . SAML_AWARE_NAMING ) ; }
private void playScaleForMenu ( Menu menu ) { final int size = menu . size ( ) ; if ( size <= _NUM ) { return ; } mFeedbackController . playAuditory ( SCALES [ Math . min ( size - _NUM , _NUM ) ] ) ; }
@ NonNull static String toHexString ( @ Nullable final byte [ ] src ) { if ( src == null ) { return STRING ; } final StringBuilder buffer = new StringBuilder ( ) ; buffer . append ( STRING ) ; boolean needComma = _BOOL ; for ( final byte srcByte : src ) { if ( needComma ) { buffer . append ( STRING ) ; } buffer . append ( String . format ( STRING , srcByte & _NUM ) ) ; needComma = _BOOL ; } buffer . append ( STRING ) ; return buffer . toString ( ) ; }
public void clear ( String className ) throws RemoteException , TransactionException , UnusableEntryException { _remoteSpaceProxy . clear ( createTemplate ( className ) , null ) ; }
public void dispose ( ) { clearListeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public void dispose ( ) { clearListeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public void dispose ( ) { clearListeners ( ) ; if ( attributes != null ) { attributes . clear ( ) ; } removed ( null ) ; }
public UCIBestMove stop ( ) { if ( ! isConnected ( ) ) { throw new IllegalStateException ( STRING ) ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING ) ; } UCIBestMove result = null ; synchronized ( stopSynch ) { if ( ! isProcessingGo ( ) ) { result = lastBestMove ; lastBestMove = null ; } else { long totalSleepTime = _NUM ; send ( STRING ) ; while ( goRunnable != null && totalSleepTime < _NUM ) { try { Thread . sleep ( _NUM ) ; totalSleepTime += _NUM ; } catch ( InterruptedException ie ) { } } result = lastBestMove ; lastBestMove = null ; } } return result ; }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void upload ( File file , long restartAt , FTPDataTransferListener listener ) throws IllegalStateException , FileNotFoundException , IOException , FTPIllegalReplyException , FTPException , FTPDataTransferException , FTPAbortedException { if ( ! file . exists ( ) ) { throw new FileNotFoundException ( file . getAbsolutePath ( ) ) ; } InputStream inputStream = null ; try { inputStream = new FileInputStream ( file ) ; } catch ( IOException e ) { throw new FTPDataTransferException ( e ) ; } try { upload ( file . getName ( ) , inputStream , restartAt , restartAt , listener ) ; } catch ( IllegalStateException e ) { throw e ; } catch ( IOException e ) { throw e ; } catch ( FTPIllegalReplyException e ) { throw e ; } catch ( FTPException e ) { throw e ; } catch ( FTPDataTransferException e ) { throw e ; } catch ( FTPAbortedException e ) { throw e ; } finally { if ( inputStream != null ) { try { inputStream . close ( ) ; } catch ( Throwable t ) { ; } } } }
public void addAttribute ( String uri , String localName , String rawName , String type , String value , boolean XSLAttribute ) throws SAXException { if ( m_elemContext . m_startTagOpen ) { ensurePrefixIsDeclared ( uri , rawName ) ; addAttributeAlways ( uri , localName , rawName , type , value , _BOOL ) ; } }
public static boolean isFolderExist ( String directoryPath ) { if ( StringUtils . isBlank ( directoryPath ) ) { return _BOOL ; } File dire = new File ( directoryPath ) ; return ( dire . exists ( ) && dire . isDirectory ( ) ) ; }
public static boolean isFolderExist ( String directoryPath ) { if ( StringUtils . isBlank ( directoryPath ) ) { return _BOOL ; } File dire = new File ( directoryPath ) ; return ( dire . exists ( ) && dire . isDirectory ( ) ) ; }
public static boolean isFileTypeSupported ( int fileType ) { List providers = getMidiFileWriters ( ) ; for ( int i = _NUM ; i < providers . size ( ) ; i ++ ) { MidiFileWriter writer = ( MidiFileWriter ) providers . get ( i ) ; if ( writer . isFileTypeSupported ( fileType ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean isFileTypeSupported ( int fileType ) { List providers = getMidiFileWriters ( ) ; for ( int i = _NUM ; i < providers . size ( ) ; i ++ ) { MidiFileWriter writer = ( MidiFileWriter ) providers . get ( i ) ; if ( writer . isFileTypeSupported ( fileType ) ) { return _BOOL ; } } return _BOOL ; }
public static < T > Set < String > convertListToString ( Collection < T > values , int maxCount ) { Set < String > ret = new HashSet < > ( ) ; if ( values == null || values . isEmpty ( ) ) return ret ; StringBuilder sb = new StringBuilder ( ) ; int count = _NUM ; for ( T t : values ) { sb . append ( t ) ; if ( count == maxCount ) { ret . add ( sb . substring ( _NUM , sb . length ( ) - _NUM ) ) ; sb = new StringBuilder ( ) ; count = _NUM ; } else { sb . append ( STRING ) ; count ++ ; } } if ( sb . length ( ) > _NUM ) ret . add ( sb . substring ( _NUM , sb . length ( ) - _NUM ) ) ; return ret ; }
public static boolean isDrawableImage ( String imagePath ) { return imagePath . startsWith ( STRING ) ; }
public static boolean isDrawableImage ( String imagePath ) { return imagePath . startsWith ( STRING ) ; }
private static void accumulate ( Vector ranges , int lb , int ub ) { if ( lb <= ub ) { ranges . add ( new int [ ] { lb , ub } ) ; for ( int j = ranges . size ( ) - _NUM ; j >= _NUM ; -- j ) { int [ ] rangea = ( int [ ] ) ranges . elementAt ( j ) ; int lba = rangea [ _NUM ] ; int uba = rangea [ _NUM ] ; int [ ] rangeb = ( int [ ] ) ranges . elementAt ( j + _NUM ) ; int lbb = rangeb [ _NUM ] ; int ubb = rangeb [ _NUM ] ; if ( Math . max ( lba , lbb ) - Math . min ( uba , ubb ) <= _NUM ) { ranges . setElementAt ( new int [ ] { Math . min ( lba , lbb ) , Math . max ( uba , ubb ) } , j ) ; ranges . remove ( j + _NUM ) ; } else if ( lba > lbb ) { ranges . setElementAt ( rangeb , j ) ; ranges . setElementAt ( rangea , j + _NUM ) ; } else { break ; } } } }
public void alter ( Instance instance , Transform matrix , AlphaTransform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - _NUM , frameNumber , _BOOL , _BOOL , null ) ; placements . add ( placement ) ; }
public void alter ( Instance instance , Transform matrix , AlphaTransform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - _NUM , frameNumber , _BOOL , _BOOL , null ) ; placements . add ( placement ) ; }
public void alter ( Instance instance , Transform matrix , AlphaTransform cxform , int ratio ) { Placement placement = new Placement ( instance , matrix , cxform , null , ratio , - _NUM , frameNumber , _BOOL , _BOOL , null ) ; placements . add ( placement ) ; }
public static String generateNativeGuid ( StorageSystem device , String uniqueId , String type ) { String typeStr = STRING ; if ( OBJECT_TYPE_SET . contains ( type ) ) { typeStr = type ; } return String . format ( STRING , _deviceTypeMap . get ( device . getSystemType ( ) ) , device . getSerialNumber ( ) , typeStr , uniqueId ) ; }
public QueryBuilder < C , F > returnTheseAttributes ( Collection < CoreTokenField > returnFields ) { Reject . ifTrue ( returnFields == null || returnFields . isEmpty ( ) ) ; Set < String > fields = new HashSet < String > ( ) ; for ( CoreTokenField field : returnFields ) { fields . add ( field . toString ( ) ) ; } return setReturnAttributes ( fields ) ; }
public QueryBuilder < C , F > returnTheseAttributes ( Collection < CoreTokenField > returnFields ) { Reject . ifTrue ( returnFields == null || returnFields . isEmpty ( ) ) ; Set < String > fields = new HashSet < String > ( ) ; for ( CoreTokenField field : returnFields ) { fields . add ( field . toString ( ) ) ; } return setReturnAttributes ( fields ) ; }
public String [ ] headers ( final String name ) { final Map < String , List < String > > headers = headers ( ) ; if ( headers == null || headers . isEmpty ( ) ) return EMPTY_STRINGS ; final List < String > values = headers . get ( name ) ; if ( values != null && ! values . isEmpty ( ) ) return values . toArray ( new String [ values . size ( ) ] ) ; else return EMPTY_STRINGS ; }
private ResultPointsAndTransitions transitionsBetween ( ResultPoint from , ResultPoint to ) { int fromX = ( int ) from . getX ( ) ; int fromY = ( int ) from . getY ( ) ; int toX = ( int ) to . getX ( ) ; int toY = ( int ) to . getY ( ) ; boolean steep = Math . abs ( toY - fromY ) > Math . abs ( toX - fromX ) ; if ( steep ) { int temp = fromX ; fromX = fromY ; fromY = temp ; temp = toX ; toX = toY ; toY = temp ; } int dx = Math . abs ( toX - fromX ) ; int dy = Math . abs ( toY - fromY ) ; int error = - dx / _NUM ; int ystep = fromY < toY ? _NUM : - _NUM ; int xstep = fromX < toX ? _NUM : - _NUM ; int transitions = _NUM ; boolean inBlack = image . get ( steep ? fromY : fromX , steep ? fromX : fromY ) ; for ( int x = fromX , y = fromY ; x != toX ; x += xstep ) { boolean isBlack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isBlack != inBlack ) { transitions ++ ; inBlack = isBlack ; } error += dy ; if ( error > _NUM ) { if ( y == toY ) { break ; } y += ystep ; error -= dx ; } } return new ResultPointsAndTransitions ( from , to , transitions ) ; }
private ResultPointsAndTransitions transitionsBetween ( ResultPoint from , ResultPoint to ) { int fromX = ( int ) from . getX ( ) ; int fromY = ( int ) from . getY ( ) ; int toX = ( int ) to . getX ( ) ; int toY = ( int ) to . getY ( ) ; boolean steep = Math . abs ( toY - fromY ) > Math . abs ( toX - fromX ) ; if ( steep ) { int temp = fromX ; fromX = fromY ; fromY = temp ; temp = toX ; toX = toY ; toY = temp ; } int dx = Math . abs ( toX - fromX ) ; int dy = Math . abs ( toY - fromY ) ; int error = - dx / _NUM ; int ystep = fromY < toY ? _NUM : - _NUM ; int xstep = fromX < toX ? _NUM : - _NUM ; int transitions = _NUM ; boolean inBlack = image . get ( steep ? fromY : fromX , steep ? fromX : fromY ) ; for ( int x = fromX , y = fromY ; x != toX ; x += xstep ) { boolean isBlack = image . get ( steep ? y : x , steep ? x : y ) ; if ( isBlack != inBlack ) { transitions ++ ; inBlack = isBlack ; } error += dy ; if ( error > _NUM ) { if ( y == toY ) { break ; } y += ystep ; error -= dx ; } } return new ResultPointsAndTransitions ( from , to , transitions ) ; }
public void writeDouble ( double value ) throws IOException { checkWritePrimitiveTypes ( ) ; primitiveTypes . writeDouble ( value ) ; }
public static List < String > bytesToStringList ( byte [ ] bytes ) { List < String > lines = new ArrayList < String > ( ) ; if ( bytes == null ) { return lines ; } BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( bytes ) , STRING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } try { try { for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return lines ; }
public static List < String > bytesToStringList ( byte [ ] bytes ) { List < String > lines = new ArrayList < String > ( ) ; if ( bytes == null ) { return lines ; } BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( bytes ) , STRING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } try { try { for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return lines ; }
public static List < String > bytesToStringList ( byte [ ] bytes ) { List < String > lines = new ArrayList < String > ( ) ; if ( bytes == null ) { return lines ; } BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( bytes ) , STRING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } try { try { for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return lines ; }
public static List < String > bytesToStringList ( byte [ ] bytes ) { List < String > lines = new ArrayList < String > ( ) ; if ( bytes == null ) { return lines ; } BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( bytes ) , STRING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } try { try { for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return lines ; }
public static List < String > bytesToStringList ( byte [ ] bytes ) { List < String > lines = new ArrayList < String > ( ) ; if ( bytes == null ) { return lines ; } BufferedReader r = null ; try { r = new BufferedReader ( new InputStreamReader ( new ByteArrayInputStream ( bytes ) , STRING ) ) ; } catch ( UnsupportedEncodingException e ) { throw new RuntimeException ( e ) ; } try { try { for ( String line = r . readLine ( ) ; line != null ; line = r . readLine ( ) ) { lines . add ( line ) ; } } finally { r . close ( ) ; } } catch ( IOException e ) { throw new RuntimeException ( e ) ; } return lines ; }
public void add ( IStatus status ) { Assert . isLegal ( status != null ) ; IStatus [ ] result = new IStatus [ children . length + _NUM ] ; System . arraycopy ( children , _NUM , result , _NUM , children . length ) ; result [ result . length - _NUM ] = status ; children = result ; int newSev = status . getSeverity ( ) ; if ( newSev > getSeverity ( ) ) { setSeverity ( newSev ) ; } }
public void addSrcClass ( SootClass clz ) { srcClasses . add ( clz . getName ( ) ) ; }
private void onHPChange ( final int amount ) { if ( User . squaredDistanceTo ( x , y ) < HEARING_DISTANCE_SQ ) { if ( amount > _NUM ) { addTextIndicator ( STRING + amount , NotificationType . POSITIVE ) ; } else { addTextIndicator ( String . valueOf ( amount ) , NotificationType . NEGATIVE ) ; } } }
public static String reverseUrl ( URL url ) { String host = url . getHost ( ) ; String file = url . getFile ( ) ; String protocol = url . getProtocol ( ) ; int port = url . getPort ( ) ; StringBuilder buf = new StringBuilder ( ) ; reverseAppendSplits ( host , buf ) ; buf . append ( STRING ) ; buf . append ( protocol ) ; if ( port != - _NUM ) { buf . append ( STRING ) ; buf . append ( port ) ; } if ( file . length ( ) > _NUM && STRING != file . charAt ( _NUM ) ) { buf . append ( STRING ) ; } buf . append ( file ) ; return buf . toString ( ) ; }
public static boolean isSamsungGalaxyMini ( ) { return sBuildModel . equalsIgnoreCase ( STRING ) ; }
public static boolean isSamsungGalaxyMini ( ) { return sBuildModel . equalsIgnoreCase ( STRING ) ; }
private void appendToBuf ( char [ ] ch , int start , int end ) { if ( start == end ) { return ; } int neededBufLen = pos + ( end - start ) ; if ( neededBufLen > buf . length ) { char [ ] newBuf = new char [ neededBufLen ] ; System . arraycopy ( buf , _NUM , newBuf , _NUM , pos ) ; if ( bufHolder == null ) { bufHolder = buf ; } buf = newBuf ; } System . arraycopy ( ch , start , buf , pos , end - start ) ; pos += ( end - start ) ; }
public static String htmlEscape ( String input ) { ParamChecks . nullNotPermitted ( input , STRING ) ; StringBuilder result = new StringBuilder ( ) ; int length = input . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = input . charAt ( i ) ; if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else { result . append ( c ) ; } } return result . toString ( ) ; }
public static String htmlEscape ( String input ) { ParamChecks . nullNotPermitted ( input , STRING ) ; StringBuilder result = new StringBuilder ( ) ; int length = input . length ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { char c = input . charAt ( i ) ; if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else if ( c == STRING ) { result . append ( STRING ) ; } else { result . append ( c ) ; } } return result . toString ( ) ; }
public RawPublicKeyIdentity ( PublicKey key ) { if ( key == null ) { throw new NullPointerException ( STRING ) ; } else { this . publicKey = key ; createNamedInformationUri ( publicKey . getEncoded ( ) ) ; } }
public static String vocabString ( ) { StringWriter sw = new StringWriter ( Vocabulary . systemSize ( ) * _NUM ) ; try { systemIndex . saveToWriter ( sw ) ; return sw . toString ( ) ; } catch ( IOException e ) { logger . error ( STRING ) ; } return STRING ; }
public static String randomRegexpishString ( Random r ) { return randomRegexpishString ( r , _NUM ) ; }
public static String randomRegexpishString ( Random r ) { return randomRegexpishString ( r , _NUM ) ; }
public static String randomRegexpishString ( Random r ) { return randomRegexpishString ( r , _NUM ) ; }
public static String randomRegexpishString ( Random r ) { return randomRegexpishString ( r , _NUM ) ; }
public static void copy ( File src , File dst ) throws IOException { if ( src . isDirectory ( ) ) { ensureDirectoryExists ( dst ) ; String [ ] filesList = src . list ( ) ; for ( String file : filesList ) { File srcFile = new File ( src , file ) ; File destFile = new File ( dst , file ) ; copy ( srcFile , destFile ) ; } } else { copyFile ( src , dst ) ; } }
public ResourcesPoet addIntegerArray ( String name , @ NotNull List < Integer > values ) { ArrayList < String > integers = new ArrayList < > ( ) ; for ( Integer value : values ) { integers . add ( String . valueOf ( value ) ) ; } addIntegerArrayStrings ( name , integers ) ; return this ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < _NUM ) { pos = - pos - _NUM ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < _NUM ) { pos = - pos - _NUM ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public synchronized void returnBuf ( byte [ ] buf ) { if ( buf == null || buf . length > mSizeLimit ) { return ; } mBuffersByLastUse . add ( buf ) ; int pos = Collections . binarySearch ( mBuffersBySize , buf , BUF_COMPARATOR ) ; if ( pos < _NUM ) { pos = - pos - _NUM ; } mBuffersBySize . add ( pos , buf ) ; mCurrentSize += buf . length ; trim ( ) ; }
public void prepend ( CharSequence s ) { text . insert ( _NUM , s ) ; }
public static String toHex ( byte [ ] data ) { try { return new String ( Hex . encode ( data ) , STRING ) ; } catch ( UnsupportedEncodingException e ) { } return null ; }
public FeatureVector readFeatureVector ( int currentUnitIndex , DataInput input ) throws IOException { byte [ ] bytes = new byte [ numByteFeatures ] ; input . readFully ( bytes ) ; short [ ] shorts = new short [ numShortFeatures ] ; for ( int i = _NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = input . readShort ( ) ; } float [ ] floats = new float [ numContinuousFeatures ] ; for ( int i = _NUM ; i < floats . length ; i ++ ) { floats [ i ] = input . readFloat ( ) ; } return new FeatureVector ( bytes , shorts , floats , currentUnitIndex ) ; }
public FeatureVector readFeatureVector ( int currentUnitIndex , DataInput input ) throws IOException { byte [ ] bytes = new byte [ numByteFeatures ] ; input . readFully ( bytes ) ; short [ ] shorts = new short [ numShortFeatures ] ; for ( int i = _NUM ; i < shorts . length ; i ++ ) { shorts [ i ] = input . readShort ( ) ; } float [ ] floats = new float [ numContinuousFeatures ] ; for ( int i = _NUM ; i < floats . length ; i ++ ) { floats [ i ] = input . readFloat ( ) ; } return new FeatureVector ( bytes , shorts , floats , currentUnitIndex ) ; }
public static boolean symbolNeedsQuoting ( CharSequence symbol , boolean quoteOperators ) { int length = symbol . length ( ) ; if ( length == _NUM ) { throw new EmptySymbolException ( ) ; } if ( ! isIdentifierKeyword ( symbol ) ) { char c = symbol . charAt ( _NUM ) ; if ( ! quoteOperators && isOperatorPart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ! isOperatorPart ( c ) ) { return _BOOL ; } } return _BOOL ; } else if ( isIdentifierStart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ( c == STRING || c < _NUM || c > _NUM ) || ! isIdentifierPart ( c ) ) { return _BOOL ; } } return _BOOL ; } } return _BOOL ; }
public static boolean symbolNeedsQuoting ( CharSequence symbol , boolean quoteOperators ) { int length = symbol . length ( ) ; if ( length == _NUM ) { throw new EmptySymbolException ( ) ; } if ( ! isIdentifierKeyword ( symbol ) ) { char c = symbol . charAt ( _NUM ) ; if ( ! quoteOperators && isOperatorPart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ! isOperatorPart ( c ) ) { return _BOOL ; } } return _BOOL ; } else if ( isIdentifierStart ( c ) ) { for ( int ii = _NUM ; ii < length ; ii ++ ) { c = symbol . charAt ( ii ) ; if ( ( c == STRING || c < _NUM || c > _NUM ) || ! isIdentifierPart ( c ) ) { return _BOOL ; } } return _BOOL ; } } return _BOOL ; }
public void sendByePacket ( ) { Vector < RtcpSdesPacket > repvec = makereports ( ) ; RtcpPacket [ ] packets = new RtcpPacket [ repvec . size ( ) + _NUM ] ; repvec . copyInto ( packets ) ; int ssrc [ ] = { rtcpSession . SSRC } ; RtcpByePacket rtcpbyepacket = new RtcpByePacket ( ssrc , null ) ; packets [ packets . length - _NUM ] = rtcpbyepacket ; RtcpCompoundPacket cp = new RtcpCompoundPacket ( packets ) ; rtcpSession . getMySource ( ) . activeSender = _BOOL ; transmit ( cp ) ; }
public void modifyLeafBlock ( BlockId blk ) { lockTbl . xLock ( blk , txNum ) ; writenIndexBlks . add ( blk ) ; }
public boolean isSameAs ( ProductVersion other ) { return version . compareTo ( other . version ) == _NUM && revision . equals ( other . revision ) ; }
public static boolean isEmpty ( Automaton a ) { if ( a . getNumStates ( ) == _NUM ) { return _BOOL ; } if ( a . isAccept ( _NUM ) == _BOOL && a . getNumTransitions ( _NUM ) == _NUM ) { return _BOOL ; } if ( a . isAccept ( _NUM ) == _BOOL ) { return _BOOL ; } LinkedList < Integer > workList = new LinkedList < > ( ) ; BitSet seen = new BitSet ( a . getNumStates ( ) ) ; workList . add ( _NUM ) ; seen . set ( _NUM ) ; Transition t = new Transition ( ) ; while ( workList . isEmpty ( ) == _BOOL ) { int state = workList . removeFirst ( ) ; if ( a . isAccept ( state ) ) { return _BOOL ; } int count = a . initTransition ( state , t ) ; for ( int i = _NUM ; i < count ; i ++ ) { a . getNextTransition ( t ) ; if ( seen . get ( t . dest ) == _BOOL ) { workList . add ( t . dest ) ; seen . set ( t . dest ) ; } } } return _BOOL ; }
public static boolean isEmpty ( Automaton a ) { if ( a . getNumStates ( ) == _NUM ) { return _BOOL ; } if ( a . isAccept ( _NUM ) == _BOOL && a . getNumTransitions ( _NUM ) == _NUM ) { return _BOOL ; } if ( a . isAccept ( _NUM ) == _BOOL ) { return _BOOL ; } LinkedList < Integer > workList = new LinkedList < > ( ) ; BitSet seen = new BitSet ( a . getNumStates ( ) ) ; workList . add ( _NUM ) ; seen . set ( _NUM ) ; Transition t = new Transition ( ) ; while ( workList . isEmpty ( ) == _BOOL ) { int state = workList . removeFirst ( ) ; if ( a . isAccept ( state ) ) { return _BOOL ; } int count = a . initTransition ( state , t ) ; for ( int i = _NUM ; i < count ; i ++ ) { a . getNextTransition ( t ) ; if ( seen . get ( t . dest ) == _BOOL ) { workList . add ( t . dest ) ; seen . set ( t . dest ) ; } } } return _BOOL ; }
public static String ifNullOrEmpty ( final String original , final String defaultString ) { Reject . ifNull ( defaultString , STRING ) ; return ( original == null || original . isEmpty ( ) ) ? defaultString : original ; }
private Workflow . Method createAttachMirrorMethod ( URI vplexURI , URI vplexVolumeURI , URI mirrorVolumeURI , URI cgURI , String detachStepId ) { return new Workflow . Method ( ATTACH_MIRROR_METHOD_NAME , vplexURI , vplexVolumeURI , mirrorVolumeURI , cgURI , detachStepId ) ; }
private Workflow . Method createAttachMirrorMethod ( URI vplexURI , URI vplexVolumeURI , URI mirrorVolumeURI , URI cgURI , String detachStepId ) { return new Workflow . Method ( ATTACH_MIRROR_METHOD_NAME , vplexURI , vplexVolumeURI , mirrorVolumeURI , cgURI , detachStepId ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp ) { int x1 = _NUM ; int x2 = a . length ; int i = x2 / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp ) { int x1 = _NUM ; int x2 = a . length ; int i = x2 / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public List < StorageFile > createStorageFilesFromEntities ( Collection < StorageFileEntity > storageFileEntities ) { List < StorageFile > storageFiles = new ArrayList < > ( ) ; for ( StorageFileEntity storageFileEntity : storageFileEntities ) { storageFiles . add ( createStorageFileFromEntity ( storageFileEntity ) ) ; } return storageFiles ; }
private void convergenceStep ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final KernelFunction k ) { double denom = _NUM ; Vec xCur = xit [ i ] ; List < ? extends VecPaired < VecPaired < Vec , Integer > , Double > > contrib = mkde . getNearbyRaw ( xCur ) ; if ( contrib . size ( ) == _NUM ) { converged [ i ] = _BOOL ; designations [ i ] = - _NUM ; } else { scratch . zeroOut ( ) ; for ( VecPaired < VecPaired < Vec , Integer > , Double > v : contrib ) { double g = - k . kPrime ( v . getPair ( ) ) ; denom += g ; scratch . mutableAdd ( g , v ) ; } scratch . mutableDivide ( denom ) ; if ( Math . abs ( scratch . pNormDist ( _NUM , xCur ) ) < _NUM ) converged [ i ] = _BOOL ; scratch . copyTo ( xCur ) ; } }
private void convergenceStep ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final KernelFunction k ) { double denom = _NUM ; Vec xCur = xit [ i ] ; List < ? extends VecPaired < VecPaired < Vec , Integer > , Double > > contrib = mkde . getNearbyRaw ( xCur ) ; if ( contrib . size ( ) == _NUM ) { converged [ i ] = _BOOL ; designations [ i ] = - _NUM ; } else { scratch . zeroOut ( ) ; for ( VecPaired < VecPaired < Vec , Integer > , Double > v : contrib ) { double g = - k . kPrime ( v . getPair ( ) ) ; denom += g ; scratch . mutableAdd ( g , v ) ; } scratch . mutableDivide ( denom ) ; if ( Math . abs ( scratch . pNormDist ( _NUM , xCur ) ) < _NUM ) converged [ i ] = _BOOL ; scratch . copyTo ( xCur ) ; } }
private void convergenceStep ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final KernelFunction k ) { double denom = _NUM ; Vec xCur = xit [ i ] ; List < ? extends VecPaired < VecPaired < Vec , Integer > , Double > > contrib = mkde . getNearbyRaw ( xCur ) ; if ( contrib . size ( ) == _NUM ) { converged [ i ] = _BOOL ; designations [ i ] = - _NUM ; } else { scratch . zeroOut ( ) ; for ( VecPaired < VecPaired < Vec , Integer > , Double > v : contrib ) { double g = - k . kPrime ( v . getPair ( ) ) ; denom += g ; scratch . mutableAdd ( g , v ) ; } scratch . mutableDivide ( denom ) ; if ( Math . abs ( scratch . pNormDist ( _NUM , xCur ) ) < _NUM ) converged [ i ] = _BOOL ; scratch . copyTo ( xCur ) ; } }
private void convergenceStep ( final Vec [ ] xit , int i , final boolean [ ] converged , final int [ ] designations , final Vec scratch , final KernelFunction k ) { double denom = _NUM ; Vec xCur = xit [ i ] ; List < ? extends VecPaired < VecPaired < Vec , Integer > , Double > > contrib = mkde . getNearbyRaw ( xCur ) ; if ( contrib . size ( ) == _NUM ) { converged [ i ] = _BOOL ; designations [ i ] = - _NUM ; } else { scratch . zeroOut ( ) ; for ( VecPaired < VecPaired < Vec , Integer > , Double > v : contrib ) { double g = - k . kPrime ( v . getPair ( ) ) ; denom += g ; scratch . mutableAdd ( g , v ) ; } scratch . mutableDivide ( denom ) ; if ( Math . abs ( scratch . pNormDist ( _NUM , xCur ) ) < _NUM ) converged [ i ] = _BOOL ; scratch . copyTo ( xCur ) ; } }
@ Override public void write ( byte [ ] buffer , int offset , int length ) { try { OutputStream os = _os ; if ( os != null ) { os . write ( buffer , offset , length ) ; } } catch ( Exception e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } }
public void addCollector ( Collector collector ) { collectors . add ( collector ) ; }
public void addCollector ( Collector collector ) { collectors . add ( collector ) ; }
public void insert ( final Object eKey , final Object element , final int position ) { _elementOrder . add ( position , eKey ) ; _elements . put ( eKey , element ) ; }
public void insert ( final Object eKey , final Object element , final int position ) { _elementOrder . add ( position , eKey ) ; _elements . put ( eKey , element ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . requireNonNull ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . requireNonNull ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . requireNonNull ( pattern , STRING ) ; return contains ( pattern ) ; }
public static Predicate < String > grep ( final String pattern ) { Objects . requireNonNull ( pattern , STRING ) ; return contains ( pattern ) ; }
public DateTimeFormatterBuilder append ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STRING ) ; appendInternal ( formatter . toPrinterParser ( _BOOL ) ) ; return this ; }
public DateTimeFormatterBuilder append ( DateTimeFormatter formatter ) { Objects . requireNonNull ( formatter , STRING ) ; appendInternal ( formatter . toPrinterParser ( _BOOL ) ) ; return this ; }
public final < U > ParallelFlux < U > map ( Function < ? super T , ? extends U > mapper ) { Objects . requireNonNull ( mapper , STRING ) ; return onAssembly ( new ParallelUnorderedMap < > ( this , mapper ) ) ; }
public boolean isInNet ( String host , String pattern , String mask ) { host = dnsResolve ( host ) ; if ( host == null || host . length ( ) == _NUM ) { return _BOOL ; } long lhost = parseIpAddressToLong ( host ) ; long lpattern = parseIpAddressToLong ( pattern ) ; long lmask = parseIpAddressToLong ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public boolean isInNet ( String host , String pattern , String mask ) { host = dnsResolve ( host ) ; if ( host == null || host . length ( ) == _NUM ) { return _BOOL ; } long lhost = parseIpAddressToLong ( host ) ; long lpattern = parseIpAddressToLong ( pattern ) ; long lmask = parseIpAddressToLong ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public boolean isInNet ( String host , String pattern , String mask ) { host = dnsResolve ( host ) ; if ( host == null || host . length ( ) == _NUM ) { return _BOOL ; } long lhost = parseIpAddressToLong ( host ) ; long lpattern = parseIpAddressToLong ( pattern ) ; long lmask = parseIpAddressToLong ( mask ) ; return ( lhost & lmask ) == lpattern ; }
public static void UF1 ( double [ ] x , double [ ] f , int nx ) { int count1 = _NUM ; int count2 = _NUM ; double sum1 = _NUM ; double sum2 = _NUM ; double yj ; for ( int j = _NUM ; j <= nx ; j ++ ) { yj = x [ j - _NUM ] - Math . sin ( _NUM * PI * x [ _NUM ] + j * PI / nx ) ; yj = yj * yj ; if ( j % _NUM == _NUM ) { sum2 += yj ; count2 ++ ; } else { sum1 += yj ; count1 ++ ; } } f [ _NUM ] = x [ _NUM ] + _NUM * sum1 / ( double ) count1 ; f [ _NUM ] = _NUM - Math . sqrt ( x [ _NUM ] ) + _NUM * sum2 / ( double ) count2 ; }
private void checkPoints ( Collection < Cache . Entry < Integer , EnemyCamp > > res , String ... points ) { Set < String > set = new HashSet < > ( Arrays . asList ( points ) ) ; assertEquals ( set . size ( ) , res . size ( ) ) ; for ( Cache . Entry < Integer , EnemyCamp > e : res ) assertTrue ( set . remove ( e . getValue ( ) . name ) ) ; }
private void checkPoints ( Collection < Cache . Entry < Integer , EnemyCamp > > res , String ... points ) { Set < String > set = new HashSet < > ( Arrays . asList ( points ) ) ; assertEquals ( set . size ( ) , res . size ( ) ) ; for ( Cache . Entry < Integer , EnemyCamp > e : res ) assertTrue ( set . remove ( e . getValue ( ) . name ) ) ; }
public void remove ( final DLItem item ) { checkWidget ( ) ; if ( item == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( ! items . contains ( item ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } items . remove ( item ) ; redrawTables ( ) ; }
@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . toString ( ) ; }
@ Override public String toString ( ) { StringBuilder result = new StringBuilder ( limit - position ) ; for ( int i = position ; i < limit ; i ++ ) { result . append ( get ( i ) ) ; } return result . toString ( ) ; }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - _NUM ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STRING ) ; synchronized ( this ) { writeLogln ( STRING + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - _NUM ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( _NUM ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STRING ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = _NUM ; } catch ( MqttException mqte ) { rc = - _NUM ; } if ( rc == - _NUM ) { writeLogln ( STRING ) ; } else { writeLogln ( STRING ) ; } } } } setTitleText ( STRING ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( _BOOL ) ; } else { led . setRed ( ) ; setConnected ( _BOOL ) ; } }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - _NUM ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STRING ) ; synchronized ( this ) { writeLogln ( STRING + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - _NUM ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( _NUM ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STRING ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = _NUM ; } catch ( MqttException mqte ) { rc = - _NUM ; } if ( rc == - _NUM ) { writeLogln ( STRING ) ; } else { writeLogln ( STRING ) ; } } } } setTitleText ( STRING ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( _BOOL ) ; } else { led . setRed ( ) ; setConnected ( _BOOL ) ; } }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - _NUM ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STRING ) ; synchronized ( this ) { writeLogln ( STRING + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - _NUM ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( _NUM ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STRING ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = _NUM ; } catch ( MqttException mqte ) { rc = - _NUM ; } if ( rc == - _NUM ) { writeLogln ( STRING ) ; } else { writeLogln ( STRING ) ; } } } } setTitleText ( STRING ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( _BOOL ) ; } else { led . setRed ( ) ; setConnected ( _BOOL ) ; } }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - _NUM ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STRING ) ; synchronized ( this ) { writeLogln ( STRING + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - _NUM ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( _NUM ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STRING ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = _NUM ; } catch ( MqttException mqte ) { rc = - _NUM ; } if ( rc == - _NUM ) { writeLogln ( STRING ) ; } else { writeLogln ( STRING ) ; } } } } setTitleText ( STRING ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( _BOOL ) ; } else { led . setRed ( ) ; setConnected ( _BOOL ) ; } }
public void connectionLost ( java . lang . Throwable cause ) { int rc = - _NUM ; led . setAmber ( ) ; led . setFlash ( ) ; setTitleText ( STRING ) ; synchronized ( this ) { writeLogln ( STRING + mqtt . getServerURI ( ) ) ; } try { while ( ( rc == - _NUM ) && connected ) { try { synchronized ( connLostWait ) { connLostWait . wait ( _NUM ) ; } } catch ( InterruptedException iex ) { } synchronized ( this ) { if ( connected ) { writeLog ( STRING ) ; try { connect ( mqtt . getServerURI ( ) , optionsComp . isPersistenceSelected ( ) ) ; rc = _NUM ; } catch ( MqttException mqte ) { rc = - _NUM ; } if ( rc == - _NUM ) { writeLogln ( STRING ) ; } else { writeLogln ( STRING ) ; } } } } setTitleText ( STRING ) ; } catch ( Exception ex ) { setTitleText ( STRING ) ; ex . printStackTrace ( ) ; disconnect ( ) ; } finally { if ( led . isFlashing ( ) ) { led . setFlash ( ) ; } } if ( connected ) { led . setGreen ( ) ; setConnected ( _BOOL ) ; } else { led . setRed ( ) ; setConnected ( _BOOL ) ; } }
public static void writeImageToPpm ( int [ ] [ ] image , String ppmFileName ) throws IOException { try ( BufferedWriter ppmOut = new BufferedWriter ( new FileWriter ( ppmFileName ) ) ) { int rows = image . length ; int cols = image [ _NUM ] . length ; ppmOut . write ( STRING ) ; ppmOut . write ( STRING + rows + STRING + cols + STRING ) ; for ( int [ ] anImage : image ) { StringBuilder s = new StringBuilder ( ) ; for ( int j = _NUM ; j < cols ; j ++ ) { s . append ( anImage [ j ] + STRING + anImage [ j ] + STRING + anImage [ j ] + STRING ) ; } ppmOut . write ( s . toString ( ) ) ; } } }
public void remove ( RequestFilter filter ) { filters . remove ( filter ) ; }
public void testCase3 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = _NUM ; int bSign = - _NUM ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
public void configureLocalServices ( ) { clientMemo . setLnTrafficController ( this ) ; clientMemo . configureCommandStation ( LnCommandStationType . COMMAND_STATION_DCS100 , _BOOL , _BOOL ) ; clientMemo . configureManagers ( ) ; }
public static Streamable < Integer > fromIntStream ( final IntStream stream ) { Objects . requireNonNull ( stream ) ; return fromStream ( ReactiveSeq . fromIntStream ( stream ) ) ; }
public void onNewData ( byte [ ] data ) ;
public String addImport ( String namespace ) { imports . add ( namespace ) ; return STRING ; }
public static boolean doCheckPoint ( ) { if ( forceChkpt ) { forceChkpt = _BOOL ; return _BOOL ; } if ( chkptDuration == _NUM ) { return _BOOL ; } long now = System . currentTimeMillis ( ) ; if ( now - lastChkpt >= TLCGlobals . chkptDuration ) { lastChkpt = now ; return _BOOL ; } return _BOOL ; }
protected final void switchState ( final TransactionState newState ) throws SQLException { synchronized ( getSynchronizationObject ( ) ) { final TransactionState currentState = state ; if ( currentState == newState ) return ; if ( currentState . isValidTransition ( newState ) ) { state = newState ; transactionListenerDispatcher . transactionStateChanged ( this , newState , currentState ) ; } else { throw new SQLException ( String . format ( STRING , newState , currentState ) ) ; } } }
protected final void switchState ( final TransactionState newState ) throws SQLException { synchronized ( getSynchronizationObject ( ) ) { final TransactionState currentState = state ; if ( currentState == newState ) return ; if ( currentState . isValidTransition ( newState ) ) { state = newState ; transactionListenerDispatcher . transactionStateChanged ( this , newState , currentState ) ; } else { throw new SQLException ( String . format ( STRING , newState , currentState ) ) ; } } }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = _NUM ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
public void clear ( ) { final ReentrantLock lock = this . lock ; lock . lock ( ) ; try { for ( Node < E > f = first ; f != null ; ) { f . item = null ; Node < E > n = f . next ; f . prev = null ; f . next = null ; f = n ; } first = last = null ; count = _NUM ; notFull . signalAll ( ) ; } finally { lock . unlock ( ) ; } }
@ Override public boolean accept ( File file ) { String name = file . getName ( ) ; for ( String wildcard : wildcards ) { if ( FilenameUtils . wildcardMatch ( name , wildcard , caseSensitivity ) ) { return _BOOL ; } } return _BOOL ; }
@ Override public boolean accept ( File file ) { String name = file . getName ( ) ; for ( String wildcard : wildcards ) { if ( FilenameUtils . wildcardMatch ( name , wildcard , caseSensitivity ) ) { return _BOOL ; } } return _BOOL ; }
public void querySorted ( String type , int index , boolean ascending , int page , int limit , int visibilityScope , CloudResponse < CloudObject [ ] > response ) { try { queryImpl ( type , null , _NUM , page , limit , visibilityScope , _NUM , index , ascending , _BOOL , _BOOL , response ) ; } catch ( CloudException e ) { response . onError ( e ) ; } }
public void savePoisFromAssets ( ) { List < Poi > pois = poiAssetLoader . loadPoisFromAssets ( ) ; Timber . d ( STRING , pois . size ( ) ) ; for ( Poi poi : pois ) { Timber . d ( STRING , poi ) ; savePoi ( poi ) ; Timber . d ( STRING ) ; } }
public static int writeString ( DataOutput out , String s ) throws IOException { ByteBuffer bytes = encode ( s ) ; int length = bytes . limit ( ) ; WritableUtils . writeVInt ( out , length ) ; out . write ( bytes . array ( ) , _NUM , length ) ; return length ; }
Builder addLenient ( String line ) { int index = line . indexOf ( STRING , _NUM ) ; if ( index != - _NUM ) { return addLenient ( line . substring ( _NUM , index ) , line . substring ( index + _NUM ) ) ; } else if ( line . startsWith ( STRING ) ) { return addLenient ( STRING , line . substring ( _NUM ) ) ; } else { return addLenient ( STRING , line ) ; } }
Builder addLenient ( String line ) { int index = line . indexOf ( STRING , _NUM ) ; if ( index != - _NUM ) { return addLenient ( line . substring ( _NUM , index ) , line . substring ( index + _NUM ) ) ; } else if ( line . startsWith ( STRING ) ) { return addLenient ( STRING , line . substring ( _NUM ) ) ; } else { return addLenient ( STRING , line ) ; } }
public static void prependResourceSource ( ResourceSource source ) { ALL_RESOURCE_SOURCES . addFirst ( source ) ; }
public static void prependResourceSource ( ResourceSource source ) { ALL_RESOURCE_SOURCES . addFirst ( source ) ; }
@ Override public String generateDeviceSpecificExportMaskAddInitiatorsWorkflow ( Workflow workflow , String zoningGroupId , StorageSystem storage , ExportGroup exportGroup , ExportMask mask , List < URI > volumes , List < URI > newInitiators , String token ) throws Exception { Set < URI > volumeURIs = new HashSet < URI > ( ) ; if ( volumes != null ) { volumeURIs . addAll ( volumes ) ; } return generateExportMaskAddInitiatorsWorkflow ( workflow , null , storage , exportGroup , mask , newInitiators , volumeURIs , token ) ; }
@ Override public String generateDeviceSpecificExportMaskAddInitiatorsWorkflow ( Workflow workflow , String zoningGroupId , StorageSystem storage , ExportGroup exportGroup , ExportMask mask , List < URI > volumes , List < URI > newInitiators , String token ) throws Exception { Set < URI > volumeURIs = new HashSet < URI > ( ) ; if ( volumes != null ) { volumeURIs . addAll ( volumes ) ; } return generateExportMaskAddInitiatorsWorkflow ( workflow , null , storage , exportGroup , mask , newInitiators , volumeURIs , token ) ; }
public void run ( ) { while ( _BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . isEmpty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . InterruptedException e ) { e . printStackTrace ( ) ; } } r = queue . remove ( queue . size ( ) - _NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public void run ( ) { while ( _BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . isEmpty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . InterruptedException e ) { e . printStackTrace ( ) ; } } r = queue . remove ( queue . size ( ) - _NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public void run ( ) { while ( _BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . isEmpty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . InterruptedException e ) { e . printStackTrace ( ) ; } } r = queue . remove ( queue . size ( ) - _NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public void run ( ) { while ( _BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . isEmpty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . InterruptedException e ) { e . printStackTrace ( ) ; } } r = queue . remove ( queue . size ( ) - _NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
public void run ( ) { while ( _BOOL ) { Runnable r = null ; synchronized ( queue ) { while ( queue . isEmpty ( ) ) { try { queue . wait ( ) ; } catch ( java . lang . InterruptedException e ) { e . printStackTrace ( ) ; } } r = queue . remove ( queue . size ( ) - _NUM ) ; } try { r . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } }
@ Override public boolean hasAntds ( ) { if ( m_Antds == null ) { return _BOOL ; } else { return ( m_Antds . size ( ) > _NUM ) ; } }
private Object handleDirectInvocation ( final Method invokedMethod , final Object [ ] args ) throws Throwable { return invokedMethod . invoke ( userImpl , args ) ; }
private Object handleDirectInvocation ( final Method invokedMethod , final Object [ ] args ) throws Throwable { return invokedMethod . invoke ( userImpl , args ) ; }
private Object handleDirectInvocation ( final Method invokedMethod , final Object [ ] args ) throws Throwable { return invokedMethod . invoke ( userImpl , args ) ; }
private static void addHorizontalSmallSpring ( Path2D . Float path , int y0 , int x1 , int x2 ) { int springHeight = _NUM ; int springWidth = _NUM ; int distance = Math . abs ( x2 - x1 ) ; int numSprings = ( distance / ( springHeight ) ) ; int leftOver = ( distance - ( numSprings * springHeight ) ) / _NUM ; path . lineTo ( x1 , y0 ) ; path . lineTo ( x1 - leftOver , y0 - leftOver ) ; int count = _NUM ; if ( x1 > x2 ) { for ( int x = x1 - leftOver ; x > x2 + leftOver ; x -= springHeight ) { int y = ( count % _NUM == _NUM ) ? y0 - springWidth : y0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } else { for ( int x = x1 + leftOver ; x < x2 - leftOver ; x += springHeight ) { int y = ( count % _NUM == _NUM ) ? y0 - springWidth : y0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } path . lineTo ( x2 + leftOver , y0 ) ; path . lineTo ( x2 , y0 ) ; }
private static void addHorizontalSmallSpring ( Path2D . Float path , int y0 , int x1 , int x2 ) { int springHeight = _NUM ; int springWidth = _NUM ; int distance = Math . abs ( x2 - x1 ) ; int numSprings = ( distance / ( springHeight ) ) ; int leftOver = ( distance - ( numSprings * springHeight ) ) / _NUM ; path . lineTo ( x1 , y0 ) ; path . lineTo ( x1 - leftOver , y0 - leftOver ) ; int count = _NUM ; if ( x1 > x2 ) { for ( int x = x1 - leftOver ; x > x2 + leftOver ; x -= springHeight ) { int y = ( count % _NUM == _NUM ) ? y0 - springWidth : y0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } else { for ( int x = x1 + leftOver ; x < x2 - leftOver ; x += springHeight ) { int y = ( count % _NUM == _NUM ) ? y0 - springWidth : y0 + springWidth ; path . lineTo ( x , y ) ; count ++ ; } } path . lineTo ( x2 + leftOver , y0 ) ; path . lineTo ( x2 , y0 ) ; }
private static void storeAsTypeWithSignaturesImport ( String strTypeToImport , @ Nullable Function objScope , PhpIndex objIndex , HashSet < String > objTypesSet ) { if ( strTypeToImport . contains ( STRING ) ) { for ( String strOneType : strTypeToImport . split ( STRING ) ) { storeAsTypeWithSignaturesImport ( Types . getType ( strOneType ) , objScope , objIndex , objTypesSet ) ; } return ; } if ( StringUtil . isEmpty ( strTypeToImport ) || strTypeToImport . equals ( STRING ) ) { return ; } if ( strTypeToImport . contains ( STRING ) ) { TypeFromSignatureResolvingUtil . resolveSignature ( strTypeToImport , objScope , objIndex , objTypesSet ) ; return ; } objTypesSet . add ( Types . getType ( strTypeToImport ) ) ; }
public void fill ( Shape s ) { mGraphics . fill ( s ) ; }
public void fill ( Shape s ) { mGraphics . fill ( s ) ; }
public static Map < String , String > parseNamedParameters ( String tagValue ) { Map < String , String > paramMap = new LinkedHashMap < String , String > ( ) ; StreamTokenizer tokenizer = makeTokenizer ( tagValue ) ; try { while ( tokenizer . nextToken ( ) == StreamTokenizer . TT_WORD ) { String key = tokenizer . sval ; if ( tokenizer . nextToken ( ) != STRING ) { break ; } switch ( tokenizer . nextToken ( ) ) { case StreamTokenizer . TT_WORD : case STRING : case STRING : paramMap . put ( key , tokenizer . sval ) ; default : break ; } } } catch ( IOException e ) { } return paramMap ; }
public DViewAsn1Dump ( JDialog parent , X509CRL crl ) throws Asn1Exception , IOException { super ( res . getString ( STRING ) ) ; this . crl = crl ; initComponents ( ) ; }
public DViewAsn1Dump ( JDialog parent , X509CRL crl ) throws Asn1Exception , IOException { super ( res . getString ( STRING ) ) ; this . crl = crl ; initComponents ( ) ; }
public DViewAsn1Dump ( JDialog parent , X509CRL crl ) throws Asn1Exception , IOException { super ( res . getString ( STRING ) ) ; this . crl = crl ; initComponents ( ) ; }
public static ClientException adaptInputException ( final Throwable cause ) { return new ClientException ( ReturnCode . ERROR_USER_DATA , ERR_CONSOLE_INPUT_ERROR . get ( cause . getMessage ( ) ) , cause ) ; }
public static int [ ] randomPermutation ( final int [ ] out , Random random ) { for ( int i = out . length - _NUM ; i > _NUM ; i -- ) { int ri = random . nextInt ( i + _NUM ) ; int tmp = out [ ri ] ; out [ ri ] = out [ i ] ; out [ i ] = tmp ; } return out ; }
static Uri createRcsContactIfNeeded ( Context context , ContactId contactId ) throws RemoteException , OperationApplicationException { int phoneId = getContactIdOfAddressBook ( context , contactId ) ; if ( phoneId != INVALID_CONTACT_ID ) { return ContentUris . withAppendedId ( ContactsContract . Contacts . CONTENT_URI , phoneId ) ; } ContentValues values = new ContentValues ( ) ; values . putNull ( ContactsContract . Contacts . DISPLAY_NAME ) ; values . put ( Phone . NUMBER , contactId . toString ( ) ) ; values . put ( Phone . TYPE , Phone . TYPE_MOBILE ) ; return createContact ( context , values ) ; }
static Uri createRcsContactIfNeeded ( Context context , ContactId contactId ) throws RemoteException , OperationApplicationException { int phoneId = getContactIdOfAddressBook ( context , contactId ) ; if ( phoneId != INVALID_CONTACT_ID ) { return ContentUris . withAppendedId ( ContactsContract . Contacts . CONTENT_URI , phoneId ) ; } ContentValues values = new ContentValues ( ) ; values . putNull ( ContactsContract . Contacts . DISPLAY_NAME ) ; values . put ( Phone . NUMBER , contactId . toString ( ) ) ; values . put ( Phone . TYPE , Phone . TYPE_MOBILE ) ; return createContact ( context , values ) ; }
public void serialize ( KXmlSerializer serializer ) throws IOException { serializer . startTag ( ns , TAG ) ; serializeAttribute ( serializer , NAME_ATTR , mName ) ; serializeAttribute ( serializer , APP_PACKAGE_NAME_ATTR , mAppPackageName ) ; serializeAttribute ( serializer , DIGEST_ATTR , getDigest ( ) ) ; if ( SIGNATURE_TEST_PKG . equals ( mName ) ) { serializer . attribute ( ns , STRING , STRING ) ; } mSuiteRoot . serialize ( serializer ) ; serializer . endTag ( ns , TAG ) ; }
public void addWarning ( Warning w ) { warnings . add ( w ) ; }
public int addItem ( String label , float value , int color ) { Item it = new Item ( ) ; it . mLabel = label ; it . mColor = color ; it . mValue = value ; it . mHighlight = Color . argb ( _NUM , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . red ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . green ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . blue ( color ) ) , _NUM ) ) ; mTotal += value ; mData . add ( it ) ; onDataChanged ( ) ; return mData . size ( ) - _NUM ; }
public int addItem ( String label , float value , int color ) { Item it = new Item ( ) ; it . mLabel = label ; it . mColor = color ; it . mValue = value ; it . mHighlight = Color . argb ( _NUM , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . red ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . green ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . blue ( color ) ) , _NUM ) ) ; mTotal += value ; mData . add ( it ) ; onDataChanged ( ) ; return mData . size ( ) - _NUM ; }
public int addItem ( String label , float value , int color ) { Item it = new Item ( ) ; it . mLabel = label ; it . mColor = color ; it . mValue = value ; it . mHighlight = Color . argb ( _NUM , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . red ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . green ( color ) ) , _NUM ) , Math . min ( ( int ) ( mHighlightStrength * ( float ) Color . blue ( color ) ) , _NUM ) ) ; mTotal += value ; mData . add ( it ) ; onDataChanged ( ) ; return mData . size ( ) - _NUM ; }
public static Class unboxType ( Class wrapperType ) { Class c = ( Class ) wrapperMap . get ( wrapperType ) ; if ( c != null ) return c ; throw new InterpreterError ( STRING + wrapperType ) ; }
public void test_parkFor_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public void test_parkFor_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public void test_parkFor_2 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public DialogueImporter importDialogue ( String dialogueFile ) { List < DialogueState > turns = XMLDialogueReader . extractDialogue ( dialogueFile ) ; DialogueImporter importer = new DialogueImporter ( this , turns ) ; importer . start ( ) ; return importer ; }
public DialogueImporter importDialogue ( String dialogueFile ) { List < DialogueState > turns = XMLDialogueReader . extractDialogue ( dialogueFile ) ; DialogueImporter importer = new DialogueImporter ( this , turns ) ; importer . start ( ) ; return importer ; }
public boolean hasSet ( String name ) { return m_map . containsKey ( name ) ; }
public boolean hasSet ( String name ) { return m_map . containsKey ( name ) ; }
public IgniteUuid affinityKey ( long blockOff , boolean includeMoved ) { if ( ranges == null ) return null ; assert ! ranges . isEmpty ( ) ; int leftIdx = _NUM , rightIdx = ranges . size ( ) - _NUM ; IgfsFileAffinityRange leftRange = ranges . get ( leftIdx ) ; IgfsFileAffinityRange rightRange = ranges . get ( rightIdx ) ; if ( leftRange . less ( blockOff ) ) return null ; if ( leftRange . belongs ( blockOff ) ) return leftRange . status ( ) != RANGE_STATUS_MOVED ? leftRange . affinityKey ( ) : includeMoved ? leftRange . affinityKey ( ) : null ; if ( rightRange . greater ( blockOff ) ) return null ; if ( rightRange . belongs ( blockOff ) ) return rightRange . status ( ) != RANGE_STATUS_MOVED ? rightRange . affinityKey ( ) : includeMoved ? leftRange . affinityKey ( ) : null ; while ( rightIdx - leftIdx > _NUM ) { int midIdx = ( leftIdx + rightIdx ) / _NUM ; IgfsFileAffinityRange midRange = ranges . get ( midIdx ) ; if ( midRange . belongs ( blockOff ) ) return midRange . status ( ) != RANGE_STATUS_MOVED ? midRange . affinityKey ( ) : includeMoved ? leftRange . affinityKey ( ) : null ; if ( midRange . less ( blockOff ) ) rightIdx = midIdx ; else { assert midRange . greater ( blockOff ) ; leftIdx = midIdx ; } } return null ; }
private String findLastStringAssignment ( Stmt stmt , Local local , BiDiInterproceduralCFG < Unit , SootMethod > cfg ) { if ( stmt instanceof AssignStmt ) { AssignStmt assign = ( AssignStmt ) stmt ; if ( assign . getLeftOp ( ) == local ) { if ( assign . getRightOp ( ) instanceof StringConstant ) return ( ( StringConstant ) assign . getRightOp ( ) ) . value ; } } for ( Unit pred : cfg . getPredsOf ( stmt ) ) { if ( ! ( pred instanceof Stmt ) ) continue ; String lastAssignment = findLastStringAssignment ( ( Stmt ) pred , local , cfg ) ; if ( lastAssignment != null ) return lastAssignment ; } return null ; }
private String findLastStringAssignment ( Stmt stmt , Local local , BiDiInterproceduralCFG < Unit , SootMethod > cfg ) { if ( stmt instanceof AssignStmt ) { AssignStmt assign = ( AssignStmt ) stmt ; if ( assign . getLeftOp ( ) == local ) { if ( assign . getRightOp ( ) instanceof StringConstant ) return ( ( StringConstant ) assign . getRightOp ( ) ) . value ; } } for ( Unit pred : cfg . getPredsOf ( stmt ) ) { if ( ! ( pred instanceof Stmt ) ) continue ; String lastAssignment = findLastStringAssignment ( ( Stmt ) pred , local , cfg ) ; if ( lastAssignment != null ) return lastAssignment ; } return null ; }
private void registerChangedResourceParent ( IResource changedResource ) throws TeamException { IContainer parent = changedResource . getParent ( ) ; if ( parent == null ) return ; if ( remoteSyncStateStore . getBytes ( parent ) == null ) { remoteSyncStateStore . setBytes ( parent , DUMMY_SYNC_BYTES ) ; registerChangedResourceParent ( parent ) ; } }
private void registerChangedResourceParent ( IResource changedResource ) throws TeamException { IContainer parent = changedResource . getParent ( ) ; if ( parent == null ) return ; if ( remoteSyncStateStore . getBytes ( parent ) == null ) { remoteSyncStateStore . setBytes ( parent , DUMMY_SYNC_BYTES ) ; registerChangedResourceParent ( parent ) ; } }
private void registerChangedResourceParent ( IResource changedResource ) throws TeamException { IContainer parent = changedResource . getParent ( ) ; if ( parent == null ) return ; if ( remoteSyncStateStore . getBytes ( parent ) == null ) { remoteSyncStateStore . setBytes ( parent , DUMMY_SYNC_BYTES ) ; registerChangedResourceParent ( parent ) ; } }
private void registerChangedResourceParent ( IResource changedResource ) throws TeamException { IContainer parent = changedResource . getParent ( ) ; if ( parent == null ) return ; if ( remoteSyncStateStore . getBytes ( parent ) == null ) { remoteSyncStateStore . setBytes ( parent , DUMMY_SYNC_BYTES ) ; registerChangedResourceParent ( parent ) ; } }
private void registerChangedResourceParent ( IResource changedResource ) throws TeamException { IContainer parent = changedResource . getParent ( ) ; if ( parent == null ) return ; if ( remoteSyncStateStore . getBytes ( parent ) == null ) { remoteSyncStateStore . setBytes ( parent , DUMMY_SYNC_BYTES ) ; registerChangedResourceParent ( parent ) ; } }
public < T extends PO > POResultSet < T > scroll ( ) throws DBException { String sql = buildSQL ( null , _BOOL ) ; PreparedStatement pstmt = null ; ResultSet rs = null ; POResultSet < T > rsPO = null ; try { pstmt = DB . prepareStatement ( sql , trxName ) ; rs = createResultSet ( pstmt ) ; rsPO = new POResultSet < T > ( table , pstmt , rs , trxName ) ; rsPO . setCloseOnError ( _BOOL ) ; return rsPO ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DBException ( e , sql ) ; } finally { if ( rsPO == null ) { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } }
public < T extends PO > POResultSet < T > scroll ( ) throws DBException { String sql = buildSQL ( null , _BOOL ) ; PreparedStatement pstmt = null ; ResultSet rs = null ; POResultSet < T > rsPO = null ; try { pstmt = DB . prepareStatement ( sql , trxName ) ; rs = createResultSet ( pstmt ) ; rsPO = new POResultSet < T > ( table , pstmt , rs , trxName ) ; rsPO . setCloseOnError ( _BOOL ) ; return rsPO ; } catch ( SQLException e ) { log . log ( Level . SEVERE , sql , e ) ; throw new DBException ( e , sql ) ; } finally { if ( rsPO == null ) { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return NOTE_ID ; case _NUM : return CLASS_NAME ; case _NUM : return INTERPRETER_CONTEXT ; default : return null ; } }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( KEY_ID ) ) { id = null ; } else { throw new IOException ( STRING + STRING ) ; } encodeThis ( ) ; }
public static boolean canTranslate ( String unlocalizedString ) { if ( I18n . hasKey ( unlocalizedString ) ) return _BOOL ; else { if ( UNLOCALIZED_STRINGS . size ( ) < _NUM && ! UNLOCALIZED_STRINGS . contains ( unlocalizedString ) ) UNLOCALIZED_STRINGS . add ( unlocalizedString ) ; return _BOOL ; } }
public static boolean canTranslate ( String unlocalizedString ) { if ( I18n . hasKey ( unlocalizedString ) ) return _BOOL ; else { if ( UNLOCALIZED_STRINGS . size ( ) < _NUM && ! UNLOCALIZED_STRINGS . contains ( unlocalizedString ) ) UNLOCALIZED_STRINGS . add ( unlocalizedString ) ; return _BOOL ; } }
public void addTabStop ( int stop ) { boundsCheck ( stop ) ; tabstops . add ( stop ) ; }
public void testGetOwnerElement1 ( ) throws Throwable { Document doc ; NodeList addressList ; Node testNode ; NamedNodeMap attributes ; Attr domesticAttr ; Element elementNode ; String name ; doc = ( Document ) load ( STRING , builder ) ; addressList = doc . getElementsByTagName ( STRING ) ; testNode = addressList . item ( _NUM ) ; attributes = testNode . getAttributes ( ) ; domesticAttr = ( Attr ) attributes . getNamedItem ( STRING ) ; elementNode = domesticAttr . getOwnerElement ( ) ; name = elementNode . getNodeName ( ) ; assertEquals ( STRING , STRING , name ) ; }
protected void serializeAttribute ( TagNode tagNode , Writer writer , String attName , String attValue ) throws IOException { if ( ! isForbiddenAttribute ( tagNode , attName , attValue ) ) { writer . write ( STRING + attName + STRING + escapeXml ( attValue ) + STRING ) ; } }
protected void serializeAttribute ( TagNode tagNode , Writer writer , String attName , String attValue ) throws IOException { if ( ! isForbiddenAttribute ( tagNode , attName , attValue ) ) { writer . write ( STRING + attName + STRING + escapeXml ( attValue ) + STRING ) ; } }
@ RpcMethod public void place ( Resource resource , AsyncMethodCallback < Host . AsyncClient . place_call > handler ) throws RpcException { ensureClient ( ) ; PlaceRequest placeRequest = new PlaceRequest ( resource ) ; clientProxy . setTimeout ( PLACE_TIMEOUT_MS ) ; logger . debug ( STRING , resource , getHostIp ( ) , placeRequest ) ; try { clientProxy . place ( placeRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ Deprecated public static void putIANA2JavaMapping ( String ianaEncoding , String javaEncoding ) { fIANA2JavaMap . put ( ianaEncoding , javaEncoding ) ; }
public CompactHashSet ( Collection < E > c ) { this ( c . size ( ) ) ; addAll ( c ) ; }
public CompactHashSet ( Collection < E > c ) { this ( c . size ( ) ) ; addAll ( c ) ; }
public void disconnect ( ) throws IOException { socket . disconnect ( ) ; }
public < U > SimpleReactStream < Double > from ( final DoubleStream stream ) { return from ( stream . boxed ( ) ) ; }
public static NeuralNetwork readFrom ( String filename ) throws IOException , ClassNotFoundException { ObjectInputStream ois = new ObjectInputStream ( new FileInputStream ( filename ) ) ; NeuralNetwork net = ( NeuralNetwork ) ois . readObject ( ) ; ois . close ( ) ; return net ; }
public static String hash ( String string ) { try { MessageDigest sha1 = MessageDigest . getInstance ( STRING ) ; sha1 . update ( string . getBytes ( STRING ) ) ; return Base64 . encode ( sha1 . digest ( ) ) ; } catch ( Exception ex ) { Debug debug = Debug . getInstance ( STRING ) ; if ( debug . warningEnabled ( ) ) { debug . warning ( STRING , ex ) ; } return null ; } }
public void keepOnly ( Set < IVarAbstraction > usefulPointers ) { Set < IVarAbstraction > reps = new HashSet < IVarAbstraction > ( ) ; for ( IVarAbstraction pn : usefulPointers ) { reps . add ( pn . getRepresentative ( ) ) ; } usefulPointers . addAll ( reps ) ; reps = null ; for ( IVarAbstraction pn : pointers ) { if ( ! usefulPointers . contains ( pn ) ) pn . deleteAll ( ) ; } System . gc ( ) ; }
private void markAsIncomplete ( VM vm ) throws IOException { File backupDir = getBackupDirForMember ( getBaselineDir ( ) , getMemberId ( vm ) ) ; assertTrue ( backupDir . exists ( ) ) ; File incomplete = new File ( backupDir , BackupManager . INCOMPLETE_BACKUP ) ; incomplete . createNewFile ( ) ; }
private boolean isLoadMore ( ) { return mNextLoadEnable && pageSize != - _NUM && mRequestLoadMoreListener != null && mData . size ( ) >= pageSize ; }
public void testFailedStage ( ) { CFException ex = new CFException ( ) ; CompletionStage < Integer > f = CompletableFuture . failedStage ( ex ) ; AtomicInteger x = new AtomicInteger ( _NUM ) ; AtomicReference < Throwable > r = new AtomicReference < Throwable > ( ) ; f . whenComplete ( null ) ; assertEquals ( x . get ( ) , _NUM ) ; assertEquals ( r . get ( ) , ex ) ; }
public void testFailedStage ( ) { CFException ex = new CFException ( ) ; CompletionStage < Integer > f = CompletableFuture . failedStage ( ex ) ; AtomicInteger x = new AtomicInteger ( _NUM ) ; AtomicReference < Throwable > r = new AtomicReference < Throwable > ( ) ; f . whenComplete ( null ) ; assertEquals ( x . get ( ) , _NUM ) ; assertEquals ( r . get ( ) , ex ) ; }
public void testFailedStage ( ) { CFException ex = new CFException ( ) ; CompletionStage < Integer > f = CompletableFuture . failedStage ( ex ) ; AtomicInteger x = new AtomicInteger ( _NUM ) ; AtomicReference < Throwable > r = new AtomicReference < Throwable > ( ) ; f . whenComplete ( null ) ; assertEquals ( x . get ( ) , _NUM ) ; assertEquals ( r . get ( ) , ex ) ; }
public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int n : nums1 ) { count . put ( n , count . containsKey ( n ) ? count . get ( n ) + _NUM : _NUM ) ; } List < Integer > intersections = new ArrayList < > ( Math . min ( nums1 . length , nums2 . length ) ) ; for ( int n : nums2 ) { if ( count . containsKey ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - _NUM ) ; if ( count . get ( n ) == _NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = _NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int n : nums1 ) { count . put ( n , count . containsKey ( n ) ? count . get ( n ) + _NUM : _NUM ) ; } List < Integer > intersections = new ArrayList < > ( Math . min ( nums1 . length , nums2 . length ) ) ; for ( int n : nums2 ) { if ( count . containsKey ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - _NUM ) ; if ( count . get ( n ) == _NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = _NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int n : nums1 ) { count . put ( n , count . containsKey ( n ) ? count . get ( n ) + _NUM : _NUM ) ; } List < Integer > intersections = new ArrayList < > ( Math . min ( nums1 . length , nums2 . length ) ) ; for ( int n : nums2 ) { if ( count . containsKey ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - _NUM ) ; if ( count . get ( n ) == _NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = _NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
public int [ ] intersect ( int [ ] nums1 , int [ ] nums2 ) { Map < Integer , Integer > count = new HashMap < > ( ) ; for ( int n : nums1 ) { count . put ( n , count . containsKey ( n ) ? count . get ( n ) + _NUM : _NUM ) ; } List < Integer > intersections = new ArrayList < > ( Math . min ( nums1 . length , nums2 . length ) ) ; for ( int n : nums2 ) { if ( count . containsKey ( n ) ) { intersections . add ( n ) ; count . put ( n , count . get ( n ) - _NUM ) ; if ( count . get ( n ) == _NUM ) count . remove ( n ) ; } } int [ ] res = new int [ intersections . size ( ) ] ; for ( int i = _NUM ; i < intersections . size ( ) ; i ++ ) { res [ i ] = intersections . get ( i ) ; } return res ; }
private void persistUnManagedExportMasks ( List < UnManagedExportMask > unManagedExportMasksToCreate , List < UnManagedExportMask > unManagedExportMasksToUpdate , boolean flush ) { if ( null != unManagedExportMasksToCreate ) { if ( flush || ( unManagedExportMasksToCreate . size ( ) >= BATCH_SIZE ) ) { _partitionManager . insertInBatches ( unManagedExportMasksToCreate , BATCH_SIZE , _dbClient , UNMANAGED_EXPORT_MASK ) ; unManagedExportMasksToCreate . clear ( ) ; } } if ( null != unManagedExportMasksToUpdate ) { if ( flush || ( unManagedExportMasksToUpdate . size ( ) >= BATCH_SIZE ) ) { _partitionManager . updateInBatches ( unManagedExportMasksToUpdate , BATCH_SIZE , _dbClient , UNMANAGED_EXPORT_MASK ) ; unManagedExportMasksToUpdate . clear ( ) ; } } }
public void addRunConfiguration ( Project project , String name , Properties properties ) { try { J2SEProjectConfigurations . createConfigurationFiles ( project , name , properties , null ) ; } catch ( IOException ex ) { Exceptions . printStackTrace ( ex ) ; } catch ( IllegalArgumentException ex ) { Exceptions . printStackTrace ( ex ) ; } }
public void writeBytes ( final byte [ ] bytes ) { if ( bytes == null ) return ; if ( currentBitIndex < Byte . SIZE - _NUM ) { for ( int i = _NUM ; i < bytes . length ; i ++ ) { write ( bytes [ i ] , Byte . SIZE ) ; } } else { byteStream . write ( bytes , _NUM , bytes . length ) ; } }
private void showNextSuperToast ( ) { final SuperActivityToast superActivityToast = mList . peek ( ) ; if ( mList . isEmpty ( ) || superActivityToast . getActivity ( ) == null ) { return ; } if ( ! superActivityToast . isShowing ( ) ) { final Message message = obtainMessage ( Messages . DISPLAY ) ; message . obj = superActivityToast ; sendMessage ( message ) ; } }
private void showNextSuperToast ( ) { final SuperActivityToast superActivityToast = mList . peek ( ) ; if ( mList . isEmpty ( ) || superActivityToast . getActivity ( ) == null ) { return ; } if ( ! superActivityToast . isShowing ( ) ) { final Message message = obtainMessage ( Messages . DISPLAY ) ; message . obj = superActivityToast ; sendMessage ( message ) ; } }
protected void preUpdateMenu ( ) { }
private void saveSortedPomFile ( final String sortedXml ) { fileUtil . savePomFile ( sortedXml ) ; log . info ( STRING + pomFile . getAbsolutePath ( ) ) ; }
@ Deprecated protected Partitioner . Partition < AbstractKafkaInputOperator < K > > createPartition ( Set < KafkaPartition > pIds , Map < KafkaPartition , Long > initOffsets , @ SuppressWarnings ( STRING ) Collection < WindowDataManager > newManagers ) { return createPartition ( pIds , initOffsets ) ; }
public static void writeStringFixedSize ( final DataOutput out , String s , int size ) throws IOException { byte [ ] b = toBytes ( s ) ; if ( b . length > size ) { throw new IOException ( STRING + b . length + STRING + toStringBinary ( b ) + STRING + size ) ; } out . writeBytes ( s ) ; for ( int i = _NUM ; i < size - s . length ( ) ; ++ i ) out . writeByte ( _NUM ) ; }
public boolean contains ( JsonElement element ) { return elements . contains ( element ) ; }
private static List < Object > arrayToList ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . asList ( ( Object [ ] ) array ) ; List < Object > result = new ArrayList < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
private static List < Object > arrayToList ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . asList ( ( Object [ ] ) array ) ; List < Object > result = new ArrayList < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
private static List < Object > arrayToList ( final Object array ) { if ( array instanceof Object [ ] ) return Arrays . asList ( ( Object [ ] ) array ) ; List < Object > result = new ArrayList < Object > ( ) ; if ( array instanceof int [ ] ) for ( int value : ( int [ ] ) array ) result . add ( value ) ; else if ( array instanceof boolean [ ] ) for ( boolean value : ( boolean [ ] ) array ) result . add ( value ) ; else if ( array instanceof long [ ] ) for ( long value : ( long [ ] ) array ) result . add ( value ) ; else if ( array instanceof float [ ] ) for ( float value : ( float [ ] ) array ) result . add ( value ) ; else if ( array instanceof double [ ] ) for ( double value : ( double [ ] ) array ) result . add ( value ) ; else if ( array instanceof short [ ] ) for ( short value : ( short [ ] ) array ) result . add ( value ) ; else if ( array instanceof byte [ ] ) for ( byte value : ( byte [ ] ) array ) result . add ( value ) ; else if ( array instanceof char [ ] ) for ( char value : ( char [ ] ) array ) result . add ( value ) ; return result ; }
public int compareSwappedTo ( IntDoublePair other ) { int fdiff = Double . compare ( this . second , other . second ) ; if ( fdiff != _NUM ) { return fdiff ; } return this . first - other . first ; }
public void closeRunningApp ( String deviceID , String app_package ) throws InterruptedException , IOException { cmd . runCommand ( STRING + deviceID + STRING + app_package ) ; }
public synchronized void animatePan ( double dx , double dy , long duration ) { double panx = dx / m_transform . getScaleX ( ) ; double pany = dy / m_transform . getScaleY ( ) ; animatePanAbs ( panx , pany , duration ) ; }
public synchronized void animatePan ( double dx , double dy , long duration ) { double panx = dx / m_transform . getScaleX ( ) ; double pany = dy / m_transform . getScaleY ( ) ; animatePanAbs ( panx , pany , duration ) ; }
public synchronized void animatePan ( double dx , double dy , long duration ) { double panx = dx / m_transform . getScaleX ( ) ; double pany = dy / m_transform . getScaleY ( ) ; animatePanAbs ( panx , pany , duration ) ; }
protected boolean check ( T item ) { return _BOOL ; }
protected boolean check ( T item ) { return _BOOL ; }
protected boolean check ( T item ) { return _BOOL ; }
protected boolean check ( T item ) { return _BOOL ; }
protected boolean check ( T item ) { return _BOOL ; }
public String graph ( ) throws Exception { StringBuffer text = new StringBuffer ( ) ; assignIDs ( - _NUM ) ; assignLeafModelNumbers ( _NUM ) ; text . append ( STRING ) ; if ( m_isLeaf ) { text . append ( STRING + m_id + STRING + m_leafModelNum + STRING + getModelParameters ( ) + STRING + STRING ) ; text . append ( STRING ) ; } else { text . append ( STRING + m_id + STRING + Utils . backQuoteChars ( m_localModel . leftSide ( m_train ) ) + STRING ) ; text . append ( STRING ) ; graphTree ( text ) ; } return text . toString ( ) + STRING ; }
public String graph ( ) throws Exception { StringBuffer text = new StringBuffer ( ) ; assignIDs ( - _NUM ) ; assignLeafModelNumbers ( _NUM ) ; text . append ( STRING ) ; if ( m_isLeaf ) { text . append ( STRING + m_id + STRING + m_leafModelNum + STRING + getModelParameters ( ) + STRING + STRING ) ; text . append ( STRING ) ; } else { text . append ( STRING + m_id + STRING + Utils . backQuoteChars ( m_localModel . leftSide ( m_train ) ) + STRING ) ; text . append ( STRING ) ; graphTree ( text ) ; } return text . toString ( ) + STRING ; }
public void assureBufferCapacity ( final int len ) { while ( len > buffer . remaining ( ) ) { int newCapacity = Math . max ( ( int ) ( len + buffer . position ( ) * BIG_SIZE_INCREASE ) , ( int ) ( ( buffer . capacity ( ) > _NUM ) ? buffer . capacity ( ) * BIG_SIZE_INCREASE : buffer . capacity ( ) * NORMAL_INCREASE ) ) ; increase ( newCapacity ) ; } }
public void assureBufferCapacity ( final int len ) { while ( len > buffer . remaining ( ) ) { int newCapacity = Math . max ( ( int ) ( len + buffer . position ( ) * BIG_SIZE_INCREASE ) , ( int ) ( ( buffer . capacity ( ) > _NUM ) ? buffer . capacity ( ) * BIG_SIZE_INCREASE : buffer . capacity ( ) * NORMAL_INCREASE ) ) ; increase ( newCapacity ) ; } }
public static final String trimFront ( String str ) { int position = _NUM ; while ( ( position < str . length ( ) ) && Character . isWhitespace ( str . charAt ( position ) ) ) { position ++ ; } return str . substring ( position , str . length ( ) ) ; }
public static String calculateDiscountPercent ( Context context , double price , double discountPrice ) { int percent ; if ( discountPrice >= price ) { percent = _NUM ; } else { percent = ( int ) Math . round ( _NUM - ( ( discountPrice / price ) * _NUM ) ) ; } return String . format ( context . getString ( R . string . format_price_discount_percents ) , percent ) ; }
private static int stringToHash ( String s ) { int len = s . length ( ) ; int hash2 = _NUM ; int hash = len ; hash <<= _NUM ; hash += s . charAt ( _NUM ) - _NUM ; int j = len ; for ( int i = _NUM ; i < _NUM && j > _NUM ; i ++ ) { j -- ; hash <<= _NUM ; hash += s . charAt ( j ) - _NUM ; hash2 <<= _NUM ; hash2 += s . charAt ( i ) - _NUM ; } return hash ^ hash2 ; }
private static int stringToHash ( String s ) { int len = s . length ( ) ; int hash2 = _NUM ; int hash = len ; hash <<= _NUM ; hash += s . charAt ( _NUM ) - _NUM ; int j = len ; for ( int i = _NUM ; i < _NUM && j > _NUM ; i ++ ) { j -- ; hash <<= _NUM ; hash += s . charAt ( j ) - _NUM ; hash2 <<= _NUM ; hash2 += s . charAt ( i ) - _NUM ; } return hash ^ hash2 ; }
public void write ( final String filename ) { PrintStream stream ; try { stream = new PrintStream ( new File ( filename ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; return ; } write ( stream ) ; stream . close ( ) ; }
private String lookupLocalAddress ( ) { long timeout = _NUM * _NUM ; long expireTime = CurrentTime . currentTime ( ) + timeout ; String address ; while ( ( address = allocateLocalAddress ( ) ) == null && CurrentTime . currentTime ( ) < expireTime ) { try { Thread . sleep ( _NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new ConfigException ( L . l ( STRING + STRING + STRING , _serverBartender . getId ( ) , _serverBartender . getAddress ( ) ) ) ; } return address ; }
private String lookupLocalAddress ( ) { long timeout = _NUM * _NUM ; long expireTime = CurrentTime . currentTime ( ) + timeout ; String address ; while ( ( address = allocateLocalAddress ( ) ) == null && CurrentTime . currentTime ( ) < expireTime ) { try { Thread . sleep ( _NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new ConfigException ( L . l ( STRING + STRING + STRING , _serverBartender . getId ( ) , _serverBartender . getAddress ( ) ) ) ; } return address ; }
private String lookupLocalAddress ( ) { long timeout = _NUM * _NUM ; long expireTime = CurrentTime . currentTime ( ) + timeout ; String address ; while ( ( address = allocateLocalAddress ( ) ) == null && CurrentTime . currentTime ( ) < expireTime ) { try { Thread . sleep ( _NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new ConfigException ( L . l ( STRING + STRING + STRING , _serverBartender . getId ( ) , _serverBartender . getAddress ( ) ) ) ; } return address ; }
private String lookupLocalAddress ( ) { long timeout = _NUM * _NUM ; long expireTime = CurrentTime . currentTime ( ) + timeout ; String address ; while ( ( address = allocateLocalAddress ( ) ) == null && CurrentTime . currentTime ( ) < expireTime ) { try { Thread . sleep ( _NUM ) ; } catch ( Exception e ) { } } if ( address == null ) { throw new ConfigException ( L . l ( STRING + STRING + STRING , _serverBartender . getId ( ) , _serverBartender . getAddress ( ) ) ) ; } return address ; }
public Config ( SamlAuthorityConfiguration samlAuthorityConfig , TokenRestrictions tokenRestrictions , Collection < List < Certificate > > validCerts , long clockTolerance , Collection < IDPConfig > inExternalIdps ) { Validate . notNull ( samlAuthorityConfig ) ; Validate . notNull ( tokenRestrictions ) ; Validate . notEmpty ( validCerts ) ; List < Certificate > authorityCert = samlAuthorityConfig . getSigningCertificateChain ( ) ; boolean authorityCertInValidCerts = _BOOL ; for ( List < Certificate > currentChain : validCerts ) { Validate . notEmpty ( currentChain ) ; Validate . noNullElements ( currentChain ) ; if ( ! authorityCertInValidCerts && currentChain . equals ( authorityCert ) ) { authorityCertInValidCerts = _BOOL ; } } Validate . isTrue ( authorityCertInValidCerts , STRING ) ; Validate . isTrue ( clockTolerance >= _NUM ) ; this . samlAuthorityConfig = samlAuthorityConfig ; this . validCerts = validCerts ; this . clockTolerance = clockTolerance ; this . tokenRestrictions = tokenRestrictions ; HashMap < String , IDPConfig > idpsSet = new HashMap < String , IDPConfig > ( ) ; if ( inExternalIdps != null ) { for ( IDPConfig conf : inExternalIdps ) { if ( conf != null ) { idpsSet . put ( conf . getEntityID ( ) , conf ) ; } } } this . externalIdps = Collections . unmodifiableMap ( idpsSet ) ; }
void addEdge ( MethodParameter in , MethodParameter out ) { Set < MethodParameter > outs = graph . get ( in ) ; if ( outs == null ) { outs = new HashSet < > ( ) ; graph . put ( in , outs ) ; } outs . add ( out ) ; }
public CActionAbout ( final JFrame parent ) { super ( String . format ( STRING , Constants . PROJECT_NAME ) ) ; m_parent = Preconditions . checkNotNull ( parent , STRING ) ; putValue ( MNEMONIC_KEY , ( int ) STRING ) ; }
public static long pause ( final long sleepTimeMS ) { final long startTime = System . currentTimeMillis ( ) ; do { try { final long sleepTime = sleepTimeMS - ( System . currentTimeMillis ( ) - startTime ) ; Thread . sleep ( sleepTime > _NUM ? sleepTime : _NUM ) ; } catch ( InterruptedException e ) { } } while ( ( System . currentTimeMillis ( ) - startTime ) < sleepTimeMS ) ; return System . currentTimeMillis ( ) - startTime ; }
public byte [ ] digest ( ) { byte [ ] result = engineDigest ( ) ; state = INITIAL ; return result ; }
public byte [ ] digest ( ) { byte [ ] result = engineDigest ( ) ; state = INITIAL ; return result ; }
public void addMoveToBeginning ( RegisterSpec result , RegisterSpec source ) { if ( result . getReg ( ) == source . getReg ( ) ) { return ; } RegisterSpecList sources = RegisterSpecList . make ( source ) ; NormalSsaInsn toAdd = new NormalSsaInsn ( new PlainInsn ( Rops . opMove ( result . getType ( ) ) , SourcePosition . NO_INFO , result , sources ) , this ) ; insns . add ( getCountPhiInsns ( ) , toAdd ) ; movesFromPhisAtBeginning ++ ; }
public void addMoveToBeginning ( RegisterSpec result , RegisterSpec source ) { if ( result . getReg ( ) == source . getReg ( ) ) { return ; } RegisterSpecList sources = RegisterSpecList . make ( source ) ; NormalSsaInsn toAdd = new NormalSsaInsn ( new PlainInsn ( Rops . opMove ( result . getType ( ) ) , SourcePosition . NO_INFO , result , sources ) , this ) ; insns . add ( getCountPhiInsns ( ) , toAdd ) ; movesFromPhisAtBeginning ++ ; }
public static String toGml ( final IDirectedGraph < ? , ? extends IGraphEdge < ? > > graph ) { Preconditions . checkNotNull ( graph , STRING ) ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING + STRING ) ; int currentId = _NUM ; final Map < Object , Integer > nodeMap = new HashMap < > ( ) ; for ( final Object node : graph . getNodes ( ) ) { sb . append ( STRING + STRING + STRING + STRING ) ; sb . append ( currentId ) ; sb . append ( STRING ) ; sb . append ( node ) ; sb . append ( STRING + STRING ) ; nodeMap . put ( node , currentId ) ; ++ currentId ; } for ( final IGraphEdge < ? > edge : graph . getEdges ( ) ) { sb . append ( STRING + STRING + STRING ) ; sb . append ( nodeMap . get ( edge . getSource ( ) ) ) ; sb . append ( STRING + STRING ) ; sb . append ( nodeMap . get ( edge . getTarget ( ) ) ) ; sb . append ( STRING + STRING + STRING + STRING + STRING + STRING + STRING ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public static String toGml ( final IDirectedGraph < ? , ? extends IGraphEdge < ? > > graph ) { Preconditions . checkNotNull ( graph , STRING ) ; final StringBuilder sb = new StringBuilder ( ) ; sb . append ( STRING + STRING ) ; int currentId = _NUM ; final Map < Object , Integer > nodeMap = new HashMap < > ( ) ; for ( final Object node : graph . getNodes ( ) ) { sb . append ( STRING + STRING + STRING + STRING ) ; sb . append ( currentId ) ; sb . append ( STRING ) ; sb . append ( node ) ; sb . append ( STRING + STRING ) ; nodeMap . put ( node , currentId ) ; ++ currentId ; } for ( final IGraphEdge < ? > edge : graph . getEdges ( ) ) { sb . append ( STRING + STRING + STRING ) ; sb . append ( nodeMap . get ( edge . getSource ( ) ) ) ; sb . append ( STRING + STRING ) ; sb . append ( nodeMap . get ( edge . getTarget ( ) ) ) ; sb . append ( STRING + STRING + STRING + STRING + STRING + STRING + STRING ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public void addCustomSashFormListener ( ICustomSashFormListener listener ) { if ( customSashFormListeners == null ) customSashFormListeners = new ArrayList ( ) ; customSashFormListeners . add ( listener ) ; }
public void addCustomSashFormListener ( ICustomSashFormListener listener ) { if ( customSashFormListeners == null ) customSashFormListeners = new ArrayList ( ) ; customSashFormListeners . add ( listener ) ; }
protected boolean connectInput ( NeuralConnection i , int n ) { if ( ! super . connectInput ( i , n ) ) { return _BOOL ; } m_weights [ m_numInputs ] = m_random . nextDouble ( ) * _NUM - _NUM ; m_changeInWeights [ m_numInputs ] = _NUM ; return _BOOL ; }
protected boolean connectInput ( NeuralConnection i , int n ) { if ( ! super . connectInput ( i , n ) ) { return _BOOL ; } m_weights [ m_numInputs ] = m_random . nextDouble ( ) * _NUM - _NUM ; m_changeInWeights [ m_numInputs ] = _NUM ; return _BOOL ; }
protected boolean connectInput ( NeuralConnection i , int n ) { if ( ! super . connectInput ( i , n ) ) { return _BOOL ; } m_weights [ m_numInputs ] = m_random . nextDouble ( ) * _NUM - _NUM ; m_changeInWeights [ m_numInputs ] = _NUM ; return _BOOL ; }
@ Override public CompletableFuture < Optional < T > > findAny ( ) { return CompletableFuture . supplyAsync ( null , exec ) ; }
public void addKey ( Key key ) { keys . add ( key ) ; }
public BlazeValueFactory valueFactory ( ) { return vf ; }
public BlazeValueFactory valueFactory ( ) { return vf ; }
public void loadClass ( Class < ? > cls ) { try { classLoader . loadClass ( cls . getName ( ) ) ; } catch ( ClassNotFoundException e ) { LogContext . debug ( STRING + cls + STRING ) ; } }
public void loadClass ( Class < ? > cls ) { try { classLoader . loadClass ( cls . getName ( ) ) ; } catch ( ClassNotFoundException e ) { LogContext . debug ( STRING + cls + STRING ) ; } }
public void loadClass ( Class < ? > cls ) { try { classLoader . loadClass ( cls . getName ( ) ) ; } catch ( ClassNotFoundException e ) { LogContext . debug ( STRING + cls + STRING ) ; } }
public void loadClass ( Class < ? > cls ) { try { classLoader . loadClass ( cls . getName ( ) ) ; } catch ( ClassNotFoundException e ) { LogContext . debug ( STRING + cls + STRING ) ; } }
protected StringTemplate ( String str ) { this . string = str ; whole = ( str . length ( ) != _NUM || ! StringUtils . isDelimiter ( str . charAt ( _NUM ) ) ) ; }
InitialImageOperation ( DistributedRegion region , RegionMap entries ) { this . region = region ; this . entries = entries ; }
public boolean deleteShipLoadName ( String load ) { if ( ! _shipLoadList . contains ( load ) ) { return _BOOL ; } _shipLoadList . remove ( load ) ; log . debug ( STRING , getName ( ) , load ) ; setDirtyAndFirePropertyChange ( LOADS_CHANGED_PROPERTY , _shipLoadList . size ( ) + _NUM , _shipLoadList . size ( ) ) ; return _BOOL ; }
public void clearPasswordChangedByRequiredTime ( ) { operations . add ( PasswordPolicyStateOperationType . CLEAR_PASSWORD_CHANGED_BY_REQUIRED_TIME ) ; }
public void clearPasswordChangedByRequiredTime ( ) { operations . add ( PasswordPolicyStateOperationType . CLEAR_PASSWORD_CHANGED_BY_REQUIRED_TIME ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
private void resetAttempts ( ) { for ( final PoliticalActionAttachment paa : PoliticalActionAttachment . getPoliticalActionAttachments ( m_player ) ) { paa . resetAttempts ( getBridge ( ) ) ; } }
private void resetAttempts ( ) { for ( final PoliticalActionAttachment paa : PoliticalActionAttachment . getPoliticalActionAttachments ( m_player ) ) { paa . resetAttempts ( getBridge ( ) ) ; } }
private void resetAttempts ( ) { for ( final PoliticalActionAttachment paa : PoliticalActionAttachment . getPoliticalActionAttachments ( m_player ) ) { paa . resetAttempts ( getBridge ( ) ) ; } }
private void calculateOptimalWidthAndHeight ( ) { if ( state == State . DEFAULT || getWidth ( ) == _NUM ) { return ; } float maxWidth = getWidth ( ) , maxHeight = getHeight ( ) ; float w = pageWidth , h = pageHeight ; float ratio = w / h ; w = maxWidth ; h = ( float ) Math . floor ( maxWidth / ratio ) ; if ( h > maxHeight ) { h = maxHeight ; w = ( float ) Math . floor ( maxHeight * ratio ) ; } optimalPageWidth = w ; optimalPageHeight = h ; }
private void calculateOptimalWidthAndHeight ( ) { if ( state == State . DEFAULT || getWidth ( ) == _NUM ) { return ; } float maxWidth = getWidth ( ) , maxHeight = getHeight ( ) ; float w = pageWidth , h = pageHeight ; float ratio = w / h ; w = maxWidth ; h = ( float ) Math . floor ( maxWidth / ratio ) ; if ( h > maxHeight ) { h = maxHeight ; w = ( float ) Math . floor ( maxHeight * ratio ) ; } optimalPageWidth = w ; optimalPageHeight = h ; }
public static void showMessageBox ( final String message , boolean buttonVisible ) { if ( MESSAGE_BOX == null ) initMessageBox ( ) ; MESSAGE_BOX . setVisible ( _BOOL ) ; MESSAGE_LABEL . setText ( message ) ; MESSAGE_OK_BUTTON . setVisible ( buttonVisible ) ; MESSAGE_BOX . setVisible ( _BOOL ) ; }
public static void showMessageBox ( final String message , boolean buttonVisible ) { if ( MESSAGE_BOX == null ) initMessageBox ( ) ; MESSAGE_BOX . setVisible ( _BOOL ) ; MESSAGE_LABEL . setText ( message ) ; MESSAGE_OK_BUTTON . setVisible ( buttonVisible ) ; MESSAGE_BOX . setVisible ( _BOOL ) ; }
void updateFeatureCounts ( int [ ] translationIds , List < List < RichTranslation < IString , String > > > nbestLists ) { for ( int i = _NUM ; i < translationIds . length ; i ++ ) { Set < String > features = new HashSet < String > ( ) ; for ( RichTranslation < IString , String > trans : nbestLists . get ( i ) ) { for ( FeatureValue < String > f : trans . features ) { features . add ( f . name ) ; } } synchronized ( clippedFeatureIndex ) { for ( String fName : features ) { Set < Integer > ids = clippedFeatureIndex . get ( fName ) ; if ( ids == null ) { ids = new TreeSet < Integer > ( ) ; clippedFeatureIndex . put ( fName , ids ) ; } if ( ids . size ( ) < minFeatureCount ) { ids . add ( translationIds [ i ] ) ; } } } } }
public void reload ( ) { if ( mOriginalGeometry != null ) { if ( ! mOriginalGeometry . isValid ( ) ) { mOriginalGeometry . reload ( ) ; } copyFromGeometry3D ( mOriginalGeometry ) ; } createBuffers ( ) ; }
public void reload ( ) { if ( mOriginalGeometry != null ) { if ( ! mOriginalGeometry . isValid ( ) ) { mOriginalGeometry . reload ( ) ; } copyFromGeometry3D ( mOriginalGeometry ) ; } createBuffers ( ) ; }
public void reload ( ) { if ( mOriginalGeometry != null ) { if ( ! mOriginalGeometry . isValid ( ) ) { mOriginalGeometry . reload ( ) ; } copyFromGeometry3D ( mOriginalGeometry ) ; } createBuffers ( ) ; }
public void reload ( ) { if ( mOriginalGeometry != null ) { if ( ! mOriginalGeometry . isValid ( ) ) { mOriginalGeometry . reload ( ) ; } copyFromGeometry3D ( mOriginalGeometry ) ; } createBuffers ( ) ; }
public void hookupStats ( StatisticsFactory f , String name ) { if ( this . _stats == null ) { this . _stats = f . createAtomicStatistics ( type , name ) ; setLocatorCount ( known_locators . get ( ) ) ; setServerCount ( endpoints_known . get ( ) ) ; setLocatorRequests ( requests_to_locator . get ( ) ) ; setLocatorResponses ( responses_from_locator . get ( ) ) ; setServerLoadUpdates ( serverLoadUpdates . get ( ) ) ; } }
public void hookupStats ( StatisticsFactory f , String name ) { if ( this . _stats == null ) { this . _stats = f . createAtomicStatistics ( type , name ) ; setLocatorCount ( known_locators . get ( ) ) ; setServerCount ( endpoints_known . get ( ) ) ; setLocatorRequests ( requests_to_locator . get ( ) ) ; setLocatorResponses ( responses_from_locator . get ( ) ) ; setServerLoadUpdates ( serverLoadUpdates . get ( ) ) ; } }
public void hookupStats ( StatisticsFactory f , String name ) { if ( this . _stats == null ) { this . _stats = f . createAtomicStatistics ( type , name ) ; setLocatorCount ( known_locators . get ( ) ) ; setServerCount ( endpoints_known . get ( ) ) ; setLocatorRequests ( requests_to_locator . get ( ) ) ; setLocatorResponses ( responses_from_locator . get ( ) ) ; setServerLoadUpdates ( serverLoadUpdates . get ( ) ) ; } }
public boolean isSourceModified ( Resource resource ) { boolean modified = _BOOL ; String fileName = resource . getName ( ) ; String path = ( String ) templatePaths . get ( fileName ) ; File currentFile = null ; for ( int i = _NUM ; currentFile == null && i < paths . size ( ) ; i ++ ) { String testPath = ( String ) paths . get ( i ) ; File testFile = new File ( testPath , fileName ) ; if ( testFile . canRead ( ) ) { currentFile = testFile ; } } File file = new File ( path , fileName ) ; if ( currentFile == null || ! file . exists ( ) ) { } else if ( currentFile . equals ( file ) && file . canRead ( ) ) { modified = ( file . lastModified ( ) != resource . getLastModified ( ) ) ; } return modified ; }
public void tagDefineTextField ( int fieldId , String fieldName , String initialText , Rect boundary , int flags , AlphaColor textColor , int alignment , int fontId , int fontSize , int charLimit , int leftMargin , int rightMargin , int indentation , int lineSpacing ) throws IOException { if ( initialText != null ) { output . println ( initialText ) ; } }
public void tagDefineTextField ( int fieldId , String fieldName , String initialText , Rect boundary , int flags , AlphaColor textColor , int alignment , int fontId , int fontSize , int charLimit , int leftMargin , int rightMargin , int indentation , int lineSpacing ) throws IOException { if ( initialText != null ) { output . println ( initialText ) ; } }
public static void recycleNodes ( Collection < AccessibilityNodeInfoCompat > nodes ) { if ( nodes == null ) { return ; } for ( AccessibilityNodeInfoCompat node : nodes ) { if ( node != null ) { node . recycle ( ) ; } } nodes . clear ( ) ; }
private boolean disconnect ( ) { if ( ! done ) { debug ( STRING ) ; } boolean clean = _BOOL ; debug ( STRING ) ; debug ( STRING ) ; put ( new Event ( EType . KILLSENDER ) ) ; while ( sendingThread != null && sendingThread . isAlive ( ) ) { try { sendingThread . join ( ) ; } catch ( InterruptedException e ) { } } try { pclient . shutdownInput ( ) ; pclient . shutdownOutput ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = _BOOL ; } try { oos . close ( ) ; ois . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = _BOOL ; } try { pclient . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = _BOOL ; } if ( isServer ) { try { pserver . close ( ) ; debug ( STRING ) ; } catch ( Exception e ) { clean = _BOOL ; } } ois = null ; oos = null ; pclient = null ; pserver = null ; debug ( clean ? STRING : STRING ) ; return clean ; }
public static String encodePassword ( String password , String algorithm ) { byte [ ] unencodedPassword = password . getBytes ( ) ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( algorithm ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; return password ; } md . reset ( ) ; md . update ( unencodedPassword ) ; byte [ ] encodedPassword = md . digest ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( byte anEncodedPassword : encodedPassword ) { if ( ( anEncodedPassword & _NUM ) < _NUM ) { buf . append ( STRING ) ; } buf . append ( Long . toString ( anEncodedPassword & _NUM , _NUM ) ) ; } return buf . toString ( ) ; }
public static String encodePassword ( String password , String algorithm ) { byte [ ] unencodedPassword = password . getBytes ( ) ; MessageDigest md = null ; try { md = MessageDigest . getInstance ( algorithm ) ; } catch ( Exception e ) { log . error ( STRING + e ) ; return password ; } md . reset ( ) ; md . update ( unencodedPassword ) ; byte [ ] encodedPassword = md . digest ( ) ; StringBuffer buf = new StringBuffer ( ) ; for ( byte anEncodedPassword : encodedPassword ) { if ( ( anEncodedPassword & _NUM ) < _NUM ) { buf . append ( STRING ) ; } buf . append ( Long . toString ( anEncodedPassword & _NUM , _NUM ) ) ; } return buf . toString ( ) ; }
public int generate ( byte [ ] output , byte [ ] additionalInput , boolean predictionResistant ) { int numberOfBits = output . length * _NUM ; if ( numberOfBits > MAX_BITS_REQUEST ) { throw new IllegalArgumentException ( STRING + MAX_BITS_REQUEST ) ; } if ( _reseedCounter > RESEED_MAX ) { return - _NUM ; } if ( predictionResistant ) { reseed ( additionalInput ) ; additionalInput = null ; } if ( additionalInput != null ) { hmac_DRBG_Update ( additionalInput ) ; } byte [ ] rv = new byte [ output . length ] ; int m = output . length / _V . length ; _hMac . init ( new KeyParameter ( _K ) ) ; for ( int i = _NUM ; i < m ; i ++ ) { _hMac . update ( _V , _NUM , _V . length ) ; _hMac . doFinal ( _V , _NUM ) ; System . arraycopy ( _V , _NUM , rv , i * _V . length , _V . length ) ; } if ( m * _V . length < rv . length ) { _hMac . update ( _V , _NUM , _V . length ) ; _hMac . doFinal ( _V , _NUM ) ; System . arraycopy ( _V , _NUM , rv , m * _V . length , rv . length - ( m * _V . length ) ) ; } hmac_DRBG_Update ( additionalInput ) ; _reseedCounter ++ ; System . arraycopy ( rv , _NUM , output , _NUM , output . length ) ; return numberOfBits ; }
public SSLSocketFactory buildSSLSocketFactory ( ) throws KeyStoreException { SSLContext sslContext = null ; try { KeyManagerFactory keyManagerFactory = KeyManagerFactory . getInstance ( KeyManagerFactory . getDefaultAlgorithm ( ) ) ; keyManagerFactory . init ( keyStore , SSL_KEYSTORE_SECRET ) ; KeyManager [ ] keyManagers = keyManagerFactory . getKeyManagers ( ) ; TrustManager [ ] trustManagers = new TrustManager [ ] { createTrustManagerFromDefaultJDKTrustStore ( ) } ; sslContext = SSLContext . getInstance ( STRING ) ; sslContext . init ( keyManagers , trustManagers , null ) ; SSLContext . setDefault ( sslContext ) ; } catch ( GeneralSecurityException | IOException e ) { throw new KeyStoreException ( STRING , e ) ; } return sslContext . getSocketFactory ( ) ; }
private String computeReplacementString ( ) { int proposalKind = fProposal . getKind ( ) ; String qualifiedTypeName = null ; char [ ] qualifiedType = null ; if ( proposalKind == CompletionProposal . TYPE_IMPORT ) { qualifiedType = fProposal . getSignature ( ) ; qualifiedTypeName = String . valueOf ( Signature . toCharArray ( qualifiedType ) ) ; } else if ( proposalKind == CompletionProposal . METHOD_IMPORT || proposalKind == CompletionProposal . FIELD_IMPORT ) { qualifiedType = Signature . getTypeErasure ( fProposal . getDeclarationSignature ( ) ) ; qualifiedTypeName = String . valueOf ( Signature . toCharArray ( qualifiedType ) ) ; } else { Assert . isTrue ( _BOOL ) ; } fImportRewrite = createImportRewrite ( ) ; if ( fImportRewrite != null ) { if ( proposalKind == CompletionProposal . TYPE_IMPORT ) { String simpleType = fImportRewrite . addImport ( qualifiedTypeName , fImportContext ) ; if ( fParentProposalKind == CompletionProposal . METHOD_REF ) { return simpleType + STRING ; } } else { String res = fImportRewrite . addStaticImport ( qualifiedTypeName , String . valueOf ( fProposal . getName ( ) ) , proposalKind == CompletionProposal . FIELD_IMPORT , fImportContext ) ; int dot = res . lastIndexOf ( STRING ) ; if ( dot != - _NUM ) { String typeName = fImportRewrite . addImport ( res . substring ( _NUM , dot ) , fImportContext ) ; return typeName + STRING ; } } return STRING ; } return qualifiedTypeName + STRING ; }
@ SuppressWarnings ( STRING ) public synchronized Object handleData ( Map data , int action , boolean allowChildEvents ) { Object result = null ; if ( data . containsKey ( getKeyAttribute ( ) ) ) { boolean oldAllowEvents = allowEvents ; allowEvents = allowChildEvents ; ProcessVar dataset = ( ProcessVar ) get ( data . get ( getKeyAttribute ( ) ) ) ; if ( dataset == null ) { dataset = new ProcessVar ( ) ; dataset . setKeyAttribute ( getKeyAttribute ( ) ) ; } dataset . putAll ( data , action , allowChildEvents ) ; allowEvents = oldAllowEvents ; result = put ( dataset . getKeyValue ( ) , dataset , action ) ; } return ( result ) ; }
@ SuppressWarnings ( STRING ) public synchronized Object handleData ( Map data , int action , boolean allowChildEvents ) { Object result = null ; if ( data . containsKey ( getKeyAttribute ( ) ) ) { boolean oldAllowEvents = allowEvents ; allowEvents = allowChildEvents ; ProcessVar dataset = ( ProcessVar ) get ( data . get ( getKeyAttribute ( ) ) ) ; if ( dataset == null ) { dataset = new ProcessVar ( ) ; dataset . setKeyAttribute ( getKeyAttribute ( ) ) ; } dataset . putAll ( data , action , allowChildEvents ) ; allowEvents = oldAllowEvents ; result = put ( dataset . getKeyValue ( ) , dataset , action ) ; } return ( result ) ; }
private VariableReference addPrimitive ( TestCase test , PrimitiveStatement < ? > old , int position ) throws ConstructionFailedException { logger . debug ( STRING ) ; Statement st = old . clone ( test ) ; return test . addStatement ( st , position ) ; }
private VariableReference addPrimitive ( TestCase test , PrimitiveStatement < ? > old , int position ) throws ConstructionFailedException { logger . debug ( STRING ) ; Statement st = old . clone ( test ) ; return test . addStatement ( st , position ) ; }
public PlainTextConverter ( ) { SimpleWikiConfiguration config = null ; try { config = new SimpleWikiConfiguration ( WikiConstants . SWEBLE_CONFIG ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( JAXBException e ) { e . printStackTrace ( ) ; } this . config = config ; this . wrapCol = Integer . MAX_VALUE ; this . enumerateSections = _BOOL ; }
public PlainTextConverter ( ) { SimpleWikiConfiguration config = null ; try { config = new SimpleWikiConfiguration ( WikiConstants . SWEBLE_CONFIG ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } catch ( JAXBException e ) { e . printStackTrace ( ) ; } this . config = config ; this . wrapCol = Integer . MAX_VALUE ; this . enumerateSections = _BOOL ; }
@ SuppressWarnings ( STRING ) private String nextLiteral ( boolean assignOffsetsOnly ) throws IOException { StringBuilder builder = null ; valuePos = - _NUM ; valueLength = _NUM ; int i = _NUM ; findNonLiteralCharacter : while ( _BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : checkLenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break findNonLiteralCharacter ; } } if ( i < buffer . length ) { if ( fillBuffer ( i + _NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , pos , i ) ; valueLength += i ; pos += i ; i = _NUM ; if ( ! fillBuffer ( _NUM ) ) { break ; } } String result ; if ( assignOffsetsOnly && builder == null ) { valuePos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = stringPool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . toString ( ) ; } valueLength += i ; pos += i ; return result ; }
@ SuppressWarnings ( STRING ) private String nextLiteral ( boolean assignOffsetsOnly ) throws IOException { StringBuilder builder = null ; valuePos = - _NUM ; valueLength = _NUM ; int i = _NUM ; findNonLiteralCharacter : while ( _BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : checkLenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break findNonLiteralCharacter ; } } if ( i < buffer . length ) { if ( fillBuffer ( i + _NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , pos , i ) ; valueLength += i ; pos += i ; i = _NUM ; if ( ! fillBuffer ( _NUM ) ) { break ; } } String result ; if ( assignOffsetsOnly && builder == null ) { valuePos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = stringPool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . toString ( ) ; } valueLength += i ; pos += i ; return result ; }
@ SuppressWarnings ( STRING ) private String nextLiteral ( boolean assignOffsetsOnly ) throws IOException { StringBuilder builder = null ; valuePos = - _NUM ; valueLength = _NUM ; int i = _NUM ; findNonLiteralCharacter : while ( _BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : checkLenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break findNonLiteralCharacter ; } } if ( i < buffer . length ) { if ( fillBuffer ( i + _NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , pos , i ) ; valueLength += i ; pos += i ; i = _NUM ; if ( ! fillBuffer ( _NUM ) ) { break ; } } String result ; if ( assignOffsetsOnly && builder == null ) { valuePos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = stringPool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . toString ( ) ; } valueLength += i ; pos += i ; return result ; }
@ SuppressWarnings ( STRING ) private String nextLiteral ( boolean assignOffsetsOnly ) throws IOException { StringBuilder builder = null ; valuePos = - _NUM ; valueLength = _NUM ; int i = _NUM ; findNonLiteralCharacter : while ( _BOOL ) { for ( ; pos + i < limit ; i ++ ) { switch ( buffer [ pos + i ] ) { case STRING : case STRING : case STRING : case STRING : case STRING : checkLenient ( ) ; case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : case STRING : break findNonLiteralCharacter ; } } if ( i < buffer . length ) { if ( fillBuffer ( i + _NUM ) ) { continue ; } else { buffer [ limit ] = STRING ; break ; } } if ( builder == null ) { builder = new StringBuilder ( ) ; } builder . append ( buffer , pos , i ) ; valueLength += i ; pos += i ; i = _NUM ; if ( ! fillBuffer ( _NUM ) ) { break ; } } String result ; if ( assignOffsetsOnly && builder == null ) { valuePos = pos ; result = null ; } else if ( skipping ) { result = STRING ; } else if ( builder == null ) { result = stringPool . get ( buffer , pos , i ) ; } else { builder . append ( buffer , pos , i ) ; result = builder . toString ( ) ; } valueLength += i ; pos += i ; return result ; }
protected int inverseTranslateRow ( int row ) { if ( enabled ) { return Arrays . binarySearch ( rowMap , row ) ; } else { return row ; } }
@ Override public boolean isFileModified ( long fileTimeStamp , long endOffset ) { boolean isFileModified = _BOOL ; if ( getLastModifiedTime ( ) > fileTimeStamp || getSize ( ) > endOffset ) { isFileModified = _BOOL ; } return isFileModified ; }
public void addFeatureProcessor ( String name , FeatureProcessor fp ) { featureProcessors . put ( name , fp ) ; }
public static String [ ] splitStringIntoArray ( String value ) { String [ ] values = new String [ _NUM ] ; if ( value != null && value . length ( ) > _NUM ) { if ( value . indexOf ( CIMConstants . COMMA_SEPERATOR ) != - _NUM ) { values = value . split ( STRING ) ; } else { values = new String [ _NUM ] ; values [ _NUM ] = value ; } } return values ; }
public static String [ ] splitStringIntoArray ( String value ) { String [ ] values = new String [ _NUM ] ; if ( value != null && value . length ( ) > _NUM ) { if ( value . indexOf ( CIMConstants . COMMA_SEPERATOR ) != - _NUM ) { values = value . split ( STRING ) ; } else { values = new String [ _NUM ] ; values [ _NUM ] = value ; } } return values ; }
Rules ( Workspace workspace ) { this . root = workspace . getRoot ( ) ; this . teamHook = workspace . getTeamHook ( ) ; workspace . addLifecycleListener ( this ) ; }
final public static boolean isMultibyteCharset ( String javaEncodingName ) { return MULTIBYTE_ENCODINGS . contains ( javaEncodingName . toUpperCase ( Locale . ENGLISH ) ) ; }
private boolean isDateFormatString ( String string ) { if ( string . length ( ) < _NUM ) { return _BOOL ; } final int strLength = string . length ( ) ; final char startChar = string . charAt ( _NUM ) ; final char endChar = string . charAt ( strLength - _NUM ) ; if ( startChar == STRING || endChar == STRING ) { return _BOOL ; } else if ( Character . isLetter ( startChar ) && string . charAt ( _NUM ) == STRING ) { return _BOOL ; } final Matcher dateFormatMatcher = DATE_FORMAT_PATTERN . matcher ( string ) ; return dateFormatMatcher . find ( ) ; }
public void connect ( ) { connect ( this . logWriter ) ; }
public DD pow ( int exp ) { if ( exp == _NUM ) return valueOf ( _NUM ) ; DD r = new DD ( this ) ; DD s = valueOf ( _NUM ) ; int n = Math . abs ( exp ) ; if ( n > _NUM ) { while ( n > _NUM ) { if ( n % _NUM == _NUM ) { s . selfMultiply ( r ) ; } n /= _NUM ; if ( n > _NUM ) r = r . sqr ( ) ; } } else { s = r ; } if ( exp < _NUM ) return s . reciprocal ( ) ; return s ; }
public DD pow ( int exp ) { if ( exp == _NUM ) return valueOf ( _NUM ) ; DD r = new DD ( this ) ; DD s = valueOf ( _NUM ) ; int n = Math . abs ( exp ) ; if ( n > _NUM ) { while ( n > _NUM ) { if ( n % _NUM == _NUM ) { s . selfMultiply ( r ) ; } n /= _NUM ; if ( n > _NUM ) r = r . sqr ( ) ; } } else { s = r ; } if ( exp < _NUM ) return s . reciprocal ( ) ; return s ; }
public WallForce ( float gravConst , float x1 , float y1 , float x2 , float y2 ) { params = new float [ ] { gravConst } ; minValues = new float [ ] { DEFAULT_MIN_GRAV_CONSTANT } ; maxValues = new float [ ] { DEFAULT_MAX_GRAV_CONSTANT } ; this . x1 = x1 ; this . y1 = y1 ; this . x2 = x2 ; this . y2 = y2 ; dx = x2 - x1 ; dy = y2 - y1 ; float r = ( float ) Math . sqrt ( dx * dx + dy * dy ) ; if ( dx != _NUM ) dx /= r ; if ( dy != _NUM ) dy /= r ; }
public ID3v23Frame ( ByteBuffer byteBuffer , String loggingFilename ) throws InvalidFrameException , InvalidDataTypeException { setLoggingFilename ( loggingFilename ) ; read ( byteBuffer ) ; }
public static String computeQualifiedWidgetTypeName ( Node widgetNode ) { if ( widgetNode . getNodeType ( ) != Node . ELEMENT_NODE ) { return null ; } String typeName = widgetNode . getLocalName ( ) ; if ( typeName . length ( ) == _NUM || Character . isLowerCase ( typeName . charAt ( _NUM ) ) ) { return null ; } String packageName = UiBinderUtilities . getPackageName ( widgetNode . getNamespaceURI ( ) ) ; return packageName != null ? JavaUtilities . getQualifiedTypeName ( typeName , packageName ) : null ; }
public Expirer ( ) { expirerThread = new Thread ( this , STRING + expirerCount ++ ) ; expirerThread . setDaemon ( _BOOL ) ; }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
protected void ensureRouteConsecutivity ( ) { boolean deAllocateRestOfRoute = _BOOL ; for ( int i = _idxCurrentOrder + _NUM ; i < _orders . size ( ) ; i ++ ) { log . debug ( _trainName + STRING + i ) ; BlockOrder bo = getBlockOrderAt ( i ) ; OBlock block = bo . getBlock ( ) ; if ( ! block . isAllocatedTo ( this ) || ( block . getState ( ) & OBlock . OCCUPIED ) != _NUM ) { deAllocateRestOfRoute = _BOOL ; } if ( deAllocateRestOfRoute ) { if ( block . isAllocatedTo ( this ) ) { log . info ( _trainName + STRING + block . getDisplayName ( ) + STRING ) ; block . deAllocate ( this ) ; } } } }
public static UUID timeBased ( ) { return new UUID ( makeMSB ( getCurrentTimestamp ( ) ) , CLOCK_SEQ_AND_NODE ) ; }
public boolean isEmpty ( ) { return filter . isEmpty ( ) && query . isEmpty ( ) && sort . isEmpty ( ) ; }
public boolean isEmpty ( ) { return filter . isEmpty ( ) && query . isEmpty ( ) && sort . isEmpty ( ) ; }
public boolean isEmpty ( ) { return filter . isEmpty ( ) && query . isEmpty ( ) && sort . isEmpty ( ) ; }
public boolean isEmpty ( ) { return filter . isEmpty ( ) && query . isEmpty ( ) && sort . isEmpty ( ) ; }
public void drawString ( final Graphics g , final JComponent c , final String text , final int underlinedChar , final int x , final int y , final boolean isEnabled , final boolean isSelected ) { char lc , uc ; int index = - _NUM , lci , uci ; if ( underlinedChar != STRING ) { uc = Character . toUpperCase ( ( char ) underlinedChar ) ; lc = Character . toLowerCase ( ( char ) underlinedChar ) ; uci = text . indexOf ( uc ) ; lci = text . indexOf ( lc ) ; if ( uci == - _NUM ) index = lci ; else if ( lci == - _NUM ) index = uci ; else index = ( lci < uci ) ? lci : uci ; } SwingUtilities2 . drawStringUnderlineCharAt ( c , g , text , index , x , y ) ; }
public void drawString ( final Graphics g , final JComponent c , final String text , final int underlinedChar , final int x , final int y , final boolean isEnabled , final boolean isSelected ) { char lc , uc ; int index = - _NUM , lci , uci ; if ( underlinedChar != STRING ) { uc = Character . toUpperCase ( ( char ) underlinedChar ) ; lc = Character . toLowerCase ( ( char ) underlinedChar ) ; uci = text . indexOf ( uc ) ; lci = text . indexOf ( lc ) ; if ( uci == - _NUM ) index = lci ; else if ( lci == - _NUM ) index = uci ; else index = ( lci < uci ) ? lci : uci ; } SwingUtilities2 . drawStringUnderlineCharAt ( c , g , text , index , x , y ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
private void log ( LogEntryType type , String tag , String message ) { if ( type . ordinal ( ) >= mLogLevel . ordinal ( ) ) { LogEntry logEntry = new LogEntry ( type , tag , message ) ; logEntry . writeToLogCat ( ) ; mEntryList . add ( logEntry ) ; } }
private double distanceD2 ( double [ ] f , double d1 ) { return Math . sqrt ( Math . pow ( normVector ( f ) , _NUM ) - Math . pow ( d1 , _NUM ) ) ; }
@ Override public final String toString ( ) { StringBuilder cab = new StringBuilder ( _NUM + getHopCount ( ) * _NUM ) ; cab . append ( STRING ) ; if ( this . localAddress != null ) { cab . append ( this . localAddress ) ; cab . append ( STRING ) ; } cab . append ( STRING ) ; if ( this . tunnelled == TunnelType . TUNNELLED ) cab . append ( STRING ) ; if ( this . layered == LayerType . LAYERED ) cab . append ( STRING ) ; if ( this . secure ) cab . append ( STRING ) ; cab . append ( STRING ) ; if ( this . proxyChain != null ) { for ( HttpHost aProxyChain : this . proxyChain ) { cab . append ( aProxyChain ) ; cab . append ( STRING ) ; } } cab . append ( this . targetHost ) ; cab . append ( STRING ) ; return cab . toString ( ) ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( self ) ; set ( cal , updates ) ; return cal . getTime ( ) ; }
public static Date updated ( Date self , Map < Object , Integer > updates ) { Calendar cal = Calendar . getInstance ( ) ; cal . setTime ( self ) ; set ( cal , updates ) ; return cal . getTime ( ) ; }
protected final void unregisterDataSource ( DataSource removed ) { unregisterDataSources ( Collections . singleton ( removed ) ) ; }
public static String delI ( String id ) { return TestHarness . deleteById ( id ) ; }
public int receiveFromDataSocket ( byte [ ] buf ) { int bytesRead ; if ( dataSocket == null ) { Log . i ( TAG , STRING ) ; return - _NUM ; } if ( ! dataSocket . isConnected ( ) ) { Log . i ( TAG , STRING ) ; return - _NUM ; } InputStream in ; try { in = dataSocket . getInputStream ( ) ; while ( ( bytesRead = in . read ( buf , _NUM , buf . length ) ) == _NUM ) { } if ( bytesRead == - _NUM ) { return - _NUM ; } } catch ( IOException e ) { Log . i ( TAG , STRING ) ; return _NUM ; } localDataSocket . reportTraffic ( bytesRead ) ; return bytesRead ; }
public int receiveFromDataSocket ( byte [ ] buf ) { int bytesRead ; if ( dataSocket == null ) { Log . i ( TAG , STRING ) ; return - _NUM ; } if ( ! dataSocket . isConnected ( ) ) { Log . i ( TAG , STRING ) ; return - _NUM ; } InputStream in ; try { in = dataSocket . getInputStream ( ) ; while ( ( bytesRead = in . read ( buf , _NUM , buf . length ) ) == _NUM ) { } if ( bytesRead == - _NUM ) { return - _NUM ; } } catch ( IOException e ) { Log . i ( TAG , STRING ) ; return _NUM ; } localDataSocket . reportTraffic ( bytesRead ) ; return bytesRead ; }
public void addNewSpawnMap ( SpawnMap spawnMap ) { if ( templates == null ) { templates = new ArrayList < SpawnMap > ( ) ; } templates . add ( spawnMap ) ; }
public void addNewSpawnMap ( SpawnMap spawnMap ) { if ( templates == null ) { templates = new ArrayList < SpawnMap > ( ) ; } templates . add ( spawnMap ) ; }
public static void createPath ( String path , boolean mustCreate ) throws IOException { File fpath = new File ( path ) ; if ( fpath . exists ( ) && mustCreate ) throw new IOException ( path + STRING ) ; else if ( ! fpath . mkdirs ( ) ) throw new IOException ( STRING + path ) ; }
public void addExceptionMessage ( ExceptionMessage exceptionMessage ) { m_exceptionMessages . addElement ( exceptionMessage ) ; Enumeration < ExceptionContext > enumeration ; enumeration = m_exceptionContexts . elements ( ) ; while ( enumeration . hasMoreElements ( ) ) { addExceptionContext ( enumeration . nextElement ( ) ) ; } }
protected void CreateCharset ( OffsetItem charsetRef , int nglyphs ) { OutputList . addLast ( new MarkerItem ( charsetRef ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) ( nglyphs - _NUM ) ) ) ; }
protected void CreateCharset ( OffsetItem charsetRef , int nglyphs ) { OutputList . addLast ( new MarkerItem ( charsetRef ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) ( nglyphs - _NUM ) ) ) ; }
protected void CreateCharset ( OffsetItem charsetRef , int nglyphs ) { OutputList . addLast ( new MarkerItem ( charsetRef ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) ( nglyphs - _NUM ) ) ) ; }
protected void CreateCharset ( OffsetItem charsetRef , int nglyphs ) { OutputList . addLast ( new MarkerItem ( charsetRef ) ) ; OutputList . addLast ( new UInt8Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) _NUM ) ) ; OutputList . addLast ( new UInt16Item ( ( char ) ( nglyphs - _NUM ) ) ) ; }
public Itinerary ( StreetSegment streetSegment , int accessIndex , ZonedDateTime fromTimeDateZD ) { transfers = _NUM ; waitingTime = _NUM ; walkTime = duration = streetSegment . duration ; distance = streetSegment . distance ; transitTime = _NUM ; startTime = fromTimeDateZD ; endTime = fromTimeDateZD . plusSeconds ( streetSegment . duration ) ; PointToPointConnection pointToPointConnection = new PointToPointConnection ( accessIndex ) ; connection = pointToPointConnection ; }
public Itinerary ( StreetSegment streetSegment , int accessIndex , ZonedDateTime fromTimeDateZD ) { transfers = _NUM ; waitingTime = _NUM ; walkTime = duration = streetSegment . duration ; distance = streetSegment . distance ; transitTime = _NUM ; startTime = fromTimeDateZD ; endTime = fromTimeDateZD . plusSeconds ( streetSegment . duration ) ; PointToPointConnection pointToPointConnection = new PointToPointConnection ( accessIndex ) ; connection = pointToPointConnection ; }
private static boolean isRetina ( ) { if ( SystemInfo . isAppleJvm ) { return hasAppleRetinaDevice ( ) ; } if ( SystemInfo . isMac ) { GraphicsEnvironment e = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = e . getScreenDevices ( ) ; for ( GraphicsDevice device : devices ) { if ( isOracleMacRetinaDevice ( device ) ) { return _BOOL ; } } } return _BOOL ; }
private static boolean isRetina ( ) { if ( SystemInfo . isAppleJvm ) { return hasAppleRetinaDevice ( ) ; } if ( SystemInfo . isMac ) { GraphicsEnvironment e = GraphicsEnvironment . getLocalGraphicsEnvironment ( ) ; GraphicsDevice [ ] devices = e . getScreenDevices ( ) ; for ( GraphicsDevice device : devices ) { if ( isOracleMacRetinaDevice ( device ) ) { return _BOOL ; } } } return _BOOL ; }
protected static < T > void addItems ( Collection < T > collection , T [ ] elements ) { if ( elements != null ) { for ( T element : elements ) { collection . add ( element ) ; } } }
public Iterator < F > filterIterator ( ) { return new IteratorWrapper ( mFilters . iterator ( ) ) ; }
public Iterator < F > filterIterator ( ) { return new IteratorWrapper ( mFilters . iterator ( ) ) ; }
public Observable < Api . Info > info ( String username ) { return api . info ( username , null ) ; }
public final void tryClaimDraw ( String str ) { if ( str . startsWith ( STRING ) ) { String drawCmd = str . substring ( str . indexOf ( STRING ) + _NUM ) ; handleDrawCmd ( drawCmd , _BOOL ) ; } }
public final void tryClaimDraw ( String str ) { if ( str . startsWith ( STRING ) ) { String drawCmd = str . substring ( str . indexOf ( STRING ) + _NUM ) ; handleDrawCmd ( drawCmd , _BOOL ) ; } }
public final void tryClaimDraw ( String str ) { if ( str . startsWith ( STRING ) ) { String drawCmd = str . substring ( str . indexOf ( STRING ) + _NUM ) ; handleDrawCmd ( drawCmd , _BOOL ) ; } }
public FileWriteStream ( FileOutputStream fos ) { super ( null , fos ) ; _os = fos ; }
public void addSubscription ( String subscriptionChannel , int streamId , FragmentHandler fragmentHandler ) { if ( ! hasSubscriptionForChannel ( subscriptionChannel ) ) { debug ( STRING , subscriptionChannel ) ; Subscription subscription = aeron . addSubscription ( subscriptionChannel , streamId ) ; debug ( STRING , subscriptionChannel ) ; SubscriptionGroup subscriptionGroup = new SubscriptionGroup ( subscriptionChannel , subscription , fragmentHandler ) ; subscriptionGroups . add ( subscriptionGroup ) ; debug ( STRING , subscriptionChannel ) ; } else { debug ( STRING , subscriptionChannel ) ; } }
private void addToCircleOfTrust ( BaseConfigType config , String realm , String entityId ) { String classMethod = STRING ; try { if ( config != null ) { Map attr = IDFFMetaUtils . getAttributes ( config ) ; List cotAttr = ( List ) attr . get ( COTConstants . COT_LIST ) ; List cotList = new ArrayList ( cotAttr ) ; if ( ( cotList != null ) && ! cotList . isEmpty ( ) ) { for ( Iterator iter = cotList . iterator ( ) ; iter . hasNext ( ) ; ) { String cotName = ( String ) iter . next ( ) ; try { cotManager . addCircleOfTrustMember ( realm , cotName , COTConstants . IDFF , entityId ) ; } catch ( COTException ce ) { debug . error ( classMethod + cotName + STRING ) ; } } } } } catch ( Exception e ) { debug . error ( classMethod + STRING + entityId + STRING , e ) ; } }
public int addMissingColumns ( MPrintFormat pf ) { log . config ( pf . toString ( ) ) ; String sql = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; PreparedStatement pstmt = null ; ResultSet rs = null ; int counter = _NUM ; try { pstmt = DB . prepareStatement ( sql , pf . get_TrxName ( ) ) ; pstmt . setInt ( _NUM , pf . getAD_PrintFormat_ID ( ) ) ; pstmt . setInt ( _NUM , pf . getAD_Table_ID ( ) ) ; rs = pstmt . executeQuery ( ) ; while ( rs . next ( ) ) { int AD_Column_ID = rs . getInt ( _NUM ) ; String ColumnName = rs . getString ( _NUM ) ; MPrintFormatItem pfi = MPrintFormatItem . createFromColumn ( pf , AD_Column_ID , _NUM ) ; if ( pfi . get_ID ( ) != _NUM ) log . fine ( STRING + ++ counter + STRING + ColumnName ) ; else log . warning ( STRING + ColumnName ) ; } } catch ( Exception e ) { log . log ( Level . SEVERE , sql , e ) ; } finally { DB . close ( rs , pstmt ) ; rs = null ; pstmt = null ; } if ( counter == _NUM ) log . fine ( STRING ) ; else log . fine ( STRING + counter ) ; return counter ; }
public JarClassLoader [ ] deploy ( final String jarNames [ ] , final byte [ ] [ ] jarBytes ) throws IOException , ClassNotFoundException { JarClassLoader [ ] jarClassLoaders = new JarClassLoader [ jarNames . length ] ; verifyWritableDeployDirectory ( ) ; lock . lock ( ) ; try { for ( int i = _NUM ; i < jarNames . length ; i ++ ) { if ( ! JarClassLoader . isValidJarContent ( jarBytes [ i ] ) ) { throw new IllegalArgumentException ( STRING + jarNames [ i ] ) ; } } for ( int i = _NUM ; i < jarNames . length ; i ++ ) { jarClassLoaders [ i ] = deployWithoutRegistering ( jarNames [ i ] , jarBytes [ i ] ) ; } for ( JarClassLoader jarClassLoader : jarClassLoaders ) { if ( jarClassLoader != null ) { jarClassLoader . loadClassesAndRegisterFunctions ( ) ; } } } finally { lock . unlock ( ) ; } return jarClassLoaders ; }
public final boolean execute ( ) throws SQLException { return m_ps . execute ( ) ; }
private void addToSet ( ObjectXmlPersist persist , IFile file , String setName ) throws IOException , CoreException { Collection < GraphEdgeMatcherDescriptor > updateSet = loadEdgeMatchers ( persist , file ) ; persistUpdatedBundle ( persist , file , updateSet , setName ) ; }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public static Object normalizeIntAndLongValues ( String data , DataType actualDataType ) { if ( null == data ) { return null ; } try { Object parsedValue = null ; switch ( actualDataType ) { case INT : parsedValue = Integer . parseInt ( data ) ; break ; case LONG : parsedValue = Long . parseLong ( data ) ; break ; default : return data ; } if ( null != parsedValue ) { return data ; } return null ; } catch ( NumberFormatException ex ) { return null ; } }
public Iterable < Notification > skip ( @ Nonnull final Iterable < Notification > notifications , final long startId , final boolean inclusive , final int limitSize ) { Objects . requireNonNull ( notifications ) ; final int position = indexOf ( notifications , startId ) ; if ( position == - _NUM ) { return Iterables . limit ( notifications , limitSize ) ; } if ( inclusive ) { return Iterables . limit ( Iterables . skip ( notifications , position ) , limitSize ) ; } return Iterables . limit ( Iterables . skip ( notifications , position + _NUM ) , limitSize ) ; }
public StatementMetric [ ] flushMetrics ( ) { rwLock . acquireWriteLock ( ) ; try { boolean isEmpty = _BOOL ; if ( currentLastElement == - _NUM ) { isEmpty = _BOOL ; } if ( isReportInactive ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( statementNames [ i ] != null ) { metrics [ i ] = new StatementMetric ( engineURI , statementNames [ i ] ) ; } } } if ( ( currentLastElement > - _NUM ) && ( ! removedStatementNames . isEmpty ( ) ) ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( removedStatementNames . contains ( statementNames [ i ] ) ) { statementNames [ i ] = null ; } } } while ( ( currentLastElement != - _NUM ) && ( statementNames [ currentLastElement ] == null ) ) { currentLastElement -- ; } if ( isEmpty ) { return null ; } StatementMetric [ ] newMetrics = new StatementMetric [ metrics . length ] ; StatementMetric [ ] oldMetrics = metrics ; metrics = newMetrics ; return oldMetrics ; } finally { rwLock . releaseWriteLock ( ) ; } }
public StatementMetric [ ] flushMetrics ( ) { rwLock . acquireWriteLock ( ) ; try { boolean isEmpty = _BOOL ; if ( currentLastElement == - _NUM ) { isEmpty = _BOOL ; } if ( isReportInactive ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( statementNames [ i ] != null ) { metrics [ i ] = new StatementMetric ( engineURI , statementNames [ i ] ) ; } } } if ( ( currentLastElement > - _NUM ) && ( ! removedStatementNames . isEmpty ( ) ) ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( removedStatementNames . contains ( statementNames [ i ] ) ) { statementNames [ i ] = null ; } } } while ( ( currentLastElement != - _NUM ) && ( statementNames [ currentLastElement ] == null ) ) { currentLastElement -- ; } if ( isEmpty ) { return null ; } StatementMetric [ ] newMetrics = new StatementMetric [ metrics . length ] ; StatementMetric [ ] oldMetrics = metrics ; metrics = newMetrics ; return oldMetrics ; } finally { rwLock . releaseWriteLock ( ) ; } }
public StatementMetric [ ] flushMetrics ( ) { rwLock . acquireWriteLock ( ) ; try { boolean isEmpty = _BOOL ; if ( currentLastElement == - _NUM ) { isEmpty = _BOOL ; } if ( isReportInactive ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( statementNames [ i ] != null ) { metrics [ i ] = new StatementMetric ( engineURI , statementNames [ i ] ) ; } } } if ( ( currentLastElement > - _NUM ) && ( ! removedStatementNames . isEmpty ( ) ) ) { for ( int i = _NUM ; i <= currentLastElement ; i ++ ) { if ( removedStatementNames . contains ( statementNames [ i ] ) ) { statementNames [ i ] = null ; } } } while ( ( currentLastElement != - _NUM ) && ( statementNames [ currentLastElement ] == null ) ) { currentLastElement -- ; } if ( isEmpty ) { return null ; } StatementMetric [ ] newMetrics = new StatementMetric [ metrics . length ] ; StatementMetric [ ] oldMetrics = metrics ; metrics = newMetrics ; return oldMetrics ; } finally { rwLock . releaseWriteLock ( ) ; } }
protected Properties createProperties ( URL location ) throws IOException { InputStream is = null ; if ( location != null ) { is = location . openStream ( ) ; } Properties tmpProperties = new Properties ( ) ; if ( is != null ) { tmpProperties . load ( is ) ; } return tmpProperties ; }
protected Properties createProperties ( URL location ) throws IOException { InputStream is = null ; if ( location != null ) { is = location . openStream ( ) ; } Properties tmpProperties = new Properties ( ) ; if ( is != null ) { tmpProperties . load ( is ) ; } return tmpProperties ; }
protected Properties createProperties ( URL location ) throws IOException { InputStream is = null ; if ( location != null ) { is = location . openStream ( ) ; } Properties tmpProperties = new Properties ( ) ; if ( is != null ) { tmpProperties . load ( is ) ; } return tmpProperties ; }
public DAuthorityKeyIdentifier ( JDialog parent , PublicKey authorityPublicKey , X500Name authorityCertName , BigInteger authorityCertSerialNumber ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; this . authorityPublicKey = authorityPublicKey ; initComponents ( ) ; prepopulateWithAuthorityCertDetails ( authorityCertName , authorityCertSerialNumber ) ; }
protected void reset ( ) throws XNIException { int count = fComponents . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fComponents . get ( i ) ; c . reset ( this ) ; } }
protected void reset ( ) throws XNIException { int count = fComponents . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fComponents . get ( i ) ; c . reset ( this ) ; } }
protected void reset ( ) throws XNIException { int count = fComponents . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fComponents . get ( i ) ; c . reset ( this ) ; } }
public void unlock ( final T tx ) { if ( DEBUG ) log . debug ( STRING ) ; lock . lock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; try { assertNotDead ( ) ; assertOwnsLock ( tx ) ; if ( queue . remove ( ) != tx ) { throw new AssertionError ( ) ; } if ( waitsFor != null ) { final Iterator < T > itr = queue . iterator ( ) ; synchronized ( waitsFor ) { while ( itr . hasNext ( ) ) { final T pendingTx = itr . next ( ) ; try { waitsFor . removeEdge ( pendingTx , tx ) ; } catch ( Throwable t ) { log . warn ( t . getMessage ( ) , t ) ; } } } } if ( queue . isEmpty ( ) ) { if ( INFO ) log . info ( STRING ) ; return ; } if ( INFO ) log . info ( STRING ) ; available . signalAll ( ) ; } finally { lock . unlock ( ) ; if ( DEBUG ) log . debug ( STRING ) ; } }
private void convertAndFillByteBufferListToByteArrayList ( List < byte [ ] > dictionaryValues , List < ByteBuffer > dictionaryValueBufferList ) { for ( ByteBuffer buffer : dictionaryValueBufferList ) { int length = buffer . limit ( ) ; byte [ ] value = new byte [ length ] ; buffer . get ( value , _NUM , value . length ) ; dictionaryValues . add ( value ) ; } }
public void removeHeader ( Header header ) { if ( header == null ) { return ; } headers . remove ( header ) ; }
public boolean removeEntry ( Entry e , int dataSetIndex ) { if ( e == null || dataSetIndex >= mDataSets . size ( ) ) return _BOOL ; IDataSet set = mDataSets . get ( dataSetIndex ) ; if ( set != null ) { boolean removed = set . removeEntry ( e ) ; if ( removed ) { calcMinMax ( ) ; } return removed ; } return _BOOL ; }
public static RequestSecurityTokenResponse parseXML ( String xml ) throws WSFederationException { Document doc = XMLUtils . toDOMDocument ( xml , debug ) ; Element root = doc . getDocumentElement ( ) ; return new RequestSecurityTokenResponse ( root ) ; }
public static RequestSecurityTokenResponse parseXML ( String xml ) throws WSFederationException { Document doc = XMLUtils . toDOMDocument ( xml , debug ) ; Element root = doc . getDocumentElement ( ) ; return new RequestSecurityTokenResponse ( root ) ; }
public static RequestSecurityTokenResponse parseXML ( String xml ) throws WSFederationException { Document doc = XMLUtils . toDOMDocument ( xml , debug ) ; Element root = doc . getDocumentElement ( ) ; return new RequestSecurityTokenResponse ( root ) ; }
protected static @ NotNull String convertMapToGroovySource ( @ NotNull Map < String , Object > map ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( sb . length ( ) > _NUM ) { sb . append ( STRING ) ; } sb . append ( entry . getKey ( ) ) ; sb . append ( STRING ) ; sb . append ( convertValueToGroovySource ( entry . getValue ( ) ) ) ; } return sb . toString ( ) ; }
protected static @ NotNull String convertMapToGroovySource ( @ NotNull Map < String , Object > map ) { StringBuilder sb = new StringBuilder ( ) ; for ( Map . Entry < String , Object > entry : map . entrySet ( ) ) { if ( sb . length ( ) > _NUM ) { sb . append ( STRING ) ; } sb . append ( entry . getKey ( ) ) ; sb . append ( STRING ) ; sb . append ( convertValueToGroovySource ( entry . getValue ( ) ) ) ; } return sb . toString ( ) ; }
public static Builder createBuilder ( AbstractManagedObjectDefinition < ? , ? > d , String propertyName ) { return new Builder ( d , propertyName ) ; }
public static int fuzzyCompare ( double a , double b , double tolerance ) { if ( tolerance < _NUM ) throw new IllegalArgumentException ( STRING ) ; double difference = a - b ; return ( Math . abs ( difference ) <= tolerance ? _NUM : ( difference > _NUM ? _NUM : - _NUM ) ) ; }
private HashMap < String , byte [ ] > readChars ( byte [ ] d ) { HashMap < String , byte [ ] > hm = new HashMap < String , byte [ ] > ( ) ; int i = findSlashName ( d , STRING ) ; if ( i < _NUM ) { return hm ; } PSParser psp = new PSParser ( d , i ) ; while ( _BOOL ) { String s = psp . readThing ( ) ; char c = s . charAt ( _NUM ) ; if ( c == STRING ) { int len = Integer . parseInt ( psp . readThing ( ) ) ; String go = psp . readThing ( ) ; if ( go . equals ( STRING ) || go . equals ( STRING ) ) { psp . setLoc ( psp . getLoc ( ) + _NUM ) ; byte [ ] line = psp . getNEncodedBytes ( len , password , lenIV ) ; hm . put ( s . substring ( _NUM ) , line ) ; } } else if ( s . equals ( STRING ) ) { break ; } } return hm ; }
private int parseEncryptionContext ( final byte [ ] b , final int off ) throws ParseException { final int len = b . length - off ; if ( len >= encryptionContextLen_ ) { encryptionContext_ = Arrays . copyOfRange ( b , off , off + encryptionContextLen_ ) ; return encryptionContextLen_ ; } else { throw new ParseException ( STRING ) ; } }
private String printOFormat ( int x ) { String sx = null ; if ( x == Integer . MIN_VALUE ) sx = STRING ; else if ( x < _NUM ) { String t = Integer . toString ( ( ~ ( - x - _NUM ) ) ^ Integer . MIN_VALUE , _NUM ) ; switch ( t . length ( ) ) { case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t . substring ( _NUM ) ; break ; } } else sx = Integer . toString ( x , _NUM ) ; return printOFormat ( sx ) ; }
private String printOFormat ( int x ) { String sx = null ; if ( x == Integer . MIN_VALUE ) sx = STRING ; else if ( x < _NUM ) { String t = Integer . toString ( ( ~ ( - x - _NUM ) ) ^ Integer . MIN_VALUE , _NUM ) ; switch ( t . length ( ) ) { case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t . substring ( _NUM ) ; break ; } } else sx = Integer . toString ( x , _NUM ) ; return printOFormat ( sx ) ; }
private MovieSetChooserModel ( ) { setName ( BUNDLE . getString ( STRING ) ) ; }
protected void fillPath ( ) { mPSStream . println ( mFillOpStr ) ; }
public void read ( InputStream in ) throws IOException { IXMLParser parser ; try { parser = XMLParserFactory . createDefaultXMLParser ( ) ; } catch ( Exception ex ) { InternalError e = new InternalError ( STRING ) ; e . initCause ( ex ) ; throw e ; } IXMLReader reader = new StdXMLReader ( in ) ; parser . setReader ( reader ) ; IXMLElement document ; try { document = ( IXMLElement ) parser . parse ( ) ; } catch ( XMLException ex ) { IOException e = new IOException ( ex . getMessage ( ) ) ; e . initCause ( ex ) ; throw e ; } read ( document ) ; }
public byte [ ] encrypt ( byte [ ] data ) throws CryptoException { try { byte [ ] ciphertext ; if ( useExplicitIv ) { ciphertext = ArrayConverter . concatenate ( encryptIv . getIV ( ) , encryptCipher . doFinal ( data ) ) ; } else { encryptCipher . init ( Cipher . ENCRYPT_MODE , encryptKey , encryptIv ) ; ciphertext = encryptCipher . doFinal ( data ) ; encryptIv = new IvParameterSpec ( Arrays . copyOfRange ( ciphertext , ciphertext . length - decryptCipher . getBlockSize ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch ( BadPaddingException | IllegalBlockSizeException | InvalidAlgorithmParameterException | InvalidKeyException ex ) { throw new CryptoException ( ex ) ; } }
public byte [ ] encrypt ( byte [ ] data ) throws CryptoException { try { byte [ ] ciphertext ; if ( useExplicitIv ) { ciphertext = ArrayConverter . concatenate ( encryptIv . getIV ( ) , encryptCipher . doFinal ( data ) ) ; } else { encryptCipher . init ( Cipher . ENCRYPT_MODE , encryptKey , encryptIv ) ; ciphertext = encryptCipher . doFinal ( data ) ; encryptIv = new IvParameterSpec ( Arrays . copyOfRange ( ciphertext , ciphertext . length - decryptCipher . getBlockSize ( ) , ciphertext . length ) ) ; } return ciphertext ; } catch ( BadPaddingException | IllegalBlockSizeException | InvalidAlgorithmParameterException | InvalidKeyException ex ) { throw new CryptoException ( ex ) ; } }
public boolean hasSubAttributes ( ) { return subAttributes != null && ! subAttributes . isEmpty ( ) ; }
public String crop ( String string ) { if ( ( null == string ) || ( string . length ( ) <= effectiveStringLength ) ) { return string ; } if ( effectiveStringLength == _NUM ) { return STRING ; } String cropped = string . substring ( _NUM , effectiveStringLength ) ; if ( USE_TRAILING_DOTS ) { cropped = appendTrailingDots ( cropped ) ; } return cropped ; }
public void filledPolygon ( double [ ] x , double [ ] y ) { int n = x . length ; GeneralPath path = new GeneralPath ( ) ; path . moveTo ( ( float ) scaleX ( x [ _NUM ] ) , ( float ) scaleY ( y [ _NUM ] ) ) ; for ( int i = _NUM ; i < n ; i ++ ) path . lineTo ( ( float ) scaleX ( x [ i ] ) , ( float ) scaleY ( y [ i ] ) ) ; path . closePath ( ) ; offscreen . fill ( path ) ; draw ( ) ; }
public void filledPolygon ( double [ ] x , double [ ] y ) { int n = x . length ; GeneralPath path = new GeneralPath ( ) ; path . moveTo ( ( float ) scaleX ( x [ _NUM ] ) , ( float ) scaleY ( y [ _NUM ] ) ) ; for ( int i = _NUM ; i < n ; i ++ ) path . lineTo ( ( float ) scaleX ( x [ i ] ) , ( float ) scaleY ( y [ i ] ) ) ; path . closePath ( ) ; offscreen . fill ( path ) ; draw ( ) ; }
@ Transactional public void delete ( T persistentObject ) { if ( ! entityManager . contains ( persistentObject ) ) { persistentObject = entityManager . merge ( persistentObject ) ; } entityManager . remove ( persistentObject ) ; }
public void reload ( String path ) throws TomcatManagerException , IOException { invoke ( STRING + URLEncoder . encode ( path , this . charset ) ) ; }
public void reload ( String path ) throws TomcatManagerException , IOException { invoke ( STRING + URLEncoder . encode ( path , this . charset ) ) ; }
public void dontDisplayMetrics ( List < String > metricsNotToDisplay ) { for ( String s : metricsNotToDisplay ) { m_metricsToDisplay . remove ( s . toLowerCase ( ) ) ; } }
public void clearCache ( ) { if ( mMemoryCache != null ) { mMemoryCache . evictAll ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( mDiskCacheLock ) { mDiskCacheStarting = _BOOL ; if ( mDiskLruCache != null && ! mDiskLruCache . isClosed ( ) ) { try { mDiskLruCache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IOException e ) { Log . e ( TAG , STRING + e ) ; } mDiskLruCache = null ; initDiskCache ( ) ; } } }
public void clearCache ( ) { if ( mMemoryCache != null ) { mMemoryCache . evictAll ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( mDiskCacheLock ) { mDiskCacheStarting = _BOOL ; if ( mDiskLruCache != null && ! mDiskLruCache . isClosed ( ) ) { try { mDiskLruCache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IOException e ) { Log . e ( TAG , STRING + e ) ; } mDiskLruCache = null ; initDiskCache ( ) ; } } }
public void clearCache ( ) { if ( mMemoryCache != null ) { mMemoryCache . evictAll ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( mDiskCacheLock ) { mDiskCacheStarting = _BOOL ; if ( mDiskLruCache != null && ! mDiskLruCache . isClosed ( ) ) { try { mDiskLruCache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IOException e ) { Log . e ( TAG , STRING + e ) ; } mDiskLruCache = null ; initDiskCache ( ) ; } } }
public void clearCache ( ) { if ( mMemoryCache != null ) { mMemoryCache . evictAll ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } synchronized ( mDiskCacheLock ) { mDiskCacheStarting = _BOOL ; if ( mDiskLruCache != null && ! mDiskLruCache . isClosed ( ) ) { try { mDiskLruCache . delete ( ) ; if ( debug ) { Log . d ( TAG , STRING ) ; } } catch ( IOException e ) { Log . e ( TAG , STRING + e ) ; } mDiskLruCache = null ; initDiskCache ( ) ; } } }
public T peek ( ) { if ( heap . size ( ) > _NUM ) return heap . elementAt ( TOP ) ; else return null ; }
public void addRequest ( ActionRequest request , LimitedQueueInfo queueInfo ) { String requestId = PennStation . requestAction ( request , queueInfo ) ; synchronized ( this ) { mLastRequestIdByType . put ( request . type ( ) , requestId ) ; mRequestIds . add ( requestId ) ; } }
public void addRequest ( ActionRequest request , LimitedQueueInfo queueInfo ) { String requestId = PennStation . requestAction ( request , queueInfo ) ; synchronized ( this ) { mLastRequestIdByType . put ( request . type ( ) , requestId ) ; mRequestIds . add ( requestId ) ; } }
public void addRequest ( ActionRequest request , LimitedQueueInfo queueInfo ) { String requestId = PennStation . requestAction ( request , queueInfo ) ; synchronized ( this ) { mLastRequestIdByType . put ( request . type ( ) , requestId ) ; mRequestIds . add ( requestId ) ; } }
public Type lub ( List < Type > ts ) { return lub ( ts . toArray ( new Type [ ts . length ( ) ] ) ) ; }
public StrBuilder insert ( final int index , final Object obj ) { if ( obj == null ) { return insert ( index , nullText ) ; } return insert ( index , obj . toString ( ) ) ; }
private String match ( Pattern re ) { if ( index >= input . length ( ) ) { return null ; } Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
private String match ( Pattern re ) { if ( index >= input . length ( ) ) { return null ; } Matcher matcher = re . matcher ( input ) ; matcher . region ( index , input . length ( ) ) ; boolean m = matcher . find ( ) ; if ( m ) { index = matcher . end ( ) ; return matcher . group ( ) ; } else { return null ; } }
public final boolean isSameSize ( final Matrix matrix ) { return this . numRows == matrix . numRows && this . numCols == matrix . numCols ; }
public final boolean isSameSize ( final Matrix matrix ) { return this . numRows == matrix . numRows && this . numCols == matrix . numCols ; }
public static void append ( Path file , Writer writer , String charset ) throws IOException { appendBuffered ( file , writer , charset , _BOOL ) ; }
public static void append ( Path file , Writer writer , String charset ) throws IOException { appendBuffered ( file , writer , charset , _BOOL ) ; }
public static void append ( Path file , Writer writer , String charset ) throws IOException { appendBuffered ( file , writer , charset , _BOOL ) ; }
public static String makeSimpleDoc ( String ... fieldsAndValues ) { try { StringWriter w = new StringWriter ( ) ; w . append ( STRING ) ; for ( int i = _NUM ; i < fieldsAndValues . length ; i += _NUM ) { XML . writeXML ( w , STRING , fieldsAndValues [ i + _NUM ] , STRING , fieldsAndValues [ i ] ) ; } w . append ( STRING ) ; return w . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING , e ) ; } }
public static String makeSimpleDoc ( String ... fieldsAndValues ) { try { StringWriter w = new StringWriter ( ) ; w . append ( STRING ) ; for ( int i = _NUM ; i < fieldsAndValues . length ; i += _NUM ) { XML . writeXML ( w , STRING , fieldsAndValues [ i + _NUM ] , STRING , fieldsAndValues [ i ] ) ; } w . append ( STRING ) ; return w . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING , e ) ; } }
public static String makeSimpleDoc ( String ... fieldsAndValues ) { try { StringWriter w = new StringWriter ( ) ; w . append ( STRING ) ; for ( int i = _NUM ; i < fieldsAndValues . length ; i += _NUM ) { XML . writeXML ( w , STRING , fieldsAndValues [ i + _NUM ] , STRING , fieldsAndValues [ i ] ) ; } w . append ( STRING ) ; return w . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( STRING , e ) ; } }
public void close ( ) { this . closed = _BOOL ; }
public void close ( ) { this . closed = _BOOL ; }
public static IndexedImage load ( byte [ ] data ) { try { DataInputStream input = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; int width = input . readShort ( ) ; int height = input . readShort ( ) ; int [ ] palette = new int [ input . readByte ( ) & _NUM ] ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . readInt ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . readFully ( arr ) ; return new IndexedImage ( width , height , palette , arr ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } }
public static IndexedImage load ( byte [ ] data ) { try { DataInputStream input = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; int width = input . readShort ( ) ; int height = input . readShort ( ) ; int [ ] palette = new int [ input . readByte ( ) & _NUM ] ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . readInt ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . readFully ( arr ) ; return new IndexedImage ( width , height , palette , arr ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } }
public static IndexedImage load ( byte [ ] data ) { try { DataInputStream input = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; int width = input . readShort ( ) ; int height = input . readShort ( ) ; int [ ] palette = new int [ input . readByte ( ) & _NUM ] ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . readInt ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . readFully ( arr ) ; return new IndexedImage ( width , height , palette , arr ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } }
public static IndexedImage load ( byte [ ] data ) { try { DataInputStream input = new DataInputStream ( new ByteArrayInputStream ( data ) ) ; int width = input . readShort ( ) ; int height = input . readShort ( ) ; int [ ] palette = new int [ input . readByte ( ) & _NUM ] ; int plen = palette . length ; for ( int iter = _NUM ; iter < plen ; iter ++ ) { palette [ iter ] = input . readInt ( ) ; } byte [ ] arr = new byte [ width * height ] ; input . readFully ( arr ) ; return new IndexedImage ( width , height , palette , arr ) ; } catch ( IOException ex ) { ex . printStackTrace ( ) ; return null ; } }
public static int probRound ( double value , Random rand ) { if ( value >= _NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + _NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + _NUM ) ; } else { return - ( int ) lower ; } } }
public static int probRound ( double value , Random rand ) { if ( value >= _NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + _NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + _NUM ) ; } else { return - ( int ) lower ; } } }
public static int probRound ( double value , Random rand ) { if ( value >= _NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + _NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + _NUM ) ; } else { return - ( int ) lower ; } } }
public static int probRound ( double value , Random rand ) { if ( value >= _NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + _NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + _NUM ) ; } else { return - ( int ) lower ; } } }
public static int probRound ( double value , Random rand ) { if ( value >= _NUM ) { double lower = Math . floor ( value ) ; double prob = value - lower ; if ( rand . nextDouble ( ) < prob ) { return ( int ) lower + _NUM ; } else { return ( int ) lower ; } } else { double lower = Math . floor ( Math . abs ( value ) ) ; double prob = Math . abs ( value ) - lower ; if ( rand . nextDouble ( ) < prob ) { return - ( ( int ) lower + _NUM ) ; } else { return - ( int ) lower ; } } }
private void validateSQLFields ( ) { boolean flag = controller . isEnableSQLDatabaseOutput ( ) ; enableSQLDatabaseConnection . setSelected ( flag ) ; sqlHostLabel . setEnabled ( flag ) ; sqlHostField . setEnabled ( flag ) ; sqlDatabaseLabel . setEnabled ( flag ) ; sqlDatabaseField . setEnabled ( flag ) ; sqlUserLabel . setEnabled ( flag ) ; sqlUserField . setEnabled ( flag ) ; sqlPasswordLabel . setEnabled ( flag ) ; sqlPasswordField . setEnabled ( flag ) ; enableZipEncodingCheckBox . setEnabled ( flag ) ; }
public void testBug68307 ( ) throws Exception { createFunction ( STRING , STRING ) ; createProcedure ( STRING , STRING ) ; DatabaseMetaData testDbMetaData = conn . getMetaData ( ) ; checkFunctionColumnTypeForBug68307 ( STRING , testDbMetaData ) ; checkProcedureColumnTypeForBug68307 ( STRING , testDbMetaData ) ; Connection connUseIS = getConnectionWithProps ( STRING ) ; testDbMetaData = connUseIS . getMetaData ( ) ; checkFunctionColumnTypeForBug68307 ( STRING , testDbMetaData ) ; checkProcedureColumnTypeForBug68307 ( STRING , testDbMetaData ) ; connUseIS . close ( ) ; }
public void testBug68307 ( ) throws Exception { createFunction ( STRING , STRING ) ; createProcedure ( STRING , STRING ) ; DatabaseMetaData testDbMetaData = conn . getMetaData ( ) ; checkFunctionColumnTypeForBug68307 ( STRING , testDbMetaData ) ; checkProcedureColumnTypeForBug68307 ( STRING , testDbMetaData ) ; Connection connUseIS = getConnectionWithProps ( STRING ) ; testDbMetaData = connUseIS . getMetaData ( ) ; checkFunctionColumnTypeForBug68307 ( STRING , testDbMetaData ) ; checkProcedureColumnTypeForBug68307 ( STRING , testDbMetaData ) ; connUseIS . close ( ) ; }
private static void outputSetting ( String setting ) { if ( out != null && ! writtenSettings . contains ( setting ) ) { if ( writtenSettings . size ( ) == _NUM ) { out . println ( STRING + ( runIndex + _NUM ) ) ; } out . println ( setting ) ; writtenSettings . add ( setting ) ; } }
private void boundsChanged ( ) { if ( runLaterPending ) return ; runLaterPending = _BOOL ; Platform . runLater ( null ) ; }
private void boundsChanged ( ) { if ( runLaterPending ) return ; runLaterPending = _BOOL ; Platform . runLater ( null ) ; }
synchronized boolean isAttached ( Monitor monitorToFind ) { return monitors . contains ( monitorToFind ) ; }
public static String normalize ( CharSequence src , Form form ) { return NormalizerBase . normalize ( src . toString ( ) , form ) ; }
public static String normalize ( CharSequence src , Form form ) { return NormalizerBase . normalize ( src . toString ( ) , form ) ; }
public void add ( ResourceCollection rc ) { classFiles . add ( rc ) ; }
private void emitEnsureCollection ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STRING ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( getImplName ( method . getGenericReturnType ( ) , _BOOL ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
private void emitEnsureCollection ( Method method , String fieldName , StringBuilder builder ) { builder . append ( STRING ) ; builder . append ( getEnsureName ( fieldName ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( fieldName ) ; builder . append ( STRING ) ; builder . append ( getImplName ( method . getGenericReturnType ( ) , _BOOL ) ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; builder . append ( STRING ) ; }
public void remove ( int i ) { individuals . remove ( i ) ; }
public static String keepCartUpdated ( HttpServletRequest request , HttpServletResponse response ) { LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( STRING ) ; HttpSession session = request . getSession ( ) ; ShoppingCart cart = getCartObject ( request ) ; if ( cart . getUserLogin ( ) == null ) { GenericValue userLogin = ( GenericValue ) session . getAttribute ( STRING ) ; if ( userLogin != null ) { try { cart . setUserLogin ( userLogin , dispatcher ) ; } catch ( CartItemModifyException e ) { Debug . logWarning ( e , module ) ; } } } if ( cart . getAutoUserLogin ( ) == null ) { GenericValue autoUserLogin = ( GenericValue ) session . getAttribute ( STRING ) ; if ( autoUserLogin != null ) { if ( cart . getUserLogin ( ) == null ) { try { cart . setAutoUserLogin ( autoUserLogin , dispatcher ) ; } catch ( CartItemModifyException e ) { Debug . logWarning ( e , module ) ; } } else { cart . setAutoUserLogin ( autoUserLogin ) ; } } } Locale locale = UtilHttp . getLocale ( request ) ; if ( cart . getLocale ( ) == null || ! locale . equals ( cart . getLocale ( ) ) ) { cart . setLocale ( locale ) ; } return STRING ; }
public void readData ( DataInput input ) throws IOException { readReference = input . readUnsignedShort ( ) ; readCount = input . readUnsignedShort ( ) ; writeReference = input . readUnsignedShort ( ) ; writeCount = input . readUnsignedShort ( ) ; int byteCount = input . readUnsignedByte ( ) ; if ( nonWordDataHandler == null ) { byte buffer [ ] = new byte [ byteCount ] ; input . readFully ( buffer , _NUM , byteCount ) ; int offset = _NUM ; registers = new Register [ writeCount ] ; for ( int register = _NUM ; register < writeCount ; register ++ ) { registers [ register ] = new SimpleRegister ( buffer [ offset ] , buffer [ offset + _NUM ] ) ; offset += _NUM ; } } else { nonWordDataHandler . readData ( input , writeReference , writeCount ) ; } }
public void readData ( DataInput input ) throws IOException { readReference = input . readUnsignedShort ( ) ; readCount = input . readUnsignedShort ( ) ; writeReference = input . readUnsignedShort ( ) ; writeCount = input . readUnsignedShort ( ) ; int byteCount = input . readUnsignedByte ( ) ; if ( nonWordDataHandler == null ) { byte buffer [ ] = new byte [ byteCount ] ; input . readFully ( buffer , _NUM , byteCount ) ; int offset = _NUM ; registers = new Register [ writeCount ] ; for ( int register = _NUM ; register < writeCount ; register ++ ) { registers [ register ] = new SimpleRegister ( buffer [ offset ] , buffer [ offset + _NUM ] ) ; offset += _NUM ; } } else { nonWordDataHandler . readData ( input , writeReference , writeCount ) ; } }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public Set < DefUseCoverageTestFitness > determineDefUsePairs ( ) { Set < DefUseCoverageTestFitness > r = preAnalyzeMethods ( ) ; for ( CCFGMethodEntryNode publicMethodEntry : ccfg . publicMethods ) { if ( analyzedMethods . contains ( publicMethodEntry ) ) { continue ; } if ( publicMethodEntry . getEntryInstruction ( ) == null ) throw new IllegalStateException ( STRING ) ; r . addAll ( determineIntraInterMethodPairs ( publicMethodEntry ) ) ; } r . addAll ( createIntraClassPairs ( ) ) ; freeMemory ( ) ; return r ; }
public void addSubpath ( Subpath subpath ) { subpaths . add ( subpath ) ; currentPoint = subpath . getLastPoint ( ) ; }
static Object valueOf ( final Class < ? > type , final String str ) { if ( ! isValidEnum ( type ) ) { return null ; } try { final String valueOfMethod = STRING ; final Method m = type . getMethod ( valueOfMethod , String . class ) ; if ( ! Modifier . isStatic ( m . getModifiers ( ) ) ) { return null ; } final Class < ? > returnType = m . getReturnType ( ) ; if ( ! type . isAssignableFrom ( returnType ) ) { return null ; } return m . invoke ( null , str ) ; } catch ( final NoSuchMethodException | InvocationTargetException | IllegalAccessException e ) { throw new RuntimeException ( e ) ; } }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
protected int offsetVal ( String maskString ) { int offset = _NUM ; for ( int i = _NUM ; i < maskString . length ( ) ; i ++ ) { if ( maskString . charAt ( i ) == STRING ) { offset = maskString . length ( ) - _NUM - i ; } } return offset ; }
@ SuppressWarnings ( STRING ) public void addSurrogateIds ( Collection < IgniteUuid > col ) { if ( surrogateIds == null ) { surrogateIds = new IgniteUuid [ ids . length ] ; for ( int i = lastExistingIdx + _NUM ; i < surrogateIds . length ; i ++ ) surrogateIds [ i ] = IgniteUuid . randomUuid ( ) ; } for ( int i = lastExistingIdx + _NUM ; i < surrogateIds . length ; i ++ ) col . add ( surrogateIds [ i ] ) ; }
@ SuppressWarnings ( STRING ) public void addSurrogateIds ( Collection < IgniteUuid > col ) { if ( surrogateIds == null ) { surrogateIds = new IgniteUuid [ ids . length ] ; for ( int i = lastExistingIdx + _NUM ; i < surrogateIds . length ; i ++ ) surrogateIds [ i ] = IgniteUuid . randomUuid ( ) ; } for ( int i = lastExistingIdx + _NUM ; i < surrogateIds . length ; i ++ ) col . add ( surrogateIds [ i ] ) ; }
public static void UF5 ( double [ ] x , double [ ] f , int nx ) { int count1 = _NUM ; int count2 = _NUM ; double sum1 = _NUM ; double sum2 = _NUM ; double yj ; double hj ; double N = _NUM ; double E = _NUM ; for ( int j = _NUM ; j <= nx ; j ++ ) { yj = x [ j - _NUM ] - Math . sin ( _NUM * PI * x [ _NUM ] + j * PI / nx ) ; hj = _NUM * yj * yj - Math . cos ( _NUM * PI * yj ) + _NUM ; if ( j % _NUM == _NUM ) { sum2 += hj ; count2 ++ ; } else { sum1 += hj ; count1 ++ ; } } hj = ( _NUM / N + E ) * Math . abs ( Math . sin ( _NUM * N * PI * x [ _NUM ] ) ) ; f [ _NUM ] = x [ _NUM ] + hj + _NUM * sum1 / ( double ) count1 ; f [ _NUM ] = _NUM - x [ _NUM ] + hj + _NUM * sum2 / ( double ) count2 ; }
private String makeHeader ( boolean ok ) { String header = STRING ; if ( ok ) { header += STRING ; } else { header += STRING ; } header += STRING ; header += STRING ; return header ; }
public void ensureCapacity ( int mincap ) { if ( mincap > array . length ) { int newcap = ( ( array . length * _NUM ) > > _NUM ) + _NUM ; int [ ] olddata = array ; array = new int [ newcap < mincap ? mincap : newcap ] ; System . arraycopy ( olddata , _NUM , array , _NUM , size ) ; } }
private float computeOverscrollPercent ( ) { if ( mOverScrollOffset >= _NUM ) { return mOverScrollOffset / mMaxOverScroll ; } else { return mOverScrollOffset / mMaxUnderScroll ; } }
private float computeOverscrollPercent ( ) { if ( mOverScrollOffset >= _NUM ) { return mOverScrollOffset / mMaxOverScroll ; } else { return mOverScrollOffset / mMaxUnderScroll ; } }
private float computeOverscrollPercent ( ) { if ( mOverScrollOffset >= _NUM ) { return mOverScrollOffset / mMaxOverScroll ; } else { return mOverScrollOffset / mMaxUnderScroll ; } }
public void onTabClosing ( long time , int tabId ) { }
public void onTabClosing ( long time , int tabId ) { }
public Point2D either ( ) { return best1 ; }
public Point2D either ( ) { return best1 ; }
public static String GotoNextNonSpace ( Vector inputVec , IntPair curLoc ) { boolean found = _BOOL ; while ( ( ! found ) && curLoc . one < inputVec . size ( ) ) { String line = ( String ) inputVec . elementAt ( curLoc . one ) ; while ( ( ! found ) && curLoc . two < line . length ( ) ) { if ( line . charAt ( curLoc . two ) == STRING ) { curLoc . two ++ ; } else { found = _BOOL ; } } if ( ! found ) { curLoc . one ++ ; curLoc . two = _NUM ; } } if ( curLoc . one < inputVec . size ( ) ) { return ( String ) inputVec . elementAt ( curLoc . one ) ; } return STRING ; }
public boolean evaluate ( Map record ) { Object recVal = record . get ( keyField ) ; return op . evaluate ( this . val , recVal ) ; }
public boolean evaluate ( Map record ) { Object recVal = record . get ( keyField ) ; return op . evaluate ( this . val , recVal ) ; }
public boolean evaluate ( Map record ) { Object recVal = record . get ( keyField ) ; return op . evaluate ( this . val , recVal ) ; }
public boolean evaluate ( Map record ) { Object recVal = record . get ( keyField ) ; return op . evaluate ( this . val , recVal ) ; }
public static Value JavaTime ( ) { int t = ( int ) System . currentTimeMillis ( ) ; return IntValue . gen ( t & _NUM ) ; }
public static Value JavaTime ( ) { int t = ( int ) System . currentTimeMillis ( ) ; return IntValue . gen ( t & _NUM ) ; }
private static List < Command > loadRewrites ( ContentResolver contentResolver , Uri uri ) throws IOException { InputStream inputStream = contentResolver . openInputStream ( uri ) ; List < Command > commands = new ArrayList < > ( ) ; if ( inputStream != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { addLine ( commands , line ) ; } inputStream . close ( ) ; } return commands ; }
private static List < Command > loadRewrites ( ContentResolver contentResolver , Uri uri ) throws IOException { InputStream inputStream = contentResolver . openInputStream ( uri ) ; List < Command > commands = new ArrayList < > ( ) ; if ( inputStream != null ) { BufferedReader reader = new BufferedReader ( new InputStreamReader ( inputStream ) ) ; String line ; while ( ( line = reader . readLine ( ) ) != null ) { addLine ( commands , line ) ; } inputStream . close ( ) ; } return commands ; }
public PoliticalActionAttachment waitForPoliticalAction ( final boolean firstRun , final IPoliticsDelegate iPoliticsDelegate ) { m_firstRun = firstRun ; m_validPoliticalActions = new ArrayList < > ( iPoliticsDelegate . getValidActions ( ) ) ; Collections . sort ( m_validPoliticalActions , new PoliticalActionComparator ( getCurrentPlayer ( ) , getData ( ) ) ) ; if ( m_firstRun && m_validPoliticalActions . isEmpty ( ) ) { return null ; } else { if ( m_firstRun ) { ClipPlayer . play ( SoundPath . CLIP_PHASE_POLITICS , getCurrentPlayer ( ) ) ; } SwingUtilities . invokeLater ( null ) ; } waitForRelease ( ) ; return m_choice ; }
public PoliticalActionAttachment waitForPoliticalAction ( final boolean firstRun , final IPoliticsDelegate iPoliticsDelegate ) { m_firstRun = firstRun ; m_validPoliticalActions = new ArrayList < > ( iPoliticsDelegate . getValidActions ( ) ) ; Collections . sort ( m_validPoliticalActions , new PoliticalActionComparator ( getCurrentPlayer ( ) , getData ( ) ) ) ; if ( m_firstRun && m_validPoliticalActions . isEmpty ( ) ) { return null ; } else { if ( m_firstRun ) { ClipPlayer . play ( SoundPath . CLIP_PHASE_POLITICS , getCurrentPlayer ( ) ) ; } SwingUtilities . invokeLater ( null ) ; } waitForRelease ( ) ; return m_choice ; }
private String normalizeResourceName ( String sName ) { return sName . replace ( STRING , STRING ) ; }
private String normalizeResourceName ( String sName ) { return sName . replace ( STRING , STRING ) ; }
public boolean isModifiedNow ( ) { boolean isModified = _classLoader . isModifiedNow ( ) ; if ( isModified ) log . fine ( STRING ) ; return isModified ; }
public boolean isModifiedNow ( ) { boolean isModified = _classLoader . isModifiedNow ( ) ; if ( isModified ) log . fine ( STRING ) ; return isModified ; }
public Payment ( ResultSet result ) throws SQLException { id = result . getInt ( STRING ) ; channelIdReceiver = result . getInt ( STRING ) ; channelIdSender = result . getInt ( STRING ) ; amount = result . getLong ( STRING ) ; fee = result . getLong ( STRING ) ; phaseSender = result . getInt ( STRING ) ; phaseReceiver = result . getInt ( STRING ) ; includeInReceiverChannel = Tools . intToBool ( result . getInt ( STRING ) ) ; includeInSenderChannel = Tools . intToBool ( result . getInt ( STRING ) ) ; includeInReceiverChannelTemp = Tools . intToBool ( result . getInt ( STRING ) ) ; includeInSenderChannelTemp = Tools . intToBool ( result . getInt ( STRING ) ) ; secretHash = result . getBytes ( STRING ) ; secret = result . getBytes ( STRING ) ; timestampAddedReceiver = result . getInt ( STRING ) ; timestampAddedSender = result . getInt ( STRING ) ; timestampSettledReceiver = result . getInt ( STRING ) ; timestampSettledSender = result . getInt ( STRING ) ; versionAddedReceiver = result . getInt ( STRING ) ; versionAddedSender = result . getInt ( STRING ) ; versionSettledReceiver = result . getInt ( STRING ) ; versionSettledSender = result . getInt ( STRING ) ; }
private static String addKey ( List < Optional < AccountSshKey > > keys , String pub ) { AccountSshKey . Id keyId = new AccountSshKey . Id ( new Account . Id ( _NUM ) , keys . size ( ) + _NUM ) ; AccountSshKey key = new AccountSshKey ( keyId , pub ) ; keys . add ( Optional . of ( key ) ) ; return key . getSshPublicKey ( ) + STRING ; }
@ Override protected void onMeasure ( int widthMeasureSpec , int heightMeasureSpec ) { setMeasuredDimension ( ( int ) Math . min ( MeasureSpec . getSize ( widthMeasureSpec ) , halfWidth * _NUM ) , ( int ) Math . min ( MeasureSpec . getSize ( heightMeasureSpec ) , height ) ) ; }
public static void putString ( String property , String val ) { SIMBRAIN_PREFERENCES . put ( property , val ) ; }
public void createChartPrintJob ( ) { PrinterJob job = PrinterJob . getPrinterJob ( ) ; PageFormat pf = job . defaultPage ( ) ; PageFormat pf2 = job . pageDialog ( pf ) ; if ( pf2 != pf ) { job . setPrintable ( this , pf2 ) ; if ( job . printDialog ( ) ) { try { job . print ( ) ; } catch ( PrinterException e ) { JOptionPane . showMessageDialog ( this , e ) ; } } } }
private static void merge ( ObjectNode tree , ObjectNode overrideTree ) { Iterator < String > fieldNames = overrideTree . fieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; JsonNode primaryValue = tree . get ( fieldName ) ; JsonNode backupValue = overrideTree . get ( fieldName ) ; if ( primaryValue == null ) { if ( backupValue != null ) { tree . set ( fieldName , backupValue ) ; } } else if ( backupValue . isNull ( ) ) { tree . remove ( fieldName ) ; } else if ( primaryValue . isObject ( ) && backupValue . isObject ( ) ) { merge ( ( ObjectNode ) primaryValue , ( ObjectNode ) backupValue . deepCopy ( ) ) ; } else { tree . set ( fieldName , overrideTree . get ( fieldName ) ) ; } } }
private static void merge ( ObjectNode tree , ObjectNode overrideTree ) { Iterator < String > fieldNames = overrideTree . fieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; JsonNode primaryValue = tree . get ( fieldName ) ; JsonNode backupValue = overrideTree . get ( fieldName ) ; if ( primaryValue == null ) { if ( backupValue != null ) { tree . set ( fieldName , backupValue ) ; } } else if ( backupValue . isNull ( ) ) { tree . remove ( fieldName ) ; } else if ( primaryValue . isObject ( ) && backupValue . isObject ( ) ) { merge ( ( ObjectNode ) primaryValue , ( ObjectNode ) backupValue . deepCopy ( ) ) ; } else { tree . set ( fieldName , overrideTree . get ( fieldName ) ) ; } } }
private static void merge ( ObjectNode tree , ObjectNode overrideTree ) { Iterator < String > fieldNames = overrideTree . fieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; JsonNode primaryValue = tree . get ( fieldName ) ; JsonNode backupValue = overrideTree . get ( fieldName ) ; if ( primaryValue == null ) { if ( backupValue != null ) { tree . set ( fieldName , backupValue ) ; } } else if ( backupValue . isNull ( ) ) { tree . remove ( fieldName ) ; } else if ( primaryValue . isObject ( ) && backupValue . isObject ( ) ) { merge ( ( ObjectNode ) primaryValue , ( ObjectNode ) backupValue . deepCopy ( ) ) ; } else { tree . set ( fieldName , overrideTree . get ( fieldName ) ) ; } } }
private static void merge ( ObjectNode tree , ObjectNode overrideTree ) { Iterator < String > fieldNames = overrideTree . fieldNames ( ) ; while ( fieldNames . hasNext ( ) ) { String fieldName = fieldNames . next ( ) ; JsonNode primaryValue = tree . get ( fieldName ) ; JsonNode backupValue = overrideTree . get ( fieldName ) ; if ( primaryValue == null ) { if ( backupValue != null ) { tree . set ( fieldName , backupValue ) ; } } else if ( backupValue . isNull ( ) ) { tree . remove ( fieldName ) ; } else if ( primaryValue . isObject ( ) && backupValue . isObject ( ) ) { merge ( ( ObjectNode ) primaryValue , ( ObjectNode ) backupValue . deepCopy ( ) ) ; } else { tree . set ( fieldName , overrideTree . get ( fieldName ) ) ; } } }
@ Override public String createInitialLoadSqlFor ( Node node , TriggerRouter trigger , Table table , TriggerHistory triggerHistory , Channel channel , String overrideSelectSql ) { String sql = super . createInitialLoadSqlFor ( node , trigger , table , triggerHistory , channel , overrideSelectSql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String createInitialLoadSqlFor ( Node node , TriggerRouter trigger , Table table , TriggerHistory triggerHistory , Channel channel , String overrideSelectSql ) { String sql = super . createInitialLoadSqlFor ( node , trigger , table , triggerHistory , channel , overrideSelectSql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String createInitialLoadSqlFor ( Node node , TriggerRouter trigger , Table table , TriggerHistory triggerHistory , Channel channel , String overrideSelectSql ) { String sql = super . createInitialLoadSqlFor ( node , trigger , table , triggerHistory , channel , overrideSelectSql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String createInitialLoadSqlFor ( Node node , TriggerRouter trigger , Table table , TriggerHistory triggerHistory , Channel channel , String overrideSelectSql ) { String sql = super . createInitialLoadSqlFor ( node , trigger , table , triggerHistory , channel , overrideSelectSql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
@ Override public String createInitialLoadSqlFor ( Node node , TriggerRouter trigger , Table table , TriggerHistory triggerHistory , Channel channel , String overrideSelectSql ) { String sql = super . createInitialLoadSqlFor ( node , trigger , table , triggerHistory , channel , overrideSelectSql ) ; sql = sql . replace ( STRING , STRING ) ; return sql ; }
public static Vector3 pow ( Vector3 o , double power ) { return new Vector3 ( Math . pow ( o . x , power ) , Math . pow ( o . y , power ) , Math . pow ( o . z , power ) ) ; }
default void removeAttributeModifiers ( final Iterable < AttributeModifier > modifiers ) { modifiers . forEach ( null ) ; }
public void start ( Stage stage ) throws Exception { stage . setScene ( new Scene ( new MyDemoPane ( ) ) ) ; stage . setTitle ( STRING ) ; stage . setWidth ( _NUM ) ; stage . setHeight ( _NUM ) ; stage . show ( ) ; }
private void reverseTransactions ( ArrayList < DataStore > restoreList , Throwable cause ) { for ( DataStore dataStore : restoreList ) { try ( DataStoreTransaction transaction = dataStore . beginTransaction ( ) ) { List < Object > list = dirtyObjects . get ( dataStore ) ; for ( Object dirtyObject : list == null ? Collections . emptyList ( ) : list ) { Object cloned = clonedObjects . get ( dirtyObject ) ; if ( cloned == NEWLY_CREATED_OBJECT ) { transaction . delete ( dirtyObject ) ; } else { transaction . save ( cloned ) ; } } transaction . commit ( ) ; } catch ( RuntimeException | IOException e ) { cause . addSuppressed ( e ) ; } } }
public void runTest ( ) throws Throwable { Document doc ; NodeList emList ; Node emNode ; CharacterData emText ; boolean hasChild ; doc = ( Document ) load ( STRING , _BOOL ) ; emList = doc . getElementsByTagName ( STRING ) ; emNode = emList . item ( _NUM ) ; emText = ( CharacterData ) emNode . getFirstChild ( ) ; hasChild = emText . hasChildNodes ( ) ; assertFalse ( STRING , hasChild ) ; }
private void snipOutEntry ( Entry entry , final Entry parent , boolean removeParentRelationship ) { final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId != null ) { final Entry previous = getEntryById ( previousId ) ; previous . setNextSiblingId ( entry . getNextSiblingId ( ) ) ; } else { parent . setFirstChildId ( entry . getNextSiblingId ( ) ) ; } final String nextId = entry . getNextSiblingId ( ) ; if ( nextId != null ) { final Entry next = getEntryById ( nextId ) ; next . setPreviousSiblingId ( previousId ) ; } else { parent . setLastChildId ( previousId ) ; } }
private void snipOutEntry ( Entry entry , final Entry parent , boolean removeParentRelationship ) { final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId != null ) { final Entry previous = getEntryById ( previousId ) ; previous . setNextSiblingId ( entry . getNextSiblingId ( ) ) ; } else { parent . setFirstChildId ( entry . getNextSiblingId ( ) ) ; } final String nextId = entry . getNextSiblingId ( ) ; if ( nextId != null ) { final Entry next = getEntryById ( nextId ) ; next . setPreviousSiblingId ( previousId ) ; } else { parent . setLastChildId ( previousId ) ; } }
private void snipOutEntry ( Entry entry , final Entry parent , boolean removeParentRelationship ) { final String previousId = entry . getPreviousSiblingId ( ) ; if ( previousId != null ) { final Entry previous = getEntryById ( previousId ) ; previous . setNextSiblingId ( entry . getNextSiblingId ( ) ) ; } else { parent . setFirstChildId ( entry . getNextSiblingId ( ) ) ; } final String nextId = entry . getNextSiblingId ( ) ; if ( nextId != null ) { final Entry next = getEntryById ( nextId ) ; next . setPreviousSiblingId ( previousId ) ; } else { parent . setLastChildId ( previousId ) ; } }
public ColumnTable ( Object [ ] arrays , int [ ] sizes ) throws TableException { setup ( arrays , sizes ) ; }
public void testExceptionally_exceptionalCompletionActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = f . exceptionally ( null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex2 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
public void testExceptionally_exceptionalCompletionActionFailed ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CFException ex1 = new CFException ( ) ; final CFException ex2 = new CFException ( ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) f . completeExceptionally ( ex1 ) ; final CompletableFuture < Integer > g = f . exceptionally ( null ) ; if ( createIncomplete ) f . completeExceptionally ( ex1 ) ; checkCompletedWithWrappedException ( g , ex2 ) ; checkCompletedExceptionally ( f , ex1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
@ SuppressLint ( STRING ) public AbstractAndroidKeystoreSecretKeyWrapper ( Context context , String alias ) throws GeneralSecurityException { mAlias = alias ; mCipher = Cipher . getInstance ( getTransformation ( ) ) ; mContext = context . getApplicationContext ( ) ; }
@ SuppressLint ( STRING ) public AbstractAndroidKeystoreSecretKeyWrapper ( Context context , String alias ) throws GeneralSecurityException { mAlias = alias ; mCipher = Cipher . getInstance ( getTransformation ( ) ) ; mContext = context . getApplicationContext ( ) ; }
@ SuppressLint ( STRING ) public AbstractAndroidKeystoreSecretKeyWrapper ( Context context , String alias ) throws GeneralSecurityException { mAlias = alias ; mCipher = Cipher . getInstance ( getTransformation ( ) ) ; mContext = context . getApplicationContext ( ) ; }
public void notifyUnlockInput ( ) { if ( locked ) { synchronized ( directorListeners ) { IDirectorListener [ ] listeners = directorListeners . toArray ( new IDirectorListener [ directorListeners . size ( ) ] ) ; for ( IDirectorListener directorListener : listeners ) { if ( directorListener != this ) directorListener . unlockUserInput ( ) ; } } } locked = _BOOL ; }
public Image flipImageHorizontally ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = _NUM ; y < height ; y ++ ) { for ( int x = _NUM ; x < width ; x ++ ) { newRGB [ ( width - x - _NUM ) + y * width ] = rgb [ x + y * width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
public Image flipImageHorizontally ( Image image , boolean maintainOpacity ) { int [ ] rgb = image . getRGB ( ) ; int [ ] newRGB = new int [ rgb . length ] ; int width = image . getWidth ( ) ; int height = image . getHeight ( ) ; for ( int y = _NUM ; y < height ; y ++ ) { for ( int x = _NUM ; x < width ; x ++ ) { newRGB [ ( width - x - _NUM ) + y * width ] = rgb [ x + y * width ] ; } } return EncodedImage . createFromRGB ( newRGB , width , height , ! maintainOpacity ) ; }
@ Override public synchronized void addTrainingSetListener ( TrainingSetListener tsl ) { m_listeners . addElement ( tsl ) ; }
@ Override public int read ( ) throws IOException { return m_InputStream . read ( ) ; }
public RegisterDescription ( final String name , final int size , final boolean editable ) { this . name = Preconditions . checkNotNull ( name , STRING ) ; if ( ! isValidSize ( size ) ) { throw new IllegalArgumentException ( String . format ( STRING , size ) ) ; } byteSize = size ; isEditable = editable ; }
private void postInitViewPager ( ) { try { Class < ? > viewpager = ViewPager . class ; Field scroller = viewpager . getDeclaredField ( STRING ) ; scroller . setAccessible ( _BOOL ) ; Field interpolator = viewpager . getDeclaredField ( STRING ) ; interpolator . setAccessible ( _BOOL ) ; mScroller = new ScrollerCustomDuration ( getContext ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , mScroller ) ; } catch ( Exception e ) { } }
private void postInitViewPager ( ) { try { Class < ? > viewpager = ViewPager . class ; Field scroller = viewpager . getDeclaredField ( STRING ) ; scroller . setAccessible ( _BOOL ) ; Field interpolator = viewpager . getDeclaredField ( STRING ) ; interpolator . setAccessible ( _BOOL ) ; mScroller = new ScrollerCustomDuration ( getContext ( ) , ( Interpolator ) interpolator . get ( null ) ) ; scroller . set ( this , mScroller ) ; } catch ( Exception e ) { } }
public static String xmlize ( String s ) { s = s . replaceAll ( STRING , STRING ) ; s = s . replaceAll ( STRING , STRING ) ; s = s . replaceAll ( STRING , STRING ) ; s = s . replaceAll ( STRING , STRING ) ; int charCount = s . length ( ) ; for ( int iter = _NUM ; iter < charCount ; iter ++ ) { char c = s . charAt ( iter ) ; if ( c > _NUM ) { StringBuilder b = new StringBuilder ( ) ; for ( int counter = _NUM ; counter < charCount ; counter ++ ) { c = s . charAt ( counter ) ; if ( c > _NUM ) { b . append ( STRING ) ; b . append ( Integer . toHexString ( c ) ) ; b . append ( STRING ) ; } else { b . append ( c ) ; } } return b . toString ( ) ; } } return s ; }
public final boolean contentEquals ( java . lang . CharSequence csq ) { if ( csq . length ( ) != _length ) return _BOOL ; for ( int i = _NUM ; i < _length ; ) { char c = _high [ i > > B1 ] [ i & M1 ] ; if ( csq . charAt ( i ++ ) != c ) return _BOOL ; } return _BOOL ; }
public final boolean contentEquals ( java . lang . CharSequence csq ) { if ( csq . length ( ) != _length ) return _BOOL ; for ( int i = _NUM ; i < _length ; ) { char c = _high [ i > > B1 ] [ i & M1 ] ; if ( csq . charAt ( i ++ ) != c ) return _BOOL ; } return _BOOL ; }
public boolean writeHeader ( OutputStream os ) { try { IOUtils . writeInt ( os , CACHE_MAGIC ) ; IOUtils . writeString ( os , key ) ; IOUtils . writeString ( os , etag == null ? STRING : etag ) ; IOUtils . writeLong ( os , serverDate ) ; IOUtils . writeLong ( os , lastModified ) ; IOUtils . writeLong ( os , ttl ) ; IOUtils . writeLong ( os , softTtl ) ; IOUtils . writeStringStringMap ( responseHeaders , os ) ; os . flush ( ) ; return _BOOL ; } catch ( IOException e ) { VolleyLog . d ( STRING , e . toString ( ) ) ; return _BOOL ; } }
protected ArrayList < ArrayList < DBIDs > > buildRanges ( Relation < V > relation ) { final int dim = RelationUtil . dimensionality ( relation ) ; final int size = relation . size ( ) ; final ArrayList < ArrayList < DBIDs > > ranges = new ArrayList < > ( ) ; ArrayModifiableDBIDs ids = DBIDUtil . newArray ( relation . getDBIDs ( ) ) ; SortDBIDsBySingleDimension sorter = new SortDBIDsBySingleDimension ( relation ) ; final double part = size * _NUM / phi ; for ( int d = _NUM ; d < dim ; d ++ ) { sorter . setDimension ( d ) ; ids . sort ( sorter ) ; ArrayList < DBIDs > dimranges = new ArrayList < > ( phi + _NUM ) ; int start = _NUM ; DBIDArrayIter iter = ids . iter ( ) ; for ( int r = _NUM ; r <= phi ; r ++ ) { int end = ( r < phi ) ? ( int ) ( part * r ) : size ; ArrayModifiableDBIDs currange = DBIDUtil . newArray ( end - start ) ; for ( iter . seek ( start ) ; iter . getOffset ( ) < end ; iter . advance ( ) ) { currange . add ( iter ) ; } start = end ; dimranges . add ( currange ) ; } ranges . add ( dimranges ) ; } return ranges ; }
private void updateHostState ( Operation operation , State hostState , AgentState agentState ) { if ( hostState . agentState != agentState ) { State patchState = new State ( ) ; patchState . agentState = agentState ; ServiceUtils . logInfo ( this , STRING + hostState . hostAddress + STRING + hostState . agentState + STRING + STRING + agentState ) ; TaskUtils . sendSelfPatch ( this , patchState ) ; } if ( operation != null ) { operation . complete ( ) ; } }
private void updateHostState ( Operation operation , State hostState , AgentState agentState ) { if ( hostState . agentState != agentState ) { State patchState = new State ( ) ; patchState . agentState = agentState ; ServiceUtils . logInfo ( this , STRING + hostState . hostAddress + STRING + hostState . agentState + STRING + STRING + agentState ) ; TaskUtils . sendSelfPatch ( this , patchState ) ; } if ( operation != null ) { operation . complete ( ) ; } }
private void errorsToHTML ( Errors errors , PrintWriter writer ) { if ( errors != null && errors . hasErrors ( ) ) { writer . print ( STRING ) ; for ( final String text : errors . getTexts ( ) ) { writer . print ( STRING ) ; writer . print ( StringEscapeUtils . escapeHtml4 ( text ) ) ; writer . print ( STRING ) ; } writer . print ( STRING ) ; } }
final protected < T > T configureImpl ( Class < T > type ) throws ConfigException { try { T value = type . newInstance ( ) ; InjectContext context = null ; injectTop ( value , context ) ; return value ; } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw ConfigException . wrap ( e ) ; } }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void addHandler ( Handler handler ) throws SecurityException { handler . getClass ( ) ; checkPermission ( ) ; handlers . add ( handler ) ; }
public void removeAllEmails ( ) { emails . clear ( ) ; }
public void removeAllEmails ( ) { emails . clear ( ) ; }
void emitNext ( Object n ) { if ( ! fastPath ) { synchronized ( this ) { first = _BOOL ; if ( emitting ) { if ( queue == null ) { queue = new ArrayList < Object > ( ) ; } queue . add ( n ) ; return ; } } fastPath = _BOOL ; } NotificationLite . accept ( actual , n ) ; }
void emitNext ( Object n ) { if ( ! fastPath ) { synchronized ( this ) { first = _BOOL ; if ( emitting ) { if ( queue == null ) { queue = new ArrayList < Object > ( ) ; } queue . add ( n ) ; return ; } } fastPath = _BOOL ; } NotificationLite . accept ( actual , n ) ; }
void updateWaitingCommands ( ) { int index = commitIndex ; if ( isLeader ( ) ) { CoreCmd ccmd = waitQueue . peek ( ) ; while ( ccmd != null && ccmd . index <= index ) { latency . tail ( ccmd . index ) ; ccmd . update ( Command . STATUS_OK , leaderId ) ; waitQueue . poll ( ) ; ccmd = waitQueue . peek ( ) ; } } saveQueue . getLatest ( savedRid ) ; index = Math . min ( commitIndex , savedRid . index ) ; commitQueue . updateCommitIndex ( index ) ; }
void updateWaitingCommands ( ) { int index = commitIndex ; if ( isLeader ( ) ) { CoreCmd ccmd = waitQueue . peek ( ) ; while ( ccmd != null && ccmd . index <= index ) { latency . tail ( ccmd . index ) ; ccmd . update ( Command . STATUS_OK , leaderId ) ; waitQueue . poll ( ) ; ccmd = waitQueue . peek ( ) ; } } saveQueue . getLatest ( savedRid ) ; index = Math . min ( commitIndex , savedRid . index ) ; commitQueue . updateCommitIndex ( index ) ; }
public static String toString ( final URL url , final Charset encoding ) throws IOException { InputStream inputStream = url . openStream ( ) ; try { return IOUtils . toString ( inputStream , encoding ) ; } finally { inputStream . close ( ) ; } }
public static String toString ( final URL url , final Charset encoding ) throws IOException { InputStream inputStream = url . openStream ( ) ; try { return IOUtils . toString ( inputStream , encoding ) ; } finally { inputStream . close ( ) ; } }
public static void writeTextFile ( String directory , String filename , String data , boolean overwrite ) { try { File f ; f = Util . createFileOnDevice ( directory , filename , overwrite ) ; FileWriter fw = new FileWriter ( f . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( data ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static void writeTextFile ( String directory , String filename , String data , boolean overwrite ) { try { File f ; f = Util . createFileOnDevice ( directory , filename , overwrite ) ; FileWriter fw = new FileWriter ( f . getAbsoluteFile ( ) ) ; BufferedWriter bw = new BufferedWriter ( fw ) ; bw . write ( data ) ; bw . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
private static JFreeChart createChart ( ) { XYSeries series1 = new XYSeries ( STRING ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; series1 . add ( _NUM , _NUM ) ; IntervalXYDataset dataset = new XYBarDataset ( new XYSeriesCollection ( series1 ) , _NUM ) ; return ChartFactory . createXYBarChart ( STRING , STRING , _BOOL , STRING , dataset ) ; }
public static List < String > filterTags ( List < LanguageRange > priorityList , Collection < String > tags , FilteringMode mode ) { return LocaleMatcher . filterTags ( priorityList , tags , mode ) ; }
public static List < String > filterTags ( List < LanguageRange > priorityList , Collection < String > tags , FilteringMode mode ) { return LocaleMatcher . filterTags ( priorityList , tags , mode ) ; }
public static List < String > filterTags ( List < LanguageRange > priorityList , Collection < String > tags , FilteringMode mode ) { return LocaleMatcher . filterTags ( priorityList , tags , mode ) ; }
public static PSQLException extractPSQLException ( Throwable exception ) { while ( exception != null ) { if ( exception instanceof PSQLException ) { return ( PSQLException ) exception ; } exception = exception . getCause ( ) ; } return null ; }
public static PSQLException extractPSQLException ( Throwable exception ) { while ( exception != null ) { if ( exception instanceof PSQLException ) { return ( PSQLException ) exception ; } exception = exception . getCause ( ) ; } return null ; }
public long toEpochSecond ( ) { return transition . toEpochSecond ( offsetBefore ) ; }
private static void addLeafWithNonExistingParents ( Spatial root , Spatial leaf ) { if ( ! ( root instanceof Node ) ) { logger . log ( Level . WARNING , STRING , new Object [ ] { leaf . getName ( ) , root . getName ( ) } ) ; return ; } for ( Spatial s = leaf ; s . getParent ( ) != null ; s = s . getParent ( ) ) { Spatial parent = s . getParent ( ) ; Spatial other = findTaggedSpatial ( root , parent ) ; if ( other == null ) { continue ; } if ( other instanceof Node ) { logger . log ( Level . INFO , STRING , new Object [ ] { s , other , root , leaf } ) ; for ( Spatial spt = leaf ; spt != parent ; spt = spt . getParent ( ) ) { spt . setUserData ( ORIGINAL_NAME , spt . getName ( ) ) ; spt . setUserData ( ORIGINAL_PATH , getSpatialPath ( spt ) ) ; spt = spt . getParent ( ) ; } Node otherNode = ( Node ) other ; otherNode . attachChild ( s ) ; logger . log ( LogLevel . USERINFO , STRING , new Object [ ] { other . getName ( ) , leaf . getName ( ) } ) ; return ; } else { logger . log ( Level . WARNING , STRING , new Object [ ] { leaf , other , root } ) ; } } logger . log ( Level . WARNING , STRING , leaf . getName ( ) ) ; }
private void stopWatchdog ( ) { if ( watchdog != null ) { watchdog . shutdownNow ( ) ; watchdog = null ; } }
public void testConstructorStringRadix10Negative ( ) { String value = STRING ; int radix = _NUM ; byte rBytes [ ] = { - _NUM , _NUM , _NUM , _NUM , - _NUM , _NUM , - _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( value , radix ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , aNumber . signum ( ) ) ; }
public void runAsserts ( List < Step > list , int size , Boolean needAssignee ) { assertEquals ( size , list . size ( ) ) ; for ( int i = _NUM ; i < size ; i ++ ) { runAsserts ( list . get ( i ) , i , needAssignee ) ; } }
public void runAsserts ( List < Step > list , int size , Boolean needAssignee ) { assertEquals ( size , list . size ( ) ) ; for ( int i = _NUM ; i < size ; i ++ ) { runAsserts ( list . get ( i ) , i , needAssignee ) ; } }
public void connect ( String view ) { try { reader = new NetMapReader ( server , port , this , view ) ; reader . start ( ) ; if ( serverPanel != null ) { serverAddrField . setEnabled ( _BOOL ) ; serverPortField . setEnabled ( _BOOL ) ; controlButton . setText ( ServerDisconnectCmd ) ; controlButton . setActionCommand ( ServerDisconnectCmd ) ; } } catch ( IOException e ) { Debug . message ( STRING , STRING + e ) ; disconnect ( ) ; } }
public static ECPublicKeyParameters readECParametersWithPublicKey ( InputStream input ) throws IOException { ECDomainParameters domainParameters = readECParameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] pointFormats = convertPointFormats ( ECPointFormat . values ( ) ) ; return TlsECCUtils . deserializeECPublicKey ( pointFormats , domainParameters , point ) ; }
public static ECPublicKeyParameters readECParametersWithPublicKey ( InputStream input ) throws IOException { ECDomainParameters domainParameters = readECParameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] pointFormats = convertPointFormats ( ECPointFormat . values ( ) ) ; return TlsECCUtils . deserializeECPublicKey ( pointFormats , domainParameters , point ) ; }
public static ECPublicKeyParameters readECParametersWithPublicKey ( InputStream input ) throws IOException { ECDomainParameters domainParameters = readECParameters ( input ) ; int length = input . read ( ) ; byte [ ] point = new byte [ length ] ; input . read ( point ) ; short [ ] pointFormats = convertPointFormats ( ECPointFormat . values ( ) ) ; return TlsECCUtils . deserializeECPublicKey ( pointFormats , domainParameters , point ) ; }
public int convertToPixels ( float dipCount ) { return Math . round ( impl . convertToPixels ( ( int ) ( dipCount * _NUM ) , _BOOL ) / _NUM ) ; }
public int convertToPixels ( float dipCount ) { return Math . round ( impl . convertToPixels ( ( int ) ( dipCount * _NUM ) , _BOOL ) / _NUM ) ; }
public int read ( ) throws IOException { int b = in . read ( ) ; if ( b != - _NUM ) { cksum . update ( b ) ; } return b ; }
public void quit ( ) { if ( ! isConnected ( ) ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING ) ; } send ( STRING ) ; try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } disconnect ( ) ; }
public void quit ( ) { if ( ! isConnected ( ) ) { return ; } if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING ) ; } send ( STRING ) ; try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } disconnect ( ) ; }
public void close ( ) throws IOException { socket . close ( ) ; }
public void close ( ) throws IOException { socket . close ( ) ; }
public void close ( ) throws IOException { socket . close ( ) ; }
public void close ( ) throws IOException { socket . close ( ) ; }
public ConcurrentCoapResource ( String name ) { super ( name ) ; this . threads = getAvailableProcessors ( ) ; setExecutor ( Executors . newFixedThreadPool ( threads , new Utils . NamedThreadFactory ( STRING + name + STRING ) ) ) ; }
public Builder ( final InputStream input_stream , TrafficDirection direction ) throws IllegalArgumentException { if ( input_stream == null ) { throw new IllegalArgumentException ( STRING ) ; } this . wrappedStream = input_stream ; if ( direction == null ) { throw new IllegalArgumentException ( STRING ) ; } this . direction = direction ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Boolean ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Boolean ) obj ) . value == value ; }
public static void prepareData ( Instances data ) throws Exception { String doptions [ ] = null ; try { doptions = MLUtils . getDatasetOptions ( data ) ; } catch ( Exception e ) { throw new Exception ( STRING , e ) ; } try { int c = ( Utils . getOptionPos ( STRING , doptions ) >= _NUM ) ? Integer . parseInt ( Utils . getOption ( STRING , doptions ) ) : Integer . parseInt ( Utils . getOption ( STRING , doptions ) ) ; if ( c < _NUM ) { c = - c ; data = F . mulan2meka ( data , c ) ; } data . setClassIndex ( c ) ; } catch ( Exception e ) { throw new Exception ( STRING + STRING + STRING + STRING + data . relationName ( ) + STRING + STRING + STRING + STRING , e ) ; } }
public Task < Void > unpinInBackground ( ) { return unpinAllInBackground ( DEFAULT_PIN , Arrays . asList ( this ) ) ; }
public Task < Void > unpinInBackground ( ) { return unpinAllInBackground ( DEFAULT_PIN , Arrays . asList ( this ) ) ; }
public Task < Void > unpinInBackground ( ) { return unpinAllInBackground ( DEFAULT_PIN , Arrays . asList ( this ) ) ; }
@ Override public String toString ( ) { return nodeId + STRING + actionValues . toString ( ) ; }
@ Override public String toString ( ) { return nodeId + STRING + actionValues . toString ( ) ; }
private static int appendIntersectionTypeSignature ( char [ ] string , int start , boolean fullyQualifyTypeNames , StringBuffer buffer ) { if ( start >= string . length - _NUM ) { throw new IllegalArgumentException ( ) ; } char c = string [ start ] ; if ( c != C_INTERSECTION ) { throw new IllegalArgumentException ( ) ; } start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start < string . length - _NUM ) { start ++ ; if ( string [ start ] != C_COLON ) { throw new IllegalArgumentException ( STRING ) ; } while ( string [ start ] == C_COLON ) { buffer . append ( STRING ) ; start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start == string . length - _NUM ) { return start ; } else if ( start > string . length - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } start ++ ; } } return start ; }
private static int appendIntersectionTypeSignature ( char [ ] string , int start , boolean fullyQualifyTypeNames , StringBuffer buffer ) { if ( start >= string . length - _NUM ) { throw new IllegalArgumentException ( ) ; } char c = string [ start ] ; if ( c != C_INTERSECTION ) { throw new IllegalArgumentException ( ) ; } start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start < string . length - _NUM ) { start ++ ; if ( string [ start ] != C_COLON ) { throw new IllegalArgumentException ( STRING ) ; } while ( string [ start ] == C_COLON ) { buffer . append ( STRING ) ; start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start == string . length - _NUM ) { return start ; } else if ( start > string . length - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } start ++ ; } } return start ; }
private static int appendIntersectionTypeSignature ( char [ ] string , int start , boolean fullyQualifyTypeNames , StringBuffer buffer ) { if ( start >= string . length - _NUM ) { throw new IllegalArgumentException ( ) ; } char c = string [ start ] ; if ( c != C_INTERSECTION ) { throw new IllegalArgumentException ( ) ; } start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start < string . length - _NUM ) { start ++ ; if ( string [ start ] != C_COLON ) { throw new IllegalArgumentException ( STRING ) ; } while ( string [ start ] == C_COLON ) { buffer . append ( STRING ) ; start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start == string . length - _NUM ) { return start ; } else if ( start > string . length - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } start ++ ; } } return start ; }
private static int appendIntersectionTypeSignature ( char [ ] string , int start , boolean fullyQualifyTypeNames , StringBuffer buffer ) { if ( start >= string . length - _NUM ) { throw new IllegalArgumentException ( ) ; } char c = string [ start ] ; if ( c != C_INTERSECTION ) { throw new IllegalArgumentException ( ) ; } start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start < string . length - _NUM ) { start ++ ; if ( string [ start ] != C_COLON ) { throw new IllegalArgumentException ( STRING ) ; } while ( string [ start ] == C_COLON ) { buffer . append ( STRING ) ; start = appendClassTypeSignature ( string , start + _NUM , fullyQualifyTypeNames , buffer ) ; if ( start == string . length - _NUM ) { return start ; } else if ( start > string . length - _NUM ) { throw new IllegalArgumentException ( STRING ) ; } start ++ ; } } return start ; }
public WrappingStringBuilder append ( final String s ) { final int end = s . length ( ) ; for ( int i = _NUM ; i < end ; i ++ ) { append ( s . charAt ( i ) ) ; } return this ; }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public void handleWindowFocusEvent ( boolean parentWindowActive ) { this . parentWindowActive = parentWindowActive ; synchronized ( classLock ) { if ( ! parentWindowActive ) { this . browserWindowFocusedApplet = globalFocusedWindow ; } if ( parentWindowActive && globalFocusedWindow != this && isParentWindowChanged ( ) ) { globalFocusedWindow = ( this . browserWindowFocusedApplet != null ) ? this . browserWindowFocusedApplet : this ; } } if ( globalFocusedWindow == this && parentWindowActive ) { responder . handleWindowFocusEvent ( parentWindowActive , null ) ; } }
public static String [ ] lineToArray ( String line ) { String [ ] splitArray ; splitArray = line . split ( STRING ) ; return splitArray ; }
public void deleteLast ( ) { final int codesSize = mCodes . size ( ) ; if ( codesSize > _NUM ) { mCodes . remove ( codesSize - _NUM ) ; final int lastPos = mTypedWord . length ( ) - _NUM ; char last = mTypedWord . charAt ( lastPos ) ; mTypedWord . deleteCharAt ( lastPos ) ; if ( Character . isUpperCase ( last ) ) mCapsCount -- ; } }
public void deleteLast ( ) { final int codesSize = mCodes . size ( ) ; if ( codesSize > _NUM ) { mCodes . remove ( codesSize - _NUM ) ; final int lastPos = mTypedWord . length ( ) - _NUM ; char last = mTypedWord . charAt ( lastPos ) ; mTypedWord . deleteCharAt ( lastPos ) ; if ( Character . isUpperCase ( last ) ) mCapsCount -- ; } }
private Client createServerClient ( ) { Client client = new Client ( ) ; client . name = STRING ; client . registrationToken = SENDER_ID + STRING ; client . profilePictureUrl = STRING ; return client ; }
protected boolean removeIfPresentEstimate ( EstimateMapKey key , LoadEstimateTask task ) { return estimateMap . remove ( key , task ) ; }
protected boolean removeIfPresentEstimate ( EstimateMapKey key , LoadEstimateTask task ) { return estimateMap . remove ( key , task ) ; }
public SDPAnnounceParser ( String message ) { int start = _NUM ; String line = null ; if ( message == null ) return ; sdpMessage = new Vector ( ) ; String sdpAnnounce = message . trim ( ) + STRING ; while ( start < sdpAnnounce . length ( ) ) { int lfPos = sdpAnnounce . indexOf ( STRING , start ) ; int crPos = sdpAnnounce . indexOf ( STRING , start ) ; if ( lfPos >= _NUM && crPos < _NUM ) { line = sdpAnnounce . substring ( start , lfPos ) ; start = lfPos + _NUM ; } else if ( lfPos < _NUM && crPos >= _NUM ) { line = sdpAnnounce . substring ( start , crPos ) ; start = crPos + _NUM ; } else if ( lfPos >= _NUM && crPos >= _NUM ) { if ( lfPos > crPos ) { line = sdpAnnounce . substring ( start , crPos ) ; if ( lfPos == crPos + _NUM ) { start = lfPos + _NUM ; } else { start = crPos + _NUM ; } } else { line = sdpAnnounce . substring ( start , lfPos ) ; if ( crPos == lfPos + _NUM ) { start = crPos + _NUM ; } else { start = lfPos + _NUM ; } } } else if ( lfPos < _NUM && crPos < _NUM ) { break ; } sdpMessage . addElement ( line ) ; } }
public static JPanel createErrorComponent ( String error ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JLabel label = new JLabel ( error , ERROR_ICON , SwingConstants . CENTER ) ; panel . add ( label , BorderLayout . CENTER ) ; return panel ; }
public static JPanel createErrorComponent ( String error ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JLabel label = new JLabel ( error , ERROR_ICON , SwingConstants . CENTER ) ; panel . add ( label , BorderLayout . CENTER ) ; return panel ; }
public static JPanel createErrorComponent ( String error ) { JPanel panel = new JPanel ( new BorderLayout ( ) ) ; JLabel label = new JLabel ( error , ERROR_ICON , SwingConstants . CENTER ) ; panel . add ( label , BorderLayout . CENTER ) ; return panel ; }
private void reset ( ) { isContent = _BOOL ; finished = _BOOL ; }
private void reset ( ) { isContent = _BOOL ; finished = _BOOL ; }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
@ TargetApi ( Build . VERSION_CODES . HONEYCOMB ) private static void choosePreviewSize ( Camera . Parameters parms , int width , int height ) { List < Camera . Size > previews = parms . getSupportedPreviewSizes ( ) ; for ( Camera . Size size : previews ) { if ( size . width == width && size . height == height ) { parms . setPreviewSize ( width , height ) ; if ( Cfg . DEBUG ) { Check . log ( TAG + STRING ) ; } return ; } } Camera . Size best = getBestPreviewSize ( parms , width , height ) ; if ( best != null ) { if ( Cfg . DEBUG ) { Check . log ( TAG + STRING + best . width + STRING + best . height ) ; } } if ( best != null ) { Log . w ( TAG , STRING + width + STRING + height ) ; parms . setPreviewSize ( best . width , best . height ) ; } }
public static boolean stringToBooleanValue ( String str ) throws ExpressionException { str = StringUtil . toLowerCase ( str . trim ( ) ) ; if ( str . equals ( STRING ) || str . equals ( STRING ) ) return _BOOL ; else if ( str . equals ( STRING ) || str . equals ( STRING ) ) return _BOOL ; throw new CasterException ( STRING + str + STRING ) ; }
public final float tanFOV ( ) { return ( ( float ) Math . tan ( Math . toRadians ( _fovY * _NUM ) ) ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
public static String stringDefaultValue ( String bytes ) { return new String ( bytes . getBytes ( ISO_8859_1 ) , InternalNano . UTF_8 ) ; }
@ Override public void operatorExported ( final Operator op , final Element opElement ) { Rectangle2D bounds = lookupOperatorRectangle ( op ) ; if ( bounds != null ) { opElement . setAttribute ( XML_ATTRIBUTE_X_POSITION , STRING + ( int ) bounds . getX ( ) ) ; opElement . setAttribute ( XML_ATTRIBUTE_Y_POSITION , STRING + ( int ) bounds . getY ( ) ) ; opElement . setAttribute ( XML_ATTRIBUTE_WIDTH , STRING + ( int ) bounds . getWidth ( ) ) ; opElement . setAttribute ( XML_ATTRIBUTE_HEIGHT , STRING + ( int ) bounds . getHeight ( ) ) ; } }
private void notifyAllEntity ( ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; signalShutdown ( resList ) ; signalShutdown ( gisList ) ; resList . clear ( ) ; gisList . clear ( ) ; }
private void notifyAllEntity ( ) { Log . printConcatLine ( super . getName ( ) , STRING ) ; signalShutdown ( resList ) ; signalShutdown ( gisList ) ; resList . clear ( ) ; gisList . clear ( ) ; }
@ Override public void resumeLocking ( ) { checkDestroyed ( ) ; try { unlock ( SUSPEND_LOCKING_TOKEN ) ; } catch ( IllegalStateException e ) { checkDestroyed ( ) ; throw e ; } }
public synchronized void removeBatchAssociationRulesListener ( BatchAssociationRulesListener al ) { m_rulesListeners . remove ( al ) ; }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( LsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } log . debug ( STRING + closePacket + STRING ) ; pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
final public void doLocalAbort ( ) { _abort ( ) ; }
final public void doLocalAbort ( ) { _abort ( ) ; }
final public void doLocalAbort ( ) { _abort ( ) ; }
private void handleHtmlSearchQuotations ( PageWrapper pageWrapper , RequestAndResponse requestAndResponse , String query , String paneId ) throws IOException , ServletException { pageWrapper . addPageIntroText ( servletText . introTextSearchQuotations ( _BOOL ) , servletText . introTextSearchQuotations ( _BOOL ) ) ; try { final StringBuilder result = new StringBuilder ( ) ; User queryUser = null ; if ( null != ( queryUser = canUserSeeUsersData ( requestAndResponse , _BOOL ) ) ) { final ResultsPaginator paginator = new ResultsPaginator ( requestAndResponse , servletText . sentenceThereWereNoMatches ( ) , result , servletText ) ; try { final List < ? > results = dbLogic . searchEntriesForUserByQuotation ( queryUser . getId ( ) , query , paginator . getStartPosition ( ) , paginator . getMaxResults ( ) ) ; entryListToHtmlAndJson ( paneId , result , paginator , results ) ; } catch ( EmptyQueryException e ) { requestAndResponse . print ( servletText . errorNeedLongerQuery ( ) ) ; } } dbLogic . commit ( ) ; requestAndResponse . print ( result . toString ( ) ) ; } catch ( final PersistenceException e ) { requestAndResponse . print ( servletText . errorInternalDatabase ( ) ) ; } }
public static String toStream ( String channel ) { if ( channel == null ) { return null ; } if ( channel . startsWith ( STRING ) ) { return channel . substring ( _NUM ) ; } return channel ; }
public long next ( ) { long result = - _NUM ; if ( cache < _NUM && bufferElements > _NUM ) { result = getNextFromBuffer ( ) ; bufferElements -- ; } else { result = cache ; cache = - _NUM ; } if ( ! cs . isEmpty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - _NUM ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - _NUM ) { throw new NoSuchElementException ( ) ; } Assert . check ( previous < result , EC . GENERAL ) ; previous = result ; readElements ++ ; return result ; }
public long next ( ) { long result = - _NUM ; if ( cache < _NUM && bufferElements > _NUM ) { result = getNextFromBuffer ( ) ; bufferElements -- ; } else { result = cache ; cache = - _NUM ; } if ( ! cs . isEmpty ( ) ) { long first = cs . first ( ) ; if ( result > first || result == - _NUM ) { cs . remove ( first ) ; cache = result ; result = first ; } } if ( result == - _NUM ) { throw new NoSuchElementException ( ) ; } Assert . check ( previous < result , EC . GENERAL ) ; previous = result ; readElements ++ ; return result ; }
public PlatformException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
public void addAction ( String action ) { Object [ ] args = new String [ _NUM ] ; SimpleDateFormat sdf = new SimpleDateFormat ( context . getString ( R . string . dateFormat ) ) ; args [ _NUM ] = sdf . format ( new Date ( ) ) ; String timestamp = context . getString ( R . string . timestamp , args ) ; history . add ( action + timestamp ) ; notifyListeners ( new PropertyChangeEvent ( this , ActivityConstants . historyProperty , null , null ) ) ; }
public Instances stringFreeStructure ( ) { ArrayList < Attribute > newAtts = new ArrayList < Attribute > ( ) ; for ( Attribute att : m_Attributes ) { if ( att . type ( ) == Attribute . STRING ) { newAtts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { newAtts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , _NUM ) , att . index ( ) ) ) ; } } if ( newAtts . size ( ) == _NUM ) { return new Instances ( this , _NUM ) ; } ArrayList < Attribute > atts = Utils . cast ( m_Attributes . clone ( ) ) ; for ( Attribute att : newAtts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , _NUM ) ; result . m_Attributes = atts ; return result ; }
public Instances stringFreeStructure ( ) { ArrayList < Attribute > newAtts = new ArrayList < Attribute > ( ) ; for ( Attribute att : m_Attributes ) { if ( att . type ( ) == Attribute . STRING ) { newAtts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { newAtts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , _NUM ) , att . index ( ) ) ) ; } } if ( newAtts . size ( ) == _NUM ) { return new Instances ( this , _NUM ) ; } ArrayList < Attribute > atts = Utils . cast ( m_Attributes . clone ( ) ) ; for ( Attribute att : newAtts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , _NUM ) ; result . m_Attributes = atts ; return result ; }
public Instances stringFreeStructure ( ) { ArrayList < Attribute > newAtts = new ArrayList < Attribute > ( ) ; for ( Attribute att : m_Attributes ) { if ( att . type ( ) == Attribute . STRING ) { newAtts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { newAtts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , _NUM ) , att . index ( ) ) ) ; } } if ( newAtts . size ( ) == _NUM ) { return new Instances ( this , _NUM ) ; } ArrayList < Attribute > atts = Utils . cast ( m_Attributes . clone ( ) ) ; for ( Attribute att : newAtts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , _NUM ) ; result . m_Attributes = atts ; return result ; }
public Instances stringFreeStructure ( ) { ArrayList < Attribute > newAtts = new ArrayList < Attribute > ( ) ; for ( Attribute att : m_Attributes ) { if ( att . type ( ) == Attribute . STRING ) { newAtts . add ( new Attribute ( att . name ( ) , ( List < String > ) null , att . index ( ) ) ) ; } else if ( att . type ( ) == Attribute . RELATIONAL ) { newAtts . add ( new Attribute ( att . name ( ) , new Instances ( att . relation ( ) , _NUM ) , att . index ( ) ) ) ; } } if ( newAtts . size ( ) == _NUM ) { return new Instances ( this , _NUM ) ; } ArrayList < Attribute > atts = Utils . cast ( m_Attributes . clone ( ) ) ; for ( Attribute att : newAtts ) { atts . set ( att . index ( ) , att ) ; } Instances result = new Instances ( this , _NUM ) ; result . m_Attributes = atts ; return result ; }
private static float snapPercent ( float percent ) { int value = ( int ) ( percent * _NUM ) ; int slope = _NUM ; if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } return ( value / _NUM ) ; }
private static float snapPercent ( float percent ) { int value = ( int ) ( percent * _NUM ) ; int slope = _NUM ; if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } if ( Math . abs ( value - _NUM ) <= slope ) { value = _NUM ; } return ( value / _NUM ) ; }
public static void append ( ReadableDateTime t , StringBuilder s ) { s . append ( t . getYear ( ) ) ; appendTwoDigits ( t . getMonthOfYear ( ) , s ) ; appendTwoDigits ( t . getDayOfMonth ( ) , s ) ; s . append ( STRING ) ; appendTwoDigits ( t . getHourOfDay ( ) , s ) ; s . append ( STRING ) ; appendTwoDigits ( t . getMinuteOfHour ( ) , s ) ; s . append ( STRING ) ; appendTwoDigits ( t . getSecondOfMinute ( ) , s ) ; s . append ( STRING ) ; appendThreeDigits ( t . getMillisOfSecond ( ) , s ) ; }
public void updateTriggerDataMember ( Boolean triggerDataMember ) throws SecurityException { checkWriteAccess ( ) ; boolean hasAccess = ConfigWebUtil . hasAccess ( config , SecurityManager . TYPE_SETTING ) ; if ( ! hasAccess ) throw new SecurityException ( STRING ) ; Element scope = _getRootElement ( STRING ) ; scope . setAttribute ( STRING , Caster . toString ( triggerDataMember , STRING ) ) ; }
private void buildDomTree ( ) { int szNodes = nodes . size ( ) ; for ( int i = _NUM ; i < szNodes ; i ++ ) { DomInfo info = domInfos [ i ] ; if ( info . idom == - _NUM ) continue ; SsaBasicBlock domParent = nodes . get ( info . idom ) ; domParent . addDomChild ( nodes . get ( i ) ) ; } }
private void buildDomTree ( ) { int szNodes = nodes . size ( ) ; for ( int i = _NUM ; i < szNodes ; i ++ ) { DomInfo info = domInfos [ i ] ; if ( info . idom == - _NUM ) continue ; SsaBasicBlock domParent = nodes . get ( info . idom ) ; domParent . addDomChild ( nodes . get ( i ) ) ; } }
private void buildDomTree ( ) { int szNodes = nodes . size ( ) ; for ( int i = _NUM ; i < szNodes ; i ++ ) { DomInfo info = domInfos [ i ] ; if ( info . idom == - _NUM ) continue ; SsaBasicBlock domParent = nodes . get ( info . idom ) ; domParent . addDomChild ( nodes . get ( i ) ) ; } }
private static void addDigest ( MessageDigest digest , String string ) { if ( string == null ) return ; int len = string . length ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { int ch = string . charAt ( i ) ; if ( ch < _NUM ) digest . update ( ( byte ) ch ) ; else if ( ch < _NUM ) { digest . update ( ( byte ) ( _NUM + ( ch > > _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ch & _NUM ) ) ) ; } else { digest . update ( ( byte ) ( _NUM + ( ch > > _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ( ch > > _NUM ) & _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ch & _NUM ) ) ) ; } } }
private static void addDigest ( MessageDigest digest , String string ) { if ( string == null ) return ; int len = string . length ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { int ch = string . charAt ( i ) ; if ( ch < _NUM ) digest . update ( ( byte ) ch ) ; else if ( ch < _NUM ) { digest . update ( ( byte ) ( _NUM + ( ch > > _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ch & _NUM ) ) ) ; } else { digest . update ( ( byte ) ( _NUM + ( ch > > _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ( ch > > _NUM ) & _NUM ) ) ) ; digest . update ( ( byte ) ( _NUM + ( ch & _NUM ) ) ) ; } } }
public static < T > List < T > createProxies ( Optional < SSLSocketFactory > sslSocketFactory , Collection < String > endpointUris , Class < T > type ) { List < T > ret = Lists . newArrayListWithCapacity ( endpointUris . size ( ) ) ; for ( String uri : endpointUris ) { ret . add ( createProxy ( sslSocketFactory , uri , type ) ) ; } return ret ; }
protected void toString ( final StringBuilder sb ) { if ( initView ) { sb . append ( STRING + rangeCount ) ; sb . append ( STRING + partitionCount ) ; sb . append ( STRING + adjustedNominalShardSize ) ; sb . append ( STRING + percentOfSplit ) ; sb . append ( STRING + tailSplit ) ; } }
public String toXML ( final XStream xstream , final Object obj ) throws ObjectStreamException { final Writer writer = new StringWriter ( ) ; try { toXML ( xstream , obj , writer ) ; } catch ( final ObjectStreamException e ) { throw e ; } catch ( final IOException e ) { throw new StreamException ( STRING , e ) ; } return writer . toString ( ) ; }
public void addToClassification ( Integer classId , int size , List < Long > positions ) throws IOException { numberOfClasses ++ ; classificationIndexTmpFileWriter . writeInt ( classId ) ; if ( size == positions . size ( ) ) classificationIndexTmpFileWriter . writeInt ( size ) ; else { classificationIndexTmpFileWriter . writeInt ( - size ) ; classificationIndexTmpFileWriter . writeInt ( positions . size ( ) ) ; } if ( positions . size ( ) > _NUM ) { classificationIndexTmpFileWriter . writeLong ( io . getPosition ( ) ) ; for ( Long pos : positions ) { io . writeLong ( pos ) ; } } else { classificationIndexTmpFileWriter . writeLong ( - _NUM ) ; } }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static File downloadFileFrom ( Release release ) throws IOException { File file = new File ( NamingUtils . buildNameFrom ( release ) ) ; if ( ! file . exists ( ) ) { obtainNewJarFrom ( release , file ) ; } return file ; }
public static void addCustomAttributes ( XMLStreamReader xtr , BaseElement element , List < ExtensionAttribute > ... blackLists ) { for ( int i = _NUM ; i < xtr . getAttributeCount ( ) ; i ++ ) { ExtensionAttribute extensionAttribute = new ExtensionAttribute ( ) ; extensionAttribute . setName ( xtr . getAttributeLocalName ( i ) ) ; extensionAttribute . setValue ( xtr . getAttributeValue ( i ) ) ; if ( StringUtils . isNotEmpty ( xtr . getAttributeNamespace ( i ) ) ) { extensionAttribute . setNamespace ( xtr . getAttributeNamespace ( i ) ) ; } if ( StringUtils . isNotEmpty ( xtr . getAttributePrefix ( i ) ) ) { extensionAttribute . setNamespacePrefix ( xtr . getAttributePrefix ( i ) ) ; } if ( ! isBlacklisted ( extensionAttribute , blackLists ) ) { element . addAttribute ( extensionAttribute ) ; } } }
@ Override public void connectionLost ( Throwable cause ) { onDisconnect ( _BOOL ) ; }
public < T > T create ( Class < T > service , TProtocolFactory protocolFactory , Scheduler subscribScheduler , Interceptor ... interceptors ) { if ( ! service . isInterface ( ) ) { throw new IllegalArgumentException ( STRING ) ; } return ( T ) Proxy . newProxyInstance ( service . getClassLoader ( ) , new Class < ? > [ ] { service } , new Client ( protocolFactory , subscribScheduler , interceptors ) ) ; }
public < T > T create ( Class < T > service , TProtocolFactory protocolFactory , Scheduler subscribScheduler , Interceptor ... interceptors ) { if ( ! service . isInterface ( ) ) { throw new IllegalArgumentException ( STRING ) ; } return ( T ) Proxy . newProxyInstance ( service . getClassLoader ( ) , new Class < ? > [ ] { service } , new Client ( protocolFactory , subscribScheduler , interceptors ) ) ; }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public static void apply ( Collection coll , Function func ) { for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { func . execute ( i . next ( ) ) ; } }
public Optional < ObaUserDataItem > loadItem ( final ObaUserDataItem tableItem ) { DynamoDBMapper mapper = createDynamoDBMapper ( ) ; ObaUserDataItem item = mapper . load ( tableItem ) ; return Optional . ofNullable ( item ) ; }
public Optional < ObaUserDataItem > loadItem ( final ObaUserDataItem tableItem ) { DynamoDBMapper mapper = createDynamoDBMapper ( ) ; ObaUserDataItem item = mapper . load ( tableItem ) ; return Optional . ofNullable ( item ) ; }
public Optional < ObaUserDataItem > loadItem ( final ObaUserDataItem tableItem ) { DynamoDBMapper mapper = createDynamoDBMapper ( ) ; ObaUserDataItem item = mapper . load ( tableItem ) ; return Optional . ofNullable ( item ) ; }
private void sleep ( long sleeptime ) { try { Thread . sleep ( sleeptime ) ; } catch ( InterruptedException e ) { } }
void remove ( String inputFragmentStr , String formatFragment ) { if ( inputFragmentStr != null && inputStr . length ( ) >= inputFragmentStr . length ( ) ) { inputStr = inputStr . substring ( inputFragmentStr . length ( ) ) ; } if ( formatFragment != null && formatStr . length ( ) >= formatFragment . length ( ) ) { formatStr = formatStr . substring ( formatFragment . length ( ) ) ; } }
private List < String > missingFood ( final Player player , final boolean hash ) { final List < String > result = new LinkedList < String > ( ) ; String doneText = player . getQuest ( QUEST_SLOT ) ; if ( doneText == null ) { doneText = STRING ; } final List < String > done = Arrays . asList ( doneText . split ( STRING ) ) ; for ( String ingredient : NEEDED_FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missingFood ( final Player player , final boolean hash ) { final List < String > result = new LinkedList < String > ( ) ; String doneText = player . getQuest ( QUEST_SLOT ) ; if ( doneText == null ) { doneText = STRING ; } final List < String > done = Arrays . asList ( doneText . split ( STRING ) ) ; for ( String ingredient : NEEDED_FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missingFood ( final Player player , final boolean hash ) { final List < String > result = new LinkedList < String > ( ) ; String doneText = player . getQuest ( QUEST_SLOT ) ; if ( doneText == null ) { doneText = STRING ; } final List < String > done = Arrays . asList ( doneText . split ( STRING ) ) ; for ( String ingredient : NEEDED_FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private List < String > missingFood ( final Player player , final boolean hash ) { final List < String > result = new LinkedList < String > ( ) ; String doneText = player . getQuest ( QUEST_SLOT ) ; if ( doneText == null ) { doneText = STRING ; } final List < String > done = Arrays . asList ( doneText . split ( STRING ) ) ; for ( String ingredient : NEEDED_FOOD ) { if ( ! done . contains ( ingredient ) ) { if ( hash ) { ingredient = STRING + ingredient ; } result . add ( ingredient ) ; } } return result ; }
private static boolean checkForSubtree ( @ NotNull LogHierarchyNode tree , @ NotNull String relativeBranch , @ NotNull String localURL ) { final LinkedList < LogHierarchyNode > queue = new LinkedList < LogHierarchyNode > ( ) ; queue . addLast ( tree ) ; while ( ! queue . isEmpty ( ) ) { final LogHierarchyNode element = queue . removeFirst ( ) ; ProgressManager . checkCanceled ( ) ; if ( checkForEntry ( element . getMe ( ) , localURL , relativeBranch ) ) return _BOOL ; queue . addAll ( element . getChildren ( ) ) ; } return _BOOL ; }
public void addIssuer ( X500Principal issuer ) { if ( issuer == null ) { throw new NullPointerException ( STRING ) ; } if ( issuerNames == null ) { issuerNames = new ArrayList < String > ( ) ; } String name = issuer . getName ( X500Principal . CANONICAL ) ; if ( ! issuerNames . contains ( name ) ) { issuerNames . add ( name ) ; } if ( issuerPrincipals == null ) { issuerPrincipals = new ArrayList < X500Principal > ( issuerNames . size ( ) ) ; } int size = issuerNames . size ( ) - _NUM ; for ( int i = issuerPrincipals . size ( ) ; i < size ; i ++ ) { issuerPrincipals . add ( new X500Principal ( issuerNames . get ( i ) ) ) ; } issuerPrincipals . add ( issuer ) ; }
public void addIssuer ( X500Principal issuer ) { if ( issuer == null ) { throw new NullPointerException ( STRING ) ; } if ( issuerNames == null ) { issuerNames = new ArrayList < String > ( ) ; } String name = issuer . getName ( X500Principal . CANONICAL ) ; if ( ! issuerNames . contains ( name ) ) { issuerNames . add ( name ) ; } if ( issuerPrincipals == null ) { issuerPrincipals = new ArrayList < X500Principal > ( issuerNames . size ( ) ) ; } int size = issuerNames . size ( ) - _NUM ; for ( int i = issuerPrincipals . size ( ) ; i < size ; i ++ ) { issuerPrincipals . add ( new X500Principal ( issuerNames . get ( i ) ) ) ; } issuerPrincipals . add ( issuer ) ; }
public void addIssuer ( X500Principal issuer ) { if ( issuer == null ) { throw new NullPointerException ( STRING ) ; } if ( issuerNames == null ) { issuerNames = new ArrayList < String > ( ) ; } String name = issuer . getName ( X500Principal . CANONICAL ) ; if ( ! issuerNames . contains ( name ) ) { issuerNames . add ( name ) ; } if ( issuerPrincipals == null ) { issuerPrincipals = new ArrayList < X500Principal > ( issuerNames . size ( ) ) ; } int size = issuerNames . size ( ) - _NUM ; for ( int i = issuerPrincipals . size ( ) ; i < size ; i ++ ) { issuerPrincipals . add ( new X500Principal ( issuerNames . get ( i ) ) ) ; } issuerPrincipals . add ( issuer ) ; }
@ Override public void endWindow ( ) { if ( currentWindowId > windowDataManager . getLargestCompletedWindow ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holdingBuffer . poll ( ) ) != null ) { processMessage ( msg ) ; emitCount ++ ; lastMsg = msg ; } windowDataManager . save ( currentWindowRecoveryState , currentWindowId ) ; currentWindowRecoveryState . clear ( ) ; if ( lastMsg != null ) { acknowledge ( ) ; } pendingAck . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emitCount = _NUM ; } else if ( currentWindowId < windowDataManager . getLargestCompletedWindow ( ) ) { pendingAck . clear ( ) ; } context . setCounters ( counters ) ; }
@ Override public void endWindow ( ) { if ( currentWindowId > windowDataManager . getLargestCompletedWindow ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holdingBuffer . poll ( ) ) != null ) { processMessage ( msg ) ; emitCount ++ ; lastMsg = msg ; } windowDataManager . save ( currentWindowRecoveryState , currentWindowId ) ; currentWindowRecoveryState . clear ( ) ; if ( lastMsg != null ) { acknowledge ( ) ; } pendingAck . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emitCount = _NUM ; } else if ( currentWindowId < windowDataManager . getLargestCompletedWindow ( ) ) { pendingAck . clear ( ) ; } context . setCounters ( counters ) ; }
@ Override public void endWindow ( ) { if ( currentWindowId > windowDataManager . getLargestCompletedWindow ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holdingBuffer . poll ( ) ) != null ) { processMessage ( msg ) ; emitCount ++ ; lastMsg = msg ; } windowDataManager . save ( currentWindowRecoveryState , currentWindowId ) ; currentWindowRecoveryState . clear ( ) ; if ( lastMsg != null ) { acknowledge ( ) ; } pendingAck . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emitCount = _NUM ; } else if ( currentWindowId < windowDataManager . getLargestCompletedWindow ( ) ) { pendingAck . clear ( ) ; } context . setCounters ( counters ) ; }
@ Override public void endWindow ( ) { if ( currentWindowId > windowDataManager . getLargestCompletedWindow ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holdingBuffer . poll ( ) ) != null ) { processMessage ( msg ) ; emitCount ++ ; lastMsg = msg ; } windowDataManager . save ( currentWindowRecoveryState , currentWindowId ) ; currentWindowRecoveryState . clear ( ) ; if ( lastMsg != null ) { acknowledge ( ) ; } pendingAck . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emitCount = _NUM ; } else if ( currentWindowId < windowDataManager . getLargestCompletedWindow ( ) ) { pendingAck . clear ( ) ; } context . setCounters ( counters ) ; }
@ Override public void endWindow ( ) { if ( currentWindowId > windowDataManager . getLargestCompletedWindow ( ) ) { synchronized ( lock ) { try { Message msg ; while ( ( msg = holdingBuffer . poll ( ) ) != null ) { processMessage ( msg ) ; emitCount ++ ; lastMsg = msg ; } windowDataManager . save ( currentWindowRecoveryState , currentWindowId ) ; currentWindowRecoveryState . clear ( ) ; if ( lastMsg != null ) { acknowledge ( ) ; } pendingAck . clear ( ) ; } catch ( Throwable t ) { Throwables . propagate ( t ) ; } } emitCount = _NUM ; } else if ( currentWindowId < windowDataManager . getLargestCompletedWindow ( ) ) { pendingAck . clear ( ) ; } context . setCounters ( counters ) ; }
public static String edgeTypeToString ( @ Type int edgeType ) { switch ( edgeType ) { case FALL_THROUGH_EDGE : return STRING ; case IFCMP_EDGE : return STRING ; case SWITCH_EDGE : return STRING ; case SWITCH_DEFAULT_EDGE : return STRING ; case JSR_EDGE : return STRING ; case RET_EDGE : return STRING ; case GOTO_EDGE : return STRING ; case RETURN_EDGE : return STRING ; case UNHANDLED_EXCEPTION_EDGE : return STRING ; case HANDLED_EXCEPTION_EDGE : return STRING ; case START_EDGE : return STRING ; case BACKEDGE_TARGET_EDGE : return STRING ; case BACKEDGE_SOURCE_EDGE : return STRING ; case EXIT_EDGE : return STRING ; } throw new IllegalStateException ( STRING + edgeType ) ; }
public static String edgeTypeToString ( @ Type int edgeType ) { switch ( edgeType ) { case FALL_THROUGH_EDGE : return STRING ; case IFCMP_EDGE : return STRING ; case SWITCH_EDGE : return STRING ; case SWITCH_DEFAULT_EDGE : return STRING ; case JSR_EDGE : return STRING ; case RET_EDGE : return STRING ; case GOTO_EDGE : return STRING ; case RETURN_EDGE : return STRING ; case UNHANDLED_EXCEPTION_EDGE : return STRING ; case HANDLED_EXCEPTION_EDGE : return STRING ; case START_EDGE : return STRING ; case BACKEDGE_TARGET_EDGE : return STRING ; case BACKEDGE_SOURCE_EDGE : return STRING ; case EXIT_EDGE : return STRING ; } throw new IllegalStateException ( STRING + edgeType ) ; }
static public JMenu helpMenu ( JMenuBar menuBar , String ref , boolean direct ) { JMenu helpMenu = makeHelpMenu ( ref , direct ) ; menuBar . add ( helpMenu ) ; return helpMenu ; }
private IPiece createPiece ( Context ctx , Scope parent , ForeignKey foreignKey ) throws ScopeException , SQLScopeException { List < ExpressionAST > joins = new LinkedList < ExpressionAST > ( ) ; for ( KeyPair pair : foreignKey . getKeys ( ) ) { joins . add ( ExpressionMaker . EQUAL ( new ColumnReference ( pair . getPrimary ( ) ) , new ColumnReference ( pair . getExported ( ) ) ) ) ; } if ( joins . size ( ) == _NUM ) { return createPiece ( ctx , parent , joins . get ( _NUM ) ) ; } else if ( joins . size ( ) > _NUM ) { return createPiece ( ctx , parent , ExpressionMaker . AND ( joins ) ) ; } else { throw new ScopeException ( STRING + foreignKey . getName ( ) + STRING + foreignKey . getForeignTable ( ) + STRING + foreignKey . getPrimaryTable ( ) ) ; } }
public synchronized void addRecentItem ( T item ) { item = fromString ( toString ( item ) ) ; if ( m_RecentItems . size ( ) > _NUM ) { if ( item . equals ( m_RecentItems . get ( _NUM ) ) ) return ; } m_RecentItems . remove ( item ) ; m_RecentItems . add ( _NUM , item ) ; while ( m_RecentItems . size ( ) > m_MaxCount ) m_RecentItems . remove ( m_RecentItems . size ( ) - _NUM ) ; if ( m_IgnoreChanges ) return ; writeProps ( ) ; updateMenu ( ) ; notifyRecentItemListenersOfAdd ( item ) ; }
protected Object skipProjectPackageFragmentRoot ( IPackageFragmentRoot root ) { if ( isProjectPackageFragmentRoot ( root ) ) return root . getParent ( ) ; return root ; }
protected Object skipProjectPackageFragmentRoot ( IPackageFragmentRoot root ) { if ( isProjectPackageFragmentRoot ( root ) ) return root . getParent ( ) ; return root ; }
public void removeFromDraggingConnections ( Block rootBlock ) { if ( mPendingDrag == null ) { return ; } mTempConnections . clear ( ) ; rootBlock . getAllConnectionsRecursive ( mTempConnections ) ; for ( int i = _NUM ; i < mTempConnections . size ( ) ; i ++ ) { Connection conn = mTempConnections . get ( i ) ; mDraggedConnections . remove ( conn ) ; conn . setDragMode ( _BOOL ) ; } }
public void removeFromDraggingConnections ( Block rootBlock ) { if ( mPendingDrag == null ) { return ; } mTempConnections . clear ( ) ; rootBlock . getAllConnectionsRecursive ( mTempConnections ) ; for ( int i = _NUM ; i < mTempConnections . size ( ) ; i ++ ) { Connection conn = mTempConnections . get ( i ) ; mDraggedConnections . remove ( conn ) ; conn . setDragMode ( _BOOL ) ; } }
public void removeFromDraggingConnections ( Block rootBlock ) { if ( mPendingDrag == null ) { return ; } mTempConnections . clear ( ) ; rootBlock . getAllConnectionsRecursive ( mTempConnections ) ; for ( int i = _NUM ; i < mTempConnections . size ( ) ; i ++ ) { Connection conn = mTempConnections . get ( i ) ; mDraggedConnections . remove ( conn ) ; conn . setDragMode ( _BOOL ) ; } }
public void removeFromDraggingConnections ( Block rootBlock ) { if ( mPendingDrag == null ) { return ; } mTempConnections . clear ( ) ; rootBlock . getAllConnectionsRecursive ( mTempConnections ) ; for ( int i = _NUM ; i < mTempConnections . size ( ) ; i ++ ) { Connection conn = mTempConnections . get ( i ) ; mDraggedConnections . remove ( conn ) ; conn . setDragMode ( _BOOL ) ; } }
public static void main ( String [ ] args ) { int result ; PrintWriter out = new PrintWriter ( new OutputStreamWriter ( System . out , UTF_8 ) ) ; PrintWriter err = new PrintWriter ( new OutputStreamWriter ( System . err , UTF_8 ) ) ; try { Main formatter = new Main ( out , err , System . in ) ; result = formatter . format ( args ) ; } catch ( UsageException e ) { err . print ( e . getMessage ( ) ) ; result = _NUM ; } finally { err . flush ( ) ; out . flush ( ) ; } System . exit ( result ) ; }
public static String reverseUrl ( String urlString ) throws MalformedURLException { return reverseUrl ( new URL ( urlString ) ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < lines . length ; i ++ ) { if ( i > _NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . toString ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < lines . length ; i ++ ) { if ( i > _NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . toString ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < lines . length ; i ++ ) { if ( i > _NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . toString ( ) ; }
public static String concatenate ( String [ ] lines , String delimiter ) { StringBuffer buffer = new StringBuffer ( ) ; for ( int i = _NUM ; i < lines . length ; i ++ ) { if ( i > _NUM ) buffer . append ( delimiter ) ; buffer . append ( lines [ i ] ) ; } return buffer . toString ( ) ; }
public JsonObject remove ( String name ) { if ( name == null ) { throw new NullPointerException ( STRING ) ; } int index = indexOf ( name ) ; if ( index != - _NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public JsonObject remove ( String name ) { if ( name == null ) { throw new NullPointerException ( STRING ) ; } int index = indexOf ( name ) ; if ( index != - _NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public JsonObject remove ( String name ) { if ( name == null ) { throw new NullPointerException ( STRING ) ; } int index = indexOf ( name ) ; if ( index != - _NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
public JsonObject remove ( String name ) { if ( name == null ) { throw new NullPointerException ( STRING ) ; } int index = indexOf ( name ) ; if ( index != - _NUM ) { table . remove ( index ) ; names . remove ( index ) ; values . remove ( index ) ; } return this ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
@ Override public boolean useBufferPerWindow ( ) { return ! Win32GraphicsEnvironment . isDWMCompositionEnabled ( ) ; }
public boolean readBit ( ) throws IOException { if ( bitField == - _NUM ) { bitField = in . read ( ) ; if ( bitField == - _NUM ) { throw new EOFException ( ) ; } mask = _NUM ; } boolean bit = ( bitField & mask ) != _NUM ; if ( ( mask <<= _NUM ) == _NUM ) { bitField = - _NUM ; } return bit ; }
public boolean readBit ( ) throws IOException { if ( bitField == - _NUM ) { bitField = in . read ( ) ; if ( bitField == - _NUM ) { throw new EOFException ( ) ; } mask = _NUM ; } boolean bit = ( bitField & mask ) != _NUM ; if ( ( mask <<= _NUM ) == _NUM ) { bitField = - _NUM ; } return bit ; }
public static Word [ ] prepareStringToken ( String str ) { if ( str == null ) { return new Word [ _NUM ] ; } final ArrayList < Word > strWithDelim = new ArrayList < Word > ( ) ; splitWordBySpace ( str , strWithDelim ) ; final Word [ ] toRet = new Word [ Math . min ( strWithDelim . size ( ) , MAX_NUM_WORDS ) ] ; for ( int i = _NUM ; i < Math . min ( strWithDelim . size ( ) , MAX_NUM_WORDS ) ; i ++ ) { toRet [ i ] = strWithDelim . get ( i ) ; } return toRet ; }
public void validationStateChanged ( K key , ValidationState newState ) { Set < ValidationState > states = validationErrorStates . get ( key ) ; if ( newState . isValid ( ) ) { if ( null == states ) { states = Collections . emptySet ( ) ; } boolean removed = states . remove ( newState ) ; if ( removed ) { if ( states . isEmpty ( ) ) { hideMessage ( key ) ; } else { showMessage ( key , states ) ; } notifyUpstream ( key , states ) ; } } else { if ( null == states ) { states = new HashSet < > ( ) ; validationErrorStates . put ( key , states ) ; } states . remove ( newState ) ; states . add ( newState ) ; showMessage ( key , states ) ; notifyUpstream ( key , states ) ; } }
public static String replaceCharacters ( final ConversionMethod conversionMethod , final String input , final int fromCharacter , final int toCharacter , final String wrap ) { String convertedText = input ; for ( int i = fromCharacter ; i <= toCharacter ; i ++ ) { final String characterToReplace = new String ( Character . toChars ( i ) ) ; if ( wrap != null ) { convertedText = convertedText . replace ( characterToReplace , wrap + convertText ( conversionMethod , characterToReplace ) + wrap ) ; } else { convertedText = convertedText . replace ( characterToReplace , convertText ( conversionMethod , characterToReplace ) ) ; } } return convertedText ; }
public static String replaceCharacters ( final ConversionMethod conversionMethod , final String input , final int fromCharacter , final int toCharacter , final String wrap ) { String convertedText = input ; for ( int i = fromCharacter ; i <= toCharacter ; i ++ ) { final String characterToReplace = new String ( Character . toChars ( i ) ) ; if ( wrap != null ) { convertedText = convertedText . replace ( characterToReplace , wrap + convertText ( conversionMethod , characterToReplace ) + wrap ) ; } else { convertedText = convertedText . replace ( characterToReplace , convertText ( conversionMethod , characterToReplace ) ) ; } } return convertedText ; }
public static String replaceCharacters ( final ConversionMethod conversionMethod , final String input , final int fromCharacter , final int toCharacter , final String wrap ) { String convertedText = input ; for ( int i = fromCharacter ; i <= toCharacter ; i ++ ) { final String characterToReplace = new String ( Character . toChars ( i ) ) ; if ( wrap != null ) { convertedText = convertedText . replace ( characterToReplace , wrap + convertText ( conversionMethod , characterToReplace ) + wrap ) ; } else { convertedText = convertedText . replace ( characterToReplace , convertText ( conversionMethod , characterToReplace ) ) ; } } return convertedText ; }
public static Collection < DebuggerException > mergeExceptionsSettings ( final DebugTargetSettings target , final Collection < DebuggerException > exceptions , final int debuggerId ) throws CouldntLoadDataException { final Map < Long , DebuggerException > exceptionsMap = getExceptionsMap ( exceptions ) ; for ( final DebuggerException dbgException : exceptions ) { final String setting = target . readSetting ( DebuggerException . getSettingKey ( dbgException , debuggerId ) ) ; if ( setting != null ) { final DebuggerExceptionHandlingAction handlingAction = DebuggerExceptionHandlingAction . convertToHandlingAction ( Integer . valueOf ( setting ) ) ; final DebuggerException newException = new DebuggerException ( dbgException . getExceptionName ( ) , dbgException . getExceptionCode ( ) , handlingAction ) ; exceptionsMap . put ( dbgException . getExceptionCode ( ) , newException ) ; } } return exceptionsMap . values ( ) ; }
public void insert ( Cell cell ) ;
@ Deprecated public static boolean encode ( final String s , final String encoding , BitSet safeOctets , boolean plusForSpace , Appendable out ) throws UnsupportedEncodingException , IOException { byte [ ] data = s . getBytes ( encoding ) ; boolean containsSpace = _BOOL ; int outputLength = _NUM ; for ( int i = _NUM ; i < data . length ; i ++ ) { int c = data [ i ] ; if ( c < _NUM ) c += _NUM ; if ( safeOctets . get ( c ) ) { out . append ( ( char ) c ) ; outputLength += _NUM ; } else if ( plusForSpace && ( c == STRING ) ) { containsSpace = _BOOL ; out . append ( STRING ) ; outputLength += _NUM ; } else { out . append ( STRING ) ; out . append ( HEX_DIGITS [ c > > _NUM ] ) ; out . append ( HEX_DIGITS [ c & _NUM ] ) ; outputLength += _NUM ; } } return containsSpace || ( outputLength != s . length ( ) ) ; }
void recoverMessages ( ) throws RollbackFailedException { if ( m_isQueue ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . clear ( ) ; if ( ! isAutoAck ( ) ) { rollbackLocalTransaction ( ) ; } } else { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . addAll ( recoverMessages ) ; LinkedList < MessageQueueElement > temp = unackedMessages ; recoverMessages . clear ( ) ; unackedMessages = recoverMessages ; recoverMessages = temp ; } }
void recoverMessages ( ) throws RollbackFailedException { if ( m_isQueue ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . clear ( ) ; if ( ! isAutoAck ( ) ) { rollbackLocalTransaction ( ) ; } } else { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . addAll ( recoverMessages ) ; LinkedList < MessageQueueElement > temp = unackedMessages ; recoverMessages . clear ( ) ; unackedMessages = recoverMessages ; recoverMessages = temp ; } }
void recoverMessages ( ) throws RollbackFailedException { if ( m_isQueue ) { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . clear ( ) ; if ( ! isAutoAck ( ) ) { rollbackLocalTransaction ( ) ; } } else { if ( _logger . isLoggable ( Level . FINE ) ) { _logger . log ( Level . FINE , STRING ) ; } unackedMessages . addAll ( recoverMessages ) ; LinkedList < MessageQueueElement > temp = unackedMessages ; recoverMessages . clear ( ) ; unackedMessages = recoverMessages ; recoverMessages = temp ; } }
public char charAt ( int index ) { return _toString . charAt ( index ) ; }
public char charAt ( int index ) { return _toString . charAt ( index ) ; }
public void testEmptySubList ( ) { final Range range = createRange ( _NUM , _NUM ) ; List subList = range . subList ( _NUM , _NUM ) ; assertEquals ( STRING , _NUM , subList . size ( ) ) ; subList = range . subList ( _NUM , _NUM ) ; assertEquals ( STRING , _NUM , subList . size ( ) ) ; }
public synchronized void add ( String property ) { String [ ] values = tokenize ( property ) ; if ( m_Root . value == null ) { m_Root . value = values [ _NUM ] ; } buildBranch ( m_Root , values , _NUM ) ; }
Operand pop ( Register s ) { Stack < Operand > stack = get ( s ) ; if ( stack == null ) { throw new OptimizingCompilerException ( STRING ) ; } else { return stack . pop ( ) ; } }
public static void write ( File file , NSObject root ) throws IOException { OutputStream out = new FileOutputStream ( file ) ; write ( out , root ) ; out . close ( ) ; }
public static byte [ ] hmacMD5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ _NUM ] ; byte [ ] opad = new byte [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; } else { ipad [ i ] = _NUM ; opad [ i ] = _NUM ; } } byte [ ] content = new byte [ data . length + _NUM ] ; System . arraycopy ( ipad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; MessageDigest md5 = MessageDigest . getInstance ( STRING ) ; data = md5 . digest ( content ) ; content = new byte [ data . length + _NUM ] ; System . arraycopy ( opad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; return md5 . digest ( content ) ; }
public static byte [ ] hmacMD5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ _NUM ] ; byte [ ] opad = new byte [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; } else { ipad [ i ] = _NUM ; opad [ i ] = _NUM ; } } byte [ ] content = new byte [ data . length + _NUM ] ; System . arraycopy ( ipad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; MessageDigest md5 = MessageDigest . getInstance ( STRING ) ; data = md5 . digest ( content ) ; content = new byte [ data . length + _NUM ] ; System . arraycopy ( opad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; return md5 . digest ( content ) ; }
public static byte [ ] hmacMD5 ( byte [ ] data , byte [ ] key ) throws Exception { byte [ ] ipad = new byte [ _NUM ] ; byte [ ] opad = new byte [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i < key . length ) { ipad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; opad [ i ] = ( byte ) ( key [ i ] ^ _NUM ) ; } else { ipad [ i ] = _NUM ; opad [ i ] = _NUM ; } } byte [ ] content = new byte [ data . length + _NUM ] ; System . arraycopy ( ipad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; MessageDigest md5 = MessageDigest . getInstance ( STRING ) ; data = md5 . digest ( content ) ; content = new byte [ data . length + _NUM ] ; System . arraycopy ( opad , _NUM , content , _NUM , _NUM ) ; System . arraycopy ( data , _NUM , content , _NUM , data . length ) ; return md5 . digest ( content ) ; }
protected abstract void addFile ( String relativeFilename ) throws CommandException ;
protected abstract void addFile ( String relativeFilename ) throws CommandException ;
private static void assertNotEmpty ( String message , String string ) { assertNotNull ( message , string ) ; assertFalse ( message , string . equals ( STRING ) ) ; }
public boolean isDown ( ) { if ( mLocalPath != null && mLocalPath . length ( ) > _NUM ) { File file = new File ( mLocalPath ) ; return ( file . exists ( ) ) ; } return _BOOL ; }
public boolean isDown ( ) { if ( mLocalPath != null && mLocalPath . length ( ) > _NUM ) { File file = new File ( mLocalPath ) ; return ( file . exists ( ) ) ; } return _BOOL ; }
public boolean isDown ( ) { if ( mLocalPath != null && mLocalPath . length ( ) > _NUM ) { File file = new File ( mLocalPath ) ; return ( file . exists ( ) ) ; } return _BOOL ; }
public boolean isDown ( ) { if ( mLocalPath != null && mLocalPath . length ( ) > _NUM ) { File file = new File ( mLocalPath ) ; return ( file . exists ( ) ) ; } return _BOOL ; }
private void addEventFromProperty ( String evt , HadoopJobInfo info , String propName ) { String val = info . property ( propName ) ; if ( ! F . isEmpty ( val ) ) { try { evts . add ( new T2 < > ( evt + STRING + nodeId , Long . parseLong ( val ) ) ) ; } catch ( NumberFormatException e ) { throw new IllegalStateException ( STRING + val + STRING + propName + STRING , e ) ; } } }
@ AndroidOnly ( STRING + STRING ) public void testSetMaxCRLNumberLjava_math_BigInteger ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; BigInteger maxCRL = new BigInteger ( STRING ) ; TestCRL crl = new TestCRL ( maxCRL ) ; selector . setMaxCRLNumber ( null ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( maxCRL ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( new BigInteger ( STRING ) ) ; assertFalse ( STRING , selector . match ( crl ) ) ; }
@ AndroidOnly ( STRING + STRING ) public void testSetMaxCRLNumberLjava_math_BigInteger ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; BigInteger maxCRL = new BigInteger ( STRING ) ; TestCRL crl = new TestCRL ( maxCRL ) ; selector . setMaxCRLNumber ( null ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( maxCRL ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( new BigInteger ( STRING ) ) ; assertFalse ( STRING , selector . match ( crl ) ) ; }
@ AndroidOnly ( STRING + STRING ) public void testSetMaxCRLNumberLjava_math_BigInteger ( ) { X509CRLSelector selector = new X509CRLSelector ( ) ; BigInteger maxCRL = new BigInteger ( STRING ) ; TestCRL crl = new TestCRL ( maxCRL ) ; selector . setMaxCRLNumber ( null ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( maxCRL ) ; assertTrue ( STRING , selector . match ( crl ) ) ; selector . setMaxCRLNumber ( new BigInteger ( STRING ) ) ; assertFalse ( STRING , selector . match ( crl ) ) ; }
private static String searchDirectories ( final File [ ] paths , final String [ ] exeNames ) { for ( final File path : paths ) { if ( path . exists ( ) ) { for ( final File subDirectory : path . listFiles ( ) ) { if ( StringUtils . startsWith ( subDirectory . getName ( ) , TF_DIRECTORY_PREFIX ) && subDirectory . isDirectory ( ) ) { final String verifiedPath = checkTfPath ( subDirectory . getPath ( ) , exeNames ) ; if ( verifiedPath != null ) { return verifiedPath ; } } } } } return null ; }
public void encode ( final ActiveMQBuffer buffer ) { buffer . writeString ( name ) ; buffer . writeString ( factoryClassName ) ; buffer . writeInt ( params == null ? _NUM : params . size ( ) ) ; if ( params != null ) { encodeMap ( buffer , params ) ; } if ( extraProps != null ) { encodeMap ( buffer , extraProps ) ; } }
@ Override protected void drawStatusBar ( final Graphics2D g2d , final int x , final int y , final int width ) { drawTitle ( g2d , x , y + _NUM , width ) ; Composite comp = g2d . getComposite ( ) ; if ( ignored && ! entity . isGhostMode ( ) ) { g2d . setComposite ( AlphaComposite . SrcAtop ) ; drawHPbar ( g2d , x , y + _NUM , width ) ; g2d . setComposite ( comp ) ; } else { drawHPbar ( g2d , x , y + _NUM , width ) ; } }
private TestEntry convertToTestEntry ( Entry entry ) { String value = entry . getNoteOrTitle ( ) ; if ( value == null && entry . isRoot ( ) ) { value = STRING ; } final TestEntry testEntry = new TestEntry ( value , entry . getId ( ) ) ; final ArrayList < Entry > childrenEntries = getChildrenInOrder ( entry ) ; final ArrayList < TestEntry > childrenTestEntries = new ArrayList < TestEntry > ( ) ; for ( final Entry childEntry : childrenEntries ) { childrenTestEntries . add ( convertToTestEntry ( childEntry ) ) ; } if ( ! childrenTestEntries . isEmpty ( ) ) { testEntry . setChildren ( childrenTestEntries . toArray ( new TestEntry [ childrenTestEntries . size ( ) ] ) ) ; } return testEntry ; }
private TestEntry convertToTestEntry ( Entry entry ) { String value = entry . getNoteOrTitle ( ) ; if ( value == null && entry . isRoot ( ) ) { value = STRING ; } final TestEntry testEntry = new TestEntry ( value , entry . getId ( ) ) ; final ArrayList < Entry > childrenEntries = getChildrenInOrder ( entry ) ; final ArrayList < TestEntry > childrenTestEntries = new ArrayList < TestEntry > ( ) ; for ( final Entry childEntry : childrenEntries ) { childrenTestEntries . add ( convertToTestEntry ( childEntry ) ) ; } if ( ! childrenTestEntries . isEmpty ( ) ) { testEntry . setChildren ( childrenTestEntries . toArray ( new TestEntry [ childrenTestEntries . size ( ) ] ) ) ; } return testEntry ; }
private void updateFont ( String family , int style , int size ) { console . setFont ( new Font ( family , style , size ) ) ; }
public int readWord ( ) throws IOException { length += _NUM ; int k1 = in . read ( ) ; if ( k1 < _NUM ) return _NUM ; return ( k1 + ( in . read ( ) << _NUM ) ) & _NUM ; }
public JSONBuffer appendKeyValue ( Object key , Object val ) { if ( stack . empty ( ) || stack . peek ( ) != Operand . HASH ) { throw new JSONException ( STRING ) ; } addQuotedString ( key ) ; buffer . append ( STRING ) ; if ( val instanceof Double ) { buffer . append ( val . toString ( ) ) ; } else if ( val instanceof Integer ) { buffer . append ( val . toString ( ) ) ; } else { addQuotedString ( val ) ; } buffer . append ( STRING ) ; return this ; }
@ Override public float generatorSortValue ( String url , WebPage row , float initSort ) throws ScoringFilterException { for ( ScoringFilter filter : filters ) { initSort = filter . generatorSortValue ( url , row , initSort ) ; } return initSort ; }
public void forceMerge ( int maxSegmentCount ) throws IOException { LuceneTestCase . maybeChangeLiveIndexWriterConfig ( r , w . getConfig ( ) ) ; w . forceMerge ( maxSegmentCount ) ; }
public PendingChange prepareAddRow ( Object [ ] row , RowIdImpl rowId , PendingChange nextChange ) throws IOException { return prepareAddRow ( row , rowId , new AddRowPendingChange ( nextChange ) ) ; }
private void createElement ( Document doc , Element parentElement , String elementName , Color value ) { Element element = doc . createElement ( elementName ) ; element . appendChild ( doc . createTextNode ( ColourUtils . fromColour ( value ) ) ) ; parentElement . appendChild ( element ) ; }
public static < T > String join ( T [ ] array , String separator ) { return join ( Arrays . asList ( array ) , separator ) ; }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
protected static void isort ( int level [ ] , float BC [ ] ) { float temp ; int temp2 ; for ( int i = _NUM ; i < BC . length - _NUM ; i ++ ) { int j = i ; temp = BC [ j + _NUM ] ; temp2 = level [ j + _NUM ] ; if ( temp == _NUM ) { continue ; } int prej = j + _NUM ; while ( j > - _NUM && ( temp < BC [ j ] || BC [ j ] == _NUM ) ) { if ( BC [ j ] == _NUM ) { j -- ; continue ; } else { BC [ prej ] = BC [ j ] ; level [ prej ] = level [ j ] ; prej = j ; j -- ; } } BC [ prej ] = temp ; level [ prej ] = temp2 ; } }
public String toPropertyString ( Resource data ) { Properties properties = toProperties ( data ) ; return PropertyUtils . joinOnPipe ( PropertyUtils . toMap ( properties ) ) ; }
public void checkAndReplaceOldPropertyNames ( LinkProperties props ) { checkAndReplaceOldPropertyName ( props , LPC_OLD_LINECOLOR , LPC_LINECOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINESTYLE , LPC_LINESTYLE ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_HIGHLIGHTCOLOR , LPC_HIGHLIGHTCOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_FILLCOLOR , LPC_FILLCOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_FILLPATTERN , LPC_FILLPATTERN ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINEWIDTH , LPC_LINEWIDTH ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINKTEXTSTRING , LPC_LINKTEXTSTRING ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINKTEXTFONT , LPC_LINKTEXTFONT ) ; }
public void checkAndReplaceOldPropertyNames ( LinkProperties props ) { checkAndReplaceOldPropertyName ( props , LPC_OLD_LINECOLOR , LPC_LINECOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINESTYLE , LPC_LINESTYLE ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_HIGHLIGHTCOLOR , LPC_HIGHLIGHTCOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_FILLCOLOR , LPC_FILLCOLOR ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_FILLPATTERN , LPC_FILLPATTERN ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINEWIDTH , LPC_LINEWIDTH ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINKTEXTSTRING , LPC_LINKTEXTSTRING ) ; checkAndReplaceOldPropertyName ( props , LPC_OLD_LINKTEXTFONT , LPC_LINKTEXTFONT ) ; }
public static String compactHex ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( ) ; for ( byte b : bytes ) { sb . append ( hex ( b ) ) ; } return sb . toString ( ) ; }
public static String compactHex ( byte [ ] bytes ) { StringBuilder sb = new StringBuilder ( ) ; for ( byte b : bytes ) { sb . append ( hex ( b ) ) ; } return sb . toString ( ) ; }
private synchronized void enumerateStringProperties ( Hashtable < String , String > h ) { if ( defaults != null ) { defaults . enumerateStringProperties ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . hasMoreElements ( ) ; ) { Object k = e . nextElement ( ) ; Object v = get ( k ) ; if ( k instanceof String && v instanceof String ) { h . put ( ( String ) k , ( String ) v ) ; } } }
private synchronized void enumerateStringProperties ( Hashtable < String , String > h ) { if ( defaults != null ) { defaults . enumerateStringProperties ( h ) ; } for ( Enumeration < ? > e = keys ( ) ; e . hasMoreElements ( ) ; ) { Object k = e . nextElement ( ) ; Object v = get ( k ) ; if ( k instanceof String && v instanceof String ) { h . put ( ( String ) k , ( String ) v ) ; } } }
public double calcPointToLineDistance ( Entry startEntry , Entry endEntry , Entry entryPoint ) { float xDiffEndStart = ( float ) endEntry . getXIndex ( ) - ( float ) startEntry . getXIndex ( ) ; float xDiffEntryStart = ( float ) entryPoint . getXIndex ( ) - ( float ) startEntry . getXIndex ( ) ; double normalLength = Math . sqrt ( ( xDiffEndStart ) * ( xDiffEndStart ) + ( endEntry . getVal ( ) - startEntry . getVal ( ) ) * ( endEntry . getVal ( ) - startEntry . getVal ( ) ) ) ; return Math . abs ( ( xDiffEntryStart ) * ( endEntry . getVal ( ) - startEntry . getVal ( ) ) - ( entryPoint . getVal ( ) - startEntry . getVal ( ) ) * ( xDiffEndStart ) ) / normalLength ; }
private void performFrameTasks ( ) { synchronized ( mFrameTaskQueue ) { AFrameTask task = mFrameTaskQueue . poll ( ) ; while ( task != null ) { task . run ( ) ; task = mFrameTaskQueue . poll ( ) ; } } }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public boolean equals ( java . lang . Object obj ) { return obj != null && obj . getClass ( ) == getClass ( ) && ( ( Float ) obj ) . value == value ; }
public long removeIndex ( int index ) { if ( index >= size ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + _NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
public long removeIndex ( int index ) { if ( index >= size ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; long [ ] items = this . items ; long value = items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + _NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; return value ; }
private void updateGoods ( ) { mGoodsTextView . setText ( String . format ( STRING , mGoods ) ) ; }
public void removeDecorator ( final OperatorDrawDecorator decorator ) { if ( decorator == null ) { throw new IllegalArgumentException ( STRING ) ; } operatorDecorators . remove ( decorator ) ; }
public static File toFile ( JavaFileObject javaFileObject ) { return new File ( javaFileObject . getName ( ) ) ; }
public static String join ( final Iterator < ? > iterator , final String separator ) { if ( iterator == null ) { return null ; } if ( ! iterator . hasNext ( ) ) { return STRING ; } final Object first = iterator . next ( ) ; if ( ! iterator . hasNext ( ) ) { return first == null ? null : first . toString ( ) ; } final StringBuilder buf = new StringBuilder ( _NUM ) ; if ( first != null ) { buf . append ( first ) ; } while ( iterator . hasNext ( ) ) { if ( separator != null ) { buf . append ( separator ) ; } final Object obj = iterator . next ( ) ; if ( obj != null ) { buf . append ( obj ) ; } } return buf . toString ( ) ; }
public static boolean isEmpty ( String str ) { return TextUtils . isEmpty ( str ) || str . equalsIgnoreCase ( STRING ) ; }
@ Override public void draw ( Canvas canvas ) { PointF detectLeftPosition = mLeftPosition ; PointF detectRightPosition = mRightPosition ; if ( ( detectLeftPosition == null ) || ( detectRightPosition == null ) ) { return ; } PointF leftPosition = new PointF ( translateX ( detectLeftPosition . x ) , translateY ( detectLeftPosition . y ) ) ; PointF rightPosition = new PointF ( translateX ( detectRightPosition . x ) , translateY ( detectRightPosition . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( rightPosition . x - leftPosition . x , _NUM ) + Math . pow ( rightPosition . y - leftPosition . y , _NUM ) ) ; float eyeRadius = EYE_RADIUS_PROPORTION * distance ; float irisRadius = IRIS_RADIUS_PROPORTION * distance ; PointF leftIrisPosition = mLeftPhysics . nextIrisPosition ( leftPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , leftPosition , eyeRadius , leftIrisPosition , irisRadius , mLeftOpen ) ; PointF rightIrisPosition = mRightPhysics . nextIrisPosition ( rightPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , rightPosition , eyeRadius , rightIrisPosition , irisRadius , mRightOpen ) ; }
@ Override public void draw ( Canvas canvas ) { PointF detectLeftPosition = mLeftPosition ; PointF detectRightPosition = mRightPosition ; if ( ( detectLeftPosition == null ) || ( detectRightPosition == null ) ) { return ; } PointF leftPosition = new PointF ( translateX ( detectLeftPosition . x ) , translateY ( detectLeftPosition . y ) ) ; PointF rightPosition = new PointF ( translateX ( detectRightPosition . x ) , translateY ( detectRightPosition . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( rightPosition . x - leftPosition . x , _NUM ) + Math . pow ( rightPosition . y - leftPosition . y , _NUM ) ) ; float eyeRadius = EYE_RADIUS_PROPORTION * distance ; float irisRadius = IRIS_RADIUS_PROPORTION * distance ; PointF leftIrisPosition = mLeftPhysics . nextIrisPosition ( leftPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , leftPosition , eyeRadius , leftIrisPosition , irisRadius , mLeftOpen ) ; PointF rightIrisPosition = mRightPhysics . nextIrisPosition ( rightPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , rightPosition , eyeRadius , rightIrisPosition , irisRadius , mRightOpen ) ; }
@ Override public void draw ( Canvas canvas ) { PointF detectLeftPosition = mLeftPosition ; PointF detectRightPosition = mRightPosition ; if ( ( detectLeftPosition == null ) || ( detectRightPosition == null ) ) { return ; } PointF leftPosition = new PointF ( translateX ( detectLeftPosition . x ) , translateY ( detectLeftPosition . y ) ) ; PointF rightPosition = new PointF ( translateX ( detectRightPosition . x ) , translateY ( detectRightPosition . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( rightPosition . x - leftPosition . x , _NUM ) + Math . pow ( rightPosition . y - leftPosition . y , _NUM ) ) ; float eyeRadius = EYE_RADIUS_PROPORTION * distance ; float irisRadius = IRIS_RADIUS_PROPORTION * distance ; PointF leftIrisPosition = mLeftPhysics . nextIrisPosition ( leftPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , leftPosition , eyeRadius , leftIrisPosition , irisRadius , mLeftOpen ) ; PointF rightIrisPosition = mRightPhysics . nextIrisPosition ( rightPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , rightPosition , eyeRadius , rightIrisPosition , irisRadius , mRightOpen ) ; }
@ Override public void draw ( Canvas canvas ) { PointF detectLeftPosition = mLeftPosition ; PointF detectRightPosition = mRightPosition ; if ( ( detectLeftPosition == null ) || ( detectRightPosition == null ) ) { return ; } PointF leftPosition = new PointF ( translateX ( detectLeftPosition . x ) , translateY ( detectLeftPosition . y ) ) ; PointF rightPosition = new PointF ( translateX ( detectRightPosition . x ) , translateY ( detectRightPosition . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( rightPosition . x - leftPosition . x , _NUM ) + Math . pow ( rightPosition . y - leftPosition . y , _NUM ) ) ; float eyeRadius = EYE_RADIUS_PROPORTION * distance ; float irisRadius = IRIS_RADIUS_PROPORTION * distance ; PointF leftIrisPosition = mLeftPhysics . nextIrisPosition ( leftPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , leftPosition , eyeRadius , leftIrisPosition , irisRadius , mLeftOpen ) ; PointF rightIrisPosition = mRightPhysics . nextIrisPosition ( rightPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , rightPosition , eyeRadius , rightIrisPosition , irisRadius , mRightOpen ) ; }
@ Override public void draw ( Canvas canvas ) { PointF detectLeftPosition = mLeftPosition ; PointF detectRightPosition = mRightPosition ; if ( ( detectLeftPosition == null ) || ( detectRightPosition == null ) ) { return ; } PointF leftPosition = new PointF ( translateX ( detectLeftPosition . x ) , translateY ( detectLeftPosition . y ) ) ; PointF rightPosition = new PointF ( translateX ( detectRightPosition . x ) , translateY ( detectRightPosition . y ) ) ; float distance = ( float ) Math . sqrt ( Math . pow ( rightPosition . x - leftPosition . x , _NUM ) + Math . pow ( rightPosition . y - leftPosition . y , _NUM ) ) ; float eyeRadius = EYE_RADIUS_PROPORTION * distance ; float irisRadius = IRIS_RADIUS_PROPORTION * distance ; PointF leftIrisPosition = mLeftPhysics . nextIrisPosition ( leftPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , leftPosition , eyeRadius , leftIrisPosition , irisRadius , mLeftOpen ) ; PointF rightIrisPosition = mRightPhysics . nextIrisPosition ( rightPosition , eyeRadius , irisRadius ) ; drawEye ( canvas , rightPosition , eyeRadius , rightIrisPosition , irisRadius , mRightOpen ) ; }
public static void refreshGOEProperties ( ) { ClassDiscovery . clearClassCache ( ) ; GenericPropertiesCreator . regenerateGlobalOutputProperties ( ) ; GenericObjectEditor . determineClasses ( ) ; ConverterUtils . initialize ( ) ; KnowledgeFlowApp . disposeSingleton ( ) ; KnowledgeFlowApp . reInitialize ( ) ; }
public static void refreshGOEProperties ( ) { ClassDiscovery . clearClassCache ( ) ; GenericPropertiesCreator . regenerateGlobalOutputProperties ( ) ; GenericObjectEditor . determineClasses ( ) ; ConverterUtils . initialize ( ) ; KnowledgeFlowApp . disposeSingleton ( ) ; KnowledgeFlowApp . reInitialize ( ) ; }
private stendhal ( ) { }
protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile ( DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier ) throws IOException { DictionaryService dictService = CarbonCommonFactory . getDictionaryService ( ) ; CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService . getDictionaryMetadataReader ( dictionaryColumnUniqueIdentifier . getCarbonTableIdentifier ( ) , dictionaryColumnUniqueIdentifier . getColumnIdentifier ( ) , carbonStorePath ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null ; try { carbonDictionaryColumnMetaChunk = columnMetadataReaderImpl . readLastEntryOfDictionaryMetaChunk ( ) ; } finally { columnMetadataReaderImpl . close ( ) ; } return carbonDictionaryColumnMetaChunk ; }
protected CarbonDictionaryColumnMetaChunk readLastChunkFromDictionaryMetadataFile ( DictionaryColumnUniqueIdentifier dictionaryColumnUniqueIdentifier ) throws IOException { DictionaryService dictService = CarbonCommonFactory . getDictionaryService ( ) ; CarbonDictionaryMetadataReader columnMetadataReaderImpl = dictService . getDictionaryMetadataReader ( dictionaryColumnUniqueIdentifier . getCarbonTableIdentifier ( ) , dictionaryColumnUniqueIdentifier . getColumnIdentifier ( ) , carbonStorePath ) ; CarbonDictionaryColumnMetaChunk carbonDictionaryColumnMetaChunk = null ; try { carbonDictionaryColumnMetaChunk = columnMetadataReaderImpl . readLastEntryOfDictionaryMetaChunk ( ) ; } finally { columnMetadataReaderImpl . close ( ) ; } return carbonDictionaryColumnMetaChunk ; }
private Rectangle2D drawFill ( Graphics2D g2 , Rectangle2D area ) { Rectangle2D filledArea = ( Rectangle2D ) area . clone ( ) ; filledArea = trimMargin ( filledArea ) ; filledArea = trimBorder ( filledArea ) ; area = trimPadding ( area ) ; g2 . setPaint ( this . fillPaint ) ; g2 . fill ( filledArea ) ; drawBorder ( g2 , filledArea ) ; return filledArea ; }
private Rectangle2D drawFill ( Graphics2D g2 , Rectangle2D area ) { Rectangle2D filledArea = ( Rectangle2D ) area . clone ( ) ; filledArea = trimMargin ( filledArea ) ; filledArea = trimBorder ( filledArea ) ; area = trimPadding ( area ) ; g2 . setPaint ( this . fillPaint ) ; g2 . fill ( filledArea ) ; drawBorder ( g2 , filledArea ) ; return filledArea ; }
public void writeToFileAndParseJSON ( ) throws IOException , AdeException { fileWriter . write ( jsonGroupObject . toString ( ) ) ; fileWriter . flush ( ) ; jsonGroupParser . parseJSON ( jsonFile ) ; }
public void writeToFileAndParseJSON ( ) throws IOException , AdeException { fileWriter . write ( jsonGroupObject . toString ( ) ) ; fileWriter . flush ( ) ; jsonGroupParser . parseJSON ( jsonFile ) ; }
@ Transactional public long createPreApprovedVoucherFromBillForPJV ( final int billId , final List < PreApprovedVoucher > voucherdetailList , final List < PreApprovedVoucher > subLedgerList ) throws ApplicationRuntimeException { String voucherStatus = null ; long vh = - _NUM ; try { final List vStatusList = appConfigValuesService . getConfigValuesByModuleAndKey ( STRING , STRING ) ; if ( ! vStatusList . isEmpty ( ) && vStatusList . size ( ) == _NUM ) { final AppConfigValues appVal = ( AppConfigValues ) vStatusList . get ( _NUM ) ; voucherStatus = appVal . getValue ( ) ; } else throw new ApplicationRuntimeException ( STRING + MISSINGMSG ) ; vh = createVoucher . createVoucherFromBillForPJV ( billId , voucherStatus , voucherdetailList , subLedgerList ) ; } catch ( final Exception e ) { LOGGER . error ( e . getMessage ( ) ) ; throw new ApplicationRuntimeException ( e . getMessage ( ) ) ; } return vh ; }
@ Transactional public long createPreApprovedVoucherFromBillForPJV ( final int billId , final List < PreApprovedVoucher > voucherdetailList , final List < PreApprovedVoucher > subLedgerList ) throws ApplicationRuntimeException { String voucherStatus = null ; long vh = - _NUM ; try { final List vStatusList = appConfigValuesService . getConfigValuesByModuleAndKey ( STRING , STRING ) ; if ( ! vStatusList . isEmpty ( ) && vStatusList . size ( ) == _NUM ) { final AppConfigValues appVal = ( AppConfigValues ) vStatusList . get ( _NUM ) ; voucherStatus = appVal . getValue ( ) ; } else throw new ApplicationRuntimeException ( STRING + MISSINGMSG ) ; vh = createVoucher . createVoucherFromBillForPJV ( billId , voucherStatus , voucherdetailList , subLedgerList ) ; } catch ( final Exception e ) { LOGGER . error ( e . getMessage ( ) ) ; throw new ApplicationRuntimeException ( e . getMessage ( ) ) ; } return vh ; }
protected void showModels ( EpoxyModel < ? > ... models ) { showModels ( Arrays . asList ( models ) ) ; }
protected void showModels ( EpoxyModel < ? > ... models ) { showModels ( Arrays . asList ( models ) ) ; }
public final int beginLine ( ) { return this . bLine ; }
public static boolean isStatic ( int mod ) { return Modifier . isStatic ( mod ) ; }
public static boolean isStatic ( int mod ) { return Modifier . isStatic ( mod ) ; }
public final Collection < To > map ( Collection < From > entities ) { final Collection < To > result = new ArrayList < > ( entities . size ( ) ) ; for ( From from : entities ) { result . add ( map ( from ) ) ; } return result ; }
public final Collection < To > map ( Collection < From > entities ) { final Collection < To > result = new ArrayList < > ( entities . size ( ) ) ; for ( From from : entities ) { result . add ( map ( from ) ) ; } return result ; }
public Object executeScript ( final Script script , final ScriptContext context ) { final ScriptEngine engine = scriptEngineProvider . getScriptEngine ( script . getType ( ) ) ; return executeScript ( script , engine , context ) ; }
public Object executeScript ( final Script script , final ScriptContext context ) { final ScriptEngine engine = scriptEngineProvider . getScriptEngine ( script . getType ( ) ) ; return executeScript ( script , engine , context ) ; }
private void updateIdealPoint ( Solution solution ) { for ( int i = _NUM ; i < solution . getNumberOfObjectives ( ) ; i ++ ) { idealPoint [ i ] = Math . min ( idealPoint [ i ] , solution . getObjective ( i ) ) ; } }
private void updateIdealPoint ( Solution solution ) { for ( int i = _NUM ; i < solution . getNumberOfObjectives ( ) ; i ++ ) { idealPoint [ i ] = Math . min ( idealPoint [ i ] , solution . getObjective ( i ) ) ; } }
private double toDouble ( IXMLElement elem , String value , double defaultValue , double min , double max ) throws IOException { try { double d = Double . valueOf ( value ) ; return Math . max ( Math . min ( d , max ) , min ) ; } catch ( NumberFormatException e ) { return defaultValue ; } }
private void addNotify ( ArrayList notifies , Map groupsMap , boolean discard ) { synchronized ( pendingNotifies ) { pendingNotifies . addLast ( new NotifyTask ( notifies , groupsMap , discard ) ) ; if ( notifierThread == null ) { notifierThread = new Notifier ( ) ; notifierThread . start ( ) ; } } }
private void addNotify ( ArrayList notifies , Map groupsMap , boolean discard ) { synchronized ( pendingNotifies ) { pendingNotifies . addLast ( new NotifyTask ( notifies , groupsMap , discard ) ) ; if ( notifierThread == null ) { notifierThread = new Notifier ( ) ; notifierThread . start ( ) ; } } }
public static void log ( ) { RequestLog current = RLOG . get ( ) ; if ( current . info == null ) { LOG . warn ( STRING ) ; return ; } LOG . info ( export ( ) ) ; current . clear ( ) ; }
public static void log ( ) { RequestLog current = RLOG . get ( ) ; if ( current . info == null ) { LOG . warn ( STRING ) ; return ; } LOG . info ( export ( ) ) ; current . clear ( ) ; }
public void currentState ( long state , Model currentModel ) { currentState = state ; if ( loggers != null ) { for ( Logger logger : loggers ) { logger . log ( state ) ; } } }
static void putEntityConfig ( String realm , String entityId , EntityConfigElement config ) { String cacheKey = buildCacheKey ( realm , entityId ) ; if ( config != null ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } configCache . put ( cacheKey , config ) ; } else { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } configCache . remove ( cacheKey ) ; } }
static void putEntityConfig ( String realm , String entityId , EntityConfigElement config ) { String cacheKey = buildCacheKey ( realm , entityId ) ; if ( config != null ) { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } configCache . put ( cacheKey , config ) ; } else { if ( debug . messageEnabled ( ) ) { debug . message ( STRING + cacheKey ) ; } configCache . remove ( cacheKey ) ; } }
public void addListener ( Listener listener ) { if ( listener == null ) { throw new IllegalArgumentException ( STRING ) ; } listeners . add ( listener ) ; }
public void addListener ( Listener listener ) { if ( listener == null ) { throw new IllegalArgumentException ( STRING ) ; } listeners . add ( listener ) ; }
public void addListener ( Listener listener ) { if ( listener == null ) { throw new IllegalArgumentException ( STRING ) ; } listeners . add ( listener ) ; }
@ SuppressWarnings ( STRING ) public List < Object > splitByLists ( String text , boolean recurse ) { List < Object > textList = new ArrayList < > ( ) ; String remainText = text ; msgHandler . logDebug ( STRING + STRING + STRING ) ; while ( _BOOL ) { Map < String , Object > listInfo = findParseBulletList ( remainText , _BOOL ) ; if ( listInfo == null ) { break ; } int startIndex = ( int ) listInfo . get ( STRING ) ; int endIndex = ( int ) listInfo . get ( STRING ) ; if ( startIndex > _NUM ) { textList . add ( remainText . substring ( _NUM , startIndex ) ) ; } if ( recurse ) { List < Object > parsedItems = new ArrayList < > ( ) ; List < Object > itemTexts = ( List < Object > ) listInfo . get ( STRING ) ; if ( itemTexts != null && ! itemTexts . isEmpty ( ) ) { for ( Object itemEntry : itemTexts ) { String itemText = ( String ) itemEntry ; List < Object > parsedItemList = splitByStructuralElems ( itemText ) ; parsedItems . add ( parsedItemList ) ; } } listInfo . put ( STRING , parsedItems ) ; } textList . add ( listInfo ) ; remainText = remainText . substring ( endIndex ) ; } if ( ! remainText . isEmpty ( ) ) { textList . add ( remainText ) ; } msgHandler . logDebug ( STRING + textList . size ( ) ) ; return textList ; }
public static int findGlobalPeakLocation ( float [ ] data ) { float max = Float . NaN ; int imax = - _NUM ; for ( int i = _NUM ; i < data . length ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) continue ; if ( Float . isNaN ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public static int findGlobalPeakLocation ( float [ ] data ) { float max = Float . NaN ; int imax = - _NUM ; for ( int i = _NUM ; i < data . length ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) continue ; if ( Float . isNaN ( max ) || data [ i ] > max ) { max = data [ i ] ; imax = i ; } } return imax ; }
public ComponentDefinition addAlias ( @ NotNull String text ) { if ( aliases == null ) { aliases = new ArrayList < String > ( ) ; } aliases . add ( text ) ; return this ; }
public ComponentDefinition addAlias ( @ NotNull String text ) { if ( aliases == null ) { aliases = new ArrayList < String > ( ) ; } aliases . add ( text ) ; return this ; }
private static Class < ? > classForParam ( String param ) { Class < ? > r ; if ( param . equals ( STRING ) ) { r = int . class ; } else if ( param . equals ( STRING ) ) { r = long . class ; } else if ( param . equals ( STRING ) ) { r = byte . class ; } else if ( param . equals ( STRING ) ) { r = short . class ; } else if ( param . equals ( STRING ) ) { r = char . class ; } else if ( param . equals ( STRING ) ) { r = boolean . class ; } else try { r = Class . forName ( param ) ; } catch ( ClassNotFoundException e ) { try { r = Class . forName ( STRING + param ) ; } catch ( ClassNotFoundException f ) { throw new RuntimeException ( e ) ; } } return r ; }
private static String stripLeadingSlash ( String name ) { if ( name . length ( ) < _NUM || name . charAt ( _NUM ) != STRING ) { return name ; } return name . substring ( _NUM ) ; }
public static < T > ByteString serialize ( final String templateName , T object ) { StringWriter templateResults = new StringWriter ( ) ; try { final Template template = configuration . getTemplate ( templateName ) ; template . process ( object , templateResults ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } return ByteString . encodeUtf8 ( templateResults . toString ( ) ) ; }
public static < T > ByteString serialize ( final String templateName , T object ) { StringWriter templateResults = new StringWriter ( ) ; try { final Template template = configuration . getTemplate ( templateName ) ; template . process ( object , templateResults ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; } return ByteString . encodeUtf8 ( templateResults . toString ( ) ) ; }
private void addMenuBar ( ) { final JMenu menu = new JMenu ( STRING ) ; final JMenuItem copyItem = new JMenuItem ( CActionProxy . proxy ( new CActionCopyAllReilCode ( m_textArea ) ) ) ; menu . add ( copyItem ) ; final JMenuBar menuBar = new JMenuBar ( ) ; menuBar . add ( menu ) ; setJMenuBar ( menuBar ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { return mGraphics . drawImage ( img , xform , obs ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { return mGraphics . drawImage ( img , xform , obs ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { return mGraphics . drawImage ( img , xform , obs ) ; }
public void addAuthPolicy ( String policyUri ) { String policies = getAuthPolicies ( ) ; if ( policies == null || AUTH_POLICY_NONE . equals ( policies ) ) setAuthPolicies ( policyUri ) ; else setAuthPolicies ( policies + STRING + policyUri ) ; }
public boolean removeEntry ( int xIndex , int dataSetIndex ) { if ( dataSetIndex >= mDataSets . size ( ) ) return _BOOL ; T dataSet = mDataSets . get ( dataSetIndex ) ; Entry e = dataSet . getEntryForXIndex ( xIndex ) ; return removeEntry ( e , dataSetIndex ) ; }
public boolean removeEntry ( int xIndex , int dataSetIndex ) { if ( dataSetIndex >= mDataSets . size ( ) ) return _BOOL ; T dataSet = mDataSets . get ( dataSetIndex ) ; Entry e = dataSet . getEntryForXIndex ( xIndex ) ; return removeEntry ( e , dataSetIndex ) ; }
public boolean removeEntry ( int xIndex , int dataSetIndex ) { if ( dataSetIndex >= mDataSets . size ( ) ) return _BOOL ; T dataSet = mDataSets . get ( dataSetIndex ) ; Entry e = dataSet . getEntryForXIndex ( xIndex ) ; return removeEntry ( e , dataSetIndex ) ; }
public static void trainEpochs ( ClassificationDataSet dataSet , UpdateableClassifier toTrain , int epochs ) { if ( epochs < _NUM ) throw new IllegalArgumentException ( STRING ) ; toTrain . setUp ( dataSet . getCategories ( ) , dataSet . getNumNumericalVars ( ) , dataSet . getPredicting ( ) ) ; IntList randomOrder = new IntList ( dataSet . getSampleSize ( ) ) ; ListUtils . addRange ( randomOrder , _NUM , dataSet . getSampleSize ( ) , _NUM ) ; for ( int epoch = _NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( randomOrder ) ; for ( int i : randomOrder ) toTrain . update ( dataSet . getDataPoint ( i ) , dataSet . getDataPointCategory ( i ) ) ; } }
public static void trainEpochs ( ClassificationDataSet dataSet , UpdateableClassifier toTrain , int epochs ) { if ( epochs < _NUM ) throw new IllegalArgumentException ( STRING ) ; toTrain . setUp ( dataSet . getCategories ( ) , dataSet . getNumNumericalVars ( ) , dataSet . getPredicting ( ) ) ; IntList randomOrder = new IntList ( dataSet . getSampleSize ( ) ) ; ListUtils . addRange ( randomOrder , _NUM , dataSet . getSampleSize ( ) , _NUM ) ; for ( int epoch = _NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( randomOrder ) ; for ( int i : randomOrder ) toTrain . update ( dataSet . getDataPoint ( i ) , dataSet . getDataPointCategory ( i ) ) ; } }
public static void trainEpochs ( ClassificationDataSet dataSet , UpdateableClassifier toTrain , int epochs ) { if ( epochs < _NUM ) throw new IllegalArgumentException ( STRING ) ; toTrain . setUp ( dataSet . getCategories ( ) , dataSet . getNumNumericalVars ( ) , dataSet . getPredicting ( ) ) ; IntList randomOrder = new IntList ( dataSet . getSampleSize ( ) ) ; ListUtils . addRange ( randomOrder , _NUM , dataSet . getSampleSize ( ) , _NUM ) ; for ( int epoch = _NUM ; epoch < epochs ; epoch ++ ) { Collections . shuffle ( randomOrder ) ; for ( int i : randomOrder ) toTrain . update ( dataSet . getDataPoint ( i ) , dataSet . getDataPointCategory ( i ) ) ; } }
public void close ( ) { if ( ! isOpen ) return ; Log . d ( TAG , STRING ) ; loadingLock . lock ( ) ; try { save ( ) ; if ( saveFileStream != null ) { SavingHelper . close ( saveFileStream ) ; saveFileStream = null ; } savingDisabled = _BOOL ; isOpen = _BOOL ; Log . i ( TAG , STRING ) ; } finally { loadingLock . unlock ( ) ; } }
public void close ( ) { if ( ! isOpen ) return ; Log . d ( TAG , STRING ) ; loadingLock . lock ( ) ; try { save ( ) ; if ( saveFileStream != null ) { SavingHelper . close ( saveFileStream ) ; saveFileStream = null ; } savingDisabled = _BOOL ; isOpen = _BOOL ; Log . i ( TAG , STRING ) ; } finally { loadingLock . unlock ( ) ; } }
public static boolean isNonPublicProxyClass ( Class < ? > cls ) { String name = cls . getName ( ) ; int i = name . lastIndexOf ( STRING ) ; String pkg = ( i != - _NUM ) ? name . substring ( _NUM , i ) : STRING ; return Proxy . isProxyClass ( cls ) && ! pkg . equals ( PROXY_PACKAGE ) ; }
public static boolean isNonPublicProxyClass ( Class < ? > cls ) { String name = cls . getName ( ) ; int i = name . lastIndexOf ( STRING ) ; String pkg = ( i != - _NUM ) ? name . substring ( _NUM , i ) : STRING ; return Proxy . isProxyClass ( cls ) && ! pkg . equals ( PROXY_PACKAGE ) ; }
public static String emptyToNull ( String s ) { if ( s == null ) return null ; return s . length ( ) == _NUM ? null : s ; }
public static String emptyToNull ( String s ) { if ( s == null ) return null ; return s . length ( ) == _NUM ? null : s ; }
TestEnvironment ( SystemTestEnvironment systemTestEnvironment , Path workingDir , Path sourceDir , Path classDir , Path jacocoDir ) { this . systemTestEnvironment = systemTestEnvironment ; this . workingDir = workingDir ; this . sourceDir = sourceDir ; this . classDir = classDir ; this . jacocoDir = jacocoDir ; this . testClassPath = systemTestEnvironment . classpath + STRING + classDir . toString ( ) ; }
public void logMessage ( SIPMessage message , String from , String to , String status , boolean sender ) { logMessage ( message , from , to , status , sender , System . currentTimeMillis ( ) ) ; }
public void logMessage ( SIPMessage message , String from , String to , String status , boolean sender ) { logMessage ( message , from , to , status , sender , System . currentTimeMillis ( ) ) ; }
protected JPopupMenu createPopupMenu ( boolean properties , boolean save , boolean print , boolean zoom ) { return createPopupMenu ( properties , _BOOL , save , print , zoom ) ; }
private String toString ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof GotoStmt ) { GotoStmt goto_stmt = ( GotoStmt ) u ; return String . format ( STRING , lnums . get ( goto_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof IfStmt ) { IfStmt if_stmt = ( IfStmt ) u ; return String . format ( STRING , if_stmt . getCondition ( ) , lnums . get ( if_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String toString ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof GotoStmt ) { GotoStmt goto_stmt = ( GotoStmt ) u ; return String . format ( STRING , lnums . get ( goto_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof IfStmt ) { IfStmt if_stmt = ( IfStmt ) u ; return String . format ( STRING , if_stmt . getCondition ( ) , lnums . get ( if_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String toString ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof GotoStmt ) { GotoStmt goto_stmt = ( GotoStmt ) u ; return String . format ( STRING , lnums . get ( goto_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof IfStmt ) { IfStmt if_stmt = ( IfStmt ) u ; return String . format ( STRING , if_stmt . getCondition ( ) , lnums . get ( if_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private String toString ( Unit u ) { if ( u == null ) return STRING ; if ( u instanceof GotoStmt ) { GotoStmt goto_stmt = ( GotoStmt ) u ; return String . format ( STRING , lnums . get ( goto_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else if ( u instanceof IfStmt ) { IfStmt if_stmt = ( IfStmt ) u ; return String . format ( STRING , if_stmt . getCondition ( ) , lnums . get ( if_stmt . getTarget ( ) ) , lnums . get ( u ) ) ; } else return String . format ( STRING , u , lnums . get ( u ) ) ; }
private void updateOverscrollAnimation ( final int scrolledOffset ) { if ( mEdgeGlowLeft == null || mEdgeGlowRight == null ) return ; int nextScrollPosition = mCurrentX + scrolledOffset ; if ( mFlingTracker == null || mFlingTracker . isFinished ( ) ) { if ( nextScrollPosition < _NUM ) { int overscroll = Math . abs ( scrolledOffset ) ; mEdgeGlowLeft . onPull ( ( float ) overscroll / getRenderWidth ( ) ) ; if ( ! mEdgeGlowRight . isFinished ( ) ) { mEdgeGlowRight . onRelease ( ) ; } } else if ( nextScrollPosition > mMaxX ) { int overscroll = Math . abs ( scrolledOffset ) ; mEdgeGlowRight . onPull ( ( float ) overscroll / getRenderWidth ( ) ) ; if ( ! mEdgeGlowLeft . isFinished ( ) ) { mEdgeGlowLeft . onRelease ( ) ; } } } }
Job loadPreview ( FutureCallback < Pair < OmniBuildEnvironment , OmniGradleBuild > > resultHandler , List < ProgressListener > listeners ) ;
public EntityQuery filterByDate ( Timestamp moment , String ... filterByFieldName ) { this . filterByDate = _BOOL ; this . filterByDateMoment = moment ; if ( filterByFieldName . length % _NUM != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } this . filterByFieldNames = Arrays . asList ( filterByFieldName ) ; return this ; }
public EntityQuery filterByDate ( Timestamp moment , String ... filterByFieldName ) { this . filterByDate = _BOOL ; this . filterByDateMoment = moment ; if ( filterByFieldName . length % _NUM != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } this . filterByFieldNames = Arrays . asList ( filterByFieldName ) ; return this ; }
public EntityQuery filterByDate ( Timestamp moment , String ... filterByFieldName ) { this . filterByDate = _BOOL ; this . filterByDateMoment = moment ; if ( filterByFieldName . length % _NUM != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } this . filterByFieldNames = Arrays . asList ( filterByFieldName ) ; return this ; }
public void clearImage ( ) { clearImageInt ( ) ; mCropOverlayView . setInitialCropWindowRect ( null ) ; }
public DGeneratingKeyPair ( JFrame parent , KeyPairType keyPairType , int keySize , Provider provider ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . keyPairType = keyPairType ; this . keySize = keySize ; this . provider = provider ; initComponents ( ) ; }
protected void createTripleBuffer ( int width , int height ) { try { tripleBuffer = mxUtils . createBufferedImage ( width , height , null ) ; tripleBufferGraphics = tripleBuffer . createGraphics ( ) ; repaintTripleBuffer ( null ) ; } catch ( OutOfMemoryError error ) { } }
protected void createTripleBuffer ( int width , int height ) { try { tripleBuffer = mxUtils . createBufferedImage ( width , height , null ) ; tripleBufferGraphics = tripleBuffer . createGraphics ( ) ; repaintTripleBuffer ( null ) ; } catch ( OutOfMemoryError error ) { } }
private void testAdvancePastNextSyncMarkerAt ( int position , int size ) throws IOException { byte sentinel = ( byte ) _NUM ; byte [ ] marker = new byte [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte [ ] haystack = createHaystack ( marker , position , size ) ; PushbackInputStream stream = new PushbackInputStream ( new ByteArrayInputStream ( haystack ) , marker . length ) ; if ( position + marker . length < size ) { haystack [ position + marker . length ] = sentinel ; assertEquals ( position + marker . length , AvroReader . advancePastNextSyncMarker ( stream , marker ) ) ; assertEquals ( sentinel , ( byte ) stream . read ( ) ) ; } else { assertEquals ( size , AvroReader . advancePastNextSyncMarker ( stream , marker ) ) ; assertEquals ( - _NUM , stream . read ( ) ) ; } }
private void testAdvancePastNextSyncMarkerAt ( int position , int size ) throws IOException { byte sentinel = ( byte ) _NUM ; byte [ ] marker = new byte [ ] { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte [ ] haystack = createHaystack ( marker , position , size ) ; PushbackInputStream stream = new PushbackInputStream ( new ByteArrayInputStream ( haystack ) , marker . length ) ; if ( position + marker . length < size ) { haystack [ position + marker . length ] = sentinel ; assertEquals ( position + marker . length , AvroReader . advancePastNextSyncMarker ( stream , marker ) ) ; assertEquals ( sentinel , ( byte ) stream . read ( ) ) ; } else { assertEquals ( size , AvroReader . advancePastNextSyncMarker ( stream , marker ) ) ; assertEquals ( - _NUM , stream . read ( ) ) ; } }
public List < Product > scrollCartOfUser ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . emptyList ( ) ; ProductCart cart = getCartOfUser ( user ) ; if ( cart == null ) return Collections . emptyList ( ) ; return setToLimitedList ( cart . getProducts ( ) , skip , top ) ; }
public List < Product > scrollCartOfUser ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . emptyList ( ) ; ProductCart cart = getCartOfUser ( user ) ; if ( cart == null ) return Collections . emptyList ( ) ; return setToLimitedList ( cart . getProducts ( ) , skip , top ) ; }
public List < Product > scrollCartOfUser ( final User user , final int skip , final int top ) { if ( user == null ) return Collections . emptyList ( ) ; ProductCart cart = getCartOfUser ( user ) ; if ( cart == null ) return Collections . emptyList ( ) ; return setToLimitedList ( cart . getProducts ( ) , skip , top ) ; }
protected void showInfo ( String msg ) { if ( msg == null ) msg = STRING ; m_LabelInfo . setText ( msg ) ; }
protected void showInfo ( String msg ) { if ( msg == null ) msg = STRING ; m_LabelInfo . setText ( msg ) ; }
protected void showInfo ( String msg ) { if ( msg == null ) msg = STRING ; m_LabelInfo . setText ( msg ) ; }
public static String droidsafeOutputFile ( IProject project , String fileName ) { String outputDir = getProjectOutputDir ( project ) ; String fullPath = outputDir + File . separator + fileName ; return fullPath ; }
public static String droidsafeOutputFile ( IProject project , String fileName ) { String outputDir = getProjectOutputDir ( project ) ; String fullPath = outputDir + File . separator + fileName ; return fullPath ; }
private double doAcquire ( double permitsToAcquire , double currentTime ) { while ( _BOOL ) { readRate . lock ( ) ; try { double permitReleaseRate = this . permitsPerSecond ; double clockDelta = permitsToAcquire / permitReleaseRate ; double lowestAllowedClock = currentTime - backlogSize ; double currentClock = clock . get ( ) ; double nextClock = currentClock + clockDelta ; if ( nextClock < lowestAllowedClock ) nextClock = lowestAllowedClock ; if ( clock . compareAndSet ( currentClock , nextClock ) ) { if ( nextClock > currentTime ) return permitReleaseRate * ( nextClock - currentTime ) ; else return _NUM ; } } finally { readRate . unlock ( ) ; } } }
private double doAcquire ( double permitsToAcquire , double currentTime ) { while ( _BOOL ) { readRate . lock ( ) ; try { double permitReleaseRate = this . permitsPerSecond ; double clockDelta = permitsToAcquire / permitReleaseRate ; double lowestAllowedClock = currentTime - backlogSize ; double currentClock = clock . get ( ) ; double nextClock = currentClock + clockDelta ; if ( nextClock < lowestAllowedClock ) nextClock = lowestAllowedClock ; if ( clock . compareAndSet ( currentClock , nextClock ) ) { if ( nextClock > currentTime ) return permitReleaseRate * ( nextClock - currentTime ) ; else return _NUM ; } } finally { readRate . unlock ( ) ; } } }
@ Override public void disconnectionNotification ( String eventName , Object source ) { if ( source == m_firstInput ) { m_firstInput = null ; m_firstInputConnectionType = STRING ; } else if ( source == m_secondInput ) { m_secondInput = null ; m_secondInputConnectionType = STRING ; } if ( m_firstInput != null && m_secondInput != null ) { if ( m_firstInputConnectionType . length ( ) > _NUM || m_secondInputConnectionType . length ( ) > _NUM ) { if ( ! m_firstInputConnectionType . equals ( STRING ) && ! m_secondInputConnectionType . equals ( STRING ) ) { m_incomingBatchConnections = _BOOL ; } else { m_incomingBatchConnections = _BOOL ; } } else { m_incomingBatchConnections = _BOOL ; } } }
public void addCPItem ( CP cp ) { String uniq = cp . getUniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void addCPItem ( CP cp ) { String uniq = cp . getUniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void addCPItem ( CP cp ) { String uniq = cp . getUniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void addCPItem ( CP cp ) { String uniq = cp . getUniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public void addCPItem ( CP cp ) { String uniq = cp . getUniq ( ) ; CP intern ; if ( ( intern = ( CP ) ( cpe . get ( uniq ) ) ) == null ) { cpe . put ( uniq , cp ) ; cp . resolve ( this ) ; } }
public static void put3ByteInt ( ByteBuffer buffer , int val , ByteOrder order ) { int pos = buffer . position ( ) ; put3ByteInt ( buffer , val , pos , order ) ; buffer . position ( pos + _NUM ) ; }
Iterator < HeapVariable < Object > > enumerateExposedHeapVariables ( ) { ArrayList < HeapVariable < Object > > v = new ArrayList < HeapVariable < Object > > ( ) ; for ( Iterator < HeapVariable < Object > > e = getHeapVariables ( ) ; e . hasNext ( ) ; ) { HeapVariable < Object > H = e . next ( ) ; if ( isExposedOnExit ( H ) ) { v . add ( H ) ; } } return v . iterator ( ) ; }
Iterator < HeapVariable < Object > > enumerateExposedHeapVariables ( ) { ArrayList < HeapVariable < Object > > v = new ArrayList < HeapVariable < Object > > ( ) ; for ( Iterator < HeapVariable < Object > > e = getHeapVariables ( ) ; e . hasNext ( ) ; ) { HeapVariable < Object > H = e . next ( ) ; if ( isExposedOnExit ( H ) ) { v . add ( H ) ; } } return v . iterator ( ) ; }
public void add ( final ConversationStates state , final String triggerString , final ChatCondition condition , boolean secondary , final ConversationStates nextState , final String reply , final ChatAction action ) { Collection < Expression > triggerExpressions = createUniqueTriggerExpressions ( state , Arrays . asList ( triggerString ) , null , condition , reply , action ) ; add ( triggerExpressions , state , condition , secondary , nextState , reply , action ) ; }
public void preDeregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . tryAcquire ( ) ) throw new IllegalStateException ( STRING ) ; try { unregisterScanners ( ) ; unregisterConfigs ( ) ; unregisterResultLogManager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
public void preDeregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . tryAcquire ( ) ) throw new IllegalStateException ( STRING ) ; try { unregisterScanners ( ) ; unregisterConfigs ( ) ; unregisterResultLogManager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
public void preDeregister ( ) throws Exception { try { close ( ) ; if ( ! sequencer . tryAcquire ( ) ) throw new IllegalStateException ( STRING ) ; try { unregisterScanners ( ) ; unregisterConfigs ( ) ; unregisterResultLogManager ( ) ; } finally { sequencer . release ( ) ; } } catch ( Exception x ) { LOG . log ( Level . FINEST , STRING + x , x ) ; throw x ; } }
protected boolean isFileSpecifyingModuleSpecifier ( String specifier ) { return specifier . length ( ) > _NUM && specifier . charAt ( specifier . length ( ) - _NUM ) != IPath . SEPARATOR ; }
protected boolean isFileSpecifyingModuleSpecifier ( String specifier ) { return specifier . length ( ) > _NUM && specifier . charAt ( specifier . length ( ) - _NUM ) != IPath . SEPARATOR ; }
public SmsMessageSender ( Context context , String [ ] dests , String msgText , long threadId ) { mContext = context ; mMessageText = msgText ; mNumberOfDests = dests . length ; mDests = new String [ mNumberOfDests ] ; System . arraycopy ( dests , _NUM , mDests , _NUM , mNumberOfDests ) ; mTimestamp = System . currentTimeMillis ( ) ; mThreadId = threadId ; mServiceCenter = getOutgoingServiceCenter ( mThreadId ) ; SharedPreferences mPrefs = PreferenceManager . getDefaultSharedPreferences ( mContext ) ; splitMessage = mPrefs . getBoolean ( mContext . getString ( R . string . pref_split_message_key ) , DEFAULT_SPLIT_MESSAGE ) ; requestDeliveryReport = mPrefs . getBoolean ( mContext . getString ( R . string . pref_delivery_report_key ) , DEFAULT_DELIVERY_REPORT_MODE ) ; }
private void handleHtmlSearchAccounts ( PageWrapper pageWrapper , RequestAndResponse requestAndResponse , String query , String paneId ) throws IOException , ServletException { pageWrapper . addPageIntroText ( servletText . introTextSearchUsers ( ) , null ) ; if ( ! isUserAnAdmin ( requestAndResponse ) ) { requestAndResponse . print ( servletText . errorPageNotAllowed ( ) ) ; } else { try { final StringBuilder result = new StringBuilder ( ) ; final User user = dbLogic . getUserByUserName ( query . toLowerCase ( ) ) ; if ( user == null ) { result . append ( servletText . sentenceThereWereNoMatches ( ) ) ; } else { startItemList ( result , paneId ) ; addUserHtml ( user , result , _NUM , paneId ) ; finishItemList ( result ) ; } dbLogic . commit ( ) ; requestAndResponse . print ( result . toString ( ) ) ; } catch ( final PersistenceException e ) { requestAndResponse . print ( servletText . errorInternalDatabase ( ) ) ; } } }
private void handleHtmlSearchAccounts ( PageWrapper pageWrapper , RequestAndResponse requestAndResponse , String query , String paneId ) throws IOException , ServletException { pageWrapper . addPageIntroText ( servletText . introTextSearchUsers ( ) , null ) ; if ( ! isUserAnAdmin ( requestAndResponse ) ) { requestAndResponse . print ( servletText . errorPageNotAllowed ( ) ) ; } else { try { final StringBuilder result = new StringBuilder ( ) ; final User user = dbLogic . getUserByUserName ( query . toLowerCase ( ) ) ; if ( user == null ) { result . append ( servletText . sentenceThereWereNoMatches ( ) ) ; } else { startItemList ( result , paneId ) ; addUserHtml ( user , result , _NUM , paneId ) ; finishItemList ( result ) ; } dbLogic . commit ( ) ; requestAndResponse . print ( result . toString ( ) ) ; } catch ( final PersistenceException e ) { requestAndResponse . print ( servletText . errorInternalDatabase ( ) ) ; } } }
private void handleHtmlSearchAccounts ( PageWrapper pageWrapper , RequestAndResponse requestAndResponse , String query , String paneId ) throws IOException , ServletException { pageWrapper . addPageIntroText ( servletText . introTextSearchUsers ( ) , null ) ; if ( ! isUserAnAdmin ( requestAndResponse ) ) { requestAndResponse . print ( servletText . errorPageNotAllowed ( ) ) ; } else { try { final StringBuilder result = new StringBuilder ( ) ; final User user = dbLogic . getUserByUserName ( query . toLowerCase ( ) ) ; if ( user == null ) { result . append ( servletText . sentenceThereWereNoMatches ( ) ) ; } else { startItemList ( result , paneId ) ; addUserHtml ( user , result , _NUM , paneId ) ; finishItemList ( result ) ; } dbLogic . commit ( ) ; requestAndResponse . print ( result . toString ( ) ) ; } catch ( final PersistenceException e ) { requestAndResponse . print ( servletText . errorInternalDatabase ( ) ) ; } } }
private void autoRequestMods ( ) { if ( ! c . autoRequestModsEnabled ( ) ) { return ; } Set < String > joinedChannels = c . getJoinedChannels ( ) ; for ( String channel : joinedChannels ) { if ( ! modsAlreadyRequested . contains ( channel ) ) { LOGGER . info ( STRING + channel ) ; modsAlreadyRequested . add ( channel ) ; requestModsSilent ( channel ) ; return ; } } }
private void autoRequestMods ( ) { if ( ! c . autoRequestModsEnabled ( ) ) { return ; } Set < String > joinedChannels = c . getJoinedChannels ( ) ; for ( String channel : joinedChannels ) { if ( ! modsAlreadyRequested . contains ( channel ) ) { LOGGER . info ( STRING + channel ) ; modsAlreadyRequested . add ( channel ) ; requestModsSilent ( channel ) ; return ; } } }
public void trim ( ) { objects . trimToSize ( ) ; }
public Builder addTargetElements ( Element ... additionalTargets ) { for ( int i = _NUM ; i < additionalTargets . length ; i ++ ) { targetElements . add ( additionalTargets [ i ] ) ; } return this ; }
private String resizeImage ( String anImageUrl , String filename , ImageSize srcImageSize , ImageSize dstImageSize , int rotationAngle ) { String imageUrl = anImageUrl ; try { if ( null != dstImageSize ) { FileInputStream imageStream = new FileInputStream ( new File ( filename ) ) ; InputStream resizeBitmapStream = null ; try { resizeBitmapStream = ImageUtils . resizeImage ( imageStream , - _NUM , ( srcImageSize . mWidth + dstImageSize . mWidth - _NUM ) / dstImageSize . mWidth , _NUM ) ; } catch ( OutOfMemoryError ex ) { Log . e ( LOG_TAG , STRING + ex . getMessage ( ) ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } if ( null != resizeBitmapStream ) { String bitmapURL = mMediasCache . saveMedia ( resizeBitmapStream , null , CommonActivityUtils . MIME_TYPE_JPEG ) ; if ( null != bitmapURL ) { imageUrl = bitmapURL ; } resizeBitmapStream . close ( ) ; } } if ( _NUM != rotationAngle ) { ImageUtils . rotateImage ( mVectorRoomActivity , imageUrl , rotationAngle , mMediasCache ) ; } } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } return imageUrl ; }
@ Deprecated public ShapelessRecipe addIngredient ( int count , Material ingredient , int rawdata ) { Validate . isTrue ( ingredients . size ( ) + count <= _NUM , STRING ) ; if ( rawdata == - _NUM ) { rawdata = Short . MAX_VALUE ; } while ( count -- > _NUM ) { ingredients . add ( new ItemStack ( ingredient , _NUM , ( short ) rawdata ) ) ; } return this ; }
protected void fillContextDefaults ( Context context ) { context . put ( STRING , instance ) ; context . put ( STRING , getOutputPath ( ) ) ; }
public static SelectClause create ( StreamSelector streamSelector , String ... propertyNames ) { List < SelectClauseElement > selectList = new ArrayList < SelectClauseElement > ( ) ; for ( String name : propertyNames ) { selectList . add ( new SelectClauseExpression ( new PropertyValueExpression ( name ) ) ) ; } return new SelectClause ( streamSelector , selectList ) ; }
void prepareForClose ( LocalRegion region , DiskRegion dr ) { if ( dr . isBackup ( ) ) { forceFlush ( ) ; } }
void prepareForClose ( LocalRegion region , DiskRegion dr ) { if ( dr . isBackup ( ) ) { forceFlush ( ) ; } }
void prepareForClose ( LocalRegion region , DiskRegion dr ) { if ( dr . isBackup ( ) ) { forceFlush ( ) ; } }
private int measureHeight ( ) { int dayOfWeek = calendar . get ( Calendar . DAY_OF_WEEK ) ; int daysOfMonth = daysOfCurrentMonth ( ) ; int n = - _NUM ; if ( dayOfWeek >= _NUM && dayOfWeek <= _NUM ) { n = daysOfMonth - ( _NUM - dayOfWeek + _NUM ) ; } else if ( dayOfWeek == _NUM ) { n = daysOfMonth - _NUM ; } int lines = _NUM + n / _NUM + ( n % _NUM == _NUM ? _NUM : _NUM ) ; return ( int ) ( cellHeight * lines ) ; }
public char reverseMap ( short glyphID ) { Short result = glyphLookup . get ( new Short ( glyphID ) ) ; if ( result == null ) { return STRING ; } return ( char ) result . shortValue ( ) ; }
@ Override protected void createHandshakeBytes ( ) { handshakeBytes = new byte [ Constants . HANDSHAKE_SIZE ] ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; handshakeBytes [ _NUM ] = _NUM ; byte [ ] rndBytes = new byte [ Constants . HANDSHAKE_SIZE - _NUM ] ; random . nextBytes ( rndBytes ) ; System . arraycopy ( rndBytes , _NUM , handshakeBytes , _NUM , ( Constants . HANDSHAKE_SIZE - _NUM ) ) ; }
ChronoLocalDateTime < D > toLocalDateTime ( ) ;
ChronoLocalDateTime < D > toLocalDateTime ( ) ;
ChronoLocalDateTime < D > toLocalDateTime ( ) ;
private static void add ( Map < String , List < Object > > map , String key , Object value ) { List < Object > values = map . get ( key ) ; if ( values == null ) { map . put ( key , values = new ArrayList < Object > ( _NUM ) ) ; } values . add ( value ) ; }
@ Override public void apply ( NexusStreamParser np ) throws Exception { np . matchIgnoreCase ( getSyntax ( ) ) ; if ( getParent ( ) instanceof OverlapGraphViewer ) { final OverlapGraphViewer overlapGraphViewer = ( OverlapGraphViewer ) getParent ( ) ; final GraphView graphView = overlapGraphViewer . getGraphView ( ) ; final NodeMap < String > node2ReadNameMap = overlapGraphViewer . getNode2ReadNameMap ( ) ; final Set < String > previousSelection = ProjectManager . getPreviouslySelectedNodeLabels ( ) ; if ( previousSelection . size ( ) > _NUM ) { Graph graph = graphView . getGraph ( ) ; NodeSet toSelect = new NodeSet ( graph ) ; for ( Node v = graph . getFirstNode ( ) ; v != null ; v = graph . getNextNode ( v ) ) { String label = node2ReadNameMap . get ( v ) ; if ( label != null && previousSelection . contains ( label ) ) toSelect . add ( v ) ; } if ( toSelect . size ( ) > _NUM ) { graphView . setSelected ( toSelect , _BOOL ) ; graphView . repaint ( ) ; } } } }
public void addTabFragment ( TabFragment tabFragment ) { fragmentList . add ( tabFragment ) ; }
void displayErrorDialog ( Window w , Throwable t ) { if ( t instanceof NoDisplayException ) { return ; } displayErrorDialog ( w , t . toString ( ) ) ; }
public void invertSelectedRelations ( ) { ISelection selection = viewer . getSelection ( ) ; if ( ! ( selection instanceof IStructuredSelection ) ) { return ; } IStructuredSelection structuredSelection = ( IStructuredSelection ) selection ; Collection < Relation > inverse = computeInverseRelations ( getTableRelations ( ) , structuredSelection ) ; StructuredSelection nextSelection = new StructuredSelection ( inverse . toArray ( ) ) ; viewer . setSelection ( nextSelection , _BOOL ) ; }
public void notifyExited ( final ActiveEntity entity , final int oldX , final int oldY ) { Rectangle2D eArea ; eArea = entity . getArea ( oldX , oldY ) ; for ( final MovementListener l : movementListeners ) { Rectangle2D area = l . getArea ( ) ; if ( area . intersects ( eArea ) ) { l . onExited ( entity , this , oldX , oldY ) ; } } }
public static Instances loadDataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . getOption ( T , options ) ; if ( filename == null || filename . isEmpty ( ) ) throw new Exception ( STRING ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STRING + filename ) ; if ( file . isDirectory ( ) ) throw new Exception ( STRING + filename + STRING ) ; try { DataSource source = new DataSource ( filename ) ; D = source . getDataSet ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new Exception ( STRING + filename + STRING ) ; } return D ; }
public static Instances loadDataset ( String options [ ] , char T ) throws Exception { Instances D = null ; String filename = Utils . getOption ( T , options ) ; if ( filename == null || filename . isEmpty ( ) ) throw new Exception ( STRING ) ; File file = new File ( filename ) ; if ( ! file . exists ( ) ) throw new Exception ( STRING + filename ) ; if ( file . isDirectory ( ) ) throw new Exception ( STRING + filename + STRING ) ; try { DataSource source = new DataSource ( filename ) ; D = source . getDataSet ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; throw new Exception ( STRING + filename + STRING ) ; } return D ; }
public void apply ( ) { setSpeedMap ( ) ; setNXdata ( ) ; }
public void apply ( ) { setSpeedMap ( ) ; setNXdata ( ) ; }
public static boolean findOption ( String name , List < String > args , boolean remove ) { int idx = args . indexOf ( name ) ; if ( idx >= _NUM ) { if ( remove ) { args . remove ( idx ) ; } return _BOOL ; } return _BOOL ; }
public static boolean findOption ( String name , List < String > args , boolean remove ) { int idx = args . indexOf ( name ) ; if ( idx >= _NUM ) { if ( remove ) { args . remove ( idx ) ; } return _BOOL ; } return _BOOL ; }
private void renderOperatorBackground ( final Operator operator , final Graphics2D g2 ) { Rectangle2D frame = model . getOperatorRect ( operator ) ; if ( frame == null ) { return ; } RoundRectangle2D background = new RoundRectangle2D . Double ( frame . getX ( ) - _NUM , frame . getY ( ) - _NUM , frame . getWidth ( ) + _NUM , frame . getHeight ( ) + _NUM , OPERATOR_BG_CORNER , OPERATOR_BG_CORNER ) ; g2 . setColor ( Color . WHITE ) ; g2 . fill ( background ) ; Rectangle2D nameBounds = OPERATOR_FONT . getStringBounds ( operator . getName ( ) , g2 . getFontRenderContext ( ) ) ; if ( nameBounds . getWidth ( ) > frame . getWidth ( ) ) { double relevantWidth = Math . min ( nameBounds . getWidth ( ) , frame . getWidth ( ) * MAX_HEADER_RATIO ) ; double offset = ( frame . getWidth ( ) - relevantWidth ) / _NUM ; int x = ( int ) ( frame . getX ( ) + offset ) ; int padding = _NUM ; RoundRectangle2D nameBackground = new RoundRectangle2D . Double ( ( int ) Math . min ( frame . getX ( ) - padding , x - padding ) , frame . getY ( ) - _NUM , relevantWidth + _NUM * padding , ProcessRendererModel . HEADER_HEIGHT + _NUM , OPERATOR_BG_CORNER , OPERATOR_BG_CORNER ) ; g2 . fill ( nameBackground ) ; } renderPortsBackground ( operator . getInputPorts ( ) , g2 ) ; renderPortsBackground ( operator . getOutputPorts ( ) , g2 ) ; }
public void doInsertionSort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = _NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > _NUM && values [ j - _NUM ] > t ) { values [ j ] = values [ j - _NUM ] ; names [ j ] = names [ j - _NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public void doInsertionSort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = _NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > _NUM && values [ j - _NUM ] > t ) { values [ j ] = values [ j - _NUM ] ; names [ j ] = names [ j - _NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public void doInsertionSort ( String [ ] names , int [ ] values ) { int i , j , t ; String temp = STRING ; for ( i = _NUM ; i < values . length ; i ++ ) { j = i ; t = values [ j ] ; temp = names [ j ] ; while ( j > _NUM && values [ j - _NUM ] > t ) { values [ j ] = values [ j - _NUM ] ; names [ j ] = names [ j - _NUM ] ; j -- ; } values [ j ] = t ; names [ j ] = temp ; } }
public static int convertStringToTimeSeconds ( String time ) { int result = _NUM ; if ( time . endsWith ( STRING ) ) { int hoursToAdd = Integer . valueOf ( StringUtils . remove ( time , STRING ) ) ; result = ( _NUM * _NUM ) * hoursToAdd ; } else if ( time . endsWith ( STRING ) ) { int minsToAdd = Integer . valueOf ( StringUtils . remove ( time , STRING ) ) ; result = _NUM * minsToAdd ; } else if ( time . endsWith ( STRING ) ) { int secsToAdd = Integer . valueOf ( StringUtils . remove ( time , STRING ) ) ; result = secsToAdd ; } return result ; }
public static String deflate ( String previous , String current ) { if ( previous == null ) return current ; StringBuilder buf = new StringBuilder ( ) ; int start1 = _NUM ; int start2 = _NUM ; while ( start1 < previous . length ( ) && start2 < current . length ( ) ) { int end1 = start1 ; int end2 = start2 ; while ( end1 <= previous . length ( ) && end2 <= current . length ( ) ) { int c1 = ( end1 < previous . length ( ) ? previous . charAt ( end1 ) : STRING ) ; int c2 = ( end2 < current . length ( ) ? current . charAt ( end2 ) : STRING ) ; if ( c1 == c2 ) { if ( c1 == STRING ) { buf . append ( STRING ) ; break ; } else { end1 ++ ; end2 ++ ; } } else { while ( end1 < previous . length ( ) && previous . charAt ( end1 ) != STRING ) { end1 ++ ; } while ( end2 < current . length ( ) && current . charAt ( end2 ) != STRING ) { end2 ++ ; } for ( int i = start2 ; i < end2 ; i ++ ) buf . append ( current . charAt ( i ) ) ; break ; } } start1 = end1 + _NUM ; start2 = end2 + _NUM ; if ( start2 < current . length ( ) ) buf . append ( STRING ) ; } return buf . toString ( ) ; }
protected ResourceLoaderLicenseLocator ( final Charset charset , final String ... licenseFiles ) { if ( licenseFiles == null || licenseFiles . length == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( charset == null ) { throw new NullPointerException ( STRING ) ; } this . licenseFiles = new ArrayList < String > ( Arrays . asList ( licenseFiles ) ) ; this . charset = charset ; }
protected ResourceLoaderLicenseLocator ( final Charset charset , final String ... licenseFiles ) { if ( licenseFiles == null || licenseFiles . length == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( charset == null ) { throw new NullPointerException ( STRING ) ; } this . licenseFiles = new ArrayList < String > ( Arrays . asList ( licenseFiles ) ) ; this . charset = charset ; }
protected ResourceLoaderLicenseLocator ( final Charset charset , final String ... licenseFiles ) { if ( licenseFiles == null || licenseFiles . length == _NUM ) { throw new IllegalArgumentException ( STRING ) ; } if ( charset == null ) { throw new NullPointerException ( STRING ) ; } this . licenseFiles = new ArrayList < String > ( Arrays . asList ( licenseFiles ) ) ; this . charset = charset ; }
public List < IvrZone > showActiveIvrZone ( ) throws NetworkDeviceControllerException { return showIvrZones ( _BOOL ) ; }
public synchronized void returnLogCursor ( LogCursor logCursor ) { logCursor . setLoaned ( _BOOL ) ; }
@ Nullable public PkiVerificationData verifyPki ( ) { return pkiVerificationData ; }
public synchronized void clearScreenMessages ( ) { talogging . setText ( STRING ) ; }
public synchronized void clearScreenMessages ( ) { talogging . setText ( STRING ) ; }
public long length ( byte [ ] id ) { ByteBuffer idBuffer = ByteBuffer . wrap ( id ) ; long length = _NUM ; while ( idBuffer . hasRemaining ( ) ) { switch ( idBuffer . get ( ) ) { case _NUM : int len = DataUtils . readVarInt ( idBuffer ) ; idBuffer . position ( idBuffer . position ( ) + len ) ; length += len ; break ; case _NUM : length += DataUtils . readVarInt ( idBuffer ) ; DataUtils . readVarLong ( idBuffer ) ; break ; case _NUM : length += DataUtils . readVarLong ( idBuffer ) ; DataUtils . readVarLong ( idBuffer ) ; break ; default : throw DataUtils . newIllegalArgumentException ( STRING , Arrays . toString ( id ) ) ; } } return length ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static Remote exportObject ( Remote obj ) throws RemoteException { int port = _NUM ; port += Randomness . nextInt ( _NUM ) ; final int TRIES = _NUM ; for ( int i = _NUM ; i < TRIES ; i ++ ) { try { int candidatePort = port + i ; return UnicastRemoteObject . exportObject ( obj , candidatePort ) ; } catch ( RemoteException e ) { } } return UnicastRemoteObject . exportObject ( obj , port ) ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , _BOOL ) ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , _BOOL ) ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , _BOOL ) ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , _BOOL ) ; }
public static void write ( File file , CharSequence data ) throws IOException { write ( file , data , Charset . defaultCharset ( ) , _BOOL ) ; }
public static String multiply ( CharSequence self , Number factor ) { int size = factor . intValue ( ) ; if ( size == _NUM ) return STRING ; else if ( size < _NUM ) { throw new IllegalArgumentException ( STRING + size ) ; } StringBuilder answer = new StringBuilder ( self ) ; for ( int i = _NUM ; i < size ; i ++ ) { answer . append ( self ) ; } return answer . toString ( ) ; }
public static String encodeJavaOpts ( String javaOpts ) { String javaOptsBase64 = DatatypeConverter . printBase64Binary ( javaOpts . getBytes ( Charset . forName ( STRING ) ) ) ; return String . format ( STRING , javaOptsBase64 . replace ( STRING , STRING ) ) ; }
public static < T > boolean containsDuplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return _BOOL ; } previous = entry ; } return _BOOL ; }
public static < T > boolean containsDuplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return _BOOL ; } previous = entry ; } return _BOOL ; }
public static < T > boolean containsDuplicates ( List < T > list , Comparator < T > comparator ) { Collections . sort ( list , comparator ) ; T previous = null ; for ( T entry : list ) { if ( previous != null && previous . equals ( entry ) ) { return _BOOL ; } previous = entry ; } return _BOOL ; }
public static String repeatCharacter ( char c , int repetitions ) { StringBuilder s = new StringBuilder ( repetitions ) ; for ( int i = _NUM ; i < repetitions ; i ++ ) { s . append ( c ) ; } return s . toString ( ) ; }
@ Override public List < Period > generateLast5Years ( Date date ) { Calendar calendar = getCalendar ( ) ; DateTimeUnit dateTimeUnit = createLocalDateUnitInstance ( date ) ; dateTimeUnit = calendar . minusYears ( dateTimeUnit , _NUM ) ; dateTimeUnit . setDay ( _NUM ) ; dateTimeUnit . setMonth ( _NUM ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < _NUM ; ++ i ) { periods . add ( createPeriod ( dateTimeUnit , calendar ) ) ; dateTimeUnit = calendar . plusYears ( dateTimeUnit , _NUM ) ; } return periods ; }
@ Override public List < Period > generateLast5Years ( Date date ) { Calendar calendar = getCalendar ( ) ; DateTimeUnit dateTimeUnit = createLocalDateUnitInstance ( date ) ; dateTimeUnit = calendar . minusYears ( dateTimeUnit , _NUM ) ; dateTimeUnit . setDay ( _NUM ) ; dateTimeUnit . setMonth ( _NUM ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < _NUM ; ++ i ) { periods . add ( createPeriod ( dateTimeUnit , calendar ) ) ; dateTimeUnit = calendar . plusYears ( dateTimeUnit , _NUM ) ; } return periods ; }
public void updateParametersFrom ( SQLiteDatabaseConfiguration other ) { if ( other == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( ! path . equals ( other . path ) ) { throw new IllegalArgumentException ( STRING + STRING ) ; } openFlags = other . openFlags ; maxSqlCacheSize = other . maxSqlCacheSize ; locale = other . locale ; foreignKeyConstraintsEnabled = other . foreignKeyConstraintsEnabled ; customFunctions . clear ( ) ; customFunctions . addAll ( other . customFunctions ) ; }
public String toString ( Object obj ) { return obj . toString ( ) ; }
@ Override public void addPropertyChangeListener ( String propertyName , PropertyChangeListener listener ) { propertyChangeSupport . addPropertyChangeListener ( propertyName , listener ) ; }
@ Override public void write ( Buffer buffer , boolean isEnd ) throws IOException { if ( _s == null ) { buffer . free ( ) ; return ; } try { _needsFlush = _BOOL ; if ( buffer . isDirect ( ) ) { _totalWriteBytes += buffer . length ( ) ; _s . write ( buffer . direct ( ) ) ; return ; } _totalWriteBytes += buffer . length ( ) ; while ( buffer . length ( ) > _NUM ) { _writeBuffer . clear ( ) ; buffer . read ( _writeBuffer ) ; _writeBuffer . flip ( ) ; _s . write ( _writeBuffer ) ; } } catch ( IOException e ) { IOException exn = ClientDisconnectException . create ( this + STRING + e , e ) ; try { close ( ) ; } catch ( IOException e1 ) { } throw exn ; } finally { buffer . free ( ) ; } }
protected void handleHoverEvent ( Event evt ) { if ( evt . getTarget ( ) instanceof Element ) { Element e = ( Element ) evt . getTarget ( ) ; Node next = e . getNextSibling ( ) ; if ( next instanceof Element ) { toggleTooltip ( ( Element ) next , evt . getType ( ) ) ; } else { LoggingUtil . warning ( STRING ) ; } } else { LoggingUtil . warning ( STRING ) ; } }
public void removeAppOffer ( Offer offer ) { int indexToRemove = getIndex ( offer ) ; if ( indexToRemove != - _NUM ) { appOffers . remove ( indexToRemove ) ; notifyDataSetChanged ( ) ; } }
public void removeAppOffer ( Offer offer ) { int indexToRemove = getIndex ( offer ) ; if ( indexToRemove != - _NUM ) { appOffers . remove ( indexToRemove ) ; notifyDataSetChanged ( ) ; } }
public static void pipeAll ( InputStream inStr , OutputStream outStr ) throws IOException { byte [ ] bs = new byte [ BUFFER_SIZE ] ; int numRead ; while ( ( numRead = inStr . read ( bs , _NUM , bs . length ) ) >= _NUM ) { outStr . write ( bs , _NUM , numRead ) ; } }
public static Vector3 ceil ( Vector3 o ) { return new Vector3 ( Math . ceil ( o . x ) , Math . ceil ( o . y ) , Math . ceil ( o . z ) ) ; }
public static Character toCharacter ( Object o , Character defaultValue ) { if ( o instanceof Character ) return ( Character ) o ; if ( defaultValue != null ) return new Character ( toCharValue ( o , defaultValue . charValue ( ) ) ) ; char res = toCharValue ( o , Character . MIN_VALUE ) ; if ( res == Character . MIN_VALUE ) return defaultValue ; return new Character ( res ) ; }
public static Character toCharacter ( Object o , Character defaultValue ) { if ( o instanceof Character ) return ( Character ) o ; if ( defaultValue != null ) return new Character ( toCharValue ( o , defaultValue . charValue ( ) ) ) ; char res = toCharValue ( o , Character . MIN_VALUE ) ; if ( res == Character . MIN_VALUE ) return defaultValue ; return new Character ( res ) ; }
public TransferableDataItem ( NodeInterface destinationTreeNode , TreePath path ) { if ( ( destinationTreeNode != null ) && ( path != null ) ) { Map < NodeInterface , TreePath > selectedData = new LinkedHashMap < NodeInterface , TreePath > ( ) ; selectedData . put ( destinationTreeNode , path ) ; internalPopulate ( selectedData ) ; } }
private synchronized void pauseTrackDataHub ( ) { if ( trackDataHub != null ) { trackDataHub . unregisterTrackDataListener ( this ) ; } trackDataHub = null ; }
public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( ObjectUtils . isEmpty ( array1 ) ) { return array2 ; } if ( ObjectUtils . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , _NUM , newArr , _NUM , array1 . length ) ; System . arraycopy ( array2 , _NUM , newArr , array1 . length , array2 . length ) ; return newArr ; }
public static String [ ] concatenateStringArrays ( String [ ] array1 , String [ ] array2 ) { if ( ObjectUtils . isEmpty ( array1 ) ) { return array2 ; } if ( ObjectUtils . isEmpty ( array2 ) ) { return array1 ; } String [ ] newArr = new String [ array1 . length + array2 . length ] ; System . arraycopy ( array1 , _NUM , newArr , _NUM , array1 . length ) ; System . arraycopy ( array2 , _NUM , newArr , array1 . length , array2 . length ) ; return newArr ; }
private static boolean caselessCompare ( char a , char b ) { return Character . toLowerCase ( a ) == Character . toLowerCase ( b ) ; }
public void start ( ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( mState ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState ) ; switch ( mState . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new IllegalStateException ( STRING + mState ) ; case STOPPED : case PLAYBACK_COMPLETED : case PREPARED : case PAUSED : if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState + STRING ) ; mMediaPlayer . start ( ) ; startPositionUpdateNotifier ( ) ; mState . set ( State . STARTED ) ; break ; case ERROR : case END : throw new IllegalStateException ( STRING + mState ) ; } } if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; }
public void start ( ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( mState ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState ) ; switch ( mState . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new IllegalStateException ( STRING + mState ) ; case STOPPED : case PLAYBACK_COMPLETED : case PREPARED : case PAUSED : if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState + STRING ) ; mMediaPlayer . start ( ) ; startPositionUpdateNotifier ( ) ; mState . set ( State . STARTED ) ; break ; case ERROR : case END : throw new IllegalStateException ( STRING + mState ) ; } } if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; }
public void start ( ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; synchronized ( mState ) { if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState ) ; switch ( mState . get ( ) ) { case IDLE : case INITIALIZED : case PREPARING : case STARTED : throw new IllegalStateException ( STRING + mState ) ; case STOPPED : case PLAYBACK_COMPLETED : case PREPARED : case PAUSED : if ( SHOW_LOGS ) Logger . v ( TAG , STRING + mState + STRING ) ; mMediaPlayer . start ( ) ; startPositionUpdateNotifier ( ) ; mState . set ( State . STARTED ) ; break ; case ERROR : case END : throw new IllegalStateException ( STRING + mState ) ; } } if ( SHOW_LOGS ) Logger . v ( TAG , STRING ) ; }
private void removeAllHotkeys ( ) { removeHotkeys ( main . getRootPane ( ) ) ; for ( JDialog popout : popouts . keySet ( ) ) { removeHotkeys ( popout . getRootPane ( ) ) ; } removeGlobalHotkeys ( ) ; removeHotkeysFromActions ( ) ; }
public void write ( char chars [ ] , int start , int length ) throws java . io . IOException { int n = length + start ; for ( int i = start ; i < n ; i ++ ) { m_os . write ( chars [ i ] ) ; } }
static char processCharLiteral ( String entity ) throws IOException , XMLParseException { if ( entity . charAt ( _NUM ) == STRING ) { entity = entity . substring ( _NUM , entity . length ( ) - _NUM ) ; return ( char ) Integer . parseInt ( entity , _NUM ) ; } else { entity = entity . substring ( _NUM , entity . length ( ) - _NUM ) ; return ( char ) Integer . parseInt ( entity , _NUM ) ; } }
protected boolean parseLineInternal ( ) { int i = _NUM ; for ( ; tokenizer . valid ( ) ; tokenizer . advance ( ) , i ++ ) { if ( ! isLabelColumn ( i ) && ! tokenizer . isQuoted ( ) ) { try { attributes . add ( tokenizer . getDouble ( ) ) ; continue ; } catch ( NumberFormatException e ) { } } String lbl = tokenizer . getStrippedSubstring ( ) ; if ( lbl . length ( ) > _NUM ) { haslabels = _BOOL ; lbl = unique . addOrGet ( lbl ) ; labels . add ( lbl ) ; } } if ( curvec == null && attributes . size == _NUM ) { columnnames = new ArrayList < > ( labels ) ; haslabels = _BOOL ; curvec = null ; curlbl = null ; labels . clear ( ) ; return _BOOL ; } curvec = createVector ( ) ; curlbl = LabelList . make ( labels ) ; attributes . clear ( ) ; labels . clear ( ) ; return _BOOL ; }
public void add ( SchedulableEvent event ) { synchronized ( lock ) { FastEventQueue list = mEventBuffer . get ( event . getTimestamp ( ) ) ; if ( list == null ) { long lowestTime = mEventBuffer . isEmpty ( ) ? Long . MAX_VALUE : mEventBuffer . firstKey ( ) ; list = new FastEventQueue ( event ) ; mEventBuffer . put ( event . getTimestamp ( ) , list ) ; if ( event . getTimestamp ( ) < lowestTime ) { lock . notify ( ) ; } } else { list . add ( event ) ; } } }
public MersenneTwisterRNG ( final byte [ ] seed ) { if ( seed == null || seed . length != SEED_SIZE_BYTES ) { throw new IllegalArgumentException ( STRING ) ; } this . seed = seed . clone ( ) ; final int [ ] seedInts = convertBytesToInts ( this . seed ) ; mt [ _NUM ] = BOOTSTRAP_SEED ; for ( mtIndex = _NUM ; mtIndex < N ; mtIndex ++ ) { mt [ mtIndex ] = BOOTSTRAP_FACTOR * ( mt [ mtIndex - _NUM ] ^ mt [ mtIndex - _NUM ] > > > _NUM ) + mtIndex ; } int i = _NUM ; int j = _NUM ; for ( int k = Math . max ( N , seedInts . length ) ; k > _NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - _NUM ] ^ mt [ i - _NUM ] > > > _NUM ) * SEED_FACTOR1 ) + seedInts [ j ] + j ; i ++ ; j ++ ; if ( i >= N ) { mt [ _NUM ] = mt [ N - _NUM ] ; i = _NUM ; } if ( j >= seedInts . length ) { j = _NUM ; } } for ( int k = N - _NUM ; k > _NUM ; k -- ) { mt [ i ] = ( mt [ i ] ^ ( mt [ i - _NUM ] ^ mt [ i - _NUM ] > > > _NUM ) * SEED_FACTOR2 ) - i ; i ++ ; if ( i >= N ) { mt [ _NUM ] = mt [ N - _NUM ] ; i = _NUM ; } } mt [ _NUM ] = UPPER_MASK ; }
public static synchronized void init ( Configuration conf ) { String server = conf . getString ( STRING , X . EMPTY ) ; if ( server . startsWith ( MEMCACHED ) ) { cacheSystem = MemCache . create ( conf ) ; } else if ( server . startsWith ( REDIS ) ) { cacheSystem = RedisCache . create ( conf ) ; } else { log . debug ( STRING ) ; cacheSystem = FileCache . create ( conf ) ; } GROUP = conf . getString ( STRING , STRING ) + STRING ; }
public static synchronized void init ( Configuration conf ) { String server = conf . getString ( STRING , X . EMPTY ) ; if ( server . startsWith ( MEMCACHED ) ) { cacheSystem = MemCache . create ( conf ) ; } else if ( server . startsWith ( REDIS ) ) { cacheSystem = RedisCache . create ( conf ) ; } else { log . debug ( STRING ) ; cacheSystem = FileCache . create ( conf ) ; } GROUP = conf . getString ( STRING , STRING ) + STRING ; }
public CharBuffer ( String string , int offset , int length ) { int capacity = Math . max ( length , MIN_CAPACITY ) ; init ( new char [ capacity ] , _NUM , length ) ; string . getChars ( offset , length , buffer ( ) , _NUM ) ; }
public Properties readSettings ( ) { Properties result = new Properties ( ) ; result . setProperty ( this . httpEnv , this . httpProxy ) ; result . setProperty ( this . httpsEnv , this . httpsProxy ) ; result . setProperty ( this . ftpEnv , this . ftpProxy ) ; result . setProperty ( this . noProxyEnv , this . noProxy ) ; return result ; }
public Properties readSettings ( ) { Properties result = new Properties ( ) ; result . setProperty ( this . httpEnv , this . httpProxy ) ; result . setProperty ( this . httpsEnv , this . httpsProxy ) ; result . setProperty ( this . ftpEnv , this . ftpProxy ) ; result . setProperty ( this . noProxyEnv , this . noProxy ) ; return result ; }
public static < U extends Object , S extends Service < U > > boolean launchServiceByClass ( Class < ? extends S > c , U user , Frame owner ) { boolean success = _BOOL ; S ret = null ; for ( Service < ? > s : SERVICE_TO_USER_MAP . keySet ( ) ) { if ( c . isInstance ( s ) ) { s . pullToFront ( ) ; return _BOOL ; } } try { ret = c . newInstance ( ) ; SERVICE_TO_USER_MAP . put ( ret , user ) ; ret . setupGUI ( owner ) ; ret . launch ( ) ; success = _BOOL ; } catch ( InstantiationException | IllegalAccessException e ) { LOG . severe ( STRING + e . getMessage ( ) ) ; } return success ; }
public static final java . lang . String readUTF ( java . io . DataInput in ) throws java . io . IOException { return decodeUTF ( in . readUnsignedShort ( ) , in ) ; }
public static final java . lang . String readUTF ( java . io . DataInput in ) throws java . io . IOException { return decodeUTF ( in . readUnsignedShort ( ) , in ) ; }
static void removeSoIfExit ( String libName , int version ) { String file = _targetSoFile ( libName , version ) ; File a = new File ( file ) ; if ( a . exists ( ) ) { a . delete ( ) ; } }
public static final Object [ ] resize ( Object [ ] a , int size ) { if ( a . length >= size ) return a ; Object [ ] b = new Object [ size ] ; System . arraycopy ( a , _NUM , b , _NUM , a . length ) ; return b ; }
public static final Object [ ] resize ( Object [ ] a , int size ) { if ( a . length >= size ) return a ; Object [ ] b = new Object [ size ] ; System . arraycopy ( a , _NUM , b , _NUM , a . length ) ; return b ; }
public void addObserver ( NotificationObserver observer ) { observers . add ( observer ) ; }
public CharSeq replaceFirst ( String regex , String replacement ) { return CharSeq . of ( str . replaceFirst ( regex , replacement ) ) ; }
public CharSeq replaceFirst ( String regex , String replacement ) { return CharSeq . of ( str . replaceFirst ( regex , replacement ) ) ; }
public static CertChainKeyPair generateSignedForClient ( String fqdn , X509Certificate issuerCertificate , PrivateKey issuerPrivateKey ) { try { return generateCertificateAndSign ( fqdn , issuerCertificate , issuerPrivateKey , getClientExtensions ( ) ) ; } catch ( CertIOException | CertificateException | OperatorCreationException e ) { throw new RuntimeException ( String . format ( STRING , e . getMessage ( ) ) , e ) ; } }
public static String createSelectorFromAddress ( String address ) { StringBuilder stringBuilder = new StringBuilder ( ) ; if ( ! address . contains ( STRING ) ) { if ( address . startsWith ( STRING ) ) { stringBuilder . append ( ManagementHelper . HDR_ADDRESS + STRING + address . substring ( _NUM , address . length ( ) ) + STRING ) ; } else { stringBuilder . append ( ManagementHelper . HDR_ADDRESS + STRING + address + STRING ) ; } return stringBuilder . toString ( ) ; } return buildSelectorFromArray ( address . split ( STRING ) ) ; }
public static String createSelectorFromAddress ( String address ) { StringBuilder stringBuilder = new StringBuilder ( ) ; if ( ! address . contains ( STRING ) ) { if ( address . startsWith ( STRING ) ) { stringBuilder . append ( ManagementHelper . HDR_ADDRESS + STRING + address . substring ( _NUM , address . length ( ) ) + STRING ) ; } else { stringBuilder . append ( ManagementHelper . HDR_ADDRESS + STRING + address + STRING ) ; } return stringBuilder . toString ( ) ; } return buildSelectorFromArray ( address . split ( STRING ) ) ; }
public ConnectUriManager ( List < String > connectUri ) throws THLException { this . uriList = connectUri ; if ( connectUri . size ( ) == _NUM ) { throw new THLException ( STRING ) ; } }
public boolean createXML ( StreamResult result ) { try { DOMSource source = new DOMSource ( getDocument ( ) ) ; TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = tFactory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , STRING ) ; transformer . setOutputProperty ( OutputKeys . INDENT , STRING ) ; transformer . transform ( source , result ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; return _BOOL ; } return _BOOL ; }
public boolean createXML ( StreamResult result ) { try { DOMSource source = new DOMSource ( getDocument ( ) ) ; TransformerFactory tFactory = TransformerFactory . newInstance ( ) ; Transformer transformer = tFactory . newTransformer ( ) ; transformer . setOutputProperty ( OutputKeys . ENCODING , STRING ) ; transformer . setOutputProperty ( OutputKeys . INDENT , STRING ) ; transformer . transform ( source , result ) ; } catch ( Exception e ) { log . log ( Level . SEVERE , STRING , e ) ; return _BOOL ; } return _BOOL ; }
protected Class < DruidQueryBuilder > buildDruidQueryBuilder ( ) { return DruidQueryBuilder . class ; }
protected Class < DruidQueryBuilder > buildDruidQueryBuilder ( ) { return DruidQueryBuilder . class ; }
protected void initBatchBuffer ( ) { try { if ( ! isIncremental ( ) ) { m_BatchBuffer = m_Loader . getDataSet ( ) ; } else { m_BatchBuffer = null ; } } catch ( Exception e ) { e . printStackTrace ( ) ; } }
private static byte [ ] lmResponse ( byte [ ] hash , byte [ ] challenge ) throws Exception { byte [ ] keyBytes = new byte [ _NUM ] ; System . arraycopy ( hash , _NUM , keyBytes , _NUM , _NUM ) ; Key lowKey = createDESKey ( keyBytes , _NUM ) ; Key middleKey = createDESKey ( keyBytes , _NUM ) ; Key highKey = createDESKey ( keyBytes , _NUM ) ; Cipher des = Cipher . getInstance ( STRING ) ; des . init ( Cipher . ENCRYPT_MODE , lowKey ) ; byte [ ] lowResponse = des . doFinal ( challenge ) ; des . init ( Cipher . ENCRYPT_MODE , middleKey ) ; byte [ ] middleResponse = des . doFinal ( challenge ) ; des . init ( Cipher . ENCRYPT_MODE , highKey ) ; byte [ ] highResponse = des . doFinal ( challenge ) ; byte [ ] lmResponse = new byte [ _NUM ] ; System . arraycopy ( lowResponse , _NUM , lmResponse , _NUM , _NUM ) ; System . arraycopy ( middleResponse , _NUM , lmResponse , _NUM , _NUM ) ; System . arraycopy ( highResponse , _NUM , lmResponse , _NUM , _NUM ) ; return lmResponse ; }
public boolean readBoolean ( ) throws IOException { return primitiveTypes . readBoolean ( ) ; }
protected void printIdentifier ( String identifier , StringBuilder ddl ) { ddl . append ( getDelimitedIdentifier ( identifier ) ) ; }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public void installLinearModels ( ) throws Exception { Evaluation nodeModelEval ; if ( m_isLeaf ) { buildLinearModel ( m_indices ) ; } else { if ( m_left != null ) { m_left . installLinearModels ( ) ; } if ( m_right != null ) { m_right . installLinearModels ( ) ; } buildLinearModel ( m_indices ) ; } nodeModelEval = new Evaluation ( m_instances ) ; nodeModelEval . evaluateModel ( m_nodeModel , m_instances ) ; m_rootMeanSquaredError = nodeModelEval . rootMeanSquaredError ( ) ; if ( ! m_saveInstances ) { m_instances = new Instances ( m_instances , _NUM ) ; } }
public static String createHandlerRequestPath ( final CacheKey cacheKey , final HttpServletRequest request ) { final String handlerQueryPath = getRequestHandlerPath ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; return request . getServletPath ( ) + handlerQueryPath ; }
public static String createHandlerRequestPath ( final CacheKey cacheKey , final HttpServletRequest request ) { final String handlerQueryPath = getRequestHandlerPath ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; return request . getServletPath ( ) + handlerQueryPath ; }
public static String createHandlerRequestPath ( final CacheKey cacheKey , final HttpServletRequest request ) { final String handlerQueryPath = getRequestHandlerPath ( cacheKey . getGroupName ( ) , cacheKey . getType ( ) ) ; return request . getServletPath ( ) + handlerQueryPath ; }
public static boolean isWindows7 ( ) { return osName . indexOf ( STRING ) > - _NUM && osVersion . equals ( STRING ) ; }
public BufferedImage createCompatibleImage ( int width , int height ) { WritableRaster wr = raster . createCompatibleWritableRaster ( width , height ) ; return new BufferedImage ( model , wr , model . isAlphaPremultiplied ( ) , null ) ; }
public BufferedImage createCompatibleImage ( int width , int height ) { WritableRaster wr = raster . createCompatibleWritableRaster ( width , height ) ; return new BufferedImage ( model , wr , model . isAlphaPremultiplied ( ) , null ) ; }
public BufferedImage createCompatibleImage ( int width , int height ) { WritableRaster wr = raster . createCompatibleWritableRaster ( width , height ) ; return new BufferedImage ( model , wr , model . isAlphaPremultiplied ( ) , null ) ; }
public BufferedImage createCompatibleImage ( int width , int height ) { WritableRaster wr = raster . createCompatibleWritableRaster ( width , height ) ; return new BufferedImage ( model , wr , model . isAlphaPremultiplied ( ) , null ) ; }
public boolean addAll ( int index , Collection < ? extends E > c ) { rangeCheckForAdd ( index ) ; Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; int numMoved = size - index ; if ( numMoved > _NUM ) { System . arraycopy ( elementData , index , elementData , index + numNew , numMoved ) ; } System . arraycopy ( a , _NUM , elementData , index , numNew ) ; size += numNew ; return numNew != _NUM ; }
public boolean addAll ( int index , Collection < ? extends E > c ) { rangeCheckForAdd ( index ) ; Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; int numMoved = size - index ; if ( numMoved > _NUM ) { System . arraycopy ( elementData , index , elementData , index + numNew , numMoved ) ; } System . arraycopy ( a , _NUM , elementData , index , numNew ) ; size += numNew ; return numNew != _NUM ; }
public boolean addAll ( int index , Collection < ? extends E > c ) { rangeCheckForAdd ( index ) ; Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; int numMoved = size - index ; if ( numMoved > _NUM ) { System . arraycopy ( elementData , index , elementData , index + numNew , numMoved ) ; } System . arraycopy ( a , _NUM , elementData , index , numNew ) ; size += numNew ; return numNew != _NUM ; }
@ Override public byte [ ] firstToken ( ) { return oneToken ; }
public static boolean loadNativeLibrary ( ) { try { Log . i ( TAG , STRING + LIBRARY_NAME ) ; System . loadLibrary ( STRING ) ; System . loadLibrary ( LIBRARY_NAME ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + e . toString ( ) ) ; return _BOOL ; } return _BOOL ; }
default Value remove ( Optional < ? extends CharSequence > name ) { return name . isPresent ( ) ? remove ( name . get ( ) ) : null ; }
public E poll ( ) { if ( isEmpty ( ) ) { return null ; } E result = elements [ _NUM ] ; removeAt ( _NUM ) ; return result ; }
protected Query finishQuery ( BooleanQuery . Builder in , boolean allTermsRequired ) { return in . build ( ) ; }
protected Query finishQuery ( BooleanQuery . Builder in , boolean allTermsRequired ) { return in . build ( ) ; }
protected Query finishQuery ( BooleanQuery . Builder in , boolean allTermsRequired ) { return in . build ( ) ; }
protected Query finishQuery ( BooleanQuery . Builder in , boolean allTermsRequired ) { return in . build ( ) ; }
public VSDecoderPane ( VSDecoderFrame p ) { super ( ) ; parent = p ; decoder_mgr = VSDecoderManager . instance ( ) ; }
public BitVector ( BitVector s ) { bits = new int [ s . bits . length ] ; this . nbits = s . nbits ; System . arraycopy ( s . bits , _NUM , this . bits , _NUM , s . bits . length ) ; }
private void fireEvent ( final IRunningQuery q ) { if ( q == null ) throw new IllegalArgumentException ( ) ; if ( listeners . isEmpty ( ) ) { return ; } final IRunningQueryListener [ ] a = listeners . toArray ( new IRunningQueryListener [ _NUM ] ) ; for ( IRunningQueryListener l : a ) { final IRunningQueryListener listener = l ; try { listener . notify ( q ) ; } catch ( Throwable t ) { if ( InnerCause . isInnerCause ( t , InterruptedException . class ) ) { throw new RuntimeException ( t ) ; } log . error ( t , t ) ; } } }
public static MultisigAggregateModificationTransaction createMultisigModification ( ) { return new MultisigAggregateModificationTransaction ( TimeInstant . ZERO , Utils . generateRandomAccount ( ) , Collections . singletonList ( new MultisigCosignatoryModification ( MultisigModificationType . AddCosignatory , Utils . generateRandomAccount ( ) ) ) ) ; }
private static Double readAmfDouble ( ParsableByteArray data ) { return Double . longBitsToDouble ( data . readLong ( ) ) ; }
@ Override public void init ( int mode , Key key , AlgorithmParameterSpec params ) throws InvalidKeyException , InvalidAlgorithmParameterException { Utils . checkNotNull ( key ) ; Utils . checkNotNull ( params ) ; cipher . init ( mode , key , params ) ; }
@ Override public void init ( int mode , Key key , AlgorithmParameterSpec params ) throws InvalidKeyException , InvalidAlgorithmParameterException { Utils . checkNotNull ( key ) ; Utils . checkNotNull ( params ) ; cipher . init ( mode , key , params ) ; }
public static GeoTimeSerie fillticks ( GeoTimeSerie gts , long location , long elevation , Object value , long [ ] ticks ) { GeoTimeSerie filled = gts . clone ( ) ; if ( null == value || GTSHelper . isBucketized ( filled ) ) { return filled ; } long [ ] gticks = filled . values > _NUM ? Arrays . copyOf ( filled . ticks , filled . values ) : new long [ _NUM ] ; Arrays . sort ( gticks ) ; Arrays . sort ( ticks ) ; int gtsidx = _NUM ; int tickidx = _NUM ; int nvalues = filled . values ; while ( gtsidx < nvalues ) { long tick = gticks [ gtsidx ] ; while ( tickidx < ticks . length && ticks [ tickidx ] < tick ) { GTSHelper . setValue ( filled , ticks [ tickidx ] , location , elevation , value , _BOOL ) ; tickidx ++ ; } gtsidx ++ ; } while ( tickidx < ticks . length ) { GTSHelper . setValue ( filled , ticks [ tickidx ] , location , elevation , value , _BOOL ) ; tickidx ++ ; } return filled ; }
public static boolean isDistributedCacheUsed ( String str ) { String [ ] parts = str . split ( Instruction . INSTRUCTION_DELIM ) ; for ( String inst : parts ) { String opcode = getOpCode ( inst ) ; if ( opcode . equalsIgnoreCase ( AppendM . OPCODE ) || opcode . equalsIgnoreCase ( MapMult . OPCODE ) || opcode . equalsIgnoreCase ( MapMultChain . OPCODE ) || opcode . equalsIgnoreCase ( PMMJ . OPCODE ) || opcode . equalsIgnoreCase ( UAggOuterChain . OPCODE ) || opcode . equalsIgnoreCase ( GroupedAggregateM . OPCODE ) || isDistQuaternaryOpcode ( opcode ) || BinaryM . isOpcode ( opcode ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean isDistributedCacheUsed ( String str ) { String [ ] parts = str . split ( Instruction . INSTRUCTION_DELIM ) ; for ( String inst : parts ) { String opcode = getOpCode ( inst ) ; if ( opcode . equalsIgnoreCase ( AppendM . OPCODE ) || opcode . equalsIgnoreCase ( MapMult . OPCODE ) || opcode . equalsIgnoreCase ( MapMultChain . OPCODE ) || opcode . equalsIgnoreCase ( PMMJ . OPCODE ) || opcode . equalsIgnoreCase ( UAggOuterChain . OPCODE ) || opcode . equalsIgnoreCase ( GroupedAggregateM . OPCODE ) || isDistQuaternaryOpcode ( opcode ) || BinaryM . isOpcode ( opcode ) ) { return _BOOL ; } } return _BOOL ; }
public Component findByName ( String name , Component rootComponent ) { Component c = ( Component ) rootComponent . getClientProperty ( STRING + name + STRING ) ; if ( c == null ) { Container newRoot = getRootAncestor ( rootComponent ) ; if ( newRoot != null && rootComponent != newRoot ) { return findByName ( name , newRoot ) ; } } return c ; }
public Component findByName ( String name , Component rootComponent ) { Component c = ( Component ) rootComponent . getClientProperty ( STRING + name + STRING ) ; if ( c == null ) { Container newRoot = getRootAncestor ( rootComponent ) ; if ( newRoot != null && rootComponent != newRoot ) { return findByName ( name , newRoot ) ; } } return c ; }
@ Override public void onBindViewHolder ( MovieViewHolder holder , int position ) { Movie movie = movies . get ( position ) ; holder . setMovie ( movie ) ; }
@ Override public void onBindViewHolder ( MovieViewHolder holder , int position ) { Movie movie = movies . get ( position ) ; holder . setMovie ( movie ) ; }
public static void showWindow ( Window window ) { window . setVisible ( _BOOL ) ; if ( window instanceof Frame ) { Frame f = ( Frame ) window ; int state = f . getExtendedState ( ) ; if ( ( state & Frame . ICONIFIED ) > _NUM ) f . setExtendedState ( state & ~ Frame . ICONIFIED ) ; } window . toFront ( ) ; }
@ Override public int hashCode ( ) { return Objects . hash ( id , version , updateSite ) ; }
private float calculateBasePageTargetY ( PanelState expandedState ) { if ( ! isFullscreenSizePanel ( ) ) return _NUM ; final float selectionY = mBasePageSelectionYPx * mPxToDp ; final float expandedHeight = getPanelHeightFromState ( expandedState ) - mSearchBarPaddingTop ; final float fullscreenHeight = getFullscreenHeight ( ) ; final float availableHeight = fullscreenHeight - expandedHeight ; float offset = - selectionY + availableHeight / _NUM ; offset = Math . min ( offset , _NUM ) ; if ( mIsToolbarShowing ) offset -= mToolbarHeight ; offset = Math . max ( offset , - expandedHeight ) ; return offset ; }
private float calculateBasePageTargetY ( PanelState expandedState ) { if ( ! isFullscreenSizePanel ( ) ) return _NUM ; final float selectionY = mBasePageSelectionYPx * mPxToDp ; final float expandedHeight = getPanelHeightFromState ( expandedState ) - mSearchBarPaddingTop ; final float fullscreenHeight = getFullscreenHeight ( ) ; final float availableHeight = fullscreenHeight - expandedHeight ; float offset = - selectionY + availableHeight / _NUM ; offset = Math . min ( offset , _NUM ) ; if ( mIsToolbarShowing ) offset -= mToolbarHeight ; offset = Math . max ( offset , - expandedHeight ) ; return offset ; }
private float calculateBasePageTargetY ( PanelState expandedState ) { if ( ! isFullscreenSizePanel ( ) ) return _NUM ; final float selectionY = mBasePageSelectionYPx * mPxToDp ; final float expandedHeight = getPanelHeightFromState ( expandedState ) - mSearchBarPaddingTop ; final float fullscreenHeight = getFullscreenHeight ( ) ; final float availableHeight = fullscreenHeight - expandedHeight ; float offset = - selectionY + availableHeight / _NUM ; offset = Math . min ( offset , _NUM ) ; if ( mIsToolbarShowing ) offset -= mToolbarHeight ; offset = Math . max ( offset , - expandedHeight ) ; return offset ; }
public JOSMTolerantFastXMLParser ( Sink sink , XMLStreamReader reader , boolean enableDateParsing ) { this . sink = sink ; this . enableDateParsing = enableDateParsing ; this . reader = reader ; if ( enableDateParsing ) { timestampFormat = new XmlTimestampFormat ( ) ; } else { Calendar calendar ; calendar = Calendar . getInstance ( ) ; calendar . set ( Calendar . MILLISECOND , _NUM ) ; dummyTimestampContainer = new SimpleTimestampContainer ( calendar . getTime ( ) ) ; } memberTypeParser = new MemberTypeParser ( ) ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public boolean isTabAssociatedWithNonDestroyedActivity ( boolean isIncognito , int tabId ) { List < WeakReference < Activity > > activities = ApplicationStatus . getRunningActivities ( ) ; for ( WeakReference < Activity > ref : activities ) { Activity activity = ref . get ( ) ; if ( activity != null && isValidActivity ( isIncognito , activity . getIntent ( ) ) && getTabIdFromIntent ( activity . getIntent ( ) ) == tabId && ! isActivityDestroyed ( activity ) ) { return _BOOL ; } } return _BOOL ; }
public ByteInterleavedRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public ByteInterleavedRaster ( SampleModel sampleModel , Point origin ) { this ( sampleModel , sampleModel . createDataBuffer ( ) , new Rectangle ( origin . x , origin . y , sampleModel . getWidth ( ) , sampleModel . getHeight ( ) ) , origin , null ) ; }
public void applyOutlierTreatment ( double [ ] values ) throws Exception { for ( int i = _NUM ; i < m_miningMeta . size ( ) ; i ++ ) { MiningFieldMetaInfo mfi = m_miningMeta . get ( i ) ; values [ i ] = mfi . applyOutlierTreatment ( values [ i ] ) ; } }
public void markKeyForPreload ( int idx ) { if ( preloadKeys == null ) preloadKeys = new BitSet ( ) ; preloadKeys . set ( idx , _BOOL ) ; }
@ Override public int read ( char [ ] array , int offset , int length ) { if ( idx >= charSequence . length ( ) ) { return - _NUM ; } if ( array == null ) { throw new NullPointerException ( STRING ) ; } if ( length < _NUM || offset < _NUM || offset + length > array . length ) { throw new IndexOutOfBoundsException ( STRING + array . length + STRING + offset + STRING + length ) ; } int count = _NUM ; for ( int i = _NUM ; i < length ; i ++ ) { int c = read ( ) ; if ( c == - _NUM ) { return count ; } array [ offset + i ] = ( char ) c ; count ++ ; } return count ; }
public void write ( Color c , String s ) throws IOException { if ( page != null ) { page . setColor ( c ) ; } write ( s ) ; if ( page != null ) { page . setColor ( color ) ; } }
public void write ( Color c , String s ) throws IOException { if ( page != null ) { page . setColor ( c ) ; } write ( s ) ; if ( page != null ) { page . setColor ( color ) ; } }
public void write ( Color c , String s ) throws IOException { if ( page != null ) { page . setColor ( c ) ; } write ( s ) ; if ( page != null ) { page . setColor ( color ) ; } }
public void write ( Color c , String s ) throws IOException { if ( page != null ) { page . setColor ( c ) ; } write ( s ) ; if ( page != null ) { page . setColor ( color ) ; } }
private int adjustForCache ( final int pointer ) { if ( fontData == null || pointer < offset || pointer >= ( offset + blockSize - _NUM ) ) { try { fontFile . seek ( pointer ) ; fontData = new byte [ blockSize ] ; fontFile . read ( fontData ) ; } catch ( final IOException e ) { LogWriter . writeLog ( STRING + e . getMessage ( ) ) ; } offset = pointer ; } return pointer - offset ; }
private int adjustForCache ( final int pointer ) { if ( fontData == null || pointer < offset || pointer >= ( offset + blockSize - _NUM ) ) { try { fontFile . seek ( pointer ) ; fontData = new byte [ blockSize ] ; fontFile . read ( fontData ) ; } catch ( final IOException e ) { LogWriter . writeLog ( STRING + e . getMessage ( ) ) ; } offset = pointer ; } return pointer - offset ; }
public static JPanel createHorizontalPanel ( String title ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; if ( title != null ) { panel . setBorder ( BorderFactory . createTitledBorder ( BorderFactory . createEtchedBorder ( ) , title ) ) ; } else { panel . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; } return panel ; }
public static JPanel createHorizontalPanel ( String title ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; if ( title != null ) { panel . setBorder ( BorderFactory . createTitledBorder ( BorderFactory . createEtchedBorder ( ) , title ) ) ; } else { panel . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; } return panel ; }
public static JPanel createHorizontalPanel ( String title ) { JPanel panel = new JPanel ( ) ; panel . setLayout ( new GridLayout ( _NUM , _NUM ) ) ; if ( title != null ) { panel . setBorder ( BorderFactory . createTitledBorder ( BorderFactory . createEtchedBorder ( ) , title ) ) ; } else { panel . setBorder ( BorderFactory . createEtchedBorder ( ) ) ; } return panel ; }
protected boolean applyFilter ( Node node , int nodeType ) { if ( fFilter != null && ( fWhatToShowFilter & nodeType ) != _NUM ) { short code = fFilter . acceptNode ( node ) ; switch ( code ) { case NodeFilter . FILTER_REJECT : case NodeFilter . FILTER_SKIP : return _BOOL ; default : } } return _BOOL ; }
public void addToConsolitatedMsg ( final String message ) { if ( consolidatedMessage != null && consolidatedMessage . length ( ) > _NUM ) { consolidatedMessage = consolidatedMessage + STRING ; } consolidatedMessage = consolidatedMessage + message ; }
public void addToConsolitatedMsg ( final String message ) { if ( consolidatedMessage != null && consolidatedMessage . length ( ) > _NUM ) { consolidatedMessage = consolidatedMessage + STRING ; } consolidatedMessage = consolidatedMessage + message ; }
public void addToConsolitatedMsg ( final String message ) { if ( consolidatedMessage != null && consolidatedMessage . length ( ) > _NUM ) { consolidatedMessage = consolidatedMessage + STRING ; } consolidatedMessage = consolidatedMessage + message ; }
public void addToConsolitatedMsg ( final String message ) { if ( consolidatedMessage != null && consolidatedMessage . length ( ) > _NUM ) { consolidatedMessage = consolidatedMessage + STRING ; } consolidatedMessage = consolidatedMessage + message ; }
public static Boolean canStringBeInlineEncoded ( String skey ) { if ( skey . length ( ) > getMaxInlineStringKey ( MAX_LONGS_USED_FOR_STRING_KEY , _BOOL ) ) { return null ; } if ( isByteEncodingOk ( skey ) ) { return Boolean . TRUE ; } else { if ( skey . length ( ) > getMaxInlineStringKey ( MAX_LONGS_USED_FOR_STRING_KEY , _BOOL ) ) { return null ; } else { return Boolean . FALSE ; } } }
public void close ( ResultSet rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException e ) { } } }
public void close ( ResultSet rs ) { if ( rs != null ) { try { rs . close ( ) ; } catch ( SQLException e ) { } } }
private void initParameterRemovalLists ( ) { parameter_to_remove_for_all_request = new ArrayList < > ( ) ; parameter_to_remove_after_initial_request = new ArrayList < > ( ) ; parameter_to_remove_for_all_request . add ( EXPAND_PARAM ) ; parameter_to_remove_after_initial_request . addAll ( parameter_to_remove_for_all_request ) ; parameter_to_remove_after_initial_request . add ( STRING ) ; parameter_to_remove_after_initial_request . add ( STRING ) ; }
@ Override public long read ( ByteBuffer buffer ) { long value = buffer . getInt ( ) ; return value ; }
@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { tryPresize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) putVal ( e . getKey ( ) , e . getValue ( ) , _BOOL ) ; }
@ Override public void putAll ( Map < ? extends K , ? extends V > m ) { tryPresize ( m . size ( ) ) ; for ( Map . Entry < ? extends K , ? extends V > e : m . entrySet ( ) ) putVal ( e . getKey ( ) , e . getValue ( ) , _BOOL ) ; }
public void sort ( ) { if ( ! sorted ) { Collections . sort ( samples ) ; sorted = _BOOL ; } }
public int fileWrite ( long handle , byte [ ] buffer , int offset , int count ) { if ( ( offset | count ) < _NUM || offset > buffer . length || buffer . length - offset < count ) { throw new ArrayIndexOutOfBoundsException ( STRING + buffer . length + STRING + offset + STRING + count ) ; } if ( count == _NUM ) { return _NUM ; } byte [ ] data = buffer ; if ( offset > _NUM ) { data = new byte [ count ] ; System . arraycopy ( buffer , offset , data , _NUM , count ) ; } IntOut bytesWrittenOut = new IntOut ( ) ; try { checkResult ( LibIMobileDevice . afc_file_write ( getRef ( ) , handle , data , count , bytesWrittenOut ) ) ; int bytesWritten = bytesWrittenOut . getValue ( ) ; return bytesWritten ; } finally { bytesWrittenOut . delete ( ) ; } }
public void writeGolomb ( int divisor , int value ) throws IOException { int q = value / divisor ; for ( int i = _NUM ; i < q ; i ++ ) { writeBit ( _BOOL , MAX_PROBABILITY / _NUM ) ; } writeBit ( _BOOL , MAX_PROBABILITY / _NUM ) ; int r = value - q * divisor ; int bit = _NUM - Integer . numberOfLeadingZeros ( divisor - _NUM ) ; if ( r < ( ( _NUM << bit ) - divisor ) ) { bit -- ; } else { r += ( _NUM << bit ) - divisor ; } for ( ; bit >= _NUM ; bit -- ) { writeBit ( ( ( r > > > bit ) & _NUM ) == _NUM , MAX_PROBABILITY / _NUM ) ; } }
void mouseDraggedInTrack ( final MouseEvent e ) { moveToMouse ( e ) ; }
public void stop ( ) throws InterruptedException { stopped = _BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socketService . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( InterruptedException e ) { logger . info ( STRING + e ) ; throw e ; } } }
public void stop ( ) throws InterruptedException { stopped = _BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socketService . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( InterruptedException e ) { logger . info ( STRING + e ) ; throw e ; } } }
public void stop ( ) throws InterruptedException { stopped = _BOOL ; if ( thd != null ) { try { logger . info ( STRING ) ; socketService . close ( ) ; thd . interrupt ( ) ; thd . join ( ) ; thd = null ; } catch ( InterruptedException e ) { logger . info ( STRING + e ) ; throw e ; } } }
public StashRowIterable ( ) { _initialIterator = createStashRowIterator ( ) ; try { _initialIterator . hasNext ( ) ; _openIterators . add ( _initialIterator ) ; } catch ( Exception e ) { try { Closeables . close ( _initialIterator , _BOOL ) ; } catch ( IOException e2 ) { } throw Throwables . propagate ( e ) ; } }
public StashRowIterable ( ) { _initialIterator = createStashRowIterator ( ) ; try { _initialIterator . hasNext ( ) ; _openIterators . add ( _initialIterator ) ; } catch ( Exception e ) { try { Closeables . close ( _initialIterator , _BOOL ) ; } catch ( IOException e2 ) { } throw Throwables . propagate ( e ) ; } }
public void addKMZWriterListener ( KMZWriterListener listener ) { writerListeners . add ( listener ) ; }
public void addKMZWriterListener ( KMZWriterListener listener ) { writerListeners . add ( listener ) ; }
public void addKMZWriterListener ( KMZWriterListener listener ) { writerListeners . add ( listener ) ; }
public static < T > List < T > toList ( T obj1 , T obj2 , T obj3 ) { List < T > list = new LinkedList < T > ( ) ; list . add ( obj1 ) ; list . add ( obj2 ) ; list . add ( obj3 ) ; return list ; }
public Date rollDate ( Date base ) { return rollDate ( base , TimeZone . getDefault ( ) ) ; }
final protected void startQuery ( final IChunkMessage < IBindingSet > msg ) { if ( ! controller ) throw new UnsupportedOperationException ( ERR_NOT_CONTROLLER ) ; if ( msg == null ) throw new IllegalArgumentException ( ) ; if ( ! queryId . equals ( msg . getQueryId ( ) ) ) throw new IllegalArgumentException ( ) ; lock . lock ( ) ; try { runState . startQuery ( msg ) ; } catch ( TimeoutException ex ) { halt ( ex ) ; } finally { lock . unlock ( ) ; } }
public boolean validateStateTransition ( ) { Log . v ( LOG_TAG , String . format ( STRING , printStates ( ) ) ) ; switch ( mTransitionDirection ) { case DO_NOTHING : Log . v ( LOG_TAG , STRING ) ; return validateNetworkStates ( ) ; case TO_CONNECTION : Log . v ( LOG_TAG , STRING ) ; return validateNetworkConnection ( ) ; case TO_DISCONNECTION : Log . v ( LOG_TAG , STRING ) ; return validateNetworkDisconnection ( ) ; default : Log . e ( LOG_TAG , STRING ) ; return _BOOL ; } }
public void addKey ( KeyCode keyCode ) { keyStrokes . add ( keyCode ) ; }
private void keepAnnotated ( Path path ) throws FileNotFoundException { for ( ClassPathElement element : path . getElements ( ) ) { forClazz : for ( String name : element . list ( ) ) { if ( name . endsWith ( CLASS_EXTENSION ) ) { DirectClassFile clazz = path . getClass ( name ) ; if ( hasRuntimeVisibleAnnotation ( clazz ) ) { filesToKeep . add ( name ) ; } else { MethodList methods = clazz . getMethods ( ) ; for ( int i = _NUM ; i < methods . size ( ) ; i ++ ) { if ( hasRuntimeVisibleAnnotation ( methods . get ( i ) ) ) { filesToKeep . add ( name ) ; continue forClazz ; } } FieldList fields = clazz . getFields ( ) ; for ( int i = _NUM ; i < fields . size ( ) ; i ++ ) { if ( hasRuntimeVisibleAnnotation ( fields . get ( i ) ) ) { filesToKeep . add ( name ) ; continue forClazz ; } } } } } } }
protected List < EvaluationStatistics > filter ( List < EvaluationStatistics > stats ) { Instances data ; Instances filtered ; Filter filter ; try { data = toInstances ( stats ) ; filter = Filter . makeCopy ( m_Filter ) ; filter . setInputFormat ( data ) ; filtered = Filter . useFilter ( data , filter ) ; stats = fromInstances ( filtered ) ; } catch ( Exception e ) { handleException ( STRING , e ) ; } return stats ; }
public JKNamespace ( final String url , final String prefix ) { logger . info ( String . format ( STRING , url , prefix ) ) ; this . url = url ; this . prefix = prefix ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public void prepReadPane ( boolean onlyChanges ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , onlyChanges ) ; } justChanges = onlyChanges ; if ( isCvTablePane ) { setCvListFromTable ( ) ; } enableButtons ( _BOOL ) ; if ( justChanges == _BOOL ) { readChangesButton . setEnabled ( _BOOL ) ; readChangesButton . setSelected ( _BOOL ) ; } else { readAllButton . setSelected ( _BOOL ) ; readAllButton . setEnabled ( _BOOL ) ; } if ( container . isBusy ( ) == _BOOL ) { container . enableButtons ( _BOOL ) ; } setToRead ( justChanges , _BOOL ) ; varListIndex = _NUM ; cvListIterator = cvList . iterator ( ) ; indexedCvListIndex = _NUM ; }
public static void cleanUpCustomTempDirectories ( ) { if ( tempDirectoryList != null ) { log . info ( STRING ) ; try { for ( File tempFile : tempDirectoryList ) if ( tempFile . exists ( ) ) { log . info ( STRING + tempFile . getCanonicalPath ( ) ) ; deleteDirectory ( tempFile ) ; } tempDirectoryList . clear ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } else log . info ( STRING ) ; log . info ( STRING ) ; }
public void clearAllWatchers ( ) { synchronized ( watchers ) { watchers . clear ( ) ; } }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } mDrawingArea . addInfinite ( ) ; mPrintMetrics . drawImage ( this , img ) ; return mGraphics . drawImage ( img , xform , obs ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } mDrawingArea . addInfinite ( ) ; mPrintMetrics . drawImage ( this , img ) ; return mGraphics . drawImage ( img , xform , obs ) ; }
public boolean drawImage ( Image img , AffineTransform xform , ImageObserver obs ) { if ( img == null ) { return _BOOL ; } mDrawingArea . addInfinite ( ) ; mPrintMetrics . drawImage ( this , img ) ; return mGraphics . drawImage ( img , xform , obs ) ; }
private static void drawChunk ( Image image , Graphics g , boolean stretch , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , boolean xDirection ) { if ( dx2 - dx1 <= _NUM || dy2 - dy1 <= _NUM || sx2 - sx1 <= _NUM || sy2 - sy1 <= _NUM ) { return ; } if ( stretch ) { g . drawImage ( image , dx1 , dy1 , dx2 , dy2 , sx1 , sy1 , sx2 , sy2 , null ) ; } else { int xSize = sx2 - sx1 ; int ySize = sy2 - sy1 ; int deltaX ; int deltaY ; if ( xDirection ) { deltaX = xSize ; deltaY = _NUM ; } else { deltaX = _NUM ; deltaY = ySize ; } while ( dx1 < dx2 && dy1 < dy2 ) { int newDX2 = Math . min ( dx2 , dx1 + xSize ) ; int newDY2 = Math . min ( dy2 , dy1 + ySize ) ; g . drawImage ( image , dx1 , dy1 , newDX2 , newDY2 , sx1 , sy1 , sx1 + newDX2 - dx1 , sy1 + newDY2 - dy1 , null ) ; dx1 += deltaX ; dy1 += deltaY ; } } }
public ByteColumn ( int nrows , int capacity , byte defaultValue ) { super ( byte . class , new Byte ( defaultValue ) ) ; if ( capacity < nrows ) { throw new IllegalArgumentException ( STRING ) ; } m_values = new byte [ capacity ] ; Arrays . fill ( m_values , defaultValue ) ; m_size = nrows ; }
public void printMap ( HashMap < String , HashMap < String , HashSet < Integer > > > map ) { map . forEach ( null ) ; }
public void printMap ( HashMap < String , HashMap < String , HashSet < Integer > > > map ) { map . forEach ( null ) ; }
public void testSubmitCallable ( ) throws Throwable { ExecutorService e = new ForkJoinPool ( _NUM ) ; PoolCleaner cleaner = null ; try { cleaner = cleaner ( e ) ; Future < String > future = e . submit ( new StringTask ( ) ) ; assertSame ( TEST_STRING , future . get ( ) ) ; assertTrue ( future . isDone ( ) ) ; assertFalse ( future . isCancelled ( ) ) ; } finally { if ( cleaner != null ) { cleaner . close ( ) ; } } }
public void writeHeader ( ) { ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; ps . println ( STRING ) ; }
public SparseIntegerVector ( TIntDoubleMap values , int dimensionality ) throws IllegalArgumentException { if ( values . size ( ) > dimensionality ) { throw new IllegalArgumentException ( STRING ) ; } this . indexes = new int [ values . size ( ) ] ; this . values = new int [ values . size ( ) ] ; { TIntDoubleIterator iter = values . iterator ( ) ; for ( int i = _NUM ; iter . hasNext ( ) ; i ++ ) { iter . advance ( ) ; this . indexes [ i ] = iter . key ( ) ; } Arrays . sort ( this . indexes ) ; } { for ( int i = _NUM ; i < values . size ( ) ; i ++ ) { this . values [ i ] = ( int ) values . get ( this . indexes [ i ] ) ; } } this . dimensionality = dimensionality ; final int maxdim = getMaxDim ( ) ; if ( maxdim > dimensionality ) { throw new IllegalArgumentException ( STRING + dimensionality + STRING + maxdim + STRING ) ; } }
public static void createDir ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new AdeUsageException ( STRING + target . getPath ( ) ) ; } }
public static void createDir ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdir ( ) ) { throw new AdeUsageException ( STRING + target . getPath ( ) ) ; } }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
public void mark ( int readlimit ) { in . mark ( readlimit ) ; if ( in . markSupported ( ) ) bytesLeftAtMark = bytesLeft ; }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STRING ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < _NUM ) { byte [ ] newByteString = new byte [ _NUM ] ; for ( int i = _NUM ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = _NUM ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STRING ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < _NUM ) { byte [ ] newByteString = new byte [ _NUM ] ; for ( int i = _NUM ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = _NUM ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STRING ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < _NUM ) { byte [ ] newByteString = new byte [ _NUM ] ; for ( int i = _NUM ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = _NUM ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STRING ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < _NUM ) { byte [ ] newByteString = new byte [ _NUM ] ; for ( int i = _NUM ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = _NUM ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
protected static Long convertStringToBuckectingLong ( String stringToBeConverted ) { if ( stringToBeConverted == null || stringToBeConverted . equals ( STRING ) ) { return null ; } byte [ ] byteString = stringToBeConverted . getBytes ( ) ; if ( byteString . length < _NUM ) { byte [ ] newByteString = new byte [ _NUM ] ; for ( int i = _NUM ; i < newByteString . length ; i ++ ) { if ( i < byteString . length ) { newByteString [ i ] = byteString [ i ] ; } else { newByteString [ i ] = _NUM ; } } byteString = newByteString ; } ByteBuffer bb = ByteBuffer . wrap ( byteString ) ; long byteMethod = bb . getLong ( ) ; byteMethod = Math . abs ( byteMethod ) ; return byteMethod ; }
public Event doWaitTimeout ( long timeout ) { Event e = null ; long towait = _NUM ; long endtime = - _NUM ; boolean usetimeout = ( timeout > _NUM ) ; if ( usetimeout ) { endtime = System . nanoTime ( ) + timeout * _NUM * _NUM ; } if ( networkThread . getDone ( ) ) return null ; while ( e == null ) { if ( usetimeout ) { towait = ( endtime - System . nanoTime ( ) ) ; if ( towait <= _NUM ) { break ; } } else { if ( timeout == _NUM ) { return latestEvents . poll ( ) ; } } try { if ( usetimeout ) { e = latestEvents . poll ( towait , TimeUnit . NANOSECONDS ) ; } else { e = latestEvents . take ( ) ; } } catch ( InterruptedException e1 ) { } if ( e != null && e . t == EType . KILLSENDER ) { return null ; } if ( networkThread . getDone ( ) ) return null ; } return e ; }
public void initStructure ( ) throws Exception { int nAttribute = _NUM ; for ( int iOrder = _NUM ; iOrder < m_Instances . numAttributes ( ) ; iOrder ++ ) { if ( nAttribute == m_Instances . classIndex ( ) ) { nAttribute ++ ; } } m_ParentSets = new ParentSet [ m_Instances . numAttributes ( ) ] ; for ( int iAttribute = _NUM ; iAttribute < m_Instances . numAttributes ( ) ; iAttribute ++ ) { m_ParentSets [ iAttribute ] = new ParentSet ( m_Instances . numAttributes ( ) ) ; } }
public ProjectAssociation ( ) { super ( _NUM , _NUM ) ; }
private double parseDouble ( String value , String setting ) { double number ; int multiplier = getMultiplier ( value ) ; if ( multiplier > _NUM ) { value = value . replaceAll ( STRING , STRING ) ; } try { number = Double . parseDouble ( value ) * multiplier ; } catch ( NumberFormatException e ) { throw new SettingsError ( STRING + value + STRING + setting + STRING + e . getMessage ( ) ) ; } return number ; }
private void sendBuffer ( ) throws IOException { buf . flip ( ) ; send ( buf , buf . remaining ( ) ) ; buf = null ; }
private void refreshDirectory ( ) { if ( mSelectedDir != null ) { changeDirectory ( mSelectedDir ) ; } }
private void refreshDirectory ( ) { if ( mSelectedDir != null ) { changeDirectory ( mSelectedDir ) ; } }
public static void banner ( Logger logger , Class < ? > clazz , String methodName , String text ) { String string = clazz . getSimpleName ( ) + STRING + methodName ; if ( text != null ) { string += STRING + text ; } logger . info ( STRING ) ; logger . info ( STRING ) ; logger . info ( STRING + string ) ; logger . info ( STRING ) ; }
public static void banner ( Logger logger , Class < ? > clazz , String methodName , String text ) { String string = clazz . getSimpleName ( ) + STRING + methodName ; if ( text != null ) { string += STRING + text ; } logger . info ( STRING ) ; logger . info ( STRING ) ; logger . info ( STRING + string ) ; logger . info ( STRING ) ; }
public static boolean isVolatile ( int mod ) { return Modifier . isVolatile ( mod ) ; }
public static boolean isVolatile ( int mod ) { return Modifier . isVolatile ( mod ) ; }
MutableAttributeSet currentTextAttributes ( ) { MutableAttributeSet attributes = new SimpleAttributeSet ( characterAttributes ) ; Integer fontnum ; Integer stateItem ; fontnum = ( Integer ) parserState . get ( STRING ) ; String fontFamily ; if ( fontnum != null ) fontFamily = fontTable . get ( fontnum ) ; else fontFamily = null ; if ( fontFamily != null ) StyleConstants . setFontFamily ( attributes , fontFamily ) ; else attributes . removeAttribute ( StyleConstants . FontFamily ) ; if ( colorTable != null ) { stateItem = ( Integer ) parserState . get ( STRING ) ; if ( stateItem != null ) { Color fg = colorTable [ stateItem . intValue ( ) ] ; StyleConstants . setForeground ( attributes , fg ) ; } else { attributes . removeAttribute ( StyleConstants . Foreground ) ; } } if ( colorTable != null ) { stateItem = ( Integer ) parserState . get ( STRING ) ; if ( stateItem != null ) { Color bg = colorTable [ stateItem . intValue ( ) ] ; attributes . addAttribute ( StyleConstants . Background , bg ) ; } else { attributes . removeAttribute ( StyleConstants . Background ) ; } } Style characterStyle = ( Style ) parserState . get ( STRING ) ; if ( characterStyle != null ) attributes . setResolveParent ( characterStyle ) ; return attributes ; }
MutableAttributeSet currentTextAttributes ( ) { MutableAttributeSet attributes = new SimpleAttributeSet ( characterAttributes ) ; Integer fontnum ; Integer stateItem ; fontnum = ( Integer ) parserState . get ( STRING ) ; String fontFamily ; if ( fontnum != null ) fontFamily = fontTable . get ( fontnum ) ; else fontFamily = null ; if ( fontFamily != null ) StyleConstants . setFontFamily ( attributes , fontFamily ) ; else attributes . removeAttribute ( StyleConstants . FontFamily ) ; if ( colorTable != null ) { stateItem = ( Integer ) parserState . get ( STRING ) ; if ( stateItem != null ) { Color fg = colorTable [ stateItem . intValue ( ) ] ; StyleConstants . setForeground ( attributes , fg ) ; } else { attributes . removeAttribute ( StyleConstants . Foreground ) ; } } if ( colorTable != null ) { stateItem = ( Integer ) parserState . get ( STRING ) ; if ( stateItem != null ) { Color bg = colorTable [ stateItem . intValue ( ) ] ; attributes . addAttribute ( StyleConstants . Background , bg ) ; } else { attributes . removeAttribute ( StyleConstants . Background ) ; } } Style characterStyle = ( Style ) parserState . get ( STRING ) ; if ( characterStyle != null ) attributes . setResolveParent ( characterStyle ) ; return attributes ; }
public void addGenerator ( Distribution gen ) { if ( trans != null ) { throw new AbortException ( STRING ) ; } axes . add ( gen ) ; dim ++ ; }
public void addGenerator ( Distribution gen ) { if ( trans != null ) { throw new AbortException ( STRING ) ; } axes . add ( gen ) ; dim ++ ; }
public void addPermission ( PermissionType permission ) { addedPermissions . add ( permission ) ; }
private void loadProfile ( String userId , String name ) { final Intent userProfileIntent = new Intent ( getActivity ( ) , UserProfileActivity . class ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_ID , userId ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_NAME , name ) ; userProfileIntent . putExtra ( AppConstants . Keys . SERVICE_SCREEN_TYPE , AppConstants . ServiceScreenType . PROFILE ) ; startActivity ( userProfileIntent ) ; }
private void loadProfile ( String userId , String name ) { final Intent userProfileIntent = new Intent ( getActivity ( ) , UserProfileActivity . class ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_ID , userId ) ; userProfileIntent . putExtra ( AppConstants . Keys . USER_NAME , name ) ; userProfileIntent . putExtra ( AppConstants . Keys . SERVICE_SCREEN_TYPE , AppConstants . ServiceScreenType . PROFILE ) ; startActivity ( userProfileIntent ) ; }
static public UniqueString resolveSynonym ( UniqueString name ) { Operator n = ( Operator ) DefinitionTable . get ( name ) ; if ( n == null ) return name ; else return n . getIdentifier ( ) ; }
public boolean isRunning ( ) { if ( process == null ) { return _BOOL ; } try { process . exitValue ( ) ; return _BOOL ; } catch ( IllegalThreadStateException e ) { } return _BOOL ; }
public void run ( ) { try { while ( _BOOL ) { Reference ref = queue . remove ( ) ; ref . clear ( ) ; synchronized ( refs ) { refs . remove ( ref ) ; if ( refs . isEmpty ( ) ) { reaper = null ; return ; } } } } catch ( InterruptedException e ) { } }
public void run ( ) { try { while ( _BOOL ) { Reference ref = queue . remove ( ) ; ref . clear ( ) ; synchronized ( refs ) { refs . remove ( ref ) ; if ( refs . isEmpty ( ) ) { reaper = null ; return ; } } } } catch ( InterruptedException e ) { } }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
private void write ( char [ ] plain ) throws Exception { buffer . write ( result ) ; buffer . clear ( ) ; result . write ( plain ) ; }
public boolean isSatisfiedBy ( final Date date ) { final Calendar testDateCal = Calendar . getInstance ( getTimeZone ( ) ) ; testDateCal . setTime ( date ) ; testDateCal . set ( Calendar . MILLISECOND , _NUM ) ; final Date originalDate = testDateCal . getTime ( ) ; testDateCal . add ( Calendar . SECOND , - _NUM ) ; final Date timeAfter = getTimeAfter ( testDateCal . getTime ( ) ) ; return timeAfter != null && timeAfter . equals ( originalDate ) ; }
public boolean isSatisfiedBy ( final Date date ) { final Calendar testDateCal = Calendar . getInstance ( getTimeZone ( ) ) ; testDateCal . setTime ( date ) ; testDateCal . set ( Calendar . MILLISECOND , _NUM ) ; final Date originalDate = testDateCal . getTime ( ) ; testDateCal . add ( Calendar . SECOND , - _NUM ) ; final Date timeAfter = getTimeAfter ( testDateCal . getTime ( ) ) ; return timeAfter != null && timeAfter . equals ( originalDate ) ; }
public boolean isSatisfiedBy ( final Date date ) { final Calendar testDateCal = Calendar . getInstance ( getTimeZone ( ) ) ; testDateCal . setTime ( date ) ; testDateCal . set ( Calendar . MILLISECOND , _NUM ) ; final Date originalDate = testDateCal . getTime ( ) ; testDateCal . add ( Calendar . SECOND , - _NUM ) ; final Date timeAfter = getTimeAfter ( testDateCal . getTime ( ) ) ; return timeAfter != null && timeAfter . equals ( originalDate ) ; }
public boolean isSatisfiedBy ( final Date date ) { final Calendar testDateCal = Calendar . getInstance ( getTimeZone ( ) ) ; testDateCal . setTime ( date ) ; testDateCal . set ( Calendar . MILLISECOND , _NUM ) ; final Date originalDate = testDateCal . getTime ( ) ; testDateCal . add ( Calendar . SECOND , - _NUM ) ; final Date timeAfter = getTimeAfter ( testDateCal . getTime ( ) ) ; return timeAfter != null && timeAfter . equals ( originalDate ) ; }
public static void cleanupDir ( String dirPath , List < String > childdirs ) throws IOException { if ( childdirs == null || childdirs . size ( ) == _NUM ) FileUtils . cleanDirectory ( new File ( dirPath ) ) ; else { for ( String cdir : childdirs ) FileUtils . cleanDirectory ( new File ( dirPath + STRING + cdir ) ) ; } }
public void printStackTrace ( PrintWriter pw ) { pw . println ( fetchStackTrace ( ) ) ; }
public void printStackTrace ( PrintWriter pw ) { pw . println ( fetchStackTrace ( ) ) ; }
public void printStackTrace ( PrintWriter pw ) { pw . println ( fetchStackTrace ( ) ) ; }
public void add ( OnClickWrapper onClickWrapper ) { onClickWrapperList . add ( onClickWrapper ) ; }
public void add ( OnClickWrapper onClickWrapper ) { onClickWrapperList . add ( onClickWrapper ) ; }
public void add ( OnClickWrapper onClickWrapper ) { onClickWrapperList . add ( onClickWrapper ) ; }
public AbstractRequest ( OneDriveAPI api , URL url , String method ) { this . api = api ; this . url = Objects . requireNonNull ( url ) ; this . method = Objects . requireNonNull ( method ) ; this . headers = new ArrayList < > ( ) ; addHeader ( STRING , STRING ) ; addHeader ( STRING , STRING ) ; }
public AbstractRequest ( OneDriveAPI api , URL url , String method ) { this . api = api ; this . url = Objects . requireNonNull ( url ) ; this . method = Objects . requireNonNull ( method ) ; this . headers = new ArrayList < > ( ) ; addHeader ( STRING , STRING ) ; addHeader ( STRING , STRING ) ; }
public AbstractRequest ( OneDriveAPI api , URL url , String method ) { this . api = api ; this . url = Objects . requireNonNull ( url ) ; this . method = Objects . requireNonNull ( method ) ; this . headers = new ArrayList < > ( ) ; addHeader ( STRING , STRING ) ; addHeader ( STRING , STRING ) ; }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } }
@ Override public void close ( ) throws IOException { synchronized ( lock ) { if ( ! isClosed ( ) ) { in . close ( ) ; buf = null ; } } }
public CDebuggerHistorySynchronizer ( final CDebugPerspectiveModel model , final JTextPane area ) { m_model = model ; m_area = area ; m_area . setEnabled ( _BOOL ) ; model . addListener ( m_perspectiveListener ) ; m_historyStringBuilder . addListener ( m_builderListener ) ; }
Double nmeaLonToDecimal ( String nmea ) throws NumberFormatException { int deg = Integer . parseInt ( nmea . substring ( _NUM , _NUM ) ) ; Double min = Double . parseDouble ( nmea . substring ( _NUM ) ) ; return deg + min / _NUM ; }
Double nmeaLonToDecimal ( String nmea ) throws NumberFormatException { int deg = Integer . parseInt ( nmea . substring ( _NUM , _NUM ) ) ; Double min = Double . parseDouble ( nmea . substring ( _NUM ) ) ; return deg + min / _NUM ; }
@ RpcMethod public void finalizeImage ( String imageId , String datastore , String tmpImagePath , AsyncMethodCallback < Host . AsyncClient . finalize_image_call > handler ) throws RpcException { ensureClient ( ) ; FinalizeImageRequest finalizeImageRequest = new FinalizeImageRequest ( ) ; finalizeImageRequest . setImage_id ( imageId ) ; finalizeImageRequest . setDatastore ( datastore ) ; finalizeImageRequest . setTmp_image_path ( tmpImagePath ) ; clientProxy . setTimeout ( FINALIZE_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , finalizeImageRequest ) ; try { clientProxy . finalize_image ( finalizeImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void finalizeImage ( String imageId , String datastore , String tmpImagePath , AsyncMethodCallback < Host . AsyncClient . finalize_image_call > handler ) throws RpcException { ensureClient ( ) ; FinalizeImageRequest finalizeImageRequest = new FinalizeImageRequest ( ) ; finalizeImageRequest . setImage_id ( imageId ) ; finalizeImageRequest . setDatastore ( datastore ) ; finalizeImageRequest . setTmp_image_path ( tmpImagePath ) ; clientProxy . setTimeout ( FINALIZE_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , finalizeImageRequest ) ; try { clientProxy . finalize_image ( finalizeImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void finalizeImage ( String imageId , String datastore , String tmpImagePath , AsyncMethodCallback < Host . AsyncClient . finalize_image_call > handler ) throws RpcException { ensureClient ( ) ; FinalizeImageRequest finalizeImageRequest = new FinalizeImageRequest ( ) ; finalizeImageRequest . setImage_id ( imageId ) ; finalizeImageRequest . setDatastore ( datastore ) ; finalizeImageRequest . setTmp_image_path ( tmpImagePath ) ; clientProxy . setTimeout ( FINALIZE_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , finalizeImageRequest ) ; try { clientProxy . finalize_image ( finalizeImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void finalizeImage ( String imageId , String datastore , String tmpImagePath , AsyncMethodCallback < Host . AsyncClient . finalize_image_call > handler ) throws RpcException { ensureClient ( ) ; FinalizeImageRequest finalizeImageRequest = new FinalizeImageRequest ( ) ; finalizeImageRequest . setImage_id ( imageId ) ; finalizeImageRequest . setDatastore ( datastore ) ; finalizeImageRequest . setTmp_image_path ( tmpImagePath ) ; clientProxy . setTimeout ( FINALIZE_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , finalizeImageRequest ) ; try { clientProxy . finalize_image ( finalizeImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
@ RpcMethod public void finalizeImage ( String imageId , String datastore , String tmpImagePath , AsyncMethodCallback < Host . AsyncClient . finalize_image_call > handler ) throws RpcException { ensureClient ( ) ; FinalizeImageRequest finalizeImageRequest = new FinalizeImageRequest ( ) ; finalizeImageRequest . setImage_id ( imageId ) ; finalizeImageRequest . setDatastore ( datastore ) ; finalizeImageRequest . setTmp_image_path ( tmpImagePath ) ; clientProxy . setTimeout ( FINALIZE_IMAGE_TIMEOUT_MS ) ; logger . info ( STRING , getHostIp ( ) , finalizeImageRequest ) ; try { clientProxy . finalize_image ( finalizeImageRequest , handler ) ; } catch ( TException e ) { throw new RpcException ( e . getMessage ( ) ) ; } }
private Point addPoint ( Polygon arrow , Rectangle rect , int pos , boolean from ) { int x = rect . x ; int y = rect . y ; Point point = null ; if ( pos == SwingConstants . TOP ) { x += rect . width / _NUM ; if ( from ) { arrow . addPoint ( x - _NUM , y ) ; arrow . addPoint ( x + _NUM , y ) ; } else arrow . addPoint ( x , y ) ; point = new Point ( x , y - _NUM ) ; } else if ( pos == SwingConstants . RIGHT ) { x += rect . width ; y += rect . height / _NUM ; if ( from ) { arrow . addPoint ( x , y - _NUM ) ; arrow . addPoint ( x , y + _NUM ) ; } else arrow . addPoint ( x , y ) ; point = new Point ( x + _NUM , y ) ; } else if ( pos == SwingConstants . LEFT ) { y += rect . height / _NUM ; if ( from ) { arrow . addPoint ( x , y - _NUM ) ; arrow . addPoint ( x , y + _NUM ) ; } else arrow . addPoint ( x , y ) ; point = new Point ( x - _NUM , y ) ; } else { x += rect . width / _NUM ; y += rect . height ; if ( from ) { arrow . addPoint ( x - _NUM , y ) ; arrow . addPoint ( x + _NUM , y ) ; } else arrow . addPoint ( x , y ) ; point = new Point ( x , y + _NUM ) ; } return point ; }
public void addMembers ( String universalId , Set names ) throws AMConsoleException { if ( ( names == null ) || names . isEmpty ( ) ) { throw new AMConsoleException ( STRING ) ; } SSOToken ssoToken = getUserSSOToken ( ) ; String currentId = STRING ; try { AMIdentity amid = IdUtils . getIdentity ( ssoToken , universalId ) ; String [ ] params = new String [ _NUM ] ; params [ _NUM ] = universalId ; for ( Iterator iter = names . iterator ( ) ; iter . hasNext ( ) ; ) { String id = ( String ) iter . next ( ) ; AMIdentity amidentity = IdUtils . getIdentity ( ssoToken , id ) ; currentId = id ; params [ _NUM ] = id ; logEvent ( STRING , params ) ; amid . addMember ( amidentity ) ; logEvent ( STRING , params ) ; } } catch ( SSOException e ) { String [ ] paramsEx = { universalId , currentId , getErrorString ( e ) } ; logEvent ( STRING , paramsEx ) ; debug . warning ( STRING , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } catch ( IdRepoException e ) { String [ ] paramsEx = { universalId , currentId , getErrorString ( e ) } ; logEvent ( STRING , paramsEx ) ; debug . warning ( STRING , e ) ; throw new AMConsoleException ( getErrorString ( e ) ) ; } }
public boolean resetUnreadCounts ( int aSection ) { boolean retCode = _BOOL ; ArrayList < RoomSummary > summariesList = mSummaryListByGroupPosition . get ( aSection ) ; if ( null != summariesList ) { for ( int summaryIdx = _NUM ; summaryIdx < summariesList . size ( ) ; summaryIdx ++ ) { retCode |= resetUnreadCount ( aSection , summaryIdx ) ; } } else { Log . w ( DBG_CLASS_NAME , STRING + aSection + STRING ) ; } return retCode ; }
public boolean resetUnreadCounts ( int aSection ) { boolean retCode = _BOOL ; ArrayList < RoomSummary > summariesList = mSummaryListByGroupPosition . get ( aSection ) ; if ( null != summariesList ) { for ( int summaryIdx = _NUM ; summaryIdx < summariesList . size ( ) ; summaryIdx ++ ) { retCode |= resetUnreadCount ( aSection , summaryIdx ) ; } } else { Log . w ( DBG_CLASS_NAME , STRING + aSection + STRING ) ; } return retCode ; }
@ Override public void eventHappened ( MapEvent event ) { if ( event . getType ( ) == MapEvent . Type . MAP_CLEARED || event . getType ( ) == MapEvent . Type . MAP_NEW ) { entityFinder = null ; updateResults ( _BOOL ) ; } }
@ Override public void restoreSnapshot ( BlockSnapshot snapshot , Volume parentVolume , String syncDirection , String taskId ) { BlockOrchestrationController controller = getController ( BlockOrchestrationController . class , BlockOrchestrationController . BLOCK_ORCHESTRATION_DEVICE ) ; controller . restoreVolume ( snapshot . getStorageController ( ) , parentVolume . getPool ( ) , parentVolume . getId ( ) , snapshot . getId ( ) , syncDirection , taskId ) ; }
public static long periodEnd ( long now , long period ) { LocalDateTime time = LocalDateTime . ofEpochSecond ( now / _NUM , _NUM , ZoneOffset . UTC ) ; long endTime = periodEnd ( now , period , time ) ; return endTime ; }
public static Vec meanVector ( DataSet dataSet ) { DenseVector dv = new DenseVector ( dataSet . getNumNumericalVars ( ) ) ; meanVector ( dv , dataSet ) ; return dv ; }
public CommandLineFiles ( String listFileFlag , String singleInputFlag , FileConstraint ... constraints ) { this ( listFileFlag , singleInputFlag ) ; mConstraints . addAll ( Arrays . asList ( constraints ) ) ; }
private static Paint darkerLinearGradientPaint ( LinearGradientPaint paint ) { final Color [ ] paintColors = paint . getColors ( ) ; for ( int i = _NUM ; i < paintColors . length ; i ++ ) { paintColors [ i ] = darker ( paintColors [ i ] ) ; } return new LinearGradientPaint ( paint . getStartPoint ( ) , paint . getEndPoint ( ) , paint . getFractions ( ) , paintColors , paint . getCycleMethod ( ) , paint . getColorSpace ( ) , paint . getTransform ( ) ) ; }
ParseResult ( Throwable throwable ) { this ( Optional . empty ( ) , singletonList ( new Problem ( throwable . getMessage ( ) , Optional . empty ( ) , Optional . of ( throwable ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
ParseResult ( Throwable throwable ) { this ( Optional . empty ( ) , singletonList ( new Problem ( throwable . getMessage ( ) , Optional . empty ( ) , Optional . of ( throwable ) ) ) , Optional . empty ( ) , Optional . empty ( ) ) ; }
Log createLogFromClassName ( String classLabel ) throws Exception { Class < ? > clazz = Class . forName ( logClassName ) ; @ SuppressWarnings ( STRING ) Constructor < Log > constructor = ( Constructor < Log > ) clazz . getConstructor ( String . class ) ; return constructor . newInstance ( classLabel ) ; }
Log createLogFromClassName ( String classLabel ) throws Exception { Class < ? > clazz = Class . forName ( logClassName ) ; @ SuppressWarnings ( STRING ) Constructor < Log > constructor = ( Constructor < Log > ) clazz . getConstructor ( String . class ) ; return constructor . newInstance ( classLabel ) ; }
public static String toString ( ByteBuffer bb ) { return bb == null ? null : toString ( bb . array ( ) , bb . arrayOffset ( ) + bb . position ( ) , bb . remaining ( ) ) ; }
public static String toString ( ByteBuffer bb ) { return bb == null ? null : toString ( bb . array ( ) , bb . arrayOffset ( ) + bb . position ( ) , bb . remaining ( ) ) ; }
protected boolean isValidDefaultValue ( String defaultSpec , int typeCode ) { return ( defaultSpec != null ) && ( ( defaultSpec . length ( ) > _NUM ) || ( ! TypeMap . isNumericType ( typeCode ) && ! TypeMap . isDateTimeType ( typeCode ) ) ) ; }
protected boolean isValidDefaultValue ( String defaultSpec , int typeCode ) { return ( defaultSpec != null ) && ( ( defaultSpec . length ( ) > _NUM ) || ( ! TypeMap . isNumericType ( typeCode ) && ! TypeMap . isDateTimeType ( typeCode ) ) ) ; }
private String schema ( @ Nullable String space ) { return emptyIfNull ( space2schema . get ( emptyIfNull ( space ) ) ) ; }
private static int detectTexturePackFormat ( File zipfile ) throws IOException { ZipInputStream zis = null ; try { zis = new ZipInputStream ( new FileInputStream ( zipfile ) ) ; boolean foundAssetsDir = _BOOL ; boolean foundBlocksDir = _BOOL ; boolean foundTerrainPng = _BOOL ; ZipEntry entry = null ; while ( ( entry = zis . getNextEntry ( ) ) != null ) { String entryName = entry . getName ( ) ; if ( entryName . startsWith ( STRING ) ) foundAssetsDir = _BOOL ; else if ( entryName . startsWith ( STRING ) ) foundBlocksDir = _BOOL ; else if ( entryName . equals ( STRING ) ) foundTerrainPng = _BOOL ; } return foundAssetsDir ? FORMAT_1_6 : foundBlocksDir ? FORMAT_1_5 : foundTerrainPng ? FORMAT_PRE_1_5 : FORMAT_INVALID ; } finally { if ( zis != null ) zis . close ( ) ; } }
public static boolean hasElementChild ( Node node ) { NodeList nl = node . getChildNodes ( ) ; Node child = null ; int length = nl . getLength ( ) ; for ( int i = _NUM ; i < length ; i ++ ) { child = nl . item ( i ) ; if ( child . getNodeType ( ) == Node . ELEMENT_NODE ) { return _BOOL ; } } return _BOOL ; }
public static ReactiveSeq < Integer > range ( final int start , final int end ) { final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator ( start , end , _BOOL ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( range , _BOOL ) , Optional . ofNullable ( range ) ) ; }
public static ReactiveSeq < Integer > range ( final int start , final int end ) { final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator ( start , end , _BOOL ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( range , _BOOL ) , Optional . ofNullable ( range ) ) ; }
public static ReactiveSeq < Integer > range ( final int start , final int end ) { final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator ( start , end , _BOOL ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( range , _BOOL ) , Optional . ofNullable ( range ) ) ; }
public static ReactiveSeq < Integer > range ( final int start , final int end ) { final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator ( start , end , _BOOL ) ; return StreamUtils . reactiveSeq ( StreamSupport . stream ( range , _BOOL ) , Optional . ofNullable ( range ) ) ; }
public void removeAllINarcPods ( ) { iNarcPods . clear ( ) ; }
public static int hash ( String key , int bitSize , String input , String hashType ) { int bitLimitedHash ; try { MessageDigest md = MessageDigest . getInstance ( hashType ) ; byte [ ] array = md . digest ( input . getBytes ( ) ) ; int hashInt = fromByteArray ( array ) ; bitLimitedHash = hashInt ; if ( bitSize < _NUM ) { bitLimitedHash = ( _NUM > > > ( _NUM - bitSize ) ) & hashInt ; } logger . debug ( STRING + hashInt + STRING + bitLimitedHash ) ; } catch ( NoSuchAlgorithmException e ) { logger . info ( e . toString ( ) ) ; bitLimitedHash = hash ( key , bitSize , input ) ; } return bitLimitedHash ; }
public boolean addAgent ( IMovingAgent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof FoodSource ) { foodSources . add ( ( FoodSource ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . getSphereRadius ( ) ; if ( r > maxAgentSphereRadius ) maxAgentSphereRadius = r ; return _BOOL ; } return _BOOL ; }
public boolean addAgent ( IMovingAgent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof FoodSource ) { foodSources . add ( ( FoodSource ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . getSphereRadius ( ) ; if ( r > maxAgentSphereRadius ) maxAgentSphereRadius = r ; return _BOOL ; } return _BOOL ; }
public boolean addAgent ( IMovingAgent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof FoodSource ) { foodSources . add ( ( FoodSource ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . getSphereRadius ( ) ; if ( r > maxAgentSphereRadius ) maxAgentSphereRadius = r ; return _BOOL ; } return _BOOL ; }
public boolean addAgent ( IMovingAgent agent ) { if ( ! agents . contains ( agent ) ) { agents . add ( agent ) ; if ( agent instanceof Hive ) { hives . add ( ( Hive ) agent ) ; } if ( agent instanceof FoodSource ) { foodSources . add ( ( FoodSource ) agent ) ; } if ( agent instanceof Obstacle ) obstacles . add ( ( Obstacle ) agent ) ; double r = agent . getSphereRadius ( ) ; if ( r > maxAgentSphereRadius ) maxAgentSphereRadius = r ; return _BOOL ; } return _BOOL ; }
public static byte [ ] fromBitSet ( Schema schema , BitSet value ) { return value . toByteArray ( ) ; }
public static byte [ ] fromBitSet ( Schema schema , BitSet value ) { return value . toByteArray ( ) ; }
public static void leftShift ( ObjectOutputStream self , Object value ) throws IOException { self . writeObject ( value ) ; }
protected void writeProgress ( String msg ) { }
public Builder addGeneratorLoader ( GeneratorLoader gLoader ) { if ( loaders == null ) { loaders = new ArrayList < GeneratorLoader > ( ) ; } if ( gLoader != null ) { loaders . add ( gLoader ) ; } return this ; }
public Builder addGeneratorLoader ( GeneratorLoader gLoader ) { if ( loaders == null ) { loaders = new ArrayList < GeneratorLoader > ( ) ; } if ( gLoader != null ) { loaders . add ( gLoader ) ; } return this ; }
private void addFinally ( ArrayList returnList , Stmnt finallyBlock ) throws CompileError { Bytecode bc = bytecode ; int n = returnList . size ( ) ; for ( int i = _NUM ; i < n ; ++ i ) { final int [ ] ret = ( int [ ] ) returnList . get ( i ) ; int pc = ret [ _NUM ] ; bc . write16bit ( pc , bc . currentPc ( ) - pc + _NUM ) ; ReturnHook hook = new JsrHook2 ( this , ret ) ; finallyBlock . accept ( this ) ; hook . remove ( this ) ; if ( ! hasReturned ) { bc . addOpcode ( Opcode . GOTO ) ; bc . addIndex ( pc + _NUM - bc . currentPc ( ) ) ; } } }
public void testMergeOneServletWithOneMappingIntoEmptyDocument ( ) throws Exception { String srcXml = STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; List < String > servletMappings = WebXmlUtils . getServletMappings ( srcWebXml , STRING ) ; assertEquals ( _NUM , servletMappings . size ( ) ) ; assertEquals ( STRING , servletMappings . get ( _NUM ) ) ; }
public String popAndEncodeAsJs ( ) { synchronized ( this ) { int length = queue . size ( ) ; if ( length == _NUM ) { return null ; } int totalPayloadLen = _NUM ; int numMessagesToSend = _NUM ; for ( JsMessage message : queue ) { int messageSize = message . calculateEncodedLength ( ) + _NUM ; if ( numMessagesToSend > _NUM && totalPayloadLen + messageSize > MAX_PAYLOAD_SIZE && MAX_PAYLOAD_SIZE > _NUM ) { break ; } totalPayloadLen += messageSize ; numMessagesToSend += _NUM ; } boolean willSendAllMessages = numMessagesToSend == queue . size ( ) ; StringBuilder sb = new StringBuilder ( totalPayloadLen + ( willSendAllMessages ? _NUM : _NUM ) ) ; for ( int i = _NUM ; i < numMessagesToSend ; ++ i ) { JsMessage message = queue . removeFirst ( ) ; if ( willSendAllMessages && ( i + _NUM == numMessagesToSend ) ) { message . encodeAsJsMessage ( sb ) ; } else { sb . append ( STRING ) ; message . encodeAsJsMessage ( sb ) ; sb . append ( STRING ) ; } } if ( ! willSendAllMessages ) { sb . append ( STRING ) ; } for ( int i = willSendAllMessages ? _NUM : _NUM ; i < numMessagesToSend ; ++ i ) { sb . append ( STRING ) ; } String ret = sb . toString ( ) ; return ret ; } }
public ServiceCall < TranslationResult > translate ( final String text , final String modelId ) { return translate ( Collections . singletonList ( text ) , modelId ) ; }
public ServiceCall < TranslationResult > translate ( final String text , final String modelId ) { return translate ( Collections . singletonList ( text ) , modelId ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IOException { if ( len <= _NUM ) { return ; } if ( charsSinceNewline > _NUM ) { if ( cbuf [ off ] != CARRIAGE_RETURN ) { super . write ( NEWLINEC , _NUM , NEWLINEC . length ) ; charsSinceNewline = _NUM ; } else { int nonnl = countNonNewline ( cbuf , off + _NUM , len - _NUM ) ; if ( nonnl < charsSinceNewline ) { super . write ( CARRIAGE_RETURN ) ; while ( charsSinceNewline > _NUM ) { final int n = Math . min ( charsSinceNewline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , _NUM , n ) ; charsSinceNewline -= n ; } } else { charsSinceNewline = _NUM ; } } } charsSinceNewline = tailingNonNewline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IOException { if ( len <= _NUM ) { return ; } if ( charsSinceNewline > _NUM ) { if ( cbuf [ off ] != CARRIAGE_RETURN ) { super . write ( NEWLINEC , _NUM , NEWLINEC . length ) ; charsSinceNewline = _NUM ; } else { int nonnl = countNonNewline ( cbuf , off + _NUM , len - _NUM ) ; if ( nonnl < charsSinceNewline ) { super . write ( CARRIAGE_RETURN ) ; while ( charsSinceNewline > _NUM ) { final int n = Math . min ( charsSinceNewline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , _NUM , n ) ; charsSinceNewline -= n ; } } else { charsSinceNewline = _NUM ; } } } charsSinceNewline = tailingNonNewline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
@ Override public void write ( char [ ] cbuf , int off , int len ) throws IOException { if ( len <= _NUM ) { return ; } if ( charsSinceNewline > _NUM ) { if ( cbuf [ off ] != CARRIAGE_RETURN ) { super . write ( NEWLINEC , _NUM , NEWLINEC . length ) ; charsSinceNewline = _NUM ; } else { int nonnl = countNonNewline ( cbuf , off + _NUM , len - _NUM ) ; if ( nonnl < charsSinceNewline ) { super . write ( CARRIAGE_RETURN ) ; while ( charsSinceNewline > _NUM ) { final int n = Math . min ( charsSinceNewline , WHITESPACE . length ( ) ) ; super . write ( WHITESPACE , _NUM , n ) ; charsSinceNewline -= n ; } } else { charsSinceNewline = _NUM ; } } } charsSinceNewline = tailingNonNewline ( cbuf , off , len ) ; super . write ( cbuf , off , len ) ; flush ( ) ; }
protected void process ( Iterator < IPathID > csvSorted , Iterator < IPathID > dbSorted ) { IPathID db = getNext ( dbSorted ) ; String dbPath = getNameWithoutExt ( db ) ; IPathID csv = getNext ( csvSorted ) ; String csvPath = getNameWithoutExt ( csv ) ; boolean found = _BOOL ; while ( ( dbPath != null ) && ( csvPath != null ) ) { int compareResult = dbPath . compareTo ( csvPath ) ; if ( compareResult == _NUM ) { process ( csv , db . getID ( ) ) ; csv = getNext ( csvSorted ) ; csvPath = getNameWithoutExt ( csv ) ; found = _BOOL ; } else if ( compareResult < _NUM ) { db = getNext ( csvSorted ) ; dbPath = getNameWithoutExt ( db ) ; } else { if ( ! found ) { process ( csv , null ) ; } csv = getNext ( csvSorted ) ; csvPath = getNameWithoutExt ( csv ) ; found = _BOOL ; } } }
@ Override public void updateAfterDelete ( int oldNcol , Header hdr ) throws FitsException { hdr . addValue ( NAXIS1 , this . rowLen ) ; }
@ Override public void updateAfterDelete ( int oldNcol , Header hdr ) throws FitsException { hdr . addValue ( NAXIS1 , this . rowLen ) ; }
public static int convertSRGBtoLinearRGB ( int color ) { float input , output ; input = color / _NUM ; if ( input <= _NUM ) { output = input / _NUM ; } else { output = ( float ) Math . pow ( ( input + _NUM ) / _NUM , _NUM ) ; } return Math . round ( output * _NUM ) ; }
public static int convertSRGBtoLinearRGB ( int color ) { float input , output ; input = color / _NUM ; if ( input <= _NUM ) { output = input / _NUM ; } else { output = ( float ) Math . pow ( ( input + _NUM ) / _NUM , _NUM ) ; } return Math . round ( output * _NUM ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = _NUM ; int x2 = length ; int i = x2 / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = _NUM ; int x2 = length ; int i = x2 / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static final int binarySearch ( Object [ ] a , Object key , Comparator cp , int length ) { int x1 = _NUM ; int x2 = length ; int i = x2 / _NUM , c ; while ( x1 < x2 ) { c = cp . compare ( a [ i ] , key ) ; if ( c == _NUM ) { return i ; } else if ( c < _NUM ) { x1 = i + _NUM ; } else { x2 = i ; } i = x1 + ( x2 - x1 ) / _NUM ; } return - _NUM * ( i + _NUM ) ; }
public static Boolean isLockGrantor ( String serviceName ) { DLockService service = ( DLockService ) DistributedLockService . getServiceNamed ( serviceName ) ; assertNotNull ( service ) ; Boolean result = Boolean . valueOf ( service . isLockGrantor ( ) ) ; logInfo ( STRING + result ) ; return result ; }
protected void resetXML11 ( ) throws XNIException { int count = fXML11Components . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fXML11Components . get ( i ) ; c . reset ( this ) ; } }
protected void resetXML11 ( ) throws XNIException { int count = fXML11Components . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { XMLComponent c = ( XMLComponent ) fXML11Components . get ( i ) ; c . reset ( this ) ; } }
private static String padRight ( String s , int minLength ) { return String . format ( STRING + minLength + STRING , s ) ; }
private ChartSpan < Integer > calculateAllPairsShortestPath ( ) { ChartSpan < Integer > distance = new ChartSpan < > ( nodes . size ( ) - _NUM , Integer . MAX_VALUE ) ; distance . setDiagonal ( _NUM ) ; for ( Node < Value > tail : nodes ) { for ( Arc < Value > arc : tail . getOutgoingArcs ( ) ) { Node < Value > head = arc . getHead ( ) ; distance . set ( tail . id ( ) , head . id ( ) , _NUM ) ; } } int size = nodes . size ( ) ; for ( int width = _NUM ; width <= size ; width ++ ) { for ( int i = _NUM ; i < size - width ; i ++ ) { int j = i + width ; for ( int k = i + _NUM ; k < j ; k ++ ) { distance . set ( i , j , Math . min ( distance . get ( i , j ) , distance . get ( i , k ) + distance . get ( k , j ) ) ) ; } } } return distance ; }
private ChartSpan < Integer > calculateAllPairsShortestPath ( ) { ChartSpan < Integer > distance = new ChartSpan < > ( nodes . size ( ) - _NUM , Integer . MAX_VALUE ) ; distance . setDiagonal ( _NUM ) ; for ( Node < Value > tail : nodes ) { for ( Arc < Value > arc : tail . getOutgoingArcs ( ) ) { Node < Value > head = arc . getHead ( ) ; distance . set ( tail . id ( ) , head . id ( ) , _NUM ) ; } } int size = nodes . size ( ) ; for ( int width = _NUM ; width <= size ; width ++ ) { for ( int i = _NUM ; i < size - width ; i ++ ) { int j = i + width ; for ( int k = i + _NUM ; k < j ; k ++ ) { distance . set ( i , j , Math . min ( distance . get ( i , j ) , distance . get ( i , k ) + distance . get ( k , j ) ) ) ; } } } return distance ; }
private SSLEngineResult unwrap ( ) throws SSLException { if ( appBuffer == null ) { appBuffer = IoBuffer . allocate ( inNetBuffer . remaining ( ) ) ; } else { appBuffer . expand ( inNetBuffer . remaining ( ) ) ; } SSLEngineResult res ; Status status = null ; HandshakeStatus handshakeStatus = null ; do { res = sslEngine . unwrap ( inNetBuffer . buf ( ) , appBuffer . buf ( ) ) ; status = res . getStatus ( ) ; handshakeStatus = res . getHandshakeStatus ( ) ; if ( status == Status . BUFFER_OVERFLOW ) { appBuffer . capacity ( appBuffer . capacity ( ) << _NUM ) ; appBuffer . limit ( appBuffer . capacity ( ) ) ; continue ; } } while ( ( ( status == Status . OK ) || ( status == Status . BUFFER_OVERFLOW ) ) && ( ( handshakeStatus == HandshakeStatus . NOT_HANDSHAKING ) || ( handshakeStatus == HandshakeStatus . NEED_UNWRAP ) ) ) ; return res ; }
public Timer ( ) { startTime = System . currentTimeMillis ( ) ; running = _BOOL ; }
public void addListener ( SearchListener listener ) { listeners . add ( listener ) ; }
protected PanelState findNearestPanelStateFromHeight ( float desiredPanelHeight ) { PanelState closestPanelState = PanelState . CLOSED ; float smallestHeightDiff = Float . POSITIVE_INFINITY ; for ( PanelState state : PanelState . values ( ) ) { if ( ! isValidState ( state ) ) { continue ; } if ( ! isFullscreenSizePanel ( ) && state == PanelState . EXPANDED ) { continue ; } float height = getPanelHeightFromState ( state ) ; float heightDiff = Math . abs ( desiredPanelHeight - height ) ; if ( heightDiff < smallestHeightDiff ) { closestPanelState = state ; smallestHeightDiff = heightDiff ; } } return closestPanelState ; }
protected PanelState findNearestPanelStateFromHeight ( float desiredPanelHeight ) { PanelState closestPanelState = PanelState . CLOSED ; float smallestHeightDiff = Float . POSITIVE_INFINITY ; for ( PanelState state : PanelState . values ( ) ) { if ( ! isValidState ( state ) ) { continue ; } if ( ! isFullscreenSizePanel ( ) && state == PanelState . EXPANDED ) { continue ; } float height = getPanelHeightFromState ( state ) ; float heightDiff = Math . abs ( desiredPanelHeight - height ) ; if ( heightDiff < smallestHeightDiff ) { closestPanelState = state ; smallestHeightDiff = heightDiff ; } } return closestPanelState ; }
protected PanelState findNearestPanelStateFromHeight ( float desiredPanelHeight ) { PanelState closestPanelState = PanelState . CLOSED ; float smallestHeightDiff = Float . POSITIVE_INFINITY ; for ( PanelState state : PanelState . values ( ) ) { if ( ! isValidState ( state ) ) { continue ; } if ( ! isFullscreenSizePanel ( ) && state == PanelState . EXPANDED ) { continue ; } float height = getPanelHeightFromState ( state ) ; float heightDiff = Math . abs ( desiredPanelHeight - height ) ; if ( heightDiff < smallestHeightDiff ) { closestPanelState = state ; smallestHeightDiff = heightDiff ; } } return closestPanelState ; }
public static File showOpenFile ( FileDataStoreFactorySpi format , Shell parent ) { return showOpenFile ( format , null , parent ) ; }
protected void processInstance ( Instance instance ) { if ( m_currentInst < m_SampleSize ) { m_subSample [ m_currentInst ] = ( Instance ) instance . copy ( ) ; } else { double r = m_random . nextDouble ( ) ; if ( r < ( ( double ) m_SampleSize / ( double ) m_currentInst ) ) { r = m_random . nextDouble ( ) ; int replace = ( int ) ( m_SampleSize * r ) ; m_subSample [ replace ] = ( Instance ) instance . copy ( ) ; } } m_currentInst ++ ; }
protected void processInstance ( Instance instance ) { if ( m_currentInst < m_SampleSize ) { m_subSample [ m_currentInst ] = ( Instance ) instance . copy ( ) ; } else { double r = m_random . nextDouble ( ) ; if ( r < ( ( double ) m_SampleSize / ( double ) m_currentInst ) ) { r = m_random . nextDouble ( ) ; int replace = ( int ) ( m_SampleSize * r ) ; m_subSample [ replace ] = ( Instance ) instance . copy ( ) ; } } m_currentInst ++ ; }
protected void preExecute ( ) { clearFromCursor ( ) ; if ( cursor >= _NUM && cursor <= selections . size ( ) ) { ISelection selection = selectionProvider . getSelection ( ) ; selections . add ( cursor , selection ) ; } }
protected void preExecute ( ) { clearFromCursor ( ) ; if ( cursor >= _NUM && cursor <= selections . size ( ) ) { ISelection selection = selectionProvider . getSelection ( ) ; selections . add ( cursor , selection ) ; } }
public static Sail createSail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . asList ( args ) : new LinkedList < Option > ( ) ; checkArgs ( file , options ) ; if ( file != null ) { props . setProperty ( STRING , file ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } props . setProperty ( STRING , String . valueOf ( options . contains ( Option . TextIndex ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . RDR ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . Quads ) ) ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; final Sail sail = getSailProviderInstance ( props ) ; return sail ; }
public static Sail createSail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . asList ( args ) : new LinkedList < Option > ( ) ; checkArgs ( file , options ) ; if ( file != null ) { props . setProperty ( STRING , file ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } props . setProperty ( STRING , String . valueOf ( options . contains ( Option . TextIndex ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . RDR ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . Quads ) ) ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; final Sail sail = getSailProviderInstance ( props ) ; return sail ; }
public static Sail createSail ( final Properties props , final String file , final Option ... args ) { final List < Option > options = args != null ? Arrays . asList ( args ) : new LinkedList < Option > ( ) ; checkArgs ( file , options ) ; if ( file != null ) { props . setProperty ( STRING , file ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; } if ( options . contains ( Option . Inference ) ) { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } else { props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; } props . setProperty ( STRING , String . valueOf ( options . contains ( Option . TextIndex ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . RDR ) ) ) ; props . setProperty ( STRING , String . valueOf ( options . contains ( Option . Quads ) ) ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; props . setProperty ( STRING , STRING ) ; final Sail sail = getSailProviderInstance ( props ) ; return sail ; }
public static double calculateContrastRatio ( double lum1 , double lum2 ) { if ( ( lum1 < _NUM ) || ( lum2 < _NUM ) ) { throw new IllegalArgumentException ( STRING ) ; } return ( Math . max ( lum1 , lum2 ) + _NUM ) / ( Math . min ( lum1 , lum2 ) + _NUM ) ; }
public String handleWord ( String aWord ) { Matcher m = conditionPattern . matcher ( aWord ) ; if ( m != null && m . matches ( ) ) { if ( type . equals ( AffixType . PREFIX ) ) { return handlePrefix ( aWord ) ; } else if ( type . equals ( AffixType . SUFFIX ) ) { return handleSuffix ( aWord ) ; } } return null ; }
private static void autofit ( TextView view , TextPaint paint , float minTextSize , float maxTextSize , int maxLines , float precision ) { if ( maxLines <= _NUM || maxLines == Integer . MAX_VALUE ) { return ; } int targetWidth = view . getWidth ( ) - view . getPaddingLeft ( ) - view . getPaddingRight ( ) ; if ( targetWidth <= _NUM ) { return ; } CharSequence text = view . getText ( ) ; TransformationMethod method = view . getTransformationMethod ( ) ; if ( method != null ) { text = method . getTransformation ( text , view ) ; } Context context = view . getContext ( ) ; Resources r = Resources . getSystem ( ) ; DisplayMetrics displayMetrics ; float size = maxTextSize ; float high = size ; float low = _NUM ; if ( context != null ) { r = context . getResources ( ) ; } displayMetrics = r . getDisplayMetrics ( ) ; paint . set ( view . getPaint ( ) ) ; paint . setTextSize ( size ) ; if ( ( maxLines == _NUM && paint . measureText ( text , _NUM , text . length ( ) ) > targetWidth ) || getLineCount ( text , paint , size , targetWidth , displayMetrics ) > maxLines ) { size = getAutofitTextSize ( text , paint , targetWidth , maxLines , low , high , precision , displayMetrics ) ; } if ( size < minTextSize ) { size = minTextSize ; } view . setTextSize ( TypedValue . COMPLEX_UNIT_PX , size ) ; }
public Pair < SolrCore , SolrCore > replicateToDestination ( SolrCore bestsrcCore , SolrCore destinationCore ) throws Exception { Pair < SolrCore , SolrCore > replicationRequestPair = null ; try { SolrInteractionUtils . replicateIndex ( destinationCore . host , destinationCore . name , bestsrcCore . host , bestsrcCore . name ) ; String fullReplication = STRING ; String replicator = String . format ( fullReplication , destinationCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , destinationCore . name , bestsrcCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , bestsrcCore . name ) ; logger . info ( STRING + replicator ) ; replicationRequestPair = new Pair < SolrCore , SolrCore > ( destinationCore , bestsrcCore ) ; logger . info ( STRING + destinationCore . host + STRING + destinationCore . name + STRING + bestsrcCore . host + STRING + bestsrcCore . name ) ; } catch ( Exception e ) { logger . info ( STRING + destinationCore . host + STRING + bestsrcCore . host ) ; if ( ! replicatorConfig . shouldSkipReplicationFailures ( ) ) { throw new ReplicationFailureException ( STRING + destinationCore . host + STRING + bestsrcCore . host ) ; } } return replicationRequestPair ; }
public Pair < SolrCore , SolrCore > replicateToDestination ( SolrCore bestsrcCore , SolrCore destinationCore ) throws Exception { Pair < SolrCore , SolrCore > replicationRequestPair = null ; try { SolrInteractionUtils . replicateIndex ( destinationCore . host , destinationCore . name , bestsrcCore . host , bestsrcCore . name ) ; String fullReplication = STRING ; String replicator = String . format ( fullReplication , destinationCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , destinationCore . name , bestsrcCore . host , SolrInteractionUtils . DEFAULT_SOLR_PORT , bestsrcCore . name ) ; logger . info ( STRING + replicator ) ; replicationRequestPair = new Pair < SolrCore , SolrCore > ( destinationCore , bestsrcCore ) ; logger . info ( STRING + destinationCore . host + STRING + destinationCore . name + STRING + bestsrcCore . host + STRING + bestsrcCore . name ) ; } catch ( Exception e ) { logger . info ( STRING + destinationCore . host + STRING + bestsrcCore . host ) ; if ( ! replicatorConfig . shouldSkipReplicationFailures ( ) ) { throw new ReplicationFailureException ( STRING + destinationCore . host + STRING + bestsrcCore . host ) ; } } return replicationRequestPair ; }
private void enlargeCapacity ( int key ) { int diff = offCount - offset ; int minCapacity = Math . max ( arr . length , key + offset + diff + _NUM ) ; if ( minCapacity > arr . length ) { int oldCapacity = arr . length ; int newCapacity = oldCapacity + ( oldCapacity > > _NUM ) ; if ( newCapacity - minCapacity < _NUM ) newCapacity = minCapacity ; if ( newCapacity - MAX_ARRAY_SIZE > _NUM ) newCapacity = hugeCapacity ( minCapacity ) ; arr = Arrays . copyOf ( arr , newCapacity ) ; } }
private void enlargeCapacity ( int key ) { int diff = offCount - offset ; int minCapacity = Math . max ( arr . length , key + offset + diff + _NUM ) ; if ( minCapacity > arr . length ) { int oldCapacity = arr . length ; int newCapacity = oldCapacity + ( oldCapacity > > _NUM ) ; if ( newCapacity - minCapacity < _NUM ) newCapacity = minCapacity ; if ( newCapacity - MAX_ARRAY_SIZE > _NUM ) newCapacity = hugeCapacity ( minCapacity ) ; arr = Arrays . copyOf ( arr , newCapacity ) ; } }
@ Override public int compareTo ( ProjectedEnergy o ) { return Double . compare ( projectedEnergy , o . projectedEnergy ) ; }
@ Override public void compute ( ) { Spliterator < P_IN > rs = spliterator , ls ; long sizeEstimate = rs . estimateSize ( ) ; long sizeThreshold = getTargetSize ( sizeEstimate ) ; boolean forkRight = _BOOL ; @ SuppressWarnings ( STRING ) K task = ( K ) this ; AtomicReference < R > sr = sharedResult ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . taskCanceled ( ) ) { result = task . getEmptyResult ( ) ; break ; } if ( sizeEstimate <= sizeThreshold || ( ls = rs . trySplit ( ) ) == null ) { result = task . doLeaf ( ) ; break ; } K leftChild , rightChild , taskToFork ; task . leftChild = leftChild = task . makeChild ( ls ) ; task . rightChild = rightChild = task . makeChild ( rs ) ; task . setPendingCount ( _NUM ) ; if ( forkRight ) { forkRight = _BOOL ; rs = ls ; task = leftChild ; taskToFork = rightChild ; } else { forkRight = _BOOL ; task = rightChild ; taskToFork = leftChild ; } taskToFork . fork ( ) ; sizeEstimate = rs . estimateSize ( ) ; } task . setLocalResult ( result ) ; task . tryComplete ( ) ; }
@ Override public void compute ( ) { Spliterator < P_IN > rs = spliterator , ls ; long sizeEstimate = rs . estimateSize ( ) ; long sizeThreshold = getTargetSize ( sizeEstimate ) ; boolean forkRight = _BOOL ; @ SuppressWarnings ( STRING ) K task = ( K ) this ; AtomicReference < R > sr = sharedResult ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . taskCanceled ( ) ) { result = task . getEmptyResult ( ) ; break ; } if ( sizeEstimate <= sizeThreshold || ( ls = rs . trySplit ( ) ) == null ) { result = task . doLeaf ( ) ; break ; } K leftChild , rightChild , taskToFork ; task . leftChild = leftChild = task . makeChild ( ls ) ; task . rightChild = rightChild = task . makeChild ( rs ) ; task . setPendingCount ( _NUM ) ; if ( forkRight ) { forkRight = _BOOL ; rs = ls ; task = leftChild ; taskToFork = rightChild ; } else { forkRight = _BOOL ; task = rightChild ; taskToFork = leftChild ; } taskToFork . fork ( ) ; sizeEstimate = rs . estimateSize ( ) ; } task . setLocalResult ( result ) ; task . tryComplete ( ) ; }
@ Override public void compute ( ) { Spliterator < P_IN > rs = spliterator , ls ; long sizeEstimate = rs . estimateSize ( ) ; long sizeThreshold = getTargetSize ( sizeEstimate ) ; boolean forkRight = _BOOL ; @ SuppressWarnings ( STRING ) K task = ( K ) this ; AtomicReference < R > sr = sharedResult ; R result ; while ( ( result = sr . get ( ) ) == null ) { if ( task . taskCanceled ( ) ) { result = task . getEmptyResult ( ) ; break ; } if ( sizeEstimate <= sizeThreshold || ( ls = rs . trySplit ( ) ) == null ) { result = task . doLeaf ( ) ; break ; } K leftChild , rightChild , taskToFork ; task . leftChild = leftChild = task . makeChild ( ls ) ; task . rightChild = rightChild = task . makeChild ( rs ) ; task . setPendingCount ( _NUM ) ; if ( forkRight ) { forkRight = _BOOL ; rs = ls ; task = leftChild ; taskToFork = rightChild ; } else { forkRight = _BOOL ; task = rightChild ; taskToFork = leftChild ; } taskToFork . fork ( ) ; sizeEstimate = rs . estimateSize ( ) ; } task . setLocalResult ( result ) ; task . tryComplete ( ) ; }
public void testInsert1 ( ) throws SQLException { DatabaseCreator . fillParentTable ( conn ) ; DatabaseCreator . fillFKStrictTable ( conn ) ; DatabaseCreator . fillFKCascadeTable ( conn ) ; statement . execute ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING ) ; statement . execute ( STRING + DatabaseCreator . FKCASCADE_TABLE + STRING ) ; }
public static String javaNameToDbName ( String javaName ) { if ( javaName == null ) return null ; if ( javaName . length ( ) <= _NUM ) return STRING ; StringBuilder dbName = new StringBuilder ( ) ; dbName . append ( Character . toUpperCase ( javaName . charAt ( _NUM ) ) ) ; int namePos = _NUM ; while ( namePos < javaName . length ( ) ) { char curChar = javaName . charAt ( namePos ) ; if ( Character . isUpperCase ( curChar ) ) dbName . append ( STRING ) ; dbName . append ( Character . toUpperCase ( curChar ) ) ; namePos ++ ; } return dbName . toString ( ) ; }
public static String javaNameToDbName ( String javaName ) { if ( javaName == null ) return null ; if ( javaName . length ( ) <= _NUM ) return STRING ; StringBuilder dbName = new StringBuilder ( ) ; dbName . append ( Character . toUpperCase ( javaName . charAt ( _NUM ) ) ) ; int namePos = _NUM ; while ( namePos < javaName . length ( ) ) { char curChar = javaName . charAt ( namePos ) ; if ( Character . isUpperCase ( curChar ) ) dbName . append ( STRING ) ; dbName . append ( Character . toUpperCase ( curChar ) ) ; namePos ++ ; } return dbName . toString ( ) ; }
public static String javaNameToDbName ( String javaName ) { if ( javaName == null ) return null ; if ( javaName . length ( ) <= _NUM ) return STRING ; StringBuilder dbName = new StringBuilder ( ) ; dbName . append ( Character . toUpperCase ( javaName . charAt ( _NUM ) ) ) ; int namePos = _NUM ; while ( namePos < javaName . length ( ) ) { char curChar = javaName . charAt ( namePos ) ; if ( Character . isUpperCase ( curChar ) ) dbName . append ( STRING ) ; dbName . append ( Character . toUpperCase ( curChar ) ) ; namePos ++ ; } return dbName . toString ( ) ; }
public static String javaNameToDbName ( String javaName ) { if ( javaName == null ) return null ; if ( javaName . length ( ) <= _NUM ) return STRING ; StringBuilder dbName = new StringBuilder ( ) ; dbName . append ( Character . toUpperCase ( javaName . charAt ( _NUM ) ) ) ; int namePos = _NUM ; while ( namePos < javaName . length ( ) ) { char curChar = javaName . charAt ( namePos ) ; if ( Character . isUpperCase ( curChar ) ) dbName . append ( STRING ) ; dbName . append ( Character . toUpperCase ( curChar ) ) ; namePos ++ ; } return dbName . toString ( ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
@ Override public synchronized void clear ( ) { File [ ] files = mRootDirectory . listFiles ( ) ; if ( files != null ) { for ( File file : files ) { file . delete ( ) ; } } mEntries . clear ( ) ; mTotalSize = _NUM ; VolleyLog . d ( STRING ) ; }
public static String minus ( CharSequence self , Object target ) { String s = self . toString ( ) ; String text = DefaultGroovyMethods . toString ( target ) ; int index = s . indexOf ( text ) ; if ( index == - _NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( _NUM , index ) + s . substring ( end ) ; } return s . substring ( _NUM , index ) ; }
public static String minus ( CharSequence self , Object target ) { String s = self . toString ( ) ; String text = DefaultGroovyMethods . toString ( target ) ; int index = s . indexOf ( text ) ; if ( index == - _NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( _NUM , index ) + s . substring ( end ) ; } return s . substring ( _NUM , index ) ; }
public static String minus ( CharSequence self , Object target ) { String s = self . toString ( ) ; String text = DefaultGroovyMethods . toString ( target ) ; int index = s . indexOf ( text ) ; if ( index == - _NUM ) return s ; int end = index + text . length ( ) ; if ( s . length ( ) > end ) { return s . substring ( _NUM , index ) + s . substring ( end ) ; } return s . substring ( _NUM , index ) ; }
public static Map < String , Object > updateDataResourceAndText ( DispatchContext dctx , Map < String , ? extends Object > context ) { Map < String , Object > thisResult = updateDataResourceMethod ( dctx , context ) ; if ( thisResult . get ( ModelService . RESPONSE_MESSAGE ) != null ) { return ServiceUtil . returnError ( ( String ) thisResult . get ( ModelService . ERROR_MESSAGE ) ) ; } String dataResourceTypeId = ( String ) context . get ( STRING ) ; if ( dataResourceTypeId != null && dataResourceTypeId . equals ( STRING ) ) { thisResult = updateElectronicText ( dctx , context ) ; if ( thisResult . get ( ModelService . RESPONSE_MESSAGE ) != null ) { return ServiceUtil . returnError ( ( String ) thisResult . get ( ModelService . ERROR_MESSAGE ) ) ; } } return ServiceUtil . returnSuccess ( ) ; }
public void start ( ) throws IOException { this . isRunning = _BOOL ; Thread thread = new Thread ( this ) ; thread . setDaemon ( _BOOL ) ; thread . setName ( STRING ) ; thread . setPriority ( Thread . MAX_PRIORITY ) ; thread . start ( ) ; }
public Iterator < TcpDiscoveryAbstractMessage > iterator ( ) { return new SkipIterator ( ) ; }
private void addListParameter ( DaemonParameters parameters , String parameterName , List < String > list ) { int i = _NUM ; if ( list == null || list . size ( ) == _NUM ) { return ; } StringBuilder listJSON = new StringBuilder ( ) ; listJSON . append ( STRING ) ; for ( String item : list ) { if ( i != _NUM ) { listJSON . append ( STRING ) ; } listJSON . append ( STRING + item + STRING ) ; i ++ ; } listJSON . append ( STRING ) ; parameters . setParameter ( parameterName , listJSON . toString ( ) ) ; }
public boolean hleKernelUnRegisterCallback ( int callbackType , int cbid ) { boolean found = _BOOL ; for ( SceKernelThreadInfo thread : threadMap . values ( ) ) { RegisteredCallbacks registeredCallbacks = thread . getRegisteredCallbacks ( callbackType ) ; pspBaseCallback callback = registeredCallbacks . getCallbackInfoByUid ( cbid ) ; if ( callback != null ) { found = _BOOL ; if ( registeredCallbacks . isCallbackReady ( callback ) ) { log . warn ( STRING + callbackType + STRING ) ; } registeredCallbacks . removeCallback ( callback ) ; break ; } } if ( ! found ) { log . warn ( STRING + callbackType + STRING + Integer . toHexString ( cbid ) + STRING ) ; } return found ; }
protected void computeTabsThatFitInComposite ( ) { tabsThatFitInComposite = Math . round ( ( getSize ( ) . y - _NUM ) / getTabHeight ( ) ) ; if ( tabsThatFitInComposite <= _NUM ) { tabsThatFitInComposite = _NUM ; } }
protected void computeTabsThatFitInComposite ( ) { tabsThatFitInComposite = Math . round ( ( getSize ( ) . y - _NUM ) / getTabHeight ( ) ) ; if ( tabsThatFitInComposite <= _NUM ) { tabsThatFitInComposite = _NUM ; } }
protected void computeTabsThatFitInComposite ( ) { tabsThatFitInComposite = Math . round ( ( getSize ( ) . y - _NUM ) / getTabHeight ( ) ) ; if ( tabsThatFitInComposite <= _NUM ) { tabsThatFitInComposite = _NUM ; } }
public static String dump ( final ConfigDescriptor descriptor ) { return String . format ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , descriptor . bLength ( ) , descriptor . bDescriptorType ( ) , descriptor . wTotalLength ( ) & _NUM , descriptor . bNumInterfaces ( ) & _NUM , descriptor . bConfigurationValue ( ) & _NUM , descriptor . iConfiguration ( ) & _NUM , String . format ( STRING , descriptor . bmAttributes ( ) & _NUM ) , ( ( descriptor . bmAttributes ( ) & _NUM ) == _NUM ) ? STRING : STRING , ( ( descriptor . bmAttributes ( ) & _NUM ) == _NUM ) ? STRING : String . format ( STRING ) , ( descriptor . bMaxPower ( ) & _NUM ) * _NUM ) ; }
public static BlockMirror checkIfBlockMirrorExistsInDB ( String mirrorNativeGuid , DbClient dbClient ) { List < BlockMirror > activeMirrors = CustomQueryUtility . getActiveBlockMirrorByNativeGuid ( dbClient , mirrorNativeGuid ) ; Iterator < BlockMirror > mirrorItr = activeMirrors . iterator ( ) ; return mirrorItr . hasNext ( ) ? mirrorItr . next ( ) : null ; }
public static BlockMirror checkIfBlockMirrorExistsInDB ( String mirrorNativeGuid , DbClient dbClient ) { List < BlockMirror > activeMirrors = CustomQueryUtility . getActiveBlockMirrorByNativeGuid ( dbClient , mirrorNativeGuid ) ; Iterator < BlockMirror > mirrorItr = activeMirrors . iterator ( ) ; return mirrorItr . hasNext ( ) ? mirrorItr . next ( ) : null ; }
public char [ ] expandCurrentSegment ( ) { char [ ] curr = _currentSegment ; int len = curr . length ; int newLen = ( len == MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + _NUM ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > _NUM ) ) ; _currentSegment = _charArray ( newLen ) ; System . arraycopy ( curr , _NUM , _currentSegment , _NUM , len ) ; return _currentSegment ; }
public char [ ] expandCurrentSegment ( ) { char [ ] curr = _currentSegment ; int len = curr . length ; int newLen = ( len == MAX_SEGMENT_LEN ) ? ( MAX_SEGMENT_LEN + _NUM ) : Math . min ( MAX_SEGMENT_LEN , len + ( len > > _NUM ) ) ; _currentSegment = _charArray ( newLen ) ; System . arraycopy ( curr , _NUM , _currentSegment , _NUM , len ) ; return _currentSegment ; }
private static DateTimeFormatter createFormatterForStyle ( String style ) { if ( style == null || style . length ( ) != _NUM ) { throw new IllegalArgumentException ( STRING + style ) ; } int dateStyle = selectStyle ( style . charAt ( _NUM ) ) ; int timeStyle = selectStyle ( style . charAt ( _NUM ) ) ; if ( dateStyle == NONE && timeStyle == NONE ) { throw new IllegalArgumentException ( STRING ) ; } return createFormatterForStyleIndex ( dateStyle , timeStyle ) ; }
private static DateTimeFormatter createFormatterForStyle ( String style ) { if ( style == null || style . length ( ) != _NUM ) { throw new IllegalArgumentException ( STRING + style ) ; } int dateStyle = selectStyle ( style . charAt ( _NUM ) ) ; int timeStyle = selectStyle ( style . charAt ( _NUM ) ) ; if ( dateStyle == NONE && timeStyle == NONE ) { throw new IllegalArgumentException ( STRING ) ; } return createFormatterForStyleIndex ( dateStyle , timeStyle ) ; }
private static String formatList ( String [ ] stringList , String listPattern , String listCompositionPattern ) { if ( listPattern == null || listCompositionPattern == null ) { StringBuilder result = new StringBuilder ( ) ; for ( int i = _NUM ; i < stringList . length ; ++ i ) { if ( i > _NUM ) { result . append ( STRING ) ; } result . append ( stringList [ i ] ) ; } return result . toString ( ) ; } if ( stringList . length > _NUM ) { MessageFormat format = new MessageFormat ( listCompositionPattern ) ; stringList = composeList ( format , stringList ) ; } Object [ ] args = new Object [ stringList . length + _NUM ] ; System . arraycopy ( stringList , _NUM , args , _NUM , stringList . length ) ; args [ _NUM ] = new Integer ( stringList . length ) ; MessageFormat format = new MessageFormat ( listPattern ) ; return format . format ( args ) ; }
public static Configuration load ( InputStream stream ) throws IOException { try { Properties properties = new Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
public static Configuration load ( InputStream stream ) throws IOException { try { Properties properties = new Properties ( ) ; properties . load ( stream ) ; return from ( properties ) ; } finally { stream . close ( ) ; } }
private void performDrag ( float x ) { float deltaX = lastMotionX - x ; lastMotionX = x ; if ( virtualPos == _NUM ) { if ( deltaX < _NUM ) { deltaX = - deltaX ; reversePos = _BOOL ; } else { reversePos = _BOOL ; } } else if ( virtualPos > _NUM ) { deltaX = - deltaX ; reversePos = _BOOL ; } else { reversePos = _BOOL ; } float oldScrollX = getScrollX ( ) ; float scrollX = oldScrollX + deltaX ; final int width = getClientWidth ( ) ; float leftBound = _NUM ; float rightBound = width * lastOffset ; final ItemInfo currentItem = infoForPosition ( this . currentItem ) ; final ItemInfo lastItem = items . get ( items . size ( ) - _NUM ) ; if ( currentItem != null ) { leftBound = currentItem . offset * width ; } if ( lastItem . position != pagerAdapter . getCount ( ) - _NUM ) { rightBound = lastItem . offset * width ; } if ( scrollX < leftBound ) { scrollX = leftBound ; } else if ( scrollX > rightBound ) { scrollX = rightBound ; } lastMotionX += scrollX - ( int ) scrollX ; scrollTo ( ( int ) scrollX , getScrollY ( ) ) ; pageScrolled ( ( int ) scrollX ) ; }
private void performDrag ( float x ) { float deltaX = lastMotionX - x ; lastMotionX = x ; if ( virtualPos == _NUM ) { if ( deltaX < _NUM ) { deltaX = - deltaX ; reversePos = _BOOL ; } else { reversePos = _BOOL ; } } else if ( virtualPos > _NUM ) { deltaX = - deltaX ; reversePos = _BOOL ; } else { reversePos = _BOOL ; } float oldScrollX = getScrollX ( ) ; float scrollX = oldScrollX + deltaX ; final int width = getClientWidth ( ) ; float leftBound = _NUM ; float rightBound = width * lastOffset ; final ItemInfo currentItem = infoForPosition ( this . currentItem ) ; final ItemInfo lastItem = items . get ( items . size ( ) - _NUM ) ; if ( currentItem != null ) { leftBound = currentItem . offset * width ; } if ( lastItem . position != pagerAdapter . getCount ( ) - _NUM ) { rightBound = lastItem . offset * width ; } if ( scrollX < leftBound ) { scrollX = leftBound ; } else if ( scrollX > rightBound ) { scrollX = rightBound ; } lastMotionX += scrollX - ( int ) scrollX ; scrollTo ( ( int ) scrollX , getScrollY ( ) ) ; pageScrolled ( ( int ) scrollX ) ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateSingle ( List elements , String expr ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateSingle ( ( StructuredContent ) o , expr ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
private synchronized void updateContainerXML ( ) throws IOException , ParserConfigurationException { synchronized ( _lock ) { if ( _containerEntry == null ) return ; } if ( m_ContainerFile != null && ! m_ContainerFile . exists ( ) ) { m_ContainerFile . createNewFile ( ) ; if ( _logger . isLoggable ( Level . FINE ) ) { _logger . fine ( STRING + m_ContainerFile + STRING + _containerName + STRING ) ; } } DocumentBuilderFactory factory = DocumentBuilderFactory . newInstance ( ) ; DocumentBuilder builder = factory . newDocumentBuilder ( ) ; m_containerFileDocument = builder . newDocument ( ) ; m_rootContainerElement = m_containerFileDocument . createElement ( _containerName ) ; m_rootSpaceElement = m_containerFileDocument . createElement ( SPACE_TAG ) ; m_rootContainerElement . appendChild ( m_rootSpaceElement ) ; synchronized ( _lock ) { if ( _containerEntry != null ) updateContainerXMLTree ( _containerEntry . getName ( ) , _containerEntry . getSpaceAttributes ( ) ) ; } saveState ( ) ; }
public static int createWithIdGeneration ( Connection connection , String rawSqlQuery , Object ... parameters ) throws SQLException { PreparedStatement stmt = null ; ResultSet rs = null ; try { stmt = connection . prepareStatement ( rawSqlQuery , Statement . RETURN_GENERATED_KEYS ) ; for ( int index = _NUM ; index < parameters . length ; index ++ ) { JdbcUtils . bindParameter ( stmt , index + _NUM , parameters [ index ] ) ; } stmt . executeUpdate ( ) ; rs = stmt . getGeneratedKeys ( ) ; rs . next ( ) ; return rs . getInt ( _NUM ) ; } finally { JdbcUtils . closeResultSet ( rs ) ; JdbcUtils . closeStatement ( stmt ) ; } }
private StringBuilder generateParameters ( ) { StringBuilder parameters = new StringBuilder ( ) ; if ( filterMap == null && expandParameters == null ) { return parameters ; } parameters . append ( STRING ) ; int filterParameterCounter = _NUM ; if ( filterMap != null && ! filterMap . isEmpty ( ) ) { parameters . append ( FILTER_PREFIX ) ; for ( Map . Entry < String , String > filterEntry : filterMap . entrySet ( ) ) { parameters . append ( String . format ( STRING , filterEntry . getKey ( ) , filterEntry . getValue ( ) ) ) ; if ( ++ filterParameterCounter < filterMap . size ( ) ) { parameters . append ( STRING ) ; } } if ( expandParameters != null ) { parameters . append ( STRING ) ; } } if ( expandParameters != null ) { parameters . append ( EXPAND_PREFIX ) ; Iterator iterator = expandParameters . iterator ( ) ; parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; while ( iterator . hasNext ( ) ) { parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; } } return parameters ; }
private StringBuilder generateParameters ( ) { StringBuilder parameters = new StringBuilder ( ) ; if ( filterMap == null && expandParameters == null ) { return parameters ; } parameters . append ( STRING ) ; int filterParameterCounter = _NUM ; if ( filterMap != null && ! filterMap . isEmpty ( ) ) { parameters . append ( FILTER_PREFIX ) ; for ( Map . Entry < String , String > filterEntry : filterMap . entrySet ( ) ) { parameters . append ( String . format ( STRING , filterEntry . getKey ( ) , filterEntry . getValue ( ) ) ) ; if ( ++ filterParameterCounter < filterMap . size ( ) ) { parameters . append ( STRING ) ; } } if ( expandParameters != null ) { parameters . append ( STRING ) ; } } if ( expandParameters != null ) { parameters . append ( EXPAND_PREFIX ) ; Iterator iterator = expandParameters . iterator ( ) ; parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; while ( iterator . hasNext ( ) ) { parameters . append ( String . format ( STRING , iterator . next ( ) ) ) ; } } return parameters ; }
public static int blendColors ( int color1 , int color2 , float ratio ) { float proportion = ratio ; proportion = Math . min ( _NUM , proportion ) ; proportion = Math . max ( _NUM , proportion ) ; int [ ] color1Comps = { Color . alpha ( color1 ) , Color . red ( color1 ) , Color . green ( color1 ) , Color . blue ( color1 ) } ; int [ ] color2Comps = { Color . alpha ( color2 ) , Color . red ( color2 ) , Color . green ( color2 ) , Color . blue ( color2 ) } ; int [ ] newColorComps = { _NUM , _NUM , _NUM , _NUM } ; for ( int i = _NUM ; i < _NUM ; i ++ ) { newColorComps [ i ] = Math . round ( color1Comps [ i ] + ( ( color2Comps [ i ] - color1Comps [ i ] ) * proportion ) ) ; } return Color . argb ( newColorComps [ _NUM ] , newColorComps [ _NUM ] , newColorComps [ _NUM ] , newColorComps [ _NUM ] ) ; }
private static String toVariableName ( String str ) { StringBuffer rtn = new StringBuffer ( ) ; char [ ] chars = str . toCharArray ( ) ; long changes = _NUM ; boolean doCorrect = _BOOL ; for ( int i = _NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; if ( i == _NUM && ( c >= STRING && c <= STRING ) ) rtn . append ( STRING + c ) ; else if ( ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || ( c >= STRING && c <= STRING ) || c == STRING || c == STRING ) rtn . append ( c ) ; else { doCorrect = _BOOL ; rtn . append ( STRING ) ; changes += ( c * ( i + _NUM ) ) ; } } if ( changes > _NUM ) rtn . append ( changes ) ; if ( doCorrect ) return correctReservedWord ( rtn . toString ( ) ) ; return rtn . toString ( ) ; }
@ SuppressWarnings ( STRING ) public Pids ( ) { Arrays . sort ( PIDs , pidComparator ) ; }
public static String suppressWhiteSpace ( String str ) { int len = str . length ( ) ; StringBuilder sb = new StringBuilder ( len ) ; char c ; char buffer = _NUM ; for ( int i = _NUM ; i < len ; i ++ ) { c = str . charAt ( i ) ; if ( c == STRING || c == STRING ) buffer = STRING ; else if ( isWhiteSpace ( c ) ) { if ( buffer == _NUM ) buffer = c ; } else { if ( buffer != _NUM ) { sb . append ( buffer ) ; buffer = _NUM ; } sb . append ( c ) ; } } if ( buffer != _NUM ) sb . append ( buffer ) ; return sb . toString ( ) ; }
void waitForLogEntry ( int index , int timeout ) throws GondolaException , InterruptedException , TimeoutException { reset ( ) ; this . index = index ; long endTs = timeout < _NUM ? Long . MAX_VALUE : gondola . getClock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS_NONE && gondola . getClock ( ) . now ( ) < endTs ) { if ( timeout < _NUM ) { updateCond . await ( ) ; } else { updateCond . await ( timeout , TimeUnit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STRING ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS_NONE : status = Command . STATUS_TIMEOUT ; throw new TimeoutException ( String . format ( STRING , timeout , index ) ) ; case Command . STATUS_NOT_LEADER : assert _BOOL ; break ; case Command . STATUS_SLAVE_MODE : throw new GondolaException ( GondolaException . Code . SLAVE_MODE , cmember . memberId ) ; case Command . STATUS_ERROR : throw new IllegalStateException ( STRING + index + STRING + errorMessage ) ; case Command . STATUS_OK : break ; } }
void waitForLogEntry ( int index , int timeout ) throws GondolaException , InterruptedException , TimeoutException { reset ( ) ; this . index = index ; long endTs = timeout < _NUM ? Long . MAX_VALUE : gondola . getClock ( ) . now ( ) + timeout ; lock . lock ( ) ; try { while ( status == Command . STATUS_NONE && gondola . getClock ( ) . now ( ) < endTs ) { if ( timeout < _NUM ) { updateCond . await ( ) ; } else { updateCond . await ( timeout , TimeUnit . MILLISECONDS ) ; } } if ( this . index != index ) { logger . error ( STRING ) ; } } finally { lock . unlock ( ) ; } switch ( status ) { case Command . STATUS_NONE : status = Command . STATUS_TIMEOUT ; throw new TimeoutException ( String . format ( STRING , timeout , index ) ) ; case Command . STATUS_NOT_LEADER : assert _BOOL ; break ; case Command . STATUS_SLAVE_MODE : throw new GondolaException ( GondolaException . Code . SLAVE_MODE , cmember . memberId ) ; case Command . STATUS_ERROR : throw new IllegalStateException ( STRING + index + STRING + errorMessage ) ; case Command . STATUS_OK : break ; } }
public Matrix copy ( ) { Matrix X = new Matrix ( m , n ) ; double [ ] [ ] C = X . getArray ( ) ; for ( int i = _NUM ; i < m ; i ++ ) { for ( int j = _NUM ; j < n ; j ++ ) { C [ i ] [ j ] = A [ i ] [ j ] ; } } return X ; }
public static boolean hasRoleInCluster ( String containerName , String clusterId , String role ) { String expectedStart = String . format ( STRING , role , clusterId ) ; return containerName . startsWith ( expectedStart ) ; }
protected int hash ( Object key1 , Object key2 , Object key3 ) { int h = _NUM ; if ( key1 != null ) { h ^= key1 . hashCode ( ) ; } if ( key2 != null ) { h ^= key2 . hashCode ( ) ; } if ( key3 != null ) { h ^= key3 . hashCode ( ) ; } h += ~ ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; h += ( h << _NUM ) ; h ^= ( h > > > _NUM ) ; return h ; }
void onInsnAdded ( SsaInsn insn ) { onSourcesChanged ( insn , null ) ; updateOneDefinition ( insn , null ) ; }
void onInsnAdded ( SsaInsn insn ) { onSourcesChanged ( insn , null ) ; updateOneDefinition ( insn , null ) ; }
void onInsnAdded ( SsaInsn insn ) { onSourcesChanged ( insn , null ) ; updateOneDefinition ( insn , null ) ; }
private double instanceTransformationProbability ( Instance first , Instance second ) { double transProb = _NUM ; int numMissAttr = _NUM ; for ( int i = _NUM ; i < m_NumAttributes ; i ++ ) { if ( i == m_Train . classIndex ( ) ) { continue ; } if ( first . isMissing ( i ) ) { numMissAttr ++ ; continue ; } transProb *= attrTransProb ( first , second , i ) ; if ( numMissAttr != m_NumAttributes ) { transProb = Math . pow ( transProb , ( double ) m_NumAttributes / ( m_NumAttributes - numMissAttr ) ) ; } else { transProb = _NUM ; } } return transProb / m_NumInstances ; }
public boolean isServerTerminated ( ) { try { process . exitValue ( ) ; } catch ( IllegalThreadStateException itse ) { return _BOOL ; } return _BOOL ; }
private SortedMap < MessageUid , MaildirMessageName > truncateMap ( Map < MessageUid , MaildirMessageName > map , MessageUid from , MessageUid to ) { TreeMap < MessageUid , MaildirMessageName > sortedMap ; if ( map instanceof TreeMap < ? , ? > ) sortedMap = ( TreeMap < MessageUid , MaildirMessageName > ) map ; else sortedMap = new TreeMap < MessageUid , MaildirMessageName > ( map ) ; if ( to != null ) return sortedMap . subMap ( from , to . next ( ) ) ; return sortedMap . tailMap ( from ) ; }
public void clearance_value_changed ( ) { Iterator < AwtreeShapeSearch > iter = search_trees . iterator ( ) ; while ( iter . hasNext ( ) ) { AwtreeShapeSearch curr_tree = iter . next ( ) ; if ( curr_tree . compensated_clearance_class_no != default_tree . compensated_clearance_class_no ) { iter . remove ( ) ; } } }
public static boolean checkForm ( String str ) { int openParentheses = _NUM ; int openBrackets = _NUM ; int openBraces = _NUM ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { char c = str . charAt ( i ) ; switch ( c ) { case STRING : openParentheses ++ ; break ; case STRING : openParentheses -- ; if ( openParentheses < _NUM ) return _BOOL ; break ; case STRING : openBrackets ++ ; break ; case STRING : openBrackets -- ; if ( openBrackets < _NUM ) return _BOOL ; break ; case STRING : openBraces ++ ; break ; case STRING : openBraces -- ; if ( openBraces < _NUM ) return _BOOL ; break ; } } boolean balanced = ( openParentheses == _NUM && openBrackets == _NUM && openBraces == _NUM ) ; return balanced ; }
public void addName ( String type , String name ) { if ( containsName ( type , name ) ) { return ; } List < CarLoad > loads = listCarLoads . get ( type ) ; if ( loads == null ) { log . debug ( STRING , type ) ; return ; } loads . add ( _NUM , new CarLoad ( name ) ) ; maxNameLength = _NUM ; setDirtyAndFirePropertyChange ( LOAD_CHANGED_PROPERTY , null , name ) ; }
public PdfArray ( PdfArray arr ) { this ( ) ; list . addAll ( arr . list ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == null || ! ( obj instanceof ValueLiteralNode ) ) { return _BOOL ; } ValueLiteralNode other = ( ValueLiteralNode ) obj ; Object val = getValue ( ) ; Object otherVal = other . getValue ( ) ; return ( ( val == null || otherVal == null ) && val == otherVal ) || val . equals ( otherVal ) ; }
public BoxAndWhiskerToolTipGenerator ( ) { super ( DEFAULT_TOOL_TIP_FORMAT , NumberFormat . getInstance ( ) ) ; }
public DSystemInformation ( JFrame parent ) { super ( parent , res . getString ( STRING ) , ModalityType . DOCUMENT_MODAL ) ; initComponents ( ) ; }
public DSystemInformation ( JFrame parent ) { super ( parent , res . getString ( STRING ) , ModalityType . DOCUMENT_MODAL ) ; initComponents ( ) ; }
public void tickBlock ( BlockPos pos ) { List < BlockPos > validCoords = new ArrayList < > ( ) ; for ( int xOffset = - TICK_RANGE ; xOffset <= TICK_RANGE ; xOffset ++ ) { for ( int zOffset = - TICK_RANGE ; zOffset <= TICK_RANGE ; zOffset ++ ) { if ( xOffset == _NUM && zOffset == _NUM ) continue ; if ( isValidSwapPosition ( pos . add ( xOffset , _NUM , zOffset ) ) ) validCoords . add ( pos . add ( xOffset , _NUM , zOffset ) ) ; } } if ( ! validCoords . isEmpty ( ) && ! world . isRemote ) { BlockPos toSwap = validCoords . get ( rand . nextInt ( validCoords . size ( ) ) ) ; world . setBlockState ( toSwap , stateToSet , _NUM | _NUM ) ; } }
public void tickBlock ( BlockPos pos ) { List < BlockPos > validCoords = new ArrayList < > ( ) ; for ( int xOffset = - TICK_RANGE ; xOffset <= TICK_RANGE ; xOffset ++ ) { for ( int zOffset = - TICK_RANGE ; zOffset <= TICK_RANGE ; zOffset ++ ) { if ( xOffset == _NUM && zOffset == _NUM ) continue ; if ( isValidSwapPosition ( pos . add ( xOffset , _NUM , zOffset ) ) ) validCoords . add ( pos . add ( xOffset , _NUM , zOffset ) ) ; } } if ( ! validCoords . isEmpty ( ) && ! world . isRemote ) { BlockPos toSwap = validCoords . get ( rand . nextInt ( validCoords . size ( ) ) ) ; world . setBlockState ( toSwap , stateToSet , _NUM | _NUM ) ; } }
private Map < Integer , Fraction > generateAbsent ( ) { Map < Integer , Fraction > generated = new HashMap < Integer , Fraction > ( ) ; do { generated . putAll ( generate ( ) ) ; for ( Integer key : javaMap . keySet ( ) ) generated . remove ( key ) ; } while ( generated . size ( ) < _NUM ) ; return generated ; }
private String readUTFBody ( long utfLen ) throws IOException { StringBuilder sbuf = new StringBuilder ( ) ; end = pos = _NUM ; while ( utfLen > _NUM ) { int avail = end - pos ; if ( avail >= _NUM || ( long ) avail == utfLen ) utfLen -= readUTFSpan ( sbuf , utfLen ) ; else { if ( avail > _NUM ) GridUnsafe . copyMemory ( utfBuf , BYTE_ARR_OFF + pos , utfBuf , BYTE_ARR_OFF , avail ) ; pos = _NUM ; end = ( int ) Math . min ( MAX_BLOCK_SIZE , utfLen ) ; readFully ( utfBuf , avail , end - avail ) ; } } return sbuf . toString ( ) ; }
private String readUTFBody ( long utfLen ) throws IOException { StringBuilder sbuf = new StringBuilder ( ) ; end = pos = _NUM ; while ( utfLen > _NUM ) { int avail = end - pos ; if ( avail >= _NUM || ( long ) avail == utfLen ) utfLen -= readUTFSpan ( sbuf , utfLen ) ; else { if ( avail > _NUM ) GridUnsafe . copyMemory ( utfBuf , BYTE_ARR_OFF + pos , utfBuf , BYTE_ARR_OFF , avail ) ; pos = _NUM ; end = ( int ) Math . min ( MAX_BLOCK_SIZE , utfLen ) ; readFully ( utfBuf , avail , end - avail ) ; } } return sbuf . toString ( ) ; }
@ Override public boolean isSet ( DatatypeConstants . Field field ) { if ( field == null ) { String methodName = STRING + STRING ; throw new NullPointerException ( DatatypeMessageFormatter . formatMessage ( null , STRING , new Object [ ] { methodName } ) ) ; } if ( field == DatatypeConstants . YEARS ) { return years != null ; } if ( field == DatatypeConstants . MONTHS ) { return months != null ; } if ( field == DatatypeConstants . DAYS ) { return days != null ; } if ( field == DatatypeConstants . HOURS ) { return hours != null ; } if ( field == DatatypeConstants . MINUTES ) { return minutes != null ; } if ( field == DatatypeConstants . SECONDS ) { return seconds != null ; } String methodName = STRING + STRING ; throw new IllegalArgumentException ( DatatypeMessageFormatter . formatMessage ( null , STRING , new Object [ ] { methodName , field . toString ( ) } ) ) ; }
public static boolean isMiddleMouseButton ( MouseEvent anEvent ) { return ( ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON2_DOWN_MASK ) != _NUM || anEvent . getButton ( ) == MouseEvent . BUTTON2 ) ; }
public static boolean isMiddleMouseButton ( MouseEvent anEvent ) { return ( ( anEvent . getModifiersEx ( ) & InputEvent . BUTTON2_DOWN_MASK ) != _NUM || anEvent . getButton ( ) == MouseEvent . BUTTON2 ) ; }
private void handleTruncatedInfo ( final StatementInfo info ) throws SQLException { final byte [ ] originalInfo = statement . getStatementInfoRequestItems ( ) ; final byte [ ] newInfoItems = new byte [ originalInfo . length + _NUM * _NUM ] ; int newIndex = _NUM ; for ( final byte infoItem : originalInfo ) { assert newIndex < newInfoItems . length : STRING ; switch ( infoItem ) { case ISCConstants . isc_info_sql_select : case ISCConstants . isc_info_sql_bind : final RowDescriptorBuilder currentBuilder = infoItem == ISCConstants . isc_info_sql_select ? info . fieldBuilder : info . parameterBuilder ; final int descriptorIndex = currentBuilder != null ? currentBuilder . getFirstUnprocessedIndex ( ) + _NUM : _NUM ; newInfoItems [ newIndex ++ ] = ISCConstants . isc_info_sql_sqlda_start ; newInfoItems [ newIndex ++ ] = _NUM ; newInfoItems [ newIndex ++ ] = ( byte ) ( descriptorIndex & _NUM ) ; newInfoItems [ newIndex ++ ] = ( byte ) ( descriptorIndex > > _NUM ) ; newInfoItems [ newIndex ++ ] = infoItem ; break ; default : newInfoItems [ newIndex ++ ] = infoItem ; break ; } } assert newIndex == newInfoItems . length : STRING ; info . requestBufferSize = Math . min ( _NUM * info . requestBufferSize , statement . getMaxSqlInfoSize ( ) ) ; info . buffer = statement . getSqlInfo ( newInfoItems , info . requestBufferSize ) ; info . currentIndex = _NUM ; }
public static < A > ListTSeq < A > fromStream ( final AnyMSeq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > ListTSeq < A > fromStream ( final AnyMSeq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > ListTSeq < A > fromStream ( final AnyMSeq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > ListTSeq < A > fromStream ( final AnyMSeq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < A > ListTSeq < A > fromStream ( final AnyMSeq < Stream < A > > monads ) { return of ( monads . map ( null ) ) ; }
public static < T > List < T > last ( List < T > elements , int limit ) { ArrayList < T > res = new ArrayList < T > ( ) ; for ( int i = _NUM ; i < elements . size ( ) ; i ++ ) { if ( res . size ( ) >= limit ) { break ; } res . add ( elements . get ( elements . size ( ) - _NUM - i ) ) ; } return res ; }
private void verifyTargetSessionIsLocalOrStateless ( SessionRequest req , SessionID sid ) throws SessionException , SessionRequestException , ForwardSessionRequestException { if ( statelessSessionManager . containsJwt ( sid ) ) { return ; } String hostServerID = foreignSessionHandler . getCurrentHostServer ( sid ) ; if ( ! serverConfig . isLocalServer ( hostServerID ) ) { try { throw new ForwardSessionRequestException ( forward ( SESSION_SERVICE_URL_SERVICE . getSessionServiceURL ( hostServerID ) , req ) ) ; } catch ( SessionException se ) { if ( ! sessionService . checkServerUp ( hostServerID ) ) { String retryHostServerID = foreignSessionHandler . getCurrentHostServer ( sid ) ; if ( retryHostServerID . equals ( hostServerID ) ) { throw se ; } else { if ( ! serverConfig . isLocalServer ( retryHostServerID ) ) { throw new ForwardSessionRequestException ( forward ( SESSION_SERVICE_URL_SERVICE . getSessionServiceURL ( hostServerID ) , req ) ) ; } } } else { throw se ; } } } if ( ! sessionService . checkSessionLocal ( sid ) ) { throw new SessionRequestException ( sid , SessionBundle . getString ( STRING ) ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( _NUM ) ; result . addElement ( new Option ( STRING + STRING + DEFAULT_EXPRESSION + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( _NUM ) ; result . addElement ( new Option ( STRING + STRING + DEFAULT_EXPRESSION + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( _NUM ) ; result . addElement ( new Option ( STRING + STRING + DEFAULT_EXPRESSION + STRING , STRING , _NUM , STRING ) ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
public void clear ( ) { m_Model . clear ( ) ; setButtons ( null ) ; }
@ Override public boolean equals ( Object obj ) { if ( obj == this ) { return _BOOL ; } if ( ! ( obj instanceof XYBubbleRenderer ) ) { return _BOOL ; } XYBubbleRenderer that = ( XYBubbleRenderer ) obj ; if ( this . scaleType != that . scaleType ) { return _BOOL ; } return super . equals ( obj ) ; }
public Route ( Vertx vertx , ResourceStorage storage , LoggingResourceManager loggingResourceManager , MonitoringHandler monitoringHandler , String userProfilePath , HttpHook httpHook , String urlPattern ) { this . vertx = vertx ; this . storage = storage ; this . loggingResourceManager = loggingResourceManager ; this . monitoringHandler = monitoringHandler ; this . userProfilePath = userProfilePath ; this . httpHook = httpHook ; this . urlPattern = urlPattern ; createRule ( ) ; createHttpClient ( ) ; createForwarder ( ) ; }
public static Account generateRandomAccount ( ) { return new Account ( new KeyPair ( ) ) ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator < String > keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
protected void graphTree ( StringBuffer text ) throws Exception { text . append ( STRING + m_clusterNum + STRING + ( ( m_children == null ) ? STRING : STRING ) + m_clusterNum + STRING + STRING + m_clusterInstances . numInstances ( ) + STRING + ( ( m_children == null ) ? STRING : STRING ) + ( m_saveInstances ? STRING + dumpData ( ) + STRING : STRING ) + STRING ) ; if ( m_children != null ) { for ( int i = _NUM ; i < m_children . size ( ) ; i ++ ) { CNode temp = m_children . get ( i ) ; text . append ( STRING + m_clusterNum + STRING + STRING + temp . m_clusterNum + STRING ) ; } for ( int i = _NUM ; i < m_children . size ( ) ; i ++ ) { CNode temp = m_children . get ( i ) ; temp . graphTree ( text ) ; } } }
public void testHasAttribute1 ( ) throws Throwable { Document doc ; NodeList elementList ; Element testNode ; boolean state ; doc = ( Document ) load ( STRING , builder ) ; elementList = doc . getElementsByTagName ( STRING ) ; testNode = ( Element ) elementList . item ( _NUM ) ; state = testNode . hasAttribute ( STRING ) ; assertFalse ( STRING , state ) ; }
public void addBestStatement ( Collection < Statement > statements ) { if ( bestStatement != null ) { statements . add ( bestStatement ) ; } }
@ Override public int read ( ) throws IOException { synchronized ( lock ) { checkNotClosed ( ) ; if ( pos < buf . length ) { return buf [ pos ++ ] ; } return in . read ( ) ; } }
protected int [ ] determineIndices ( int numAttributes ) throws Exception { int [ ] result ; Vector < Integer > list ; int i ; StringTokenizer tok ; String token ; String [ ] range ; int from ; int to ; list = new Vector < Integer > ( ) ; tok = new StringTokenizer ( m_NewOrderCols , STRING ) ; while ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( token . indexOf ( STRING ) > - _NUM ) { range = token . split ( STRING ) ; if ( range . length != _NUM ) { throw new IllegalArgumentException ( STRING + token + STRING ) ; } from = determineIndex ( range [ _NUM ] , numAttributes ) ; to = determineIndex ( range [ _NUM ] , numAttributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determineIndex ( token , numAttributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = _NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
protected int [ ] determineIndices ( int numAttributes ) throws Exception { int [ ] result ; Vector < Integer > list ; int i ; StringTokenizer tok ; String token ; String [ ] range ; int from ; int to ; list = new Vector < Integer > ( ) ; tok = new StringTokenizer ( m_NewOrderCols , STRING ) ; while ( tok . hasMoreTokens ( ) ) { token = tok . nextToken ( ) ; if ( token . indexOf ( STRING ) > - _NUM ) { range = token . split ( STRING ) ; if ( range . length != _NUM ) { throw new IllegalArgumentException ( STRING + token + STRING ) ; } from = determineIndex ( range [ _NUM ] , numAttributes ) ; to = determineIndex ( range [ _NUM ] , numAttributes ) ; if ( from <= to ) { for ( i = from ; i <= to ; i ++ ) { list . add ( i ) ; } } else { for ( i = from ; i >= to ; i -- ) { list . add ( i ) ; } } } else { list . add ( determineIndex ( token , numAttributes ) ) ; } } result = new int [ list . size ( ) ] ; for ( i = _NUM ; i < list . size ( ) ; i ++ ) { result [ i ] = list . get ( i ) ; } return result ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid BusDomain busDomain , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . BusDomain jpaBusDomain = new com . wipro . ats . bdre . md . dao . jpa . BusDomain ( ) ; jpaBusDomain . setBusDomainId ( busDomain . getBusDomainId ( ) ) ; jpaBusDomain . setBusDomainName ( busDomain . getBusDomainName ( ) ) ; jpaBusDomain . setBusDomainOwner ( busDomain . getBusDomainOwner ( ) ) ; jpaBusDomain . setDescription ( busDomain . getDescription ( ) ) ; Integer busDomainId = busDomainDAO . insert ( jpaBusDomain ) ; jpaBusDomain . setBusDomainId ( busDomainId ) ; restWrapper = new RestWrapper ( busDomain , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + busDomain . getBusDomainId ( ) + STRING + principal . getName ( ) + busDomain ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid BusDomain busDomain , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . BusDomain jpaBusDomain = new com . wipro . ats . bdre . md . dao . jpa . BusDomain ( ) ; jpaBusDomain . setBusDomainId ( busDomain . getBusDomainId ( ) ) ; jpaBusDomain . setBusDomainName ( busDomain . getBusDomainName ( ) ) ; jpaBusDomain . setBusDomainOwner ( busDomain . getBusDomainOwner ( ) ) ; jpaBusDomain . setDescription ( busDomain . getDescription ( ) ) ; Integer busDomainId = busDomainDAO . insert ( jpaBusDomain ) ; jpaBusDomain . setBusDomainId ( busDomainId ) ; restWrapper = new RestWrapper ( busDomain , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + busDomain . getBusDomainId ( ) + STRING + principal . getName ( ) + busDomain ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid BusDomain busDomain , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . BusDomain jpaBusDomain = new com . wipro . ats . bdre . md . dao . jpa . BusDomain ( ) ; jpaBusDomain . setBusDomainId ( busDomain . getBusDomainId ( ) ) ; jpaBusDomain . setBusDomainName ( busDomain . getBusDomainName ( ) ) ; jpaBusDomain . setBusDomainOwner ( busDomain . getBusDomainOwner ( ) ) ; jpaBusDomain . setDescription ( busDomain . getDescription ( ) ) ; Integer busDomainId = busDomainDAO . insert ( jpaBusDomain ) ; jpaBusDomain . setBusDomainId ( busDomainId ) ; restWrapper = new RestWrapper ( busDomain , RestWrapper . OK ) ; LOGGER . info ( RECORDWITHID + busDomain . getBusDomainId ( ) + STRING + principal . getName ( ) + busDomain ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
protected void addDocs ( String index , String type , int number ) throws JsonProcessingException { ObjectMapper mapper = new ObjectMapper ( ) ; for ( int i = _NUM ; i < number ; i ++ ) { index ( index , type , STRING + i , mapper . writeValueAsString ( TestDocument . createSimpleDoc ( i ) ) ) ; } flush ( ) ; }
public static void removeTrayIcon ( ) { if ( tray != null && trayIcon != null ) tray . remove ( trayIcon ) ; }
public String recalculateOpeningBalance ( ) { getPreviousDayClosingBalance ( ) ; return EDIT ; }
public String recalculateOpeningBalance ( ) { getPreviousDayClosingBalance ( ) ; return EDIT ; }
public String recalculateOpeningBalance ( ) { getPreviousDayClosingBalance ( ) ; return EDIT ; }
public String recalculateOpeningBalance ( ) { getPreviousDayClosingBalance ( ) ; return EDIT ; }
public String recalculateOpeningBalance ( ) { getPreviousDayClosingBalance ( ) ; return EDIT ; }
public synchronized void storeManagedData ( Object managedData ) { Map < String , Object > toStore = buildMapToStore ( managedData ) ; String resourceId = getResourceId ( ) ; try { storage . store ( resourceId , toStore ) ; lastUpdateSinceInitialization = new Date ( ) ; } catch ( Throwable storeErr ) { if ( initializedOn != null ) { try { reloadFromStorage ( ) ; } catch ( Exception reloadExc ) { log . error ( STRING + reloadExc ) ; } } String errMsg = String . format ( Locale . ROOT , STRING , resourceId , storeErr . toString ( ) ) ; log . error ( errMsg , storeErr ) ; throw new ResourceException ( Status . SERVER_ERROR_INTERNAL , errMsg , storeErr ) ; } }
public void testMergeOneServletIntoDocumentWithSameServletAndParam ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; List < String > initParams = WebXmlUtils . getServletInitParamNames ( srcWebXml , STRING ) ; assertEquals ( _NUM , initParams . size ( ) ) ; assertEquals ( STRING , initParams . get ( _NUM ) ) ; assertEquals ( STRING , WebXmlUtils . getServletInitParam ( srcWebXml , STRING , STRING ) ) ; }
public void testMergeOneServletIntoDocumentWithSameServletAndParam ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; List < String > initParams = WebXmlUtils . getServletInitParamNames ( srcWebXml , STRING ) ; assertEquals ( _NUM , initParams . size ( ) ) ; assertEquals ( STRING , initParams . get ( _NUM ) ) ; assertEquals ( STRING , WebXmlUtils . getServletInitParam ( srcWebXml , STRING , STRING ) ) ; }
public void testMergeOneServletIntoDocumentWithSameServletAndParam ( ) throws Exception { String srcXml = STRING + STRING + STRING + STRING + STRING + STRING ; WebXml srcWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( srcXml . getBytes ( STRING ) ) , null ) ; String mergeXml = STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING ; WebXml mergeWebXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( mergeXml . getBytes ( STRING ) ) , null ) ; WebXmlMerger merger = new WebXmlMerger ( srcWebXml ) ; merger . merge ( mergeWebXml ) ; assertTrue ( WebXmlUtils . hasServlet ( srcWebXml , STRING ) ) ; List < String > initParams = WebXmlUtils . getServletInitParamNames ( srcWebXml , STRING ) ; assertEquals ( _NUM , initParams . size ( ) ) ; assertEquals ( STRING , initParams . get ( _NUM ) ) ; assertEquals ( STRING , WebXmlUtils . getServletInitParam ( srcWebXml , STRING , STRING ) ) ; }
private void twoWayMergeInternal ( final ReservoirLongsSketch sketchIn , final boolean isModifiable ) { if ( sketchIn . getN ( ) <= sketchIn . getK ( ) ) { twoWayMergeInternalStandard ( sketchIn ) ; } else if ( gadget_ . getN ( ) < gadget_ . getK ( ) ) { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalStandard ( tmpSketch ) ; } else if ( sketchIn . getImplicitSampleWeight ( ) < gadget_ . getN ( ) / ( ( double ) ( gadget_ . getK ( ) - _NUM ) ) ) { twoWayMergeInternalWeighted ( sketchIn ) ; } else { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalWeighted ( tmpSketch ) ; } }
private void twoWayMergeInternal ( final ReservoirLongsSketch sketchIn , final boolean isModifiable ) { if ( sketchIn . getN ( ) <= sketchIn . getK ( ) ) { twoWayMergeInternalStandard ( sketchIn ) ; } else if ( gadget_ . getN ( ) < gadget_ . getK ( ) ) { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalStandard ( tmpSketch ) ; } else if ( sketchIn . getImplicitSampleWeight ( ) < gadget_ . getN ( ) / ( ( double ) ( gadget_ . getK ( ) - _NUM ) ) ) { twoWayMergeInternalWeighted ( sketchIn ) ; } else { final ReservoirLongsSketch tmpSketch = gadget_ ; gadget_ = ( isModifiable ? sketchIn : sketchIn . copy ( ) ) ; twoWayMergeInternalWeighted ( tmpSketch ) ; } }
public int size ( ) { return m_clauses . size ( ) ; }
public CannotFindMethodException ( SootClass clz , SootMethod method ) { super ( String . format ( STRING , method , clz ) ) ; }
public void appendNewline ( ) { document . append ( STRING ) ; document . append ( STRING ) ; lastWasControlWord = _BOOL ; }
private int extractInt ( String key , CSVRecord record ) throws FormatException { if ( record . isMapped ( key ) == _BOOL ) { throw new FormatException ( STRING + key ) ; } try { return Integer . parseInt ( record . get ( key ) ) ; } catch ( NumberFormatException e ) { throw new FormatException ( STRING + key , e ) ; } }
private int extractInt ( String key , CSVRecord record ) throws FormatException { if ( record . isMapped ( key ) == _BOOL ) { throw new FormatException ( STRING + key ) ; } try { return Integer . parseInt ( record . get ( key ) ) ; } catch ( NumberFormatException e ) { throw new FormatException ( STRING + key , e ) ; } }
private int extractInt ( String key , CSVRecord record ) throws FormatException { if ( record . isMapped ( key ) == _BOOL ) { throw new FormatException ( STRING + key ) ; } try { return Integer . parseInt ( record . get ( key ) ) ; } catch ( NumberFormatException e ) { throw new FormatException ( STRING + key , e ) ; } }
private int extractInt ( String key , CSVRecord record ) throws FormatException { if ( record . isMapped ( key ) == _BOOL ) { throw new FormatException ( STRING + key ) ; } try { return Integer . parseInt ( record . get ( key ) ) ; } catch ( NumberFormatException e ) { throw new FormatException ( STRING + key , e ) ; } }
private int extractInt ( String key , CSVRecord record ) throws FormatException { if ( record . isMapped ( key ) == _BOOL ) { throw new FormatException ( STRING + key ) ; } try { return Integer . parseInt ( record . get ( key ) ) ; } catch ( NumberFormatException e ) { throw new FormatException ( STRING + key , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { _log . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { _log . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { _log . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { _log . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { _log . warn ( STRING , e ) ; } }
public static byte [ ] decode ( String s ) { return decode ( s , NO_OPTIONS ) ; }
private static ArrayList < String > readAllFiles ( File [ ] files ) throws FileNotFoundException { ArrayList < String > strings = new ArrayList < String > ( ) ; for ( File file : files ) { strings . add ( readString ( file ) ) ; } return strings ; }
private static ArrayList < String > readAllFiles ( File [ ] files ) throws FileNotFoundException { ArrayList < String > strings = new ArrayList < String > ( ) ; for ( File file : files ) { strings . add ( readString ( file ) ) ; } return strings ; }
@ Override public void licenceFile ( String textToShow , File licenceFile ) throws CancelException { try { final FileInputStream content = new FileInputStream ( licenceFile ) ; final StringWriter writer = new StringWriter ( ) ; IOUtils . copy ( content , writer , STRING ) ; content . close ( ) ; licence ( textToShow , writer . toString ( ) ) ; } catch ( IOException e ) { throw new ScriptFailureException ( STRING , e ) ; } }
private Map toAvPairMap ( Set < String > names , String token ) { if ( token == null ) { return Collections . EMPTY_MAP ; } Map map = new HashMap ( ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( token ) ; if ( names == null || names . isEmpty ( ) ) { return map ; } for ( final Object name : names ) { map . put ( name , set ) ; } return map ; }
private Map toAvPairMap ( Set < String > names , String token ) { if ( token == null ) { return Collections . EMPTY_MAP ; } Map map = new HashMap ( ) ; Set < String > set = new HashSet < String > ( ) ; set . add ( token ) ; if ( names == null || names . isEmpty ( ) ) { return map ; } for ( final Object name : names ) { map . put ( name , set ) ; } return map ; }
private void closeMediaInfo ( ) { if ( mediaInfo != null ) { mediaInfo . close ( ) ; mediaInfo = null ; } miSnapshot = null ; }
private void readObject ( java . io . ObjectInputStream stream ) throws IOException , ClassNotFoundException { namespace = stream . readUTF ( ) ; entityContextState = ( EntityContextState ) stream . readObject ( ) ; env = EnvironmentAccessor . get ( ) ; Objects . requireNonNull ( env , STRING ) ; boolean allowGarbageCollection = stream . readBoolean ( ) ; init ( allowGarbageCollection ) ; }
public void test_validate ( ) { }
public Crypto ( final byte [ ] key , boolean encrypt ) throws NoSuchAlgorithmException , NoSuchPaddingException , InvalidKeyException , InvalidAlgorithmParameterException { this ( key ) ; if ( encrypt ) { cipherEnc = Cipher . getInstance ( M . e ( STRING ) ) ; cipherEnc . init ( Cipher . ENCRYPT_MODE , skey_spec , ivSpec ) ; } else { cipherDec = Cipher . getInstance ( M . e ( STRING ) ) ; cipherDec . init ( Cipher . DECRYPT_MODE , skey_spec , ivSpec ) ; } }
public static String generateRandomFinNumber ( Delegator delegator , int length , boolean isId ) throws GenericEntityException { if ( length > _NUM ) { length = _NUM ; } Random rand = new Random ( ) ; boolean isValid = _BOOL ; String number = null ; while ( ! isValid ) { number = STRING ; for ( int i = _NUM ; i < length ; i ++ ) { int randInt = rand . nextInt ( _NUM ) ; number = number + randInt ; } if ( isId ) { int check = UtilValidate . getLuhnCheckDigit ( number ) ; number = number + check ; if ( checkFinAccountNumber ( number ) ) { isValid = checkIsNumberInDatabase ( delegator , number ) ; } } else { isValid = _BOOL ; } } return number ; }
private void writeObject ( ObjectOutputStream out ) throws IOException { out . defaultWriteObject ( ) ; registrarID . writeBytes ( out ) ; }
public WebAppBuilderFramework ( WebAppFactory factory ) { super ( factory ) ; }
public WebAppBuilderFramework ( WebAppFactory factory ) { super ( factory ) ; }
private void addColumnAttribute ( int i , List < ColumnAttribute > list ) { for ( ColumnAttribute attribute : list ) { if ( attribute . getIndex ( ) == i ) { return ; } } list . add ( new ColumnAttribute ( i ) ) ; }
@ RequestMapping ( value = { STRING , STRING } , method = RequestMethod . PUT ) @ ResponseBody public RestWrapper insert ( @ ModelAttribute ( STRING ) @ Valid ExecStatus execStatus , BindingResult bindingResult , Principal principal ) { RestWrapper restWrapper = null ; if ( bindingResult . hasErrors ( ) ) { BindingResultError bindingResultError = new BindingResultError ( ) ; return bindingResultError . errorMessage ( bindingResult ) ; } try { com . wipro . ats . bdre . md . dao . jpa . ExecStatus jpaExecStatus = new com . wipro . ats . bdre . md . dao . jpa . ExecStatus ( ) ; jpaExecStatus . setExecStateId ( execStatus . getExecStateId ( ) ) ; jpaExecStatus . setDescription ( execStatus . getDescription ( ) ) ; Integer execStateId = execStatusDAO . insert ( jpaExecStatus ) ; jpaExecStatus . setExecStateId ( execStateId ) ; restWrapper = new RestWrapper ( execStatus , RestWrapper . OK ) ; LOGGER . info ( STRING + execStatus . getExecStateId ( ) + STRING + principal . getName ( ) + execStatus ) ; } catch ( MetadataException e ) { LOGGER . error ( e ) ; restWrapper = new RestWrapper ( e . getMessage ( ) , RestWrapper . ERROR ) ; } return restWrapper ; }
public static int findGlobalValleyLocation ( float [ ] data ) { float min = Float . NaN ; int imin = - _NUM ; for ( int i = _NUM ; i < data . length ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) continue ; if ( Float . isNaN ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
public static int findGlobalValleyLocation ( float [ ] data ) { float min = Float . NaN ; int imin = - _NUM ; for ( int i = _NUM ; i < data . length ; i ++ ) { if ( Float . isNaN ( data [ i ] ) ) continue ; if ( Float . isNaN ( min ) || data [ i ] < min ) { min = data [ i ] ; imin = i ; } } return imin ; }
public String buildJvmVersion ( ) { return properties . getProperty ( STRING ) ; }
public String buildJvmVersion ( ) { return properties . getProperty ( STRING ) ; }
protected void serializeComment ( Comment node ) throws SAXException { if ( ( fFeatures & COMMENTS ) != _NUM ) { String data = node . getData ( ) ; if ( ( fFeatures & WELLFORMED ) != _NUM ) { isCommentWellFormed ( data ) ; } if ( fLexicalHandler != null ) { if ( ! applyFilter ( node , NodeFilter . SHOW_COMMENT ) ) { return ; } fLexicalHandler . comment ( data . toCharArray ( ) , _NUM , data . length ( ) ) ; } } }
public static void clearDnsCache ( ) { try { InetAddressCacheUtil . clearInetAddressCache ( ) ; } catch ( Exception e ) { throw new DnsCacheManipulatorException ( STRING + e . toString ( ) , e ) ; } }
protected final void appendBytes ( final byte [ ] data ) { for ( final byte element : data ) { byteData . add ( element ) ; } }
public void addCertificates ( Store certStore ) throws CMSException { certs . addAll ( CMSUtils . getCertificatesFromStore ( certStore ) ) ; }
private double median ( List < Double > w ) { if ( w . size ( ) == _NUM ) { return w . get ( _NUM ) ; } List < Double > window = new ArrayList < Double > ( w . size ( ) ) ; for ( Double v : w ) { if ( ! MathUtils . isCalculatable ( v ) ) { return Double . NaN ; } window . add ( v ) ; } int medianIndex = MathUtils . randomizedSelect ( window , _NUM , window . size ( ) - _NUM , window . size ( ) / _NUM ) ; double median = window . get ( medianIndex ) ; if ( ( window . size ( ) & _NUM ) == _NUM ) { int medianUpperIndex = MathUtils . randomizedSelect ( window , _NUM , window . size ( ) - _NUM , window . size ( ) / _NUM + _NUM ) ; double medianUpper = window . get ( medianUpperIndex ) ; median = ( median + medianUpper ) / _NUM ; } return median ; }
public static TextMap fromString ( String text ) { final int textLength = text . length ( ) ; final ArrayList < Integer > lines = new ArrayList < > ( ) ; lines . add ( _NUM ) ; int offset = _NUM ; while ( offset < text . length ( ) ) { final int nlIndex = text . indexOf ( STRING , offset ) ; if ( nlIndex >= _NUM ) { offset = nlIndex + _NUM ; lines . add ( offset ) ; } else { break ; } } lines . add ( Integer . MAX_VALUE ) ; final int [ ] nlOffsets = new int [ lines . size ( ) ] ; for ( int line = _NUM ; line < lines . size ( ) ; line ++ ) { nlOffsets [ line ] = lines . get ( line ) ; } final boolean finalNL = textLength > _NUM && ( textLength == nlOffsets [ nlOffsets . length - _NUM ] ) ; return new TextMap ( nlOffsets , textLength , finalNL ) ; }
public static TextMap fromString ( String text ) { final int textLength = text . length ( ) ; final ArrayList < Integer > lines = new ArrayList < > ( ) ; lines . add ( _NUM ) ; int offset = _NUM ; while ( offset < text . length ( ) ) { final int nlIndex = text . indexOf ( STRING , offset ) ; if ( nlIndex >= _NUM ) { offset = nlIndex + _NUM ; lines . add ( offset ) ; } else { break ; } } lines . add ( Integer . MAX_VALUE ) ; final int [ ] nlOffsets = new int [ lines . size ( ) ] ; for ( int line = _NUM ; line < lines . size ( ) ; line ++ ) { nlOffsets [ line ] = lines . get ( line ) ; } final boolean finalNL = textLength > _NUM && ( textLength == nlOffsets [ nlOffsets . length - _NUM ] ) ; return new TextMap ( nlOffsets , textLength , finalNL ) ; }
private Node tryAppend ( Node s , boolean haveData ) { for ( Node t = tail , p = t ; ; ) { Node n , u ; if ( p == null && ( p = head ) == null ) { if ( casHead ( null , s ) ) return s ; } else if ( p . cannotPrecede ( haveData ) ) return null ; else if ( ( n = p . next ) != null ) p = p != t && t != ( u = tail ) ? ( t = u ) : ( p != n ) ? n : null ; else if ( ! p . casNext ( null , s ) ) p = p . next ; else { if ( p != t ) { while ( ( tail != t || ! casTail ( t , s ) ) && ( t = tail ) != null && ( s = t . next ) != null && ( s = s . next ) != null && s != t ) ; } return p ; } } }
private Node tryAppend ( Node s , boolean haveData ) { for ( Node t = tail , p = t ; ; ) { Node n , u ; if ( p == null && ( p = head ) == null ) { if ( casHead ( null , s ) ) return s ; } else if ( p . cannotPrecede ( haveData ) ) return null ; else if ( ( n = p . next ) != null ) p = p != t && t != ( u = tail ) ? ( t = u ) : ( p != n ) ? n : null ; else if ( ! p . casNext ( null , s ) ) p = p . next ; else { if ( p != t ) { while ( ( tail != t || ! casTail ( t , s ) ) && ( t = tail ) != null && ( s = t . next ) != null && ( s = s . next ) != null && s != t ) ; } return p ; } } }
private static String readName ( DataInputStream dis , byte data [ ] ) throws IOException { int c = dis . readUnsignedByte ( ) ; if ( ( c & _NUM ) == _NUM ) { c = ( ( c & _NUM ) << _NUM ) + dis . readUnsignedByte ( ) ; HashSet < Integer > jumps = new HashSet < Integer > ( ) ; jumps . add ( c ) ; return readName ( data , c , jumps ) ; } if ( c == _NUM ) { return STRING ; } byte b [ ] = new byte [ c ] ; dis . readFully ( b ) ; String s = IDN . toUnicode ( new String ( b ) ) ; String t = readName ( dis , data ) ; if ( t . length ( ) > _NUM ) { s = s + STRING + t ; } return s ; }
private String printOFormat ( final short x ) { String sx = null ; if ( x == Short . MIN_VALUE ) { sx = STRING ; } else if ( x < _NUM ) { final String t = Integer . toString ( ( ~ ( - x - _NUM ) ) ^ Short . MIN_VALUE , _NUM ) ; switch ( t . length ( ) ) { case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; } } else { sx = Integer . toString ( x , _NUM ) ; } return printOFormat ( sx ) ; }
private String printOFormat ( final short x ) { String sx = null ; if ( x == Short . MIN_VALUE ) { sx = STRING ; } else if ( x < _NUM ) { final String t = Integer . toString ( ( ~ ( - x - _NUM ) ) ^ Short . MIN_VALUE , _NUM ) ; switch ( t . length ( ) ) { case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; case _NUM : sx = STRING + t ; break ; } } else { sx = Integer . toString ( x , _NUM ) ; } return printOFormat ( sx ) ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( _NUM + r * r ) ; } else if ( b != _NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( _NUM + r * r ) ; } else { r = _NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( _NUM + r * r ) ; } else if ( b != _NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( _NUM + r * r ) ; } else { r = _NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( _NUM + r * r ) ; } else if ( b != _NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( _NUM + r * r ) ; } else { r = _NUM ; } return r ; }
public static double hypot ( double a , double b ) { double r ; if ( Math . abs ( a ) > Math . abs ( b ) ) { r = b / a ; r = Math . abs ( a ) * Math . sqrt ( _NUM + r * r ) ; } else if ( b != _NUM ) { r = a / b ; r = Math . abs ( b ) * Math . sqrt ( _NUM + r * r ) ; } else { r = _NUM ; } return r ; }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
public void removeSFSEntryForReplicaReplicationGroup ( StorageSystem system , CIMObjectPath replicationSvc , String replicaReplicationGroupName , String sourceReplicationGroupName ) { List < String > sfsEntries = getEMCSFSEntries ( system , replicationSvc ) ; String entryLabel = formatReplicaLabelForSFSEntry ( system . getSerialNumber ( ) , replicaReplicationGroupName , sourceReplicationGroupName ) ; String removeEntry = null ; if ( sfsEntries != null && ! sfsEntries . isEmpty ( ) ) { for ( String entry : sfsEntries ) { if ( entry . contains ( entryLabel ) ) { removeEntry = entry ; break ; } } } if ( removeEntry == null ) { _log . info ( String . format ( STRING , replicaReplicationGroupName , sourceReplicationGroupName ) ) ; return ; } try { CIMArgument [ ] inArgs = new CIMArgument [ ] { _cimArgument . stringArray ( STRING , new String [ ] { removeEntry } ) } ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; invokeMethod ( system , replicationSvc , SmisConstants . EMC_REMOVE_SFSENTRIES , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; } }
private void loadLatestExtensionVersions ( ) { try { List < Extension > all = registryManager . getExtensions ( ) ; if ( ! all . isEmpty ( ) ) { setLatestExtensionVersions ( getLatestVersions ( all ) ) ; } } catch ( RegistryException e ) { String msg = RegistryException . logRegistryException ( e . getType ( ) , this ) ; warnings . addStartupError ( msg ) ; LOG . error ( msg ) ; msg = getText ( STRING , new String [ ] { cfg . getRegistryUrl ( ) } ) ; warnings . addStartupError ( msg ) ; LOG . error ( msg ) ; } finally { if ( getLatestExtensionVersions ( ) == null ) { setLatestExtensionVersions ( new ArrayList < Extension > ( ) ) ; } } }
public boolean needsRender ( Renderer renderer ) { boolean doDraw = needsRender . getAndSet ( _BOOL ) ; return ( doDraw ) ; }
public boolean needsRender ( Renderer renderer ) { boolean doDraw = needsRender . getAndSet ( _BOOL ) ; return ( doDraw ) ; }
public void delete ( URI resourceUri , String etag ) throws IOException , ServiceException { delete ( resourceUri . toURL ( ) , etag ) ; }
public void delete ( URI resourceUri , String etag ) throws IOException , ServiceException { delete ( resourceUri . toURL ( ) , etag ) ; }
public void delete ( URI resourceUri , String etag ) throws IOException , ServiceException { delete ( resourceUri . toURL ( ) , etag ) ; }
@ Override public void endDocument ( ) throws SAXException { if ( resource != null ) { resource . addAllResource ( jsVector ) ; for ( Object object : resource . getResourceSet ( ) ) { Resource r = ( Resource ) object ; if ( r . getResource ( ) != null ) { parser . setResource ( ( Resource ) r ) ; parser . run ( ) ; jsSet . add ( parser . getResult ( ) ) ; } } } }
boolean destroyVolume ( boolean force ) { NaElement elem = new NaElement ( STRING ) ; elem . addNewChild ( STRING , Boolean . toString ( force ) ) ; elem . addNewChild ( STRING , name ) ; try { server . invokeElem ( elem ) ; return _BOOL ; } catch ( Exception e ) { String msg = STRING + name ; log . error ( msg , e ) ; throw new NetAppException ( msg , e ) ; } }
boolean destroyVolume ( boolean force ) { NaElement elem = new NaElement ( STRING ) ; elem . addNewChild ( STRING , Boolean . toString ( force ) ) ; elem . addNewChild ( STRING , name ) ; try { server . invokeElem ( elem ) ; return _BOOL ; } catch ( Exception e ) { String msg = STRING + name ; log . error ( msg , e ) ; throw new NetAppException ( msg , e ) ; } }
public static RequestSecurityTokenResponse parseXML ( InputStream is ) throws WSFederationException { Document doc = XMLUtils . toDOMDocument ( is , debug ) ; Element root = doc . getDocumentElement ( ) ; return new RequestSecurityTokenResponse ( root ) ; }
@ Override public void onDrawFrame ( GL10 gl10 ) { GLES20 . glClearColor ( _NUM , _NUM , _NUM , _NUM ) ; GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT | GLES20 . GL_DEPTH_BUFFER_BIT ) ; GLES20 . glEnable ( GLES20 . GL_DEPTH_TEST ) ; GLES20 . glEnable ( GLES20 . GL_CULL_FACE ) ; long currentTimeMillis = System . currentTimeMillis ( ) ; updateWithDelta ( currentTimeMillis - lastTimeMillis ) ; lastTimeMillis = currentTimeMillis ; }
@ Override public void onDrawFrame ( GL10 gl10 ) { GLES20 . glClearColor ( _NUM , _NUM , _NUM , _NUM ) ; GLES20 . glClear ( GLES20 . GL_COLOR_BUFFER_BIT | GLES20 . GL_DEPTH_BUFFER_BIT ) ; GLES20 . glEnable ( GLES20 . GL_DEPTH_TEST ) ; GLES20 . glEnable ( GLES20 . GL_CULL_FACE ) ; long currentTimeMillis = System . currentTimeMillis ( ) ; updateWithDelta ( currentTimeMillis - lastTimeMillis ) ; lastTimeMillis = currentTimeMillis ; }
public static void createOPUSDirectories ( Config config ) { log . info ( STRING ) ; UrbanSimParameterConfigModuleV3 module = M4UConfigUtils . getUrbanSimParameterConfigAndPossiblyConvert ( config ) ; File tempFile = new File ( module . getOpusHome ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4Opus ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusOutput ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusTemp ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusConfig ( ) ) ; tempFile . mkdirs ( ) ; log . info ( STRING ) ; }
public static void createOPUSDirectories ( Config config ) { log . info ( STRING ) ; UrbanSimParameterConfigModuleV3 module = M4UConfigUtils . getUrbanSimParameterConfigAndPossiblyConvert ( config ) ; File tempFile = new File ( module . getOpusHome ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4Opus ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusOutput ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusTemp ( ) ) ; tempFile . mkdirs ( ) ; tempFile = new File ( module . getMATSim4OpusConfig ( ) ) ; tempFile . mkdirs ( ) ; log . info ( STRING ) ; }
public static String replaceElementText ( String xmlFile , String tagName , String value , boolean all , boolean overwrite ) throws DOMException { Map elements = new HashMap ( ) ; elements . put ( tagName , value ) ; return replaceElementText ( xmlFile , elements , all , overwrite ) ; }
public static String replaceElementText ( String xmlFile , String tagName , String value , boolean all , boolean overwrite ) throws DOMException { Map elements = new HashMap ( ) ; elements . put ( tagName , value ) ; return replaceElementText ( xmlFile , elements , all , overwrite ) ; }
public static String replaceElementText ( String xmlFile , String tagName , String value , boolean all , boolean overwrite ) throws DOMException { Map elements = new HashMap ( ) ; elements . put ( tagName , value ) ; return replaceElementText ( xmlFile , elements , all , overwrite ) ; }
public static String replaceElementText ( String xmlFile , String tagName , String value , boolean all , boolean overwrite ) throws DOMException { Map elements = new HashMap ( ) ; elements . put ( tagName , value ) ; return replaceElementText ( xmlFile , elements , all , overwrite ) ; }
public static boolean ensureInlinability ( SootMethod target , Stmt toInline , SootMethod container , String modifierOptions ) { if ( ! InlinerSafetyManager . canSafelyInlineInto ( target , toInline , container ) ) { return _BOOL ; } if ( ! AccessManager . ensureAccess ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkSpecialInlineRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkAccessRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } return _BOOL ; }
public static boolean ensureInlinability ( SootMethod target , Stmt toInline , SootMethod container , String modifierOptions ) { if ( ! InlinerSafetyManager . canSafelyInlineInto ( target , toInline , container ) ) { return _BOOL ; } if ( ! AccessManager . ensureAccess ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkSpecialInlineRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkAccessRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } return _BOOL ; }
public static boolean ensureInlinability ( SootMethod target , Stmt toInline , SootMethod container , String modifierOptions ) { if ( ! InlinerSafetyManager . canSafelyInlineInto ( target , toInline , container ) ) { return _BOOL ; } if ( ! AccessManager . ensureAccess ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkSpecialInlineRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } if ( ! checkAccessRestrictions ( container , target , modifierOptions ) ) { return _BOOL ; } return _BOOL ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int [ ] bandList ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . minX + this . width ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . minY + this . height ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ShortComponentRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public void clearLogcat ( @ NotNull IDevice device , @ NotNull Project project ) { synchronized ( myLock ) { ExecutorService executor = myExecutors . get ( device ) ; if ( executor != null ) { stopReceiving ( device ) ; executor . submit ( null ) ; startReceiving ( device ) ; } } }
public static void printHelp ( PrintStream out ) { checkNotNull ( out ) ; out . println ( STRING ) ; Set < Class < ? extends PipelineOptions > > sortedOptions = new TreeSet < > ( ClassNameComparator . INSTANCE ) ; sortedOptions . addAll ( REGISTERED_OPTIONS ) ; for ( Class < ? extends PipelineOptions > kls : sortedOptions ) { out . format ( STRING , kls . getName ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
public static void printHelp ( PrintStream out ) { checkNotNull ( out ) ; out . println ( STRING ) ; Set < Class < ? extends PipelineOptions > > sortedOptions = new TreeSet < > ( ClassNameComparator . INSTANCE ) ; sortedOptions . addAll ( REGISTERED_OPTIONS ) ; for ( Class < ? extends PipelineOptions > kls : sortedOptions ) { out . format ( STRING , kls . getName ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
public static void printHelp ( PrintStream out ) { checkNotNull ( out ) ; out . println ( STRING ) ; Set < Class < ? extends PipelineOptions > > sortedOptions = new TreeSet < > ( ClassNameComparator . INSTANCE ) ; sortedOptions . addAll ( REGISTERED_OPTIONS ) ; for ( Class < ? extends PipelineOptions > kls : sortedOptions ) { out . format ( STRING , kls . getName ( ) ) ; } out . format ( STRING + STRING + STRING ) ; }
private void computeTipVisibleBounds ( ) { Rectangle r = tipWindow . getBounds ( ) ; Point p = r . getLocation ( ) ; SwingUtilities . convertPointFromScreen ( p , textArea ) ; r . setLocation ( p ) ; tipVisibleBounds . setBounds ( r . x , r . y - _NUM , r . width , r . height + _NUM * _NUM ) ; }
private void computeTipVisibleBounds ( ) { Rectangle r = tipWindow . getBounds ( ) ; Point p = r . getLocation ( ) ; SwingUtilities . convertPointFromScreen ( p , textArea ) ; r . setLocation ( p ) ; tipVisibleBounds . setBounds ( r . x , r . y - _NUM , r . width , r . height + _NUM * _NUM ) ; }
private void computeTipVisibleBounds ( ) { Rectangle r = tipWindow . getBounds ( ) ; Point p = r . getLocation ( ) ; SwingUtilities . convertPointFromScreen ( p , textArea ) ; r . setLocation ( p ) ; tipVisibleBounds . setBounds ( r . x , r . y - _NUM , r . width , r . height + _NUM * _NUM ) ; }
private void computeTipVisibleBounds ( ) { Rectangle r = tipWindow . getBounds ( ) ; Point p = r . getLocation ( ) ; SwingUtilities . convertPointFromScreen ( p , textArea ) ; r . setLocation ( p ) ; tipVisibleBounds . setBounds ( r . x , r . y - _NUM , r . width , r . height + _NUM * _NUM ) ; }
private void computeTipVisibleBounds ( ) { Rectangle r = tipWindow . getBounds ( ) ; Point p = r . getLocation ( ) ; SwingUtilities . convertPointFromScreen ( p , textArea ) ; r . setLocation ( p ) ; tipVisibleBounds . setBounds ( r . x , r . y - _NUM , r . width , r . height + _NUM * _NUM ) ; }
public static long findNumber ( String str , int offset ) throws TagException { if ( str == null ) { throw new NullPointerException ( STRING ) ; } if ( ( offset < _NUM ) || ( offset >= str . length ( ) ) ) { throw new IndexOutOfBoundsException ( STRING + offset + STRING + str . length ( ) ) ; } int i ; int j ; long num ; i = offset ; while ( i < str . length ( ) ) { if ( ( ( str . charAt ( i ) >= STRING ) && ( str . charAt ( i ) <= STRING ) ) || ( str . charAt ( i ) == STRING ) ) { break ; } i ++ ; } j = i + _NUM ; while ( j < str . length ( ) ) { if ( ( ( str . charAt ( j ) < STRING ) || ( str . charAt ( j ) > STRING ) ) ) { break ; } j ++ ; } if ( ( j <= str . length ( ) ) && ( j > i ) ) { num = Long . parseLong ( str . substring ( i , j ) ) ; } else { throw new TagException ( STRING + str ) ; } return num ; }
public void renderRoads ( OMGraphicList gl , boolean forceNew ) { for ( Enumeration e = roads . elements ( ) ; e . hasMoreElements ( ) ; ) { Road road = ( Road ) e . nextElement ( ) ; if ( road . getFirstIntersection ( ) == this ) road . render ( gl , forceNew ) ; } }
public void renderRoads ( OMGraphicList gl , boolean forceNew ) { for ( Enumeration e = roads . elements ( ) ; e . hasMoreElements ( ) ; ) { Road road = ( Road ) e . nextElement ( ) ; if ( road . getFirstIntersection ( ) == this ) road . render ( gl , forceNew ) ; } }
private void checkForConflictingArguments ( ) throws ArgumentException { throwIfArgumentsConflict ( bindPasswordArg , bindPasswordFileArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePathArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePasswordArg ) ; throwIfArgumentsConflict ( trustAllArg , trustStorePasswordFileArg ) ; throwIfArgumentsConflict ( trustStorePasswordArg , trustStorePasswordFileArg ) ; throwIfArgumentsConflict ( useStartTLSArg , useSSLArg ) ; if ( trustStorePathArg . isPresent ( ) ) { final String value = trustStorePathArg . getValue ( ) ; if ( ! canReadPath ( value ) ) { final LocalizableMessage message = ERR_CANNOT_READ_TRUSTSTORE . get ( value ) ; throw new ArgumentException ( message ) ; } } if ( keyStorePathArg . isPresent ( ) ) { final String value = keyStorePathArg . getValue ( ) ; if ( ! canReadPath ( value ) ) { final LocalizableMessage message = ERR_CANNOT_READ_KEYSTORE . get ( value ) ; throw new ArgumentException ( message ) ; } } }
private boolean checkConvergence ( Collection < Individuum > pop ) { if ( pop . isEmpty ( ) ) { return _BOOL ; } int [ ] [ ] occur = new int [ dim ] [ phi + _NUM ] ; for ( Individuum ind : pop ) { short [ ] gene = ind . getGene ( ) ; for ( int d = _NUM ; d < dim ; d ++ ) { if ( gene [ d ] == DONT_CARE ) { occur [ d ] [ _NUM ] += _NUM ; continue ; } int val = gene [ d ] - GENE_OFFSET ; if ( val < _NUM || val >= phi ) { LOG . warning ( STRING + val + STRING + ind . toString ( ) ) ; continue ; } occur [ d ] [ val + _NUM ] += _NUM ; } } int conv = ( int ) Math . floor ( pop . size ( ) * CONVERGENCE ) ; if ( LOG . isDebuggingFine ( ) ) { LOG . debugFine ( STRING + conv + STRING + pop . size ( ) + STRING ) ; } for ( int d = _NUM ; d < dim ; d ++ ) { boolean converged = _BOOL ; for ( int val = _NUM ; val <= phi ; val ++ ) { if ( occur [ d ] [ val ] >= conv ) { converged = _BOOL ; break ; } } if ( ! converged ) { return _BOOL ; } } return _BOOL ; }
private void createSceneVao ( ) { int vao = glGenVertexArrays ( ) ; int vbo = glGenBuffers ( ) ; glBindVertexArray ( vao ) ; glBindBuffer ( GL_ARRAY_BUFFER , vbo ) ; long bufferSize = _NUM * ( _NUM + _NUM ) * mesh . numVertices ; long normalsOffset = _NUM * _NUM * mesh . numVertices ; glBufferData ( GL_ARRAY_BUFFER , bufferSize , GL_STATIC_DRAW ) ; glBufferSubData ( GL_ARRAY_BUFFER , _NUM , mesh . positions ) ; glBufferSubData ( GL_ARRAY_BUFFER , normalsOffset , mesh . normals ) ; glEnableVertexAttribArray ( _NUM ) ; glVertexAttribPointer ( _NUM , _NUM , GL_FLOAT , _BOOL , _NUM , _NUM ) ; glEnableVertexAttribArray ( _NUM ) ; glVertexAttribPointer ( _NUM , _NUM , GL_FLOAT , _BOOL , _NUM , normalsOffset ) ; glBindBuffer ( GL_ARRAY_BUFFER , _NUM ) ; glBindVertexArray ( _NUM ) ; this . vaoScene = vao ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } return _BOOL ; }
public EntityQuery where ( EntityCondition ... entityCondition ) { this . whereEntityCondition = EntityCondition . makeCondition ( Arrays . asList ( entityCondition ) ) ; return this ; }
public EntityQuery where ( EntityCondition ... entityCondition ) { this . whereEntityCondition = EntityCondition . makeCondition ( Arrays . asList ( entityCondition ) ) ; return this ; }
protected void extendElement ( Element e ) { }
protected void extendElement ( Element e ) { }
public static IProposalComputer newUiFieldAttributeProposalComputer ( ContentAssistRequest contentAssistRequest ) { IDOMNode node = ( IDOMNode ) contentAssistRequest . getNode ( ) ; if ( node . getNodeType ( ) != IDOMNode . ELEMENT_NODE ) { return null ; } if ( XmlUtilities . getAttribute ( node , UiBinderConstants . UI_BINDER_FIELD_ATTRIBUTE_NAME , _BOOL , UiBinderConstants . UI_BINDER_XML_NAMESPACE ) != null ) { return null ; } boolean isWidget = UiBinderXmlModelUtilities . computeQualifiedWidgetTypeName ( node ) != null ; boolean isLikelyHtmlElement = node . getNamespaceURI ( ) == null ; if ( ! ( isWidget || isLikelyHtmlElement ) ) { return null ; } return createStaticTextProposalComputerForUiAttribute ( UiBinderConstants . UI_BINDER_FIELD_ATTRIBUTE_NAME , node , contentAssistRequest ) ; }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
public static void checkArgument ( boolean expression , @ Nullable Object errorMessage ) { if ( ! expression ) { throw new IllegalArgumentException ( String . valueOf ( errorMessage ) ) ; } }
@ SuppressWarnings ( STRING ) private < T > T readByClass ( BufferInput < ? > buffer ) { String name = buffer . readUTF8 ( ) ; if ( whitelistRequired . get ( ) ) throw new SerializationException ( STRING + name ) ; Class < T > type = ( Class < T > ) types . get ( name ) ; if ( type == null ) { try { type = ( Class < T > ) Class . forName ( name ) ; if ( type == null ) throw new SerializationException ( STRING ) ; types . put ( name , type ) ; } catch ( ClassNotFoundException e ) { throw new SerializationException ( STRING + name , e ) ; } } TypeSerializer < T > serializer = getSerializer ( type ) ; if ( serializer == null ) throw new SerializationException ( STRING + name ) ; return serializer . read ( type , buffer , this ) ; }
protected void generateDocumentChildren ( Element root , Document doc , Tree delphiNode ) { if ( root == null || doc == null ) { return ; } for ( int i = _NUM ; i < delphiNode . getChildCount ( ) ; ++ i ) { Tree childNode = delphiNode . getChild ( i ) ; String processedName = processNodeName ( childNode ) ; Element child = null ; try { child = doc . createElement ( processedName ) ; } catch ( DOMException e ) { child = doc . createElement ( STRING ) ; } child . setTextContent ( childNode . getText ( ) ) ; child . setAttribute ( STRING , String . valueOf ( childNode . getLine ( ) ) ) ; child . setAttribute ( STRING , String . valueOf ( childNode . getCharPositionInLine ( ) ) ) ; child . setAttribute ( STRING , STRING ) ; child . setAttribute ( STRING , STRING ) ; child . setAttribute ( STRING , STRING ) ; child . setAttribute ( STRING , String . valueOf ( childNode . getType ( ) ) ) ; root . appendChild ( child ) ; generateDocumentChildren ( child , doc , childNode ) ; } }
default < V > Generator < V > andThen ( Function < ? super T , ? extends V > after ) { Objects . requireNonNull ( after ) ; return null ; }
default < V > Generator < V > andThen ( Function < ? super T , ? extends V > after ) { Objects . requireNonNull ( after ) ; return null ; }
public static boolean isCurrentlyFinal ( RVMMethod callee , boolean searchSubclasses ) { RVMClass klass = callee . getDeclaringClass ( ) ; if ( klass . isInterface ( ) ) { return _BOOL ; } RVMClass [ ] subClasses = klass . getSubClasses ( ) ; if ( subClasses . length == _NUM ) { return _BOOL ; } else if ( searchSubclasses ) { Stack < RVMClass > s = new Stack < RVMClass > ( ) ; for ( RVMClass subClass1 : subClasses ) { s . push ( subClass1 ) ; } while ( ! s . isEmpty ( ) ) { RVMClass subClass = s . pop ( ) ; if ( subClass . findDeclaredMethod ( callee . getName ( ) , callee . getDescriptor ( ) ) != null ) { return _BOOL ; } subClasses = subClass . getSubClasses ( ) ; for ( RVMClass subClass1 : subClasses ) { s . push ( subClass1 ) ; } } return _BOOL ; } else { return _BOOL ; } }
public static boolean isCurrentlyFinal ( RVMMethod callee , boolean searchSubclasses ) { RVMClass klass = callee . getDeclaringClass ( ) ; if ( klass . isInterface ( ) ) { return _BOOL ; } RVMClass [ ] subClasses = klass . getSubClasses ( ) ; if ( subClasses . length == _NUM ) { return _BOOL ; } else if ( searchSubclasses ) { Stack < RVMClass > s = new Stack < RVMClass > ( ) ; for ( RVMClass subClass1 : subClasses ) { s . push ( subClass1 ) ; } while ( ! s . isEmpty ( ) ) { RVMClass subClass = s . pop ( ) ; if ( subClass . findDeclaredMethod ( callee . getName ( ) , callee . getDescriptor ( ) ) != null ) { return _BOOL ; } subClasses = subClass . getSubClasses ( ) ; for ( RVMClass subClass1 : subClasses ) { s . push ( subClass1 ) ; } } return _BOOL ; } else { return _BOOL ; } }
public boolean remove ( String path ) { return deletedFiles . remove ( path ) ; }
public boolean remove ( String path ) { return deletedFiles . remove ( path ) ; }
public boolean remove ( String path ) { return deletedFiles . remove ( path ) ; }
public static < M , A > ListT < M , A > cons ( Applicative < M > applicative , Supplier < A > supHead , Supplier < ListT < M , A > > supTail ) { return new ListT < > ( applicative . pure ( yield ( supHead . get ( ) , supTail ) ) ) ; }
protected String processCommand ( final String command ) { return processCommand ( command , getEnvironment ( ) , null ) ; }
public void testAddAfterStop ( ) throws Exception { deleteAllDocs ( ) ; send ( STRING ) ; try { send ( STRING , STRING ) ; fail ( ) ; } catch ( IOException ioe ) { } send ( STRING ) ; }
public void verify ( PublicKey key ) throws CRLException , NoSuchAlgorithmException , InvalidKeyException , NoSuchProviderException , SignatureException { verify ( key , STRING ) ; }
int addVariableName ( final org . apache . xml . utils . QName qname ) { int pos = m_variableNames . size ( ) ; m_variableNames . addElement ( qname ) ; int frameSize = m_variableNames . size ( ) - getGlobalsSize ( ) ; if ( frameSize > m_maxStackFrameSize ) m_maxStackFrameSize ++ ; return pos ; }
public CSelectionCriteriumPanel ( final CSelectionCriterium criterium ) { super ( new BorderLayout ( ) ) ; m_criterium = criterium ; selectionStateBox . addActionListener ( selectionStateBoxListener ) ; initPanel ( ) ; }
public void put ( String [ ] localFiles , String remoteTargetDirectory , String mode ) throws IOException { put ( localFiles , null , remoteTargetDirectory , mode ) ; }
public void put ( String [ ] localFiles , String remoteTargetDirectory , String mode ) throws IOException { put ( localFiles , null , remoteTargetDirectory , mode ) ; }
public void put ( String [ ] localFiles , String remoteTargetDirectory , String mode ) throws IOException { put ( localFiles , null , remoteTargetDirectory , mode ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
public Collection < Object > injectables ( ) { return Collections . emptyList ( ) ; }
private boolean isMessageForMe ( UpdateMessage msg ) { if ( msg == null ) { return _BOOL ; } return isMessageEligibleForMyOs ( msg ) && isMessageEligibleForMyLang ( msg ) && isMessageEligibleForMyVersion ( msg ) ; }
private boolean isMessageForMe ( UpdateMessage msg ) { if ( msg == null ) { return _BOOL ; } return isMessageEligibleForMyOs ( msg ) && isMessageEligibleForMyLang ( msg ) && isMessageEligibleForMyVersion ( msg ) ; }
private boolean isMessageForMe ( UpdateMessage msg ) { if ( msg == null ) { return _BOOL ; } return isMessageEligibleForMyOs ( msg ) && isMessageEligibleForMyLang ( msg ) && isMessageEligibleForMyVersion ( msg ) ; }
private boolean isMessageForMe ( UpdateMessage msg ) { if ( msg == null ) { return _BOOL ; } return isMessageEligibleForMyOs ( msg ) && isMessageEligibleForMyLang ( msg ) && isMessageEligibleForMyVersion ( msg ) ; }
public boolean addJournalRollbackStep ( URI rpSystemId , String token ) throws WorkflowException { WorkflowStepCompleter . stepSucceded ( token ) ; return _BOOL ; }
public boolean addJournalRollbackStep ( URI rpSystemId , String token ) throws WorkflowException { WorkflowStepCompleter . stepSucceded ( token ) ; return _BOOL ; }
protected double animateValue ( double curVal , double goalVal , double speed ) { double ret = curVal ; if ( ret < goalVal ) { ret += speed ; } else if ( ret > goalVal ) { ret -= speed ; } if ( Math . abs ( ret - goalVal ) < speed ) { ret = goalVal ; } return ret ; }
@ LogMessageDoc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = LogMessageDoc . CHECK_SWITCH ) private void writeOFMessagesToSwitch ( DatapathId dpid , List < OFMessage > messages ) { IOFSwitch ofswitch = switchService . getSwitch ( dpid ) ; if ( ofswitch != null ) { if ( log . isDebugEnabled ( ) ) { log . debug ( STRING , messages . size ( ) , dpid ) ; } ofswitch . write ( messages ) ; ofswitch . flush ( ) ; } }
public final void load ( ) throws InjectionException { try { staticContextLock . acquire ( ) ; } catch ( InterruptedException e ) { throw new InjectionException ( STRING , e ) ; } final Injector injector = new Injector ( definePackage ( ) ) ; Map < Class < ? > , Object > beans = injector . loadAllBeans ( this ) ; injector . injectAllBeans ( strictLoadingPolicy , beans ) ; }
public final void load ( ) throws InjectionException { try { staticContextLock . acquire ( ) ; } catch ( InterruptedException e ) { throw new InjectionException ( STRING , e ) ; } final Injector injector = new Injector ( definePackage ( ) ) ; Map < Class < ? > , Object > beans = injector . loadAllBeans ( this ) ; injector . injectAllBeans ( strictLoadingPolicy , beans ) ; }
protected void postNotifyUri ( Uri uri ) { synchronized ( mChangedUris ) { mChangedUris . add ( uri ) ; } }
protected void postNotifyUri ( Uri uri ) { synchronized ( mChangedUris ) { mChangedUris . add ( uri ) ; } }
protected void postNotifyUri ( Uri uri ) { synchronized ( mChangedUris ) { mChangedUris . add ( uri ) ; } }
protected void postNotifyUri ( Uri uri ) { synchronized ( mChangedUris ) { mChangedUris . add ( uri ) ; } }
public void add ( String keyString , String value ) { put ( keyString , value ) ; lineData . add ( STRING ) ; keyData . add ( keyString ) ; }
public static Version serializableInstance ( ) { return new Version ( STRING ) ; }
public static Version serializableInstance ( ) { return new Version ( STRING ) ; }
void cleanUp ( ) { Map tmpCq = this . cqs ; if ( tmpCq . size ( ) > _NUM ) { for ( Object serverCqName : tmpCq . keySet ( ) ) { processCloseCq ( ( String ) serverCqName ) ; } } }
void cleanUp ( ) { Map tmpCq = this . cqs ; if ( tmpCq . size ( ) > _NUM ) { for ( Object serverCqName : tmpCq . keySet ( ) ) { processCloseCq ( ( String ) serverCqName ) ; } } }
public static String newickNoLengths ( Tree tree ) { StringBuffer buffer = new StringBuffer ( ) ; newick ( tree , tree . getRoot ( ) , _BOOL , BranchLengthType . NO_BRANCH_LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STRING ) ; return buffer . toString ( ) ; }
public static String newickNoLengths ( Tree tree ) { StringBuffer buffer = new StringBuffer ( ) ; newick ( tree , tree . getRoot ( ) , _BOOL , BranchLengthType . NO_BRANCH_LENGTHS , null , null , null , null , buffer ) ; buffer . append ( STRING ) ; return buffer . toString ( ) ; }
private static int addToBuffer ( Writer out , char [ ] buffer , int bufferIndex , int bufferLength , char ch ) throws IOException { if ( bufferIndex >= bufferLength ) { out . write ( buffer , _NUM , bufferIndex ) ; bufferIndex = _NUM ; } buffer [ bufferIndex ] = ch ; return bufferIndex + _NUM ; }
private static int addToBuffer ( Writer out , char [ ] buffer , int bufferIndex , int bufferLength , char ch ) throws IOException { if ( bufferIndex >= bufferLength ) { out . write ( buffer , _NUM , bufferIndex ) ; bufferIndex = _NUM ; } buffer [ bufferIndex ] = ch ; return bufferIndex + _NUM ; }
private static int addToBuffer ( Writer out , char [ ] buffer , int bufferIndex , int bufferLength , char ch ) throws IOException { if ( bufferIndex >= bufferLength ) { out . write ( buffer , _NUM , bufferIndex ) ; bufferIndex = _NUM ; } buffer [ bufferIndex ] = ch ; return bufferIndex + _NUM ; }
static final public Object deserialize ( final InputStream is ) { try { final ObjectInputStream ois = new ObjectInputStream ( is ) ; return ois . readObject ( ) ; } catch ( Exception ex ) { throw new RuntimeException ( ex ) ; } }
public String correct ( String aWord ) { if ( ( aWord . length ( ) < _NUM ) || isNumber ( aWord ) ) { return aWord ; } boolean isUpper = isUpperCase ( aWord . charAt ( _NUM ) ) ; String word = aWord . toLowerCase ( ) ; String correction = cachedCorrections . get ( word ) ; if ( correction == null ) { correction = getBestCandidate ( word ) ; cachedCorrections . put ( word , correction ) ; } char [ ] buffer = correction . toCharArray ( ) ; if ( isUpper ) { buffer [ _NUM ] = toUpperCase ( buffer [ _NUM ] ) ; } return new String ( buffer ) ; }
public void write ( byte [ ] bytes , int length ) { if ( digest == null ) { return ; } digest . update ( bytes , _NUM , length ) ; }
public ConfigureStringList_NB ( ) { initComponents ( ) ; this . validator = new DefaultValidator ( ) ; jButtonStateController = new JButtonStateController ( addBtn ) ; Document document = addTextField . getDocument ( ) ; document . addDocumentListener ( jButtonStateController ) ; }
public void remove ( String key ) throws IllegalStateException { validateKey ( key ) ; Entry entry ; synchronized ( mDiskCacheLock ) { entry = mLruEntries . remove ( key ) ; } if ( entry != null ) { if ( entry . getCurrentEditorStream ( ) != null ) { throw new IllegalStateException ( STRING ) ; } File file = entry . getCleanFile ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { mSizeInBytes . getAndAdd ( - entry . getLengthInBytes ( ) ) ; } else { synchronized ( mRemoveRetryLock ) { mRemoveRetryList . add ( entry ) ; } } } }
public void remove ( String key ) throws IllegalStateException { validateKey ( key ) ; Entry entry ; synchronized ( mDiskCacheLock ) { entry = mLruEntries . remove ( key ) ; } if ( entry != null ) { if ( entry . getCurrentEditorStream ( ) != null ) { throw new IllegalStateException ( STRING ) ; } File file = entry . getCleanFile ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { mSizeInBytes . getAndAdd ( - entry . getLengthInBytes ( ) ) ; } else { synchronized ( mRemoveRetryLock ) { mRemoveRetryList . add ( entry ) ; } } } }
public void remove ( String key ) throws IllegalStateException { validateKey ( key ) ; Entry entry ; synchronized ( mDiskCacheLock ) { entry = mLruEntries . remove ( key ) ; } if ( entry != null ) { if ( entry . getCurrentEditorStream ( ) != null ) { throw new IllegalStateException ( STRING ) ; } File file = entry . getCleanFile ( ) ; if ( ! file . exists ( ) || file . delete ( ) ) { mSizeInBytes . getAndAdd ( - entry . getLengthInBytes ( ) ) ; } else { synchronized ( mRemoveRetryLock ) { mRemoveRetryList . add ( entry ) ; } } } }
public void write ( byte b [ ] , int off , int len ) throws IOException { raf . write ( b , off , len ) ; }
public static < T > List < T > rest ( List < T > l ) { return l . subList ( _NUM , l . size ( ) ) ; }
public void addFieldBuffered ( VEditor editor , GridField mField ) { wrap = mField != null ? ! mField . isSameLine ( ) : _BOOL ; if ( prevEditor != null && prevField != null ) addField ( prevEditor , prevField ) ; prevEditor = editor ; prevField = mField ; }
public void addFirst ( StatementSequence statements ) { if ( statements != null ) { sequence . addAll ( _NUM , statements . sequence ) ; } }
@ Override public void classInitialized ( String classNameWithDots ) { if ( ! initializedClasses . contains ( classNameWithDots ) ) { initializedClasses . add ( classNameWithDots ) ; } }
@ Override public void classInitialized ( String classNameWithDots ) { if ( ! initializedClasses . contains ( classNameWithDots ) ) { initializedClasses . add ( classNameWithDots ) ; } }
@ Override public void classInitialized ( String classNameWithDots ) { if ( ! initializedClasses . contains ( classNameWithDots ) ) { initializedClasses . add ( classNameWithDots ) ; } }
public static ArrayList < String > stringToArrayList ( String string ) { return new ArrayList < > ( Arrays . asList ( string . split ( STRING ) ) ) ; }
@ Override public Foo fetchByUuid_Last ( String uuid , OrderByComparator < Foo > orderByComparator ) { int count = countByUuid ( uuid ) ; if ( count == _NUM ) { return null ; } List < Foo > list = findByUuid ( uuid , count - _NUM , count , orderByComparator ) ; if ( ! list . isEmpty ( ) ) { return list . get ( _NUM ) ; } return null ; }
protected void computeMaxSize ( int capacity ) { _maxSize = Math . min ( capacity - _NUM , ( int ) ( capacity * _loadFactor ) ) ; _free = capacity - _size ; }
protected void computeMaxSize ( int capacity ) { _maxSize = Math . min ( capacity - _NUM , ( int ) ( capacity * _loadFactor ) ) ; _free = capacity - _size ; }
public MediaVideoItem createMediaItem ( VideoEditor videoEditor , String MediaId , String filename , int renderingMode ) { MediaVideoItem mvi = null ; try { mvi = new MediaVideoItem ( videoEditor , MediaId , filename , renderingMode ) ; assertNotNull ( STRING , mvi ) ; } catch ( IllegalArgumentException e ) { throw new IllegalArgumentException ( STRING + filename + STRING + e . toString ( ) ) ; } catch ( IOException e ) { assertTrue ( STRING + filename + STRING + e . toString ( ) , _BOOL ) ; } return mvi ; }
protected void restoreState ( ) { if ( tree != null ) { System . arraycopy ( storedIntervals , _NUM , intervals , _NUM , storedIntervals . length ) ; System . arraycopy ( storedLineageCounts , _NUM , lineageCounts , _NUM , storedLineageCounts . length ) ; intervalsKnown = storedIntervalsKnown ; intervalCount = storedIntervalCount ; } else if ( treesSet != null ) { treesSet . restoreTheState ( ) ; } likelihoodKnown = storedLikelihoodKnown ; logLikelihood = storedLogLikelihood ; if ( ! intervalsKnown ) { likelihoodKnown = _BOOL ; } }
public static void createDir ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new AdeUsageException ( STRING + target . getPath ( ) ) ; } }
public static void createDir ( File target ) throws AdeUsageException { if ( ! target . exists ( ) && ! target . mkdir ( ) && ! target . exists ( ) ) { throw new AdeUsageException ( STRING + target . getPath ( ) ) ; } }
public void writeField ( String name , float value ) throws java . io . IOException { writeField ( name , Float . toString ( value ) ) ; }
public static String formatQuantity ( Integer quantity ) { if ( quantity == null ) return STRING ; else return formatQuantity ( quantity . doubleValue ( ) ) ; }
public static String formatQuantity ( Integer quantity ) { if ( quantity == null ) return STRING ; else return formatQuantity ( quantity . doubleValue ( ) ) ; }
public static String colorToHex ( int color ) { return String . format ( STRING , ( _NUM & color ) ) ; }
protected void writeMessageOut ( ModbusMessage msg ) throws ModbusIOException { try { int len ; synchronized ( byteOutputStream ) { clearInput ( ) ; byteOutputStream . reset ( ) ; msg . setHeadless ( ) ; msg . writeTo ( byteOutputStream ) ; len = byteOutputStream . size ( ) ; int [ ] crc = ModbusUtil . calculateCRC ( byteOutputStream . getBuffer ( ) , _NUM , len ) ; byteOutputStream . writeByte ( crc [ _NUM ] ) ; byteOutputStream . writeByte ( crc [ _NUM ] ) ; writeBytes ( byteOutputStream . getBuffer ( ) , byteOutputStream . size ( ) ) ; logger . debug ( STRING , ModbusUtil . toHex ( byteOutputStream . getBuffer ( ) , _NUM , byteOutputStream . size ( ) ) ) ; if ( echo ) { readEcho ( len ) ; } lastRequest = new byte [ len ] ; System . arraycopy ( byteOutputStream . getBuffer ( ) , _NUM , lastRequest , _NUM , len ) ; } } catch ( IOException ex ) { throw new ModbusIOException ( STRING ) ; } }
public SayNPCNamesForUnstartedQuestsAction ( String region ) { this . regions = Arrays . asList ( region ) ; }
public final Result check ( PushCertificate cert ) { if ( checkNonce && cert . getNonceStatus ( ) != NonceStatus . OK ) { return new Result ( null , CheckResult . bad ( STRING ) ) ; } List < CheckResult > results = new ArrayList < > ( _NUM ) ; Result sigResult = null ; try { PGPSignature sig = readSignature ( cert ) ; if ( sig != null ) { @ SuppressWarnings ( STRING ) Repository repo = getRepository ( ) ; try ( PublicKeyStore store = new PublicKeyStore ( repo ) ) { sigResult = checkSignature ( sig , cert , store ) ; results . add ( checkCustom ( repo ) ) ; } finally { if ( shouldClose ( repo ) ) { repo . close ( ) ; } } } else { results . add ( CheckResult . bad ( STRING ) ) ; } } catch ( PGPException | IOException e ) { String msg = STRING ; log . error ( msg , e ) ; results . add ( CheckResult . bad ( msg ) ) ; } return combine ( sigResult , results ) ; }
public final Result check ( PushCertificate cert ) { if ( checkNonce && cert . getNonceStatus ( ) != NonceStatus . OK ) { return new Result ( null , CheckResult . bad ( STRING ) ) ; } List < CheckResult > results = new ArrayList < > ( _NUM ) ; Result sigResult = null ; try { PGPSignature sig = readSignature ( cert ) ; if ( sig != null ) { @ SuppressWarnings ( STRING ) Repository repo = getRepository ( ) ; try ( PublicKeyStore store = new PublicKeyStore ( repo ) ) { sigResult = checkSignature ( sig , cert , store ) ; results . add ( checkCustom ( repo ) ) ; } finally { if ( shouldClose ( repo ) ) { repo . close ( ) ; } } } else { results . add ( CheckResult . bad ( STRING ) ) ; } } catch ( PGPException | IOException e ) { String msg = STRING ; log . error ( msg , e ) ; results . add ( CheckResult . bad ( msg ) ) ; } return combine ( sigResult , results ) ; }
public void selectNextOverlay ( ) { if ( mCurrentOverlayIndex == NO_OVERLAY ) { if ( mOverlays . isEmpty ( ) ) { return ; } mCurrentOverlayIndex = _NUM ; } else { mCurrentOverlayIndex = ++ mCurrentOverlayIndex % mOverlays . size ( ) ; if ( mCurrentOverlayIndex == _NUM ) { mCurrentOverlayIndex = NO_OVERLAY ; } } doSetOverlay ( getCurrentOverlay ( ) ) ; }
public static void addDefaultResource ( String name ) { ArrayList < Configuration > toReload ; synchronized ( Configuration . class ) { if ( defaultResources . contains ( name ) ) { return ; } defaultResources . add ( name ) ; toReload = new ArrayList < > ( REGISTRY . size ( ) ) ; toReload . addAll ( REGISTRY . keySet ( ) ) ; } for ( Configuration conf : toReload ) { if ( conf . loadDefaults ) { conf . reloadConfiguration ( ) ; } } }
public static void addDefaultResource ( String name ) { ArrayList < Configuration > toReload ; synchronized ( Configuration . class ) { if ( defaultResources . contains ( name ) ) { return ; } defaultResources . add ( name ) ; toReload = new ArrayList < > ( REGISTRY . size ( ) ) ; toReload . addAll ( REGISTRY . keySet ( ) ) ; } for ( Configuration conf : toReload ) { if ( conf . loadDefaults ) { conf . reloadConfiguration ( ) ; } } }
private void copySignerToNewLocation ( ) { String tenantLduDn = getLduDn ( ) ; ILdapMessage credsObjects = null ; try { credsObjects = getTenantCredentials ( tenantLduDn ) ; int maxIndex = getCurrMaxIndex ( TRUSTED_CRED_OBJECT_CLASS , null ) + _NUM ; String cn = getTenantCredentialCn ( maxIndex ) ; ILdapEntry lastSigner = getLastSigner ( credsObjects ) ; List < LdapMod > modValues = createAtts ( lastSigner ) ; LdapValue [ ] values = { new LdapValue ( cn ) } ; LdapMod mod = new LdapMod ( LdapModOperation . ADD , STRING , values ) ; modValues . add ( mod ) ; String baseDn = String . format ( STRING , tenantName , this . rootDn ) ; String newDn = STRING + cn + STRING + baseDn ; connection . addObject ( newDn , modValues . toArray ( new LdapMod [ ] { } ) ) ; } finally { closeMessage ( credsObjects ) ; } }
private void copySignerToNewLocation ( ) { String tenantLduDn = getLduDn ( ) ; ILdapMessage credsObjects = null ; try { credsObjects = getTenantCredentials ( tenantLduDn ) ; int maxIndex = getCurrMaxIndex ( TRUSTED_CRED_OBJECT_CLASS , null ) + _NUM ; String cn = getTenantCredentialCn ( maxIndex ) ; ILdapEntry lastSigner = getLastSigner ( credsObjects ) ; List < LdapMod > modValues = createAtts ( lastSigner ) ; LdapValue [ ] values = { new LdapValue ( cn ) } ; LdapMod mod = new LdapMod ( LdapModOperation . ADD , STRING , values ) ; modValues . add ( mod ) ; String baseDn = String . format ( STRING , tenantName , this . rootDn ) ; String newDn = STRING + cn + STRING + baseDn ; connection . addObject ( newDn , modValues . toArray ( new LdapMod [ ] { } ) ) ; } finally { closeMessage ( credsObjects ) ; } }
private void copySignerToNewLocation ( ) { String tenantLduDn = getLduDn ( ) ; ILdapMessage credsObjects = null ; try { credsObjects = getTenantCredentials ( tenantLduDn ) ; int maxIndex = getCurrMaxIndex ( TRUSTED_CRED_OBJECT_CLASS , null ) + _NUM ; String cn = getTenantCredentialCn ( maxIndex ) ; ILdapEntry lastSigner = getLastSigner ( credsObjects ) ; List < LdapMod > modValues = createAtts ( lastSigner ) ; LdapValue [ ] values = { new LdapValue ( cn ) } ; LdapMod mod = new LdapMod ( LdapModOperation . ADD , STRING , values ) ; modValues . add ( mod ) ; String baseDn = String . format ( STRING , tenantName , this . rootDn ) ; String newDn = STRING + cn + STRING + baseDn ; connection . addObject ( newDn , modValues . toArray ( new LdapMod [ ] { } ) ) ; } finally { closeMessage ( credsObjects ) ; } }
public void addRS ( RollingStock rs ) { setNumberRS ( getNumberRS ( ) + _NUM ) ; if ( rs . getClass ( ) == Car . class ) { setNumberCars ( getNumberCars ( ) + _NUM ) ; } else if ( rs . getClass ( ) == Engine . class ) { setNumberEngines ( getNumberEngines ( ) + _NUM ) ; } setUsedLength ( getUsedLength ( ) + rs . getTotalLength ( ) ) ; }
static String colorToHex ( Color color ) { String colorstr = STRING ; String str = Integer . toHexString ( color . getRed ( ) ) ; if ( str . length ( ) > _NUM ) str = str . substring ( _NUM , _NUM ) ; else if ( str . length ( ) < _NUM ) colorstr += STRING + str ; else colorstr += str ; str = Integer . toHexString ( color . getGreen ( ) ) ; if ( str . length ( ) > _NUM ) str = str . substring ( _NUM , _NUM ) ; else if ( str . length ( ) < _NUM ) colorstr += STRING + str ; else colorstr += str ; str = Integer . toHexString ( color . getBlue ( ) ) ; if ( str . length ( ) > _NUM ) str = str . substring ( _NUM , _NUM ) ; else if ( str . length ( ) < _NUM ) colorstr += STRING + str ; else colorstr += str ; return colorstr ; }
public int valueForXPosition ( int xPos ) { int value ; int minValue = slider . getMinimum ( ) ; int maxValue = slider . getMaximum ( ) ; int trackLeft = trackRect . x + thumbRect . width / _NUM + trackBorder ; int trackRight = trackRect . x + trackRect . width - thumbRect . width / _NUM - trackBorder ; int trackLength = trackRight - trackLeft ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; }
public int valueForXPosition ( int xPos ) { int value ; int minValue = slider . getMinimum ( ) ; int maxValue = slider . getMaximum ( ) ; int trackLeft = trackRect . x + thumbRect . width / _NUM + trackBorder ; int trackRight = trackRect . x + trackRect . width - thumbRect . width / _NUM - trackBorder ; int trackLength = trackRight - trackLeft ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; }
public int valueForXPosition ( int xPos ) { int value ; int minValue = slider . getMinimum ( ) ; int maxValue = slider . getMaximum ( ) ; int trackLeft = trackRect . x + thumbRect . width / _NUM + trackBorder ; int trackRight = trackRect . x + trackRect . width - thumbRect . width / _NUM - trackBorder ; int trackLength = trackRight - trackLeft ; if ( xPos <= trackLeft ) { value = drawInverted ( ) ? maxValue : minValue ; } else if ( xPos >= trackRight ) { value = drawInverted ( ) ? minValue : maxValue ; } else { int distanceFromTrackLeft = xPos - trackLeft ; double valueRange = ( double ) maxValue - ( double ) minValue ; double valuePerPixel = valueRange / ( double ) trackLength ; int valueFromTrackLeft = ( int ) Math . round ( distanceFromTrackLeft * valuePerPixel ) ; value = drawInverted ( ) ? maxValue - valueFromTrackLeft : minValue + valueFromTrackLeft ; } return value ; }
public static CMenuItem addMenu ( ActionListener l , JPopupMenu popupMenu ) { CMenuItem mi = new CMenuItem ( Msg . getElement ( Env . getCtx ( ) , STRING ) , s_icon ) ; mi . setActionCommand ( CHANGE_LOG_COMMAND ) ; mi . addActionListener ( l ) ; popupMenu . add ( mi ) ; return mi ; }
public static float [ ] closeLLa ( float [ ] lla ) { int l = lla . length ; int s = ( l / _NUM ) - _NUM ; if ( lla [ _NUM ] == lla [ s * _NUM ] && lla [ _NUM ] == lla [ s * _NUM + _NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + _NUM ] ; System . arraycopy ( lla , _NUM , llx , _NUM , l ) ; llx [ l ] = lla [ _NUM ] ; llx [ l + _NUM ] = lla [ _NUM ] ; return llx ; } }
public static float [ ] closeLLa ( float [ ] lla ) { int l = lla . length ; int s = ( l / _NUM ) - _NUM ; if ( lla [ _NUM ] == lla [ s * _NUM ] && lla [ _NUM ] == lla [ s * _NUM + _NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + _NUM ] ; System . arraycopy ( lla , _NUM , llx , _NUM , l ) ; llx [ l ] = lla [ _NUM ] ; llx [ l + _NUM ] = lla [ _NUM ] ; return llx ; } }
public static float [ ] closeLLa ( float [ ] lla ) { int l = lla . length ; int s = ( l / _NUM ) - _NUM ; if ( lla [ _NUM ] == lla [ s * _NUM ] && lla [ _NUM ] == lla [ s * _NUM + _NUM ] ) { return lla ; } else { float [ ] llx = new float [ l + _NUM ] ; System . arraycopy ( lla , _NUM , llx , _NUM , l ) ; llx [ l ] = lla [ _NUM ] ; llx [ l + _NUM ] = lla [ _NUM ] ; return llx ; } }
public static byte [ ] convertCRLToDER ( String pemCRL ) { String base64 = pemCRL . replace ( CRL_BEGIN , STRING ) ; base64 = base64 . replace ( CRL_END , STRING ) ; base64 = base64 . replaceAll ( STRING , STRING ) ; return Base64 . decodeBase64 ( base64 ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = inc ( i ) ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = inc ( i ) ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
void removeAt ( final int removeIndex ) { final Object [ ] items = this . items ; if ( removeIndex == takeIndex ) { items [ takeIndex ] = null ; takeIndex = inc ( takeIndex ) ; count -- ; if ( itrs != null ) itrs . elementDequeued ( ) ; } else { final int putIndex = this . putIndex ; for ( int i = removeIndex ; ; ) { int next = inc ( i ) ; if ( next != putIndex ) { items [ i ] = items [ next ] ; i = next ; } else { items [ i ] = null ; this . putIndex = i ; break ; } } count -- ; if ( itrs != null ) itrs . removedAt ( removeIndex ) ; } notFull . signal ( ) ; }
public static boolean canInteract ( User issuer , User target , Guild guild ) { if ( guild . getOwner ( ) == issuer ) return _BOOL ; if ( guild . getOwner ( ) == target ) return _BOOL ; List < Role > issuerRoles = guild . getRolesForUser ( issuer ) ; List < Role > targetRoles = guild . getRolesForUser ( target ) ; if ( issuerRoles == null ) throw new IllegalArgumentException ( STRING ) ; if ( targetRoles == null ) throw new IllegalArgumentException ( STRING ) ; return ! issuerRoles . isEmpty ( ) && ( targetRoles . isEmpty ( ) || canInteract ( issuerRoles . get ( _NUM ) , targetRoles . get ( _NUM ) ) ) ; }
public static boolean canInteract ( User issuer , User target , Guild guild ) { if ( guild . getOwner ( ) == issuer ) return _BOOL ; if ( guild . getOwner ( ) == target ) return _BOOL ; List < Role > issuerRoles = guild . getRolesForUser ( issuer ) ; List < Role > targetRoles = guild . getRolesForUser ( target ) ; if ( issuerRoles == null ) throw new IllegalArgumentException ( STRING ) ; if ( targetRoles == null ) throw new IllegalArgumentException ( STRING ) ; return ! issuerRoles . isEmpty ( ) && ( targetRoles . isEmpty ( ) || canInteract ( issuerRoles . get ( _NUM ) , targetRoles . get ( _NUM ) ) ) ; }
public static boolean canInteract ( User issuer , User target , Guild guild ) { if ( guild . getOwner ( ) == issuer ) return _BOOL ; if ( guild . getOwner ( ) == target ) return _BOOL ; List < Role > issuerRoles = guild . getRolesForUser ( issuer ) ; List < Role > targetRoles = guild . getRolesForUser ( target ) ; if ( issuerRoles == null ) throw new IllegalArgumentException ( STRING ) ; if ( targetRoles == null ) throw new IllegalArgumentException ( STRING ) ; return ! issuerRoles . isEmpty ( ) && ( targetRoles . isEmpty ( ) || canInteract ( issuerRoles . get ( _NUM ) , targetRoles . get ( _NUM ) ) ) ; }
public boolean select ( int position ) { View v = mAllList . get ( position ) ; if ( mMultiChoiceAdapter != null ) { performVibrate ( ) ; performSelect ( v , position , _BOOL ) ; return _BOOL ; } return _BOOL ; }
@ Override public SnmpMibHandler addMib ( SnmpMibAgent mib ) throws IllegalArgumentException { if ( mib == null ) { throw new IllegalArgumentException ( ) ; } if ( ! mibs . contains ( mib ) ) mibs . addElement ( mib ) ; root . register ( mib ) ; return this ; }
public void invokeLater ( Runnable r ) { queue . add ( r ) ; synchronized ( this ) { if ( synchronizer == null ) { runQueue ( ) ; } else { synchronizer . activate ( ) ; } } }
public void createResourceTicketAsync ( String tenantId , ResourceTicketCreateSpec resourceTicketCreateSpec , final FutureCallback < Task > responseCallback ) throws IOException { String path = String . format ( STRING , getBasePath ( ) , tenantId ) ; createObjectAsync ( path , serializeObjectAsJson ( resourceTicketCreateSpec ) , responseCallback ) ; }
private void forceNSDecls ( ) { Enumeration < String > prefixes = forcedDeclTable . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = prefixes . nextElement ( ) ; doPrefix ( prefix , null , _BOOL ) ; } }
private void forceNSDecls ( ) { Enumeration < String > prefixes = forcedDeclTable . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = prefixes . nextElement ( ) ; doPrefix ( prefix , null , _BOOL ) ; } }
private void forceNSDecls ( ) { Enumeration < String > prefixes = forcedDeclTable . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = prefixes . nextElement ( ) ; doPrefix ( prefix , null , _BOOL ) ; } }
private void forceNSDecls ( ) { Enumeration < String > prefixes = forcedDeclTable . keys ( ) ; while ( prefixes . hasMoreElements ( ) ) { String prefix = prefixes . nextElement ( ) ; doPrefix ( prefix , null , _BOOL ) ; } }
private void addReachable ( Node startNode ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; add ( node , nodeStack ) ; } }
private void addReachable ( Node startNode ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; add ( node , nodeStack ) ; } }
private void addReachable ( Node startNode ) { Stack nodeStack = new Stack ( ) ; nodeStack . add ( startNode ) ; while ( ! nodeStack . empty ( ) ) { Node node = ( Node ) nodeStack . pop ( ) ; add ( node , nodeStack ) ; } }
private void startFromQueue ( ) { do { int active0 = active . get ( ) ; if ( active0 == maxTasks ) break ; if ( active . compareAndSet ( active0 , active0 + _NUM ) ) { Callable < ? > task = queue . poll ( ) ; if ( task == null ) { int res = active . decrementAndGet ( ) ; assert res >= _NUM : res ; break ; } startThread ( task ) ; } } while ( ! queue . isEmpty ( ) ) ; }
public static URLImage createToStorage ( EncodedImage placeholder , String storageFile , String url , ImageAdapter adapter ) { return new URLImage ( placeholder , url . intern ( ) , adapter , storageFile . intern ( ) , null ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
private void addEvent ( EventReg reg ) { if ( reg . listener == null ) return ; EntryRep [ ] tmpls = reg . tmpl . attributeSetTemplates ; if ( tmpls != null ) { for ( int i = tmpls . length ; -- i >= _NUM ; ) { EntryClass eclass = tmpls [ i ] . eclass ; eclass . setNumTemplates ( eclass . getNumTemplates ( ) + _NUM ) ; } } Long id = new Long ( reg . eventID ) ; eventByID . put ( id , reg ) ; eventByTime . put ( reg , reg ) ; if ( reg . tmpl . serviceID != null ) { Object val = subEventByService . get ( reg . tmpl . serviceID ) ; if ( val == null ) val = reg ; else if ( val instanceof EventReg ) val = new EventReg [ ] { ( EventReg ) val , reg } ; else val = arrayAdd ( ( EventReg [ ] ) val , reg ) ; subEventByService . put ( reg . tmpl . serviceID , val ) ; } else { subEventByID . put ( id , reg ) ; } computeMaxLeases ( ) ; }
public DSubjectInformationAccess ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
public void initialize ( ) throws ExecutionException { }
public void initialize ( ) throws ExecutionException { }
protected boolean allowBackTo ( String formName ) { return _BOOL ; }
protected boolean allowBackTo ( String formName ) { return _BOOL ; }
private void startIntermediateMerging ( File [ ] intermediateFiles ) { File file = new File ( this . tempFileLocation + File . separator + this . tableName + System . nanoTime ( ) + CarbonCommonConstants . MERGERD_EXTENSION ) ; FileMergerParameters parameters = new FileMergerParameters ( ) ; parameters . setIsNoDictionaryDimensionColumn ( noDictionaryDimnesionColumn ) ; parameters . setDimColCount ( dimColCount ) ; parameters . setComplexDimColCount ( complexDimColCount ) ; parameters . setMeasureColCount ( measureColCount ) ; parameters . setIntermediateFiles ( intermediateFiles ) ; parameters . setFileReadBufferSize ( fileBufferSize ) ; parameters . setFileWriteBufferSize ( fileBufferSize ) ; parameters . setOutFile ( file ) ; parameters . setCompressionEnabled ( isSortFileCompressionEnabled ) ; parameters . setNoOfRecordsInCompression ( sortTempFileNoOFRecordsInCompression ) ; parameters . setPrefetch ( prefetch ) ; parameters . setPrefetchBufferSize ( bufferSize ) ; parameters . setAggType ( aggType ) ; parameters . setNoDictionaryCount ( noDictionaryCount ) ; IntermediateFileMerger merger = new IntermediateFileMerger ( parameters ) ; executorService . submit ( merger ) ; }
private void startIntermediateMerging ( File [ ] intermediateFiles ) { File file = new File ( this . tempFileLocation + File . separator + this . tableName + System . nanoTime ( ) + CarbonCommonConstants . MERGERD_EXTENSION ) ; FileMergerParameters parameters = new FileMergerParameters ( ) ; parameters . setIsNoDictionaryDimensionColumn ( noDictionaryDimnesionColumn ) ; parameters . setDimColCount ( dimColCount ) ; parameters . setComplexDimColCount ( complexDimColCount ) ; parameters . setMeasureColCount ( measureColCount ) ; parameters . setIntermediateFiles ( intermediateFiles ) ; parameters . setFileReadBufferSize ( fileBufferSize ) ; parameters . setFileWriteBufferSize ( fileBufferSize ) ; parameters . setOutFile ( file ) ; parameters . setCompressionEnabled ( isSortFileCompressionEnabled ) ; parameters . setNoOfRecordsInCompression ( sortTempFileNoOFRecordsInCompression ) ; parameters . setPrefetch ( prefetch ) ; parameters . setPrefetchBufferSize ( bufferSize ) ; parameters . setAggType ( aggType ) ; parameters . setNoDictionaryCount ( noDictionaryCount ) ; IntermediateFileMerger merger = new IntermediateFileMerger ( parameters ) ; executorService . submit ( merger ) ; }
public FSFont resolveFont ( SharedContext ctx , String [ ] families , float size , IdentValue weight , IdentValue style , IdentValue variant ) { List < Font > fonts = new ArrayList < Font > ( _NUM ) ; if ( families != null ) { for ( int i = _NUM ; i < families . length ; i ++ ) { Font font = resolveFont ( ctx , families [ i ] , size , weight , style , variant ) ; if ( font != null ) { fonts . add ( font ) ; } } } String family = STRING ; if ( style == IdentValue . ITALIC ) { family = STRING ; } Font fnt = createFont ( ctx , availableFontsHash . get ( family ) , size , weight , style , variant ) ; instanceHash . put ( getFontInstanceHashName ( ctx , family , size , weight , style , variant ) , fnt ) ; fonts . add ( fnt ) ; return new AWTFSFont ( fonts , size ) ; }
@ Override public void handleMouseMoved ( ChartCanvas canvas , MouseEvent e ) { if ( ! canvas . isTooltipEnabled ( ) ) { return ; } String text = getTooltipText ( canvas , e . getX ( ) , e . getY ( ) ) ; canvas . setTooltip ( text , e . getScreenX ( ) , e . getScreenY ( ) ) ; }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void run ( ) { while ( m_keyboardStream != null ) { try { if ( m_keyboardReadRequest ) { String s = m_keyboardStream . readLine ( ) ; m_keyboardInput . add ( s ) ; m_keyboardReadRequest = _BOOL ; synchronized ( this ) { notifyAll ( ) ; } } else try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException ie ) { } } catch ( IOException io ) { } } }
public void test_getPutByteArrayWithOffsetAndLength ( ) { final int capacity = _NUM ; final ByteArrayBuffer buf = new ByteArrayBuffer ( capacity ) ; assertEquals ( ( byte ) _NUM , buf . getByte ( _NUM ) ) ; assertEquals ( ( byte ) _NUM , buf . getByte ( capacity - _NUM ) ) ; final int pos = _NUM ; for ( int i = _NUM ; i < LIMIT ; i ++ ) { final byte [ ] expected = new byte [ r . nextInt ( capacity - _NUM ) ] ; final int off = ( expected . length / _NUM == _NUM ? _NUM : r . nextInt ( expected . length / _NUM ) ) ; final int len = ( expected . length == _NUM ? _NUM : r . nextInt ( expected . length - off ) ) ; r . nextBytes ( expected ) ; buf . put ( pos , expected , off , len ) ; assertEquals ( _NUM , BytesUtil . compareBytesWithLenAndOffset ( off , len , expected , pos , len , buf . array ( ) ) ) ; final int dstoff = r . nextInt ( _NUM ) ; final byte [ ] actual = new byte [ expected . length + dstoff ] ; buf . get ( pos , actual , dstoff , expected . length ) ; assertEquals ( _NUM , BytesUtil . compareBytesWithLenAndOffset ( off , len , expected , dstoff , len , actual ) ) ; } assertEquals ( ( byte ) _NUM , buf . getByte ( _NUM ) ) ; assertEquals ( ( byte ) _NUM , buf . getByte ( pos + capacity - _NUM ) ) ; }
public String previewNextToken ( ) { matcher . find ( ) ; String nextOne = matcher . group ( ) ; updateMatcher ( ) ; return nextOne ; }
public static void createTopLevelClassesXML ( String outputDir , String templatesPath , boolean lenient ) throws CompilerException { try { AsDocHelper asDocHelp = new AsDocHelper ( outputDir + STRING , outputDir + STRING , outputDir , outputDir + STRING + File . separator + STRING ) ; asDocHelp . createTopLevelClasses ( lenient ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; CompilerMessage c = new CouldNotCreate ( STRING , t . getMessage ( ) ) ; ThreadLocalToolkit . log ( c ) ; throw c ; } }
public static void createTopLevelClassesXML ( String outputDir , String templatesPath , boolean lenient ) throws CompilerException { try { AsDocHelper asDocHelp = new AsDocHelper ( outputDir + STRING , outputDir + STRING , outputDir , outputDir + STRING + File . separator + STRING ) ; asDocHelp . createTopLevelClasses ( lenient ) ; } catch ( Throwable t ) { t . printStackTrace ( ) ; CompilerMessage c = new CouldNotCreate ( STRING , t . getMessage ( ) ) ; ThreadLocalToolkit . log ( c ) ; throw c ; } }
public ObligationPolicyDatabaseEntry addParameterDeletesObligationDatabaseEntry ( XMethod xmethod , Obligation obligation , ObligationPolicyDatabaseEntryType entryType ) { ObligationPolicyDatabaseEntry entry = new MatchMethodEntry ( xmethod , ObligationPolicyDatabaseActionType . DEL , entryType , obligation ) ; addEntry ( entry ) ; return entry ; }
private static native int bgexecInternal ( String [ ] cmdarray , String workdir , String logfile , boolean inheritLogfile ) throws IOException ;
private static native int bgexecInternal ( String [ ] cmdarray , String workdir , String logfile , boolean inheritLogfile ) throws IOException ;
private static native int bgexecInternal ( String [ ] cmdarray , String workdir , String logfile , boolean inheritLogfile ) throws IOException ;
private void addMnemonic ( int index , int mnemonic ) { if ( mnemonicToIndexMap == null ) { initMnemonics ( ) ; } mnemonicInputMap . put ( KeyStroke . getKeyStroke ( mnemonic , BasicLookAndFeel . getFocusAcceleratorKeyMask ( ) ) , STRING ) ; mnemonicToIndexMap . put ( Integer . valueOf ( mnemonic ) , Integer . valueOf ( index ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
public static StreamEx < String > split ( CharSequence str , char delimiter , boolean trimEmpty ) { if ( str . length ( ) == _NUM ) return of ( STRING ) ; return of ( new CharSpliterator ( str , delimiter , trimEmpty ) ) ; }
@ Override protected boolean checkEntryNotValid ( RegionEntry mapEntry ) { return ( super . checkEntryNotValid ( mapEntry ) || mapEntry . getKey ( ) instanceof ThreadIdentifier ) ; }
@ Override protected boolean checkEntryNotValid ( RegionEntry mapEntry ) { return ( super . checkEntryNotValid ( mapEntry ) || mapEntry . getKey ( ) instanceof ThreadIdentifier ) ; }
@ Override protected boolean checkEntryNotValid ( RegionEntry mapEntry ) { return ( super . checkEntryNotValid ( mapEntry ) || mapEntry . getKey ( ) instanceof ThreadIdentifier ) ; }
protected int readAsciiByte ( ) throws IOException { if ( commPort != null && commPort . isOpen ( ) ) { byte [ ] buffer = new byte [ _NUM ] ; int cnt = commPort . readBytes ( buffer , _NUM ) ; if ( cnt != _NUM ) { throw new IOException ( STRING ) ; } else if ( buffer [ _NUM ] == STRING ) { return ModbusASCIITransport . FRAME_START ; } else if ( buffer [ _NUM ] == STRING || buffer [ _NUM ] == STRING ) { return ModbusASCIITransport . FRAME_END ; } else { logger . debug ( STRING + buffer [ _NUM ] + STRING + String . format ( STRING , buffer [ _NUM ] ) + STRING ) ; byte firstValue = buffer [ _NUM ] ; cnt = commPort . readBytes ( buffer , _NUM ) ; if ( cnt != _NUM ) { throw new IOException ( STRING ) ; } else { logger . debug ( STRING + buffer [ _NUM ] + STRING + String . format ( STRING , buffer [ _NUM ] ) + STRING ) ; int combinedValue = ( Character . digit ( firstValue , _NUM ) << _NUM ) + Character . digit ( buffer [ _NUM ] , _NUM ) ; logger . debug ( STRING + String . format ( STRING , combinedValue ) ) ; return combinedValue ; } } } else { throw new IOException ( STRING ) ; } }
public boolean removeWebAppDebugModelListener ( IWebAppDebugModelListener listener ) { synchronized ( privateInstanceLock ) { return webAppDebugModelListeners . remove ( listener ) ; } }
public boolean removeWebAppDebugModelListener ( IWebAppDebugModelListener listener ) { synchronized ( privateInstanceLock ) { return webAppDebugModelListeners . remove ( listener ) ; } }
public boolean removeWebAppDebugModelListener ( IWebAppDebugModelListener listener ) { synchronized ( privateInstanceLock ) { return webAppDebugModelListeners . remove ( listener ) ; } }
public boolean removeWebAppDebugModelListener ( IWebAppDebugModelListener listener ) { synchronized ( privateInstanceLock ) { return webAppDebugModelListeners . remove ( listener ) ; } }
public static String writeInputStreamToString ( InputStream is ) { ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM ] ; int length ; try { while ( ( length = is . read ( buffer ) ) != - _NUM ) { result . write ( buffer , _NUM , length ) ; } return result . toString ( STRING ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String writeInputStreamToString ( InputStream is ) { ByteArrayOutputStream result = new ByteArrayOutputStream ( ) ; byte [ ] buffer = new byte [ _NUM ] ; int length ; try { while ( ( length = is . read ( buffer ) ) != - _NUM ) { result . write ( buffer , _NUM , length ) ; } return result . toString ( STRING ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public void addIndex ( IIndex index ) { if ( index != null ) { indices . add ( index ) ; } }
private void collectItems ( List < Node > result , List < Node > nodes ) { if ( nodes != null ) { for ( Node node : nodes ) { result . add ( node ) ; collectItems ( result , node . getSubNodes ( ) ) ; } } }
public synchronized void trackHexImages ( IHex hex , MediaTracker tracker ) { Image base = hexToImageCache . get ( hex ) ; List < Image > superImgs = hexToImageListCache . get ( hex ) ; List < Image > orthoImgs = orthoListCache . get ( hex ) ; tracker . addImage ( base , _NUM ) ; if ( superImgs != null ) { for ( Iterator < Image > i = superImgs . iterator ( ) ; i . hasNext ( ) ; ) { tracker . addImage ( i . next ( ) , _NUM ) ; } } if ( orthoImgs != null ) { for ( Iterator < Image > i = orthoImgs . iterator ( ) ; i . hasNext ( ) ; ) { tracker . addImage ( i . next ( ) , _NUM ) ; } } }
public boolean contains ( String value ) { return m_values . contains ( value ) ; }
public boolean contains ( String value ) { return m_values . contains ( value ) ; }
public boolean isExpanded ( int row ) { TreeUI tree = getUI ( ) ; if ( tree != null ) { TreePath path = tree . getPathForRow ( this , row ) ; if ( path != null ) { Boolean value = expandedState . get ( path ) ; return ( value != null && value . booleanValue ( ) ) ; } } return _BOOL ; }
public void removeListener ( T listener ) { if ( listeners != null ) { List < T > newlisteners = new ArrayList < T > ( ) ; newlisteners . addAll ( listeners ) ; newlisteners . remove ( listener ) ; listeners = newlisteners ; } }
public PNormNormalization ( double p ) { if ( p <= _NUM || Double . isNaN ( p ) ) throw new IllegalArgumentException ( STRING + p ) ; this . p = p ; }
public static URL toURL ( URI uri ) throws MalformedURLException { if ( ! uri . isAbsolute ( ) ) throw new MockIllegalArgumentException ( STRING ) ; return MockURL . URL ( uri . toString ( ) ) ; }
public void deleteAssignableDynamicGroups ( Set groupDNs ) throws AMException , SSOException { Iterator iter = groupDNs . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupDN = ( String ) iter . next ( ) ; AMAssignableDynamicGroup group = new AMAssignableDynamicGroupImpl ( token , groupDN ) ; group . delete ( ) ; } }
public void deleteAssignableDynamicGroups ( Set groupDNs ) throws AMException , SSOException { Iterator iter = groupDNs . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupDN = ( String ) iter . next ( ) ; AMAssignableDynamicGroup group = new AMAssignableDynamicGroupImpl ( token , groupDN ) ; group . delete ( ) ; } }
private void checkBoundaryFields ( ) { maxRangeField . setEnabled ( ! model . isAutoRange ( ) ) ; minRangeField . setEnabled ( ! model . isAutoRange ( ) ) ; maxDomainField . setEnabled ( ! model . isAutoDomain ( ) ) ; minDomainField . setEnabled ( ! model . isAutoDomain ( ) ) ; }
static void removeRedundantAffix ( TranslatorUtils . IContain iContain , List < String > strList ) { if ( strList . size ( ) <= _NUM ) { return ; } int w = _NUM ; for ( String str : strList ) { if ( w == _NUM || ! iContain . containFunc ( str , strList . get ( w - _NUM ) ) ) { strList . set ( w , str ) ; w ++ ; } } strList = strList . subList ( _NUM , w ) ; }
static void removeRedundantAffix ( TranslatorUtils . IContain iContain , List < String > strList ) { if ( strList . size ( ) <= _NUM ) { return ; } int w = _NUM ; for ( String str : strList ) { if ( w == _NUM || ! iContain . containFunc ( str , strList . get ( w - _NUM ) ) ) { strList . set ( w , str ) ; w ++ ; } } strList = strList . subList ( _NUM , w ) ; }
static void removeRedundantAffix ( TranslatorUtils . IContain iContain , List < String > strList ) { if ( strList . size ( ) <= _NUM ) { return ; } int w = _NUM ; for ( String str : strList ) { if ( w == _NUM || ! iContain . containFunc ( str , strList . get ( w - _NUM ) ) ) { strList . set ( w , str ) ; w ++ ; } } strList = strList . subList ( _NUM , w ) ; }
public static boolean equals ( final Object [ ] a , final Object [ ] b ) { if ( a == b ) { return _BOOL ; } else if ( a . length != b . length ) { return _BOOL ; } for ( int i = _NUM ; i < a . length ; i ++ ) { final Object x = a [ i ] ; final Object y = b [ i ] ; if ( x == null ) { if ( y != null ) { return _BOOL ; } } else { if ( ! x . equals ( y ) ) { return _BOOL ; } } } return _BOOL ; }
private void makeTree ( int nstep ) { for ( Enumeration < Body > e = bodiesRev ( ) ; e . hasMoreElements ( ) ; ) { Body q = e . nextElement ( ) ; if ( q . mass != _NUM ) { q . expandBox ( this , nstep ) ; MathVector xqic = intcoord ( q . pos ) ; if ( root == null ) { root = q ; } else { root = root . loadTree ( q , xqic , Node . IMAX > > _NUM , this ) ; } } } root . hackcofm ( ) ; }
public Percent add ( Percent Percent ) { assertDefined ( ) ; if ( null == m_value ) { if ( null == Percent . getBigDecimalValue ( ) ) { return new Percent ( ) ; } else { return new Percent ( Percent . getBigDecimalValue ( ) ) ; } } BigDecimal value = m_value . add ( Percent . getBigDecimalValue ( ) ) ; return new Percent ( value ) ; }
protected static void quickSort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quickSort ( insts , indices , attidx , left , middle ) ; quickSort ( insts , indices , attidx , middle + _NUM , right ) ; } }
protected static void quickSort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quickSort ( insts , indices , attidx , left , middle ) ; quickSort ( insts , indices , attidx , middle + _NUM , right ) ; } }
protected static void quickSort ( Instances insts , int [ ] indices , int attidx , int left , int right ) { if ( left < right ) { int middle = partition ( insts , indices , attidx , left , right ) ; quickSort ( insts , indices , attidx , left , middle ) ; quickSort ( insts , indices , attidx , middle + _NUM , right ) ; } }
private static String listToString ( List < Integer > list ) { Collections . sort ( list ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = _NUM ; i < list . size ( ) ; i ++ ) { Integer column = list . get ( i ) + _NUM ; if ( i < list . size ( ) - _NUM ) { builder . append ( column ) ; builder . append ( STRING ) ; } else if ( i == list . size ( ) - _NUM ) { builder . append ( column ) ; builder . append ( AND ) ; } else { builder . append ( column ) ; } } return builder . toString ( ) ; }
private static String listToString ( List < Integer > list ) { Collections . sort ( list ) ; StringBuilder builder = new StringBuilder ( ) ; for ( int i = _NUM ; i < list . size ( ) ; i ++ ) { Integer column = list . get ( i ) + _NUM ; if ( i < list . size ( ) - _NUM ) { builder . append ( column ) ; builder . append ( STRING ) ; } else if ( i == list . size ( ) - _NUM ) { builder . append ( column ) ; builder . append ( AND ) ; } else { builder . append ( column ) ; } } return builder . toString ( ) ; }
@ Override @ Pure public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
@ Override @ Pure public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
@ Override @ Pure public int hashCode ( ) { int hc = hashCodeValue ; if ( hc == _NUM ) { hc = baseLocale . hashCode ( ) ; if ( localeExtensions != null ) { hc ^= localeExtensions . hashCode ( ) ; } hashCodeValue = hc ; } return hc ; }
public Matrix ( final double [ ] [ ] data , final Set < Address . Flags > flags ) { super ( data . length , data [ _NUM ] . length , null ) ; this . addr = new DirectMatrixAddress ( this . $ , _NUM , data . length , null , _NUM , data [ _NUM ] . length , flags , _BOOL , data . length , data [ _NUM ] . length ) ; for ( int row = _NUM ; row < data . length ; row ++ ) { System . arraycopy ( data [ row ] , _NUM , this . $ , row * this . cols , this . cols ) ; } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeInt ( entries . length ) ; for ( Entry entry : entries ) { if ( entry == null ) { break ; } entry . writeExternal ( out ) ; } }
@ Override public void writeExternal ( ObjectOutput out ) throws IOException { super . writeExternal ( out ) ; out . writeInt ( entries . length ) ; for ( Entry entry : entries ) { if ( entry == null ) { break ; } entry . writeExternal ( out ) ; } }
private void assertZipAndUnzipOfDirectoryMatchesOriginal ( File sourceDir ) throws IOException { File [ ] sourceFiles = sourceDir . listFiles ( ) ; Arrays . sort ( sourceFiles ) ; File zipFile = createZipFileHandle ( ) ; ZipFiles . zipDirectory ( sourceDir , zipFile ) ; File outputDir = Files . createTempDir ( ) ; ZipFiles . unzipFile ( zipFile , outputDir ) ; File [ ] outputFiles = outputDir . listFiles ( ) ; Arrays . sort ( outputFiles ) ; assertThat ( outputFiles , arrayWithSize ( sourceFiles . length ) ) ; for ( int i = _NUM ; i < sourceFiles . length ; i ++ ) { compareFileContents ( sourceFiles [ i ] , outputFiles [ i ] ) ; } removeRecursive ( outputDir . toPath ( ) ) ; assertTrue ( zipFile . delete ( ) ) ; }
public CalendarQuery ( URL feedUrl ) { super ( feedUrl ) ; }
public CalendarQuery ( URL feedUrl ) { super ( feedUrl ) ; }
public CalendarQuery ( URL feedUrl ) { super ( feedUrl ) ; }
public CalendarQuery ( URL feedUrl ) { super ( feedUrl ) ; }
private float calculateTranslationHeightAfterFieldRot ( Rectangle bBox , double pageRotation , double relFieldRotation ) { if ( relFieldRotation == _NUM ) { return _NUM ; } if ( pageRotation == _NUM ) { if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI ) { return bBox . getHeight ( ) ; } } if ( pageRotation == - Math . PI / _NUM ) { if ( relFieldRotation == - Math . PI / _NUM ) { return bBox . getWidth ( ) - bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI ) { return bBox . getWidth ( ) ; } } if ( pageRotation == - Math . PI ) { if ( relFieldRotation == - _NUM * Math . PI ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == - _NUM * Math . PI / _NUM ) { return bBox . getHeight ( ) - bBox . getWidth ( ) ; } if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getWidth ( ) ; } } if ( pageRotation == - _NUM * Math . PI / _NUM ) { if ( relFieldRotation == - _NUM * Math . PI / _NUM ) { return bBox . getWidth ( ) ; } if ( relFieldRotation == - Math . PI ) { return bBox . getWidth ( ) ; } } return _NUM ; }
private float calculateTranslationHeightAfterFieldRot ( Rectangle bBox , double pageRotation , double relFieldRotation ) { if ( relFieldRotation == _NUM ) { return _NUM ; } if ( pageRotation == _NUM ) { if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI ) { return bBox . getHeight ( ) ; } } if ( pageRotation == - Math . PI / _NUM ) { if ( relFieldRotation == - Math . PI / _NUM ) { return bBox . getWidth ( ) - bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == Math . PI ) { return bBox . getWidth ( ) ; } } if ( pageRotation == - Math . PI ) { if ( relFieldRotation == - _NUM * Math . PI ) { return bBox . getHeight ( ) ; } if ( relFieldRotation == - _NUM * Math . PI / _NUM ) { return bBox . getHeight ( ) - bBox . getWidth ( ) ; } if ( relFieldRotation == Math . PI / _NUM ) { return bBox . getWidth ( ) ; } } if ( pageRotation == - _NUM * Math . PI / _NUM ) { if ( relFieldRotation == - _NUM * Math . PI / _NUM ) { return bBox . getWidth ( ) ; } if ( relFieldRotation == - Math . PI ) { return bBox . getWidth ( ) ; } } return _NUM ; }
void purgeLastArticles ( int amountToPurge ) { if ( ! isDBAvailable ( ) ) return ; long time = System . currentTimeMillis ( ) ; String query = STRING + TABLE_ARTICLES + STRING + ( Utils . ARTICLE_LIMIT - amountToPurge + STRING ) ; safelyDeleteArticles ( query , null ) ; Log . d ( TAG , STRING + ( System . currentTimeMillis ( ) - time ) + STRING ) ; }
protected void addToPortMap ( IOFSwitch sw , MacAddress mac , VlanVid vlan , OFPort portVal ) { Map < MacVlanPair , OFPort > swMap = macVlanToSwitchPortMap . get ( sw ) ; if ( vlan == VlanVid . FULL_MASK || vlan == null ) { vlan = VlanVid . ofVlan ( _NUM ) ; } if ( swMap == null ) { swMap = Collections . synchronizedMap ( new LRULinkedHashMap < MacVlanPair , OFPort > ( MAX_MACS_PER_SWITCH ) ) ; macVlanToSwitchPortMap . put ( sw , swMap ) ; } swMap . put ( new MacVlanPair ( mac , vlan ) , portVal ) ; }
public void test_singleResourceLocking_serialized_lowConcurrency5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_singleResourceLocking_serialized_lowConcurrency5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_singleResourceLocking_serialized_lowConcurrency5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
public void test_singleResourceLocking_serialized_lowConcurrency5 ( ) throws Exception { Properties properties = new Properties ( ) ; properties . setProperty ( TestOptions . NTHREADS , STRING ) ; properties . setProperty ( TestOptions . NTASKS , STRING ) ; properties . setProperty ( TestOptions . NRESOURCES , STRING ) ; properties . setProperty ( TestOptions . MIN_LOCKS , STRING ) ; properties . setProperty ( TestOptions . MAX_LOCKS , STRING ) ; properties . setProperty ( TestOptions . PREDECLARE_LOCKS , STRING ) ; properties . setProperty ( TestOptions . SORT_LOCK_REQUESTS , STRING ) ; doComparisonTest ( properties ) ; }
private RefactoringStatus checkCanCreateIntermediaryMethod ( ) throws JavaModelException { List < ITypeBinding > parameterBindings = new ArrayList < ITypeBinding > ( ) ; if ( ! isStaticTarget ( ) ) parameterBindings . add ( fIntermediaryFirstParameterType ) ; parameterBindings . addAll ( Arrays . asList ( fTargetMethodBinding . getParameterTypes ( ) ) ) ; return Checks . checkMethodInType ( fIntermediaryTypeBinding , fIntermediaryMethodName , parameterBindings . toArray ( new ITypeBinding [ parameterBindings . size ( ) ] ) ) ; }
@ Override public DataSource createDataSource ( Properties properties ) throws SQLException { Properties propertiesCopy = new Properties ( ) ; if ( properties != null ) { propertiesCopy . putAll ( properties ) ; } rejectUnsupportedOptions ( propertiesCopy ) ; rejectPoolingOptions ( propertiesCopy ) ; JdbcDataSource dataSource = new JdbcDataSource ( ) ; setupH2DataSource ( dataSource , propertiesCopy ) ; return dataSource ; }
public static HttpResponse executeGetRequest ( String serviceEndPoint , boolean secure ) throws IOException { URL url = ( secure ) ? new URL ( SERVICE_ROOT_URI + STRING + serviceEndPoint ) : new URL ( SERVICE_ROOT_URI + serviceEndPoint ) ; HttpURLConnection connection = ( HttpURLConnection ) url . openConnection ( ) ; if ( secure ) { connection . setRequestProperty ( STRING , AUTHORIZATION ) ; } try { return new HttpResponse ( connection ) ; } finally { connection . disconnect ( ) ; } }
public boolean contains ( long prefix_hash ) { if ( prefix_hash == _NUM ) { return _BOOL ; } int idx = - _NUM * Arrays . binarySearch ( hashes_idx , prefix_hash ) - _NUM ; if ( idx == cache_size ) { return _BOOL ; } else { return ( hashes_idx [ idx ] & PREFIX_HASH_MASK ) == prefix_hash ; } }
public boolean contains ( long prefix_hash ) { if ( prefix_hash == _NUM ) { return _BOOL ; } int idx = - _NUM * Arrays . binarySearch ( hashes_idx , prefix_hash ) - _NUM ; if ( idx == cache_size ) { return _BOOL ; } else { return ( hashes_idx [ idx ] & PREFIX_HASH_MASK ) == prefix_hash ; } }
private void checkAndWriteDictionaryChunkToFile ( ) throws IOException { if ( oneDictionaryChunkList . size ( ) >= dictionary_one_chunk_size ) { writeDictionaryFile ( ) ; createChunkList ( ) ; } }
private void checkAndWriteDictionaryChunkToFile ( ) throws IOException { if ( oneDictionaryChunkList . size ( ) >= dictionary_one_chunk_size ) { writeDictionaryFile ( ) ; createChunkList ( ) ; } }
public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return _BOOL ; } int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLast = csLength - _NUM ; int searchLast = searchLength - _NUM ; for ( int i = _NUM ; i < csLength ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = _NUM ; j < searchLength ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j == searchLast ) { return _BOOL ; } if ( i < csLast && searchChars [ j + _NUM ] == cs . charAt ( i + _NUM ) ) { return _BOOL ; } } else { return _BOOL ; } } } } return _BOOL ; }
public static boolean containsAny ( CharSequence cs , char [ ] searchChars ) { if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return _BOOL ; } int csLength = cs . length ( ) ; int searchLength = searchChars . length ; int csLast = csLength - _NUM ; int searchLast = searchLength - _NUM ; for ( int i = _NUM ; i < csLength ; i ++ ) { char ch = cs . charAt ( i ) ; for ( int j = _NUM ; j < searchLength ; j ++ ) { if ( searchChars [ j ] == ch ) { if ( Character . isHighSurrogate ( ch ) ) { if ( j == searchLast ) { return _BOOL ; } if ( i < csLast && searchChars [ j + _NUM ] == cs . charAt ( i + _NUM ) ) { return _BOOL ; } } else { return _BOOL ; } } } } return _BOOL ; }
public int readUnsignedByteBE ( ) throws IOException { return inputStream . readUnsignedByte ( ) ; }
public int readUnsignedByteBE ( ) throws IOException { return inputStream . readUnsignedByte ( ) ; }
public int readUnsignedByteBE ( ) throws IOException { return inputStream . readUnsignedByte ( ) ; }
public void testShiftRightNegNonZeroes ( ) { byte aBytes [ ] = { _NUM , - _NUM , _NUM , _NUM , - _NUM , - _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = - _NUM ; int number = _NUM ; byte rBytes [ ] = { - _NUM , - _NUM , _NUM , - _NUM , _NUM , - _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger result = aNumber . shiftRight ( number ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , result . signum ( ) ) ; }
public void fillDefaultValues ( ) { tfLearningRate . setText ( Double . toString ( SubtractiveNormalizationRule . DEFAULT_LEARNING_RATE ) ) ; }
public void fillDefaultValues ( ) { tfLearningRate . setText ( Double . toString ( SubtractiveNormalizationRule . DEFAULT_LEARNING_RATE ) ) ; }
void flush ( VcfWriter writer ) throws IOException { if ( mPrevRecord != null ) { if ( ! mPrevDense ) { writeCount ( writer , mPrevRecord ) ; } else { mVcfFilterStatistics . increment ( Stat . DENSITY_WINDOW_COUNT ) ; } } mPrevRecord = null ; mPrevDense = _BOOL ; }
public void testConnectA2dp ( ) { int iterations = BluetoothTestRunner . sConnectA2dpIterations ; if ( iterations == _NUM ) { return ; } BluetoothAdapter adapter = BluetoothAdapter . getDefaultAdapter ( ) ; BluetoothDevice device = adapter . getRemoteDevice ( BluetoothTestRunner . sDeviceAddress ) ; mTestUtils . disable ( adapter ) ; mTestUtils . enable ( adapter ) ; mTestUtils . unpair ( adapter , device ) ; mTestUtils . pair ( adapter , device , BluetoothTestRunner . sDevicePairPasskey , BluetoothTestRunner . sDevicePairPin ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . A2DP , null ) ; for ( int i = _NUM ; i < iterations ; i ++ ) { mTestUtils . writeOutput ( STRING + ( i + _NUM ) + STRING + iterations ) ; mTestUtils . connectProfile ( adapter , device , BluetoothProfile . A2DP , String . format ( STRING , device ) ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . A2DP , String . format ( STRING , device ) ) ; } mTestUtils . unpair ( adapter , device ) ; mTestUtils . disable ( adapter ) ; }
public void testConnectA2dp ( ) { int iterations = BluetoothTestRunner . sConnectA2dpIterations ; if ( iterations == _NUM ) { return ; } BluetoothAdapter adapter = BluetoothAdapter . getDefaultAdapter ( ) ; BluetoothDevice device = adapter . getRemoteDevice ( BluetoothTestRunner . sDeviceAddress ) ; mTestUtils . disable ( adapter ) ; mTestUtils . enable ( adapter ) ; mTestUtils . unpair ( adapter , device ) ; mTestUtils . pair ( adapter , device , BluetoothTestRunner . sDevicePairPasskey , BluetoothTestRunner . sDevicePairPin ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . A2DP , null ) ; for ( int i = _NUM ; i < iterations ; i ++ ) { mTestUtils . writeOutput ( STRING + ( i + _NUM ) + STRING + iterations ) ; mTestUtils . connectProfile ( adapter , device , BluetoothProfile . A2DP , String . format ( STRING , device ) ) ; mTestUtils . disconnectProfile ( adapter , device , BluetoothProfile . A2DP , String . format ( STRING , device ) ) ; } mTestUtils . unpair ( adapter , device ) ; mTestUtils . disable ( adapter ) ; }
private String collapseSlashes ( String path ) { int length = path . length ( ) ; if ( length < _NUM ) return path ; if ( path . indexOf ( STRING , _NUM ) == - _NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = _NUM ; boolean hasPrevious = _BOOL ; char [ ] characters = path . toCharArray ( ) ; for ( int index = _NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c == SEPARATOR ) { if ( hasPrevious ) { if ( device == null && index == _NUM ) { result [ count ] = c ; count ++ ; } } else { hasPrevious = _BOOL ; result [ count ] = c ; count ++ ; } } else { hasPrevious = _BOOL ; result [ count ] = c ; count ++ ; } } return new String ( result , _NUM , count ) ; }
private String collapseSlashes ( String path ) { int length = path . length ( ) ; if ( length < _NUM ) return path ; if ( path . indexOf ( STRING , _NUM ) == - _NUM ) return path ; char [ ] result = new char [ path . length ( ) ] ; int count = _NUM ; boolean hasPrevious = _BOOL ; char [ ] characters = path . toCharArray ( ) ; for ( int index = _NUM ; index < characters . length ; index ++ ) { char c = characters [ index ] ; if ( c == SEPARATOR ) { if ( hasPrevious ) { if ( device == null && index == _NUM ) { result [ count ] = c ; count ++ ; } } else { hasPrevious = _BOOL ; result [ count ] = c ; count ++ ; } } else { hasPrevious = _BOOL ; result [ count ] = c ; count ++ ; } } return new String ( result , _NUM , count ) ; }
public static int unixTimestamp ( ) { return ( int ) ( System . currentTimeMillis ( ) / _NUM ) ; }
public void importPKCS8 ( BurpCertificate certificate , String filename ) { setStatus ( STRING ) ; FileInputStream fis ; File file = new File ( filename ) ; PrivateKey privateKey ; try { fis = new FileInputStream ( file ) ; DataInputStream dis = new DataInputStream ( fis ) ; byte [ ] keyBytes = new byte [ ( int ) file . length ( ) ] ; dis . readFully ( keyBytes ) ; dis . close ( ) ; PKCS8EncodedKeySpec keySpec = new PKCS8EncodedKeySpec ( keyBytes ) ; KeyFactory keyFactory = KeyFactory . getInstance ( STRING ) ; privateKey = keyFactory . generatePrivate ( keySpec ) ; certificate . setPrivateKey ( privateKey ) ; setCertificateTree ( ) ; setStatus ( STRING ) ; } catch ( IOException | NoSuchAlgorithmException | InvalidKeySpecException e ) { setStatus ( STRING + e . getMessage ( ) + STRING ) ; e . printStackTrace ( ) ; } catch ( Exception e ) { setStatus ( STRING + e . getMessage ( ) + STRING ) ; } }
public void removeListener ( final IMemoryListener listener ) { m_listeners . remove ( listener ) ; }
public double median ( double [ ] series ) { double [ ] clonedSeries = series . clone ( ) ; Arrays . sort ( clonedSeries ) ; double median ; if ( clonedSeries . length % _NUM == _NUM ) { median = ( clonedSeries [ clonedSeries . length / _NUM ] + ( double ) clonedSeries [ clonedSeries . length / _NUM - _NUM ] ) / _NUM ; } else { median = clonedSeries [ clonedSeries . length / _NUM ] ; } return median ; }
public ColourMapModel ( ColourMapModelUpdateInterface parent ) { this . parentObj = parent ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STRING ) ) ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STRING ) ) ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STRING ) ) ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STRING ) ) ; columnList . add ( Localisation . getString ( FieldConfigBase . class , STRING ) ) ; }
private static boolean calculateIsFailure ( ) { int randomValue = random . nextInt ( _NUM ) + _NUM ; return randomValue <= ERROR_PCT ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public void create ( ) { WindowSupport . setDefaultWindowSupportDisplayType ( WindowSupport . Dlg . class ) ; setLayout ( createLayoutManager ( ) ) ; leftSlider = new JSplitPane ( ) ; leftSlider . setBorder ( null ) ; leftSlider . setResizeWeight ( _NUM ) ; leftSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider = new JSplitPane ( ) ; rightSlider . setBorder ( null ) ; rightSlider . setResizeWeight ( _NUM ) ; rightSlider . setOneTouchExpandable ( _BOOL ) ; rightSlider . setLeftComponent ( leftSlider ) ; rightSlider . setRightComponent ( null ) ; if ( _BOOL ) { bottomSlider = new JSplitPane ( JSplitPane . VERTICAL_SPLIT ) ; bottomSlider . setBorder ( null ) ; bottomSlider . setResizeWeight ( _NUM ) ; bottomSlider . setOneTouchExpandable ( _BOOL ) ; leftSlider . setRightComponent ( bottomSlider ) ; } super . add ( rightSlider , BorderLayout . CENTER ) ; }
public ViewTranslatingGraphMousePlugin ( int modifiers ) { super ( modifiers ) ; this . cursor = Cursor . getPredefinedCursor ( Cursor . MOVE_CURSOR ) ; }
public static BigDecimal calculateFee ( Player player , int price ) { BigDecimal fee = BigDecimal . valueOf ( price ) ; fee = fee . multiply ( BigDecimal . valueOf ( TRADING_FEE_PERCENTAGE ) ) ; if ( player . isBadBoy ( ) ) { fee = fee . multiply ( BigDecimal . valueOf ( _NUM + TRADING_FEE_PLAYER_KILLER_PENALTY ) ) ; } BigDecimal feeBonus = BigDecimal . ONE ; feeBonus = BigDecimal . valueOf ( Math . exp ( - player . getTradescore ( ) / FEE_BONUS_CONSTANT ) ) ; fee = fee . multiply ( feeBonus ) ; return fee . max ( BigDecimal . ONE ) ; }
public static BigDecimal calculateFee ( Player player , int price ) { BigDecimal fee = BigDecimal . valueOf ( price ) ; fee = fee . multiply ( BigDecimal . valueOf ( TRADING_FEE_PERCENTAGE ) ) ; if ( player . isBadBoy ( ) ) { fee = fee . multiply ( BigDecimal . valueOf ( _NUM + TRADING_FEE_PLAYER_KILLER_PENALTY ) ) ; } BigDecimal feeBonus = BigDecimal . ONE ; feeBonus = BigDecimal . valueOf ( Math . exp ( - player . getTradescore ( ) / FEE_BONUS_CONSTANT ) ) ; fee = fee . multiply ( feeBonus ) ; return fee . max ( BigDecimal . ONE ) ; }
public static Z uz ( ) { return new Z ( R . nextDouble ( ) , R . nextDouble ( ) ) ; }
static private String SHORT_Max_Plus ( ) { long tempValue = Short . MAX_VALUE + _NUM ; return String . valueOf ( tempValue ) ; }
@ Pure @ CausesError ( { IncorrectPure4JImmutableCallException . class , PureMethodParameterNotImmutableException . class } ) public String testParam1Bad ( Object in1 , Object in2 ) { Object in3 = in2 ; Pure4J . immutable ( in1 , in2 ) ; return in3 . toString ( ) ; }
public void removeActiveLineRangeListener ( ActiveLineRangeListener l ) { listenerList . remove ( ActiveLineRangeListener . class , l ) ; }
public static int showYesNoError ( final Component parent , final String msg ) { return JOptionPane . showConfirmDialog ( isIconified ( parent ) ? null : parent , msg , System . getProperty ( DEFAULT_WINDOW_TITLE_PROPERTY ) , JOptionPane . YES_NO_OPTION , JOptionPane . ERROR_MESSAGE ) ; }
public void addOption ( T option , double weight ) { if ( weight < _NUM ) throw new IllegalArgumentException ( STRING ) ; options . add ( option ) ; weights . add ( weight ) ; weightSum += weight ; }
public ByteBuffer createBuffer ( Map < String , Object > parameters ) { ByteBuffer buffer = createByteBuffer ( ) ; for ( Field field : fields ) { log . trace ( STRING , buffer . position ( ) ) ; field . write ( resolveInputValue ( parameters , field ) , buffer ) ; log . trace ( STRING , buffer . position ( ) ) ; } buffer . flip ( ) ; return buffer ; }
public ByteBuffer createBuffer ( Map < String , Object > parameters ) { ByteBuffer buffer = createByteBuffer ( ) ; for ( Field field : fields ) { log . trace ( STRING , buffer . position ( ) ) ; field . write ( resolveInputValue ( parameters , field ) , buffer ) ; log . trace ( STRING , buffer . position ( ) ) ; } buffer . flip ( ) ; return buffer ; }
public void addProfiles ( @ NonNull IProfile ... profiles ) { if ( mAccountHeaderBuilder . mProfiles == null ) { mAccountHeaderBuilder . mProfiles = new ArrayList < > ( ) ; } Collections . addAll ( mAccountHeaderBuilder . mProfiles , profiles ) ; mAccountHeaderBuilder . updateHeaderAndList ( ) ; }
private int [ ] toIntArray ( String str ) { int [ ] retVal = new int [ _NUM ] ; str = str + STRING ; int rlen = retVal . length ; for ( int i = _NUM ; i < rlen ; i ++ ) { retVal [ i ] = Integer . parseInt ( str . substring ( _NUM , str . indexOf ( STRING ) ) ) ; str = str . substring ( str . indexOf ( STRING ) + _NUM , str . length ( ) ) ; } return retVal ; }
@ Override public void drawRangeLine ( Graphics2D g2 , XYPlot plot , ValueAxis axis , Rectangle2D dataArea , double value , Paint paint , Stroke stroke ) { Range range = axis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } PlotOrientation orientation = plot . getOrientation ( ) ; Line2D line = null ; double v = axis . valueToJava2D ( value , dataArea , plot . getRangeAxisEdge ( ) ) ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( v , dataArea . getMinY ( ) , v , dataArea . getMaxY ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , v , dataArea . getMaxX ( ) , v ) ; } g2 . setPaint ( paint ) ; g2 . setStroke ( stroke ) ; Object saved = g2 . getRenderingHint ( RenderingHints . KEY_STROKE_CONTROL ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , RenderingHints . VALUE_STROKE_NORMALIZE ) ; g2 . draw ( line ) ; g2 . setRenderingHint ( RenderingHints . KEY_STROKE_CONTROL , saved ) ; }
public boolean addProperty ( OwlProperty property ) { property . addRestriction ( this ) ; return properties . add ( property ) ; }
public boolean addProperty ( OwlProperty property ) { property . addRestriction ( this ) ; return properties . add ( property ) ; }
private void interruptIdleWorkers ( boolean onlyOne ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { Iterator < Worker > it = workers . iterator ( ) ; while ( it . hasNext ( ) ) { Worker w = it . next ( ) ; Thread t = w . thread ; if ( ! t . isInterrupted ( ) && w . tryLock ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } finally { w . unlock ( ) ; } } if ( onlyOne ) break ; } } finally { mainLock . unlock ( ) ; } }
private void interruptIdleWorkers ( boolean onlyOne ) { final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { Iterator < Worker > it = workers . iterator ( ) ; while ( it . hasNext ( ) ) { Worker w = it . next ( ) ; Thread t = w . thread ; if ( ! t . isInterrupted ( ) && w . tryLock ( ) ) { try { t . interrupt ( ) ; } catch ( SecurityException ignore ) { } finally { w . unlock ( ) ; } } if ( onlyOne ) break ; } } finally { mainLock . unlock ( ) ; } }
public void begin ( Attributes attributes ) throws Exception { UIComponent uic = ( UIComponent ) digester . peek ( ) ; AttributesImpl attrs = new AttributesImpl ( attributes ) ; for ( int i = _NUM ; i < attrs . getLength ( ) ; i ++ ) { String qName = attributes . getQName ( i ) ; attrs . setLocalName ( i , qName ) ; attrs . setValue ( i , attributes . getValue ( qName ) ) ; } bc . handleNestedComponentTag ( uic , STRING , attrs ) ; }
@ Override public IndexableField createField ( SchemaField field , Object value , float boost ) { throw new UnsupportedOperationException ( STRING + field . getName ( ) ) ; }
@ Override public IndexableField createField ( SchemaField field , Object value , float boost ) { throw new UnsupportedOperationException ( STRING + field . getName ( ) ) ; }
@ Override public IndexableField createField ( SchemaField field , Object value , float boost ) { throw new UnsupportedOperationException ( STRING + field . getName ( ) ) ; }
public DisMaxQueryBuilder add ( QueryBuilder queryBuilder ) { queries . add ( queryBuilder ) ; return this ; }
public void delete ( String name ) throws IOException { if ( name . equalsIgnoreCase ( QUALIFIERS ) ) { policyQualifiers = Collections . emptySet ( ) ; } else if ( name . equalsIgnoreCase ( ID ) ) { throw new IOException ( STRING + STRING ) ; } else { throw new IOException ( STRING + name + STRING ) ; } }
@ Override public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { checkQName ( qualifiedName ) ; return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; }
@ Override public DocumentType createDocumentType ( String qualifiedName , String publicID , String systemID ) { checkQName ( qualifiedName ) ; return new DocumentTypeImpl ( null , qualifiedName , publicID , systemID ) ; }
public static boolean canResize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canResize ( ) ) return _BOOL ; } return _BOOL ; }
public static boolean canResize ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canResize ( ) ) return _BOOL ; } return _BOOL ; }
@ Override public void readExternal ( ObjectInput is ) throws IOException { readFields ( is ) ; }
@ Override public void readExternal ( ObjectInput is ) throws IOException { readFields ( is ) ; }
public TriggerInListCondition ( final String ... trigger ) { this ( Arrays . asList ( trigger ) ) ; }
private Comparable < ? > castToComparable ( Object value ) { try { return ( Comparable < ? > ) value ; } catch ( ClassCastException e ) { throw new IllegalArgumentException ( STRING , e ) ; } }
public void read ( byte [ ] buff , int off , int len ) { System . arraycopy ( data , pos , buff , off , len ) ; pos += len ; }
public synchronized void update ( double sample ) { long now = System . currentTimeMillis ( ) ; if ( lastMillis == _NUM ) { average = sample ; lastMillis = now ; return ; } long deltaTime = now - lastMillis ; double coeff = Math . exp ( - _NUM * ( ( double ) deltaTime / windowMillis ) ) ; average = ( _NUM - coeff ) * sample + coeff * average ; lastMillis = now ; }
public final void removeAllHelperTextColors ( ) { helperTextColors . clear ( ) ; }
public final void removeAllHelperTextColors ( ) { helperTextColors . clear ( ) ; }
public final void removeAllHelperTextColors ( ) { helperTextColors . clear ( ) ; }
private void capacityWarn ( ) { if ( warningCounter == _NUM ) { LOGGER . warn ( STRING + buffer . size ( ) + STRING ) ; warningCounter = WARNING_FREQUENCY ; } else { warningCounter = warningCounter - _NUM ; } }
public void dump ( PrintWriter output , int pad , String title ) { Utilities . dump ( output , pad , title ) ; features . dump ( output , pad + _NUM , title + STRING ) ; dumpProcessors ( output , pad + _NUM , title + STRING ) ; }
public void removeVersion ( final SoftwareVersion version ) throws LocalRepositoryException { final String prefix = STRING + version + STRING ; _log . debug ( prefix ) ; final String [ ] cmd = { _SYSTOOL_CMD , _SYSTOOL_REMOVE , version . toString ( ) } ; exec ( prefix , cmd ) ; _log . info ( prefix + STRING ) ; }
private DoubleConstant parseDoubleConstant ( int index ) throws IOException { long bits = readLong ( ) ; double value = Double . longBitsToDouble ( bits ) ; return new DoubleConstant ( _class . getConstantPool ( ) , index , value ) ; }
protected void addResourceDelta ( IResourceDelta child ) { switch ( this . kind ) { case ADDED : case REMOVED : return ; case CHANGED : this . changeFlags |= F_CONTENT ; break ; default : this . kind = CHANGED ; this . changeFlags |= F_CONTENT ; } if ( this . resourceDeltas == null ) { this . resourceDeltas = new IResourceDelta [ _NUM ] ; this . resourceDeltas [ this . resourceDeltasCounter ++ ] = child ; return ; } if ( this . resourceDeltas . length == this . resourceDeltasCounter ) { System . arraycopy ( this . resourceDeltas , _NUM , ( this . resourceDeltas = new IResourceDelta [ this . resourceDeltasCounter * _NUM ] ) , _NUM , this . resourceDeltasCounter ) ; } this . resourceDeltas [ this . resourceDeltasCounter ++ ] = child ; }
protected void addResourceDelta ( IResourceDelta child ) { switch ( this . kind ) { case ADDED : case REMOVED : return ; case CHANGED : this . changeFlags |= F_CONTENT ; break ; default : this . kind = CHANGED ; this . changeFlags |= F_CONTENT ; } if ( this . resourceDeltas == null ) { this . resourceDeltas = new IResourceDelta [ _NUM ] ; this . resourceDeltas [ this . resourceDeltasCounter ++ ] = child ; return ; } if ( this . resourceDeltas . length == this . resourceDeltasCounter ) { System . arraycopy ( this . resourceDeltas , _NUM , ( this . resourceDeltas = new IResourceDelta [ this . resourceDeltasCounter * _NUM ] ) , _NUM , this . resourceDeltasCounter ) ; } this . resourceDeltas [ this . resourceDeltasCounter ++ ] = child ; }
public void addGlueRules ( ArrayList < FeatureFunction > featureFunctions ) { HieroFormatReader reader = new HieroFormatReader ( ) ; String goalNT = FormatUtils . cleanNonTerminal ( joshuaConfiguration . goal_symbol ) ; String defaultNT = FormatUtils . cleanNonTerminal ( joshuaConfiguration . default_non_terminal ) ; String [ ] ruleStrings = new String [ ] { String . format ( STRING , goalNT , Vocabulary . START_SYM , Vocabulary . START_SYM ) , String . format ( STRING , goalNT , goalNT , defaultNT , goalNT , defaultNT ) , String . format ( STRING , goalNT , goalNT , Vocabulary . STOP_SYM , goalNT , Vocabulary . STOP_SYM ) } ; for ( String ruleString : ruleStrings ) { Rule rule = reader . parseLine ( ruleString ) ; addRule ( rule ) ; rule . estimateRuleCost ( featureFunctions ) ; } }
public static int maximumSumNonAdjacentSubSequence ( int [ ] a ) { int incl = a [ _NUM ] , excl = _NUM , prevIncl = incl ; for ( int i = _NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prevIncl , excl ) ; prevIncl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximumSumNonAdjacentSubSequence ( int [ ] a ) { int incl = a [ _NUM ] , excl = _NUM , prevIncl = incl ; for ( int i = _NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prevIncl , excl ) ; prevIncl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximumSumNonAdjacentSubSequence ( int [ ] a ) { int incl = a [ _NUM ] , excl = _NUM , prevIncl = incl ; for ( int i = _NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prevIncl , excl ) ; prevIncl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximumSumNonAdjacentSubSequence ( int [ ] a ) { int incl = a [ _NUM ] , excl = _NUM , prevIncl = incl ; for ( int i = _NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prevIncl , excl ) ; prevIncl = incl ; } return Math . max ( incl , excl ) ; }
public static int maximumSumNonAdjacentSubSequence ( int [ ] a ) { int incl = a [ _NUM ] , excl = _NUM , prevIncl = incl ; for ( int i = _NUM ; i < a . length ; i ++ ) { incl = excl + a [ i ] ; excl = Math . max ( prevIncl , excl ) ; prevIncl = incl ; } return Math . max ( incl , excl ) ; }
private static void runRandomTest ( final int wordLength , final int bytePadding , final int wordCount ) { final long seed = randomLong ( ) ; final Random random = new Random ( seed ) ; final Random verificationRandom = new Random ( seed ) ; final long wordMask ; if ( wordLength == _NUM ) { wordMask = ~ _NUM ; } else { wordMask = ( _NUM << wordLength ) - _NUM ; } final BigEndianAscendingWordSerializer serializer = new BigEndianAscendingWordSerializer ( wordLength , wordCount , bytePadding ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { final long value = random . nextLong ( ) & wordMask ; serializer . writeWord ( value ) ; } final byte [ ] bytes = serializer . getBytes ( ) ; final BigEndianAscendingWordDeserializer deserializer = new BigEndianAscendingWordDeserializer ( wordLength , bytePadding , bytes ) ; assertEquals ( deserializer . totalWordCount ( ) , wordCount ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { assertEquals ( deserializer . readWord ( ) , ( verificationRandom . nextLong ( ) & wordMask ) ) ; } }
private static void runRandomTest ( final int wordLength , final int bytePadding , final int wordCount ) { final long seed = randomLong ( ) ; final Random random = new Random ( seed ) ; final Random verificationRandom = new Random ( seed ) ; final long wordMask ; if ( wordLength == _NUM ) { wordMask = ~ _NUM ; } else { wordMask = ( _NUM << wordLength ) - _NUM ; } final BigEndianAscendingWordSerializer serializer = new BigEndianAscendingWordSerializer ( wordLength , wordCount , bytePadding ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { final long value = random . nextLong ( ) & wordMask ; serializer . writeWord ( value ) ; } final byte [ ] bytes = serializer . getBytes ( ) ; final BigEndianAscendingWordDeserializer deserializer = new BigEndianAscendingWordDeserializer ( wordLength , bytePadding , bytes ) ; assertEquals ( deserializer . totalWordCount ( ) , wordCount ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { assertEquals ( deserializer . readWord ( ) , ( verificationRandom . nextLong ( ) & wordMask ) ) ; } }
private static void runRandomTest ( final int wordLength , final int bytePadding , final int wordCount ) { final long seed = randomLong ( ) ; final Random random = new Random ( seed ) ; final Random verificationRandom = new Random ( seed ) ; final long wordMask ; if ( wordLength == _NUM ) { wordMask = ~ _NUM ; } else { wordMask = ( _NUM << wordLength ) - _NUM ; } final BigEndianAscendingWordSerializer serializer = new BigEndianAscendingWordSerializer ( wordLength , wordCount , bytePadding ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { final long value = random . nextLong ( ) & wordMask ; serializer . writeWord ( value ) ; } final byte [ ] bytes = serializer . getBytes ( ) ; final BigEndianAscendingWordDeserializer deserializer = new BigEndianAscendingWordDeserializer ( wordLength , bytePadding , bytes ) ; assertEquals ( deserializer . totalWordCount ( ) , wordCount ) ; for ( int i = _NUM ; i < wordCount ; i ++ ) { assertEquals ( deserializer . readWord ( ) , ( verificationRandom . nextLong ( ) & wordMask ) ) ; } }
private InvocationConstraints createInvocationConstraints ( ) { if ( MIN_RETRY >= sleepTime [ tryIndx ] ) { return new InvocationConstraints ( new ConnectionAbsoluteTime ( System . currentTimeMillis ( ) + sleepTime [ tryIndx ] ) , null ) ; } else { return InvocationConstraints . EMPTY ; } }
private InvocationConstraints createInvocationConstraints ( ) { if ( MIN_RETRY >= sleepTime [ tryIndx ] ) { return new InvocationConstraints ( new ConnectionAbsoluteTime ( System . currentTimeMillis ( ) + sleepTime [ tryIndx ] ) , null ) ; } else { return InvocationConstraints . EMPTY ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
private void adjustChildrenToGroupChange ( ) { int index = _NUM ; DecimalRectangle tempBounds ; for ( MathObject mathObj : getObjects ( ) ) { tempBounds = objectBounds . get ( index ) ; mathObj . setxPos ( getxPos ( ) + ( int ) Math . round ( tempBounds . getX ( ) * getWidth ( ) ) ) ; mathObj . setyPos ( getyPos ( ) + ( int ) Math . round ( tempBounds . getY ( ) * getHeight ( ) ) ) ; mathObj . setWidth ( ( int ) Math . round ( tempBounds . getWidth ( ) * getWidth ( ) ) ) ; mathObj . setHeight ( ( int ) Math . round ( tempBounds . getHeight ( ) * getHeight ( ) ) ) ; if ( mathObj . getWidth ( ) == _NUM ) { mathObj . setWidth ( _NUM ) ; } if ( mathObj . getHeight ( ) == _NUM ) { mathObj . setHeight ( _NUM ) ; } index ++ ; } }
protected void sparseToDense ( ) { if ( ! isSparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = _NUM ; i < dimension ; ++ i ) { coordinates [ i ] = _NUM ; } for ( int i = _NUM ; i < sparseOffsets . length ; ++ i ) { coordinates [ Math . abs ( sparseOffsets [ i ] ) - _NUM ] = Math . signum ( sparseOffsets [ i ] ) ; } isSparse = _BOOL ; }
protected void sparseToDense ( ) { if ( ! isSparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = _NUM ; i < dimension ; ++ i ) { coordinates [ i ] = _NUM ; } for ( int i = _NUM ; i < sparseOffsets . length ; ++ i ) { coordinates [ Math . abs ( sparseOffsets [ i ] ) - _NUM ] = Math . signum ( sparseOffsets [ i ] ) ; } isSparse = _BOOL ; }
protected void sparseToDense ( ) { if ( ! isSparse ) { return ; } coordinates = new float [ dimension ] ; for ( int i = _NUM ; i < dimension ; ++ i ) { coordinates [ i ] = _NUM ; } for ( int i = _NUM ; i < sparseOffsets . length ; ++ i ) { coordinates [ Math . abs ( sparseOffsets [ i ] ) - _NUM ] = Math . signum ( sparseOffsets [ i ] ) ; } isSparse = _BOOL ; }
private static GeneralizedTime createTime ( final String value , final int year , final int month , final int day , final int hour , final int minute , final int second , final TimeZone tz ) { try { final GregorianCalendar calendar = new GregorianCalendar ( ) ; calendar . setLenient ( _BOOL ) ; calendar . setTimeZone ( tz ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , _NUM ) ; return new GeneralizedTime ( calendar , null , Long . MIN_VALUE , value ) ; } catch ( final Exception e ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_ILLEGAL_TIME . get ( value , String . valueOf ( e ) ) ; throw new LocalizedIllegalArgumentException ( message , e ) ; } }
private static GeneralizedTime createTime ( final String value , final int year , final int month , final int day , final int hour , final int minute , final int second , final TimeZone tz ) { try { final GregorianCalendar calendar = new GregorianCalendar ( ) ; calendar . setLenient ( _BOOL ) ; calendar . setTimeZone ( tz ) ; calendar . set ( year , month , day , hour , minute , second ) ; calendar . set ( Calendar . MILLISECOND , _NUM ) ; return new GeneralizedTime ( calendar , null , Long . MIN_VALUE , value ) ; } catch ( final Exception e ) { final LocalizableMessage message = WARN_ATTR_SYNTAX_GENERALIZED_TIME_ILLEGAL_TIME . get ( value , String . valueOf ( e ) ) ; throw new LocalizedIllegalArgumentException ( message , e ) ; } }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
@ Override public int startupNewWorker ( int priority , String tcpUri , String temporaryDirectory ) { startupNewWorker ( priority ) ; return _NUM ; }
public static void deviceReportPressed ( String devName , Frame parent ) { JTextArea text = null ; JScrollPane scrollPane = null ; text = new javax . swing . JTextArea ( _NUM , _NUM ) ; text . setEditable ( _BOOL ) ; text . setTabSize ( _NUM ) ; search ( devName , text ) ; scrollPane = new JScrollPane ( text ) ; makeDialog ( scrollPane , null , parent , rbm . getString ( STRING ) ) ; }
private void sendComposedText ( ) { AttributedString as = new AttributedString ( buffer . toString ( ) ) ; as . addAttribute ( TextAttribute . INPUT_METHOD_HIGHLIGHT , InputMethodHighlight . SELECTED_RAW_TEXT_HIGHLIGHT ) ; context . dispatchInputMethodEvent ( InputMethodEvent . INPUT_METHOD_TEXT_CHANGED , as . getIterator ( ) , _NUM , TextHitInfo . leading ( insertionPoint ) , null ) ; }
public void tryObtain ( ) throws IOException { if ( fileLock != null && fileLock . isValid ( ) ) { return ; } fileLock = fileToLock . tryLock ( ) ; }
public static String toJSONString ( Collection collection ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( collection , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String toJSONString ( Collection collection ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( collection , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String toJSONString ( Collection collection ) { final StringWriter writer = new StringWriter ( ) ; try { writeJSONString ( collection , writer ) ; return writer . toString ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public void read_design ( ObjectInputStream p_design ) throws ClassNotFoundException , IOException { r_board = ( RoutingBoard ) p_design . readObject ( ) ; r_board . set_transient_item ( this ) ; itera_settings = ( IteraSettings ) p_design . readObject ( ) ; itera_settings . set_transient_fields ( r_board , actlog ) ; coordinate_transform = ( PlaCoordTransform ) p_design . readObject ( ) ; gdi_context = ( GdiContext ) p_design . readObject ( ) ; gdi_context . set_transient_field ( stat ) ; screen_messages . show_layer_name ( itera_settings . get_layer ( ) ) ; }
public final boolean skipAny ( CharSet charSet , CharSequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && charSet . contains ( csq . charAt ( i ) ) ; i ++ ) { } if ( i == index ) return _BOOL ; index = i ; return _BOOL ; }
public final boolean skipAny ( CharSet charSet , CharSequence csq ) { int i = index ; int n = csq . length ( ) ; for ( ; ( i < n ) && charSet . contains ( csq . charAt ( i ) ) ; i ++ ) { } if ( i == index ) return _BOOL ; index = i ; return _BOOL ; }
public int indexOfSegment ( Segment segment ) { return selectedSegments . indexOf ( segment ) ; }
void deriveConfidenceValue ( double baseCount ) { if ( Utils . isMissingValue ( m_confidence ) && ! Utils . isMissingValue ( baseCount ) && baseCount > _NUM ) { m_confidence = m_recordCount / baseCount ; } }
public void remove ( MenuComponent m ) { if ( m == null ) { return ; } synchronized ( getTreeLock ( ) ) { if ( m == menuBar ) { menuBar = null ; FramePeer peer = ( FramePeer ) this . peer ; if ( peer != null ) { mbManagement = _BOOL ; invalidateIfValid ( ) ; peer . setMenuBar ( null ) ; m . removeNotify ( ) ; } m . parent = null ; } else { super . remove ( m ) ; } } }
public String toString ( ) { StringBuffer result = new StringBuffer ( ) ; result . append ( STRING ) ; for ( int i = _NUM ; i < chars . length ; i += _NUM ) { if ( chars [ i ] == chars [ i + _NUM ] ) { result . append ( STRING ) ; result . append ( Integer . toHexString ( chars [ i ] ) ) ; } else { result . append ( STRING ) ; result . append ( Integer . toHexString ( chars [ i ] ) ) ; result . append ( STRING ) ; result . append ( Integer . toHexString ( chars [ i + _NUM ] ) ) ; } } result . append ( STRING ) ; return result . toString ( ) ; }
public void addListener ( final IPluginInterfaceListener listener ) { listeners . addListener ( listener ) ; }
@ Override public void close ( ) { synchronized ( lock ) { if ( isOpen ( ) ) { buf = null ; } } }
public void toSingletonString ( StringBuilder sb , boolean forceSingle ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . charAt ( _NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( forceSingle ) sb . append ( STRING ) ; } } }
public void toSingletonString ( StringBuilder sb , boolean forceSingle ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . charAt ( _NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( forceSingle ) sb . append ( STRING ) ; } } }
public void toSingletonString ( StringBuilder sb , boolean forceSingle ) { sb . append ( STRING ) ; for ( String step : steps ) { if ( step . charAt ( _NUM ) != STRING ) { sb . append ( STRING ) ; sb . append ( step ) ; if ( forceSingle ) sb . append ( STRING ) ; } } }
public DVector2D ( int c1 , int c2 ) { defaultCapacity2 = Math . max ( defaultDefaultCapacity2 , c2 ) ; vector = new double [ Math . max ( defaultCapacity1 , c1 ) ] [ defaultCapacity2 ] ; sizes = new IVector ( c1 ) ; }
public void add ( WeightedObservedPoint observed ) { observations . add ( observed ) ; }
@ Override public SolrInfoMBean put ( String key , SolrInfoMBean infoBean ) { if ( server != null && infoBean != null ) { try { ObjectName name = getObjectName ( key , infoBean ) ; if ( server . isRegistered ( name ) ) server . unregisterMBean ( name ) ; SolrDynamicMBean mbean = new SolrDynamicMBean ( coreHashCode , infoBean , useCachedStatsBetweenGetMBeanInfoCalls ) ; server . registerMBean ( mbean , name ) ; } catch ( Exception e ) { log . warn ( STRING + key , e ) ; } } return super . put ( key , infoBean ) ; }
@ Override public SolrInfoMBean put ( String key , SolrInfoMBean infoBean ) { if ( server != null && infoBean != null ) { try { ObjectName name = getObjectName ( key , infoBean ) ; if ( server . isRegistered ( name ) ) server . unregisterMBean ( name ) ; SolrDynamicMBean mbean = new SolrDynamicMBean ( coreHashCode , infoBean , useCachedStatsBetweenGetMBeanInfoCalls ) ; server . registerMBean ( mbean , name ) ; } catch ( Exception e ) { log . warn ( STRING + key , e ) ; } } return super . put ( key , infoBean ) ; }
public ConcurrentLinkedHashMapPro ( Map < ? extends K , ? extends V > m ) { this ( Math . max ( ( int ) ( m . size ( ) / DEFAULT_LOAD_FACTOR ) + _NUM , DEFAULT_INITIAL_CAPACITY ) , DEFAULT_LOAD_FACTOR , DEFAULT_CONCURRENCY_LEVEL , UNLIMITED_SIZE , new FIFOPolicy ( ) ) ; putAll ( m ) ; }
@ Override public boolean communicationInitiated ( ) { return bugsPopulated . getCount ( ) == _NUM && communicationInitiated && networkClient . ready ( ) ; }
protected ESOptimization createOptimizer ( RandomGenerator random ) throws UndefinedParameterError { return new ESParameterOptimization ( this , operators . length , ESOptimization . INIT_TYPE_RANDOM , getParameterAsInt ( PARAMETER_MAX_GENERATIONS ) , getParameterAsInt ( PARAMETER_GENERATIONS_WITHOUT_IMPROVAL ) , getParameterAsInt ( PARAMETER_POPULATION_SIZE ) , getParameterAsInt ( PARAMETER_SELECTION_TYPE ) , getParameterAsDouble ( PARAMETER_TOURNAMENT_FRACTION ) , getParameterAsBoolean ( PARAMETER_KEEP_BEST ) , getParameterAsInt ( PARAMETER_MUTATION_TYPE ) , getParameterAsDouble ( PARAMETER_CROSSOVER_PROB ) , getParameterAsBoolean ( PARAMETER_SHOW_CONVERGENCE_PLOT ) , random , this ) ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
private int findOrCreateHeapIdx ( int cmid ) { if ( cmid >= map . length ) { growHeapMap ( cmid ) ; } int index = map [ cmid ] ; if ( index == _NUM ) { index = nextIndex ++ ; if ( index >= counts . length ) { growHeap ( ) ; } counts [ index ] = _NUM ; cmids [ index ] = cmid ; map [ cmid ] = index ; } return index ; }
@ LogMessageDoc ( level = STRING , message = STRING , explanation = STRING + STRING , recommendation = LogMessageDoc . REPORT_CONTROLLER_BUG ) public void queueHint ( String storeName , ByteArray key , Versioned < byte [ ] > value ) { try { HintKey hk = new HintKey ( storeName , key ) ; hintLock . lock ( ) ; try { boolean needed = ! hints . containsKey ( hk ) ; needed &= hints . doput ( hk , value ) ; if ( needed ) { hintQueue . add ( hk ) ; hintsAvailable . signal ( ) ; } } finally { hintLock . unlock ( ) ; } } catch ( SyncException e ) { logger . error ( STRING + storeName , e ) ; } }
@ Override public String toString ( ) { StringBuilder output = new StringBuilder ( ) ; if ( mTestClass != null ) { output . append ( mTestClass ) ; output . append ( STRING ) ; } if ( mTestName != null ) { output . append ( mTestName ) ; } if ( output . length ( ) > _NUM ) { return output . toString ( ) ; } return STRING ; }
private static String contentsOfFile ( WeakReference < Context > weakContext , String filename ) { Context context = null ; if ( weakContext != null ) { context = weakContext . get ( ) ; if ( context != null ) { StringBuilder contents = new StringBuilder ( ) ; BufferedReader reader = null ; try { File file = new File ( filename ) ; reader = new BufferedReader ( new FileReader ( file ) ) ; String line = null ; while ( ( line = reader . readLine ( ) ) != null ) { contents . append ( line ) ; contents . append ( System . getProperty ( STRING ) ) ; } } catch ( FileNotFoundException e ) { } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { IOUtils . closeQuietly ( reader ) ; } return contents . toString ( ) ; } } return null ; }
public static Optional < String > createInputDialog ( final Window owner , final String title , final String label ) { final TextInputDialog dialog = new TextInputDialog ( ) ; dialog . setTitle ( title ) ; dialog . setHeaderText ( null ) ; dialog . setContentText ( label ) ; dialog . initOwner ( owner ) ; return dialog . showAndWait ( ) ; }
public void register ( AbstractAutomaton a ) { synchronized ( automats ) { automats . add ( a ) ; } notify ( STRING , null , Integer . valueOf ( indexOf ( a ) ) ) ; }
public void register ( AbstractAutomaton a ) { synchronized ( automats ) { automats . add ( a ) ; } notify ( STRING , null , Integer . valueOf ( indexOf ( a ) ) ) ; }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public List < AcronymExpansion > doInBackground ( String acronym ) { try { List < AcronymExpansion > longForms = mAcronymCache . get ( acronym ) ; if ( longForms != null && ! longForms . isEmpty ( ) ) { Log . v ( TAG , acronym + STRING ) ; return longForms ; } else { Log . v ( TAG , acronym + STRING ) ; AcronymData result = null ; longForms = result . getLfs ( ) ; mAcronymCache . put ( result . getSf ( ) , longForms ) ; return longForms ; } } catch ( Exception e ) { Log . v ( TAG , STRING + e ) ; return null ; } }
public int size ( ) { return shards . size ( ) ; }
private List < UserNamespaceAuthorization > createUserNamespaceAuthorizationsFromEntities ( List < UserNamespaceAuthorizationEntity > userNamespaceAuthorizationEntities ) { List < UserNamespaceAuthorization > userNamespaceAuthorizations = new ArrayList < > ( ) ; for ( UserNamespaceAuthorizationEntity userNamespaceAuthorizationEntity : userNamespaceAuthorizationEntities ) { userNamespaceAuthorizations . add ( createUserNamespaceAuthorizationFromEntity ( userNamespaceAuthorizationEntity ) ) ; } return userNamespaceAuthorizations ; }
public void serializeAsField ( Object bean , JsonGenerator jgen , SerializerProvider prov ) throws Exception { Object value = get ( bean ) ; if ( value == null ) { if ( ! _suppressNulls ) { jgen . writeFieldName ( _name ) ; prov . defaultSerializeNull ( jgen ) ; } return ; } if ( value == bean ) { _reportSelfReference ( bean ) ; } if ( _suppressableValue != null && _suppressableValue . equals ( value ) ) { return ; } JsonSerializer < Object > ser = _serializer ; if ( ser == null ) { Class < ? > cls = value . getClass ( ) ; PropertySerializerMap map = _dynamicSerializers ; ser = map . serializerFor ( cls ) ; if ( ser == null ) { ser = _findAndAddDynamic ( map , cls , prov ) ; } } jgen . writeFieldName ( _name ) ; if ( _typeSerializer == null ) { ser . serialize ( value , jgen , prov ) ; } else { ser . serializeWithType ( value , jgen , prov , _typeSerializer ) ; } }
public void serializeAsField ( Object bean , JsonGenerator jgen , SerializerProvider prov ) throws Exception { Object value = get ( bean ) ; if ( value == null ) { if ( ! _suppressNulls ) { jgen . writeFieldName ( _name ) ; prov . defaultSerializeNull ( jgen ) ; } return ; } if ( value == bean ) { _reportSelfReference ( bean ) ; } if ( _suppressableValue != null && _suppressableValue . equals ( value ) ) { return ; } JsonSerializer < Object > ser = _serializer ; if ( ser == null ) { Class < ? > cls = value . getClass ( ) ; PropertySerializerMap map = _dynamicSerializers ; ser = map . serializerFor ( cls ) ; if ( ser == null ) { ser = _findAndAddDynamic ( map , cls , prov ) ; } } jgen . writeFieldName ( _name ) ; if ( _typeSerializer == null ) { ser . serialize ( value , jgen , prov ) ; } else { ser . serializeWithType ( value , jgen , prov , _typeSerializer ) ; } }
private Map loadBinaryLexicon ( InputStream is , int estimatedSize ) throws IOException { DataInputStream dis = new DataInputStream ( new BufferedInputStream ( is ) ) ; int size = _NUM ; int numEntries = _NUM ; List phonemeList = new ArrayList ( ) ; Map lexicon = new LinkedHashMap ( ) ; int magic ; try { if ( dis . readInt ( ) != MAGIC ) { throw new Error ( STRING ) ; } } catch ( IOException e ) { throw e ; } if ( dis . readInt ( ) != VERSION ) { throw new Error ( STRING ) ; } size = dis . readInt ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { String phoneme = getString ( dis ) ; phonemeList . add ( phoneme ) ; } numEntries = dis . readInt ( ) ; for ( int i = _NUM ; i < numEntries ; i ++ ) { String wordAndPos = getString ( dis ) ; String pos = Character . toString ( wordAndPos . charAt ( wordAndPos . length ( ) - _NUM ) ) ; if ( ! partsOfSpeech . contains ( pos ) ) { partsOfSpeech . add ( pos ) ; } int numPhonemes = dis . readByte ( ) ; String [ ] phonemes = new String [ numPhonemes ] ; for ( int j = _NUM ; j < numPhonemes ; j ++ ) { phonemes [ j ] = ( String ) phonemeList . get ( dis . readByte ( ) ) ; } lexicon . put ( wordAndPos , phonemes ) ; } dis . close ( ) ; return lexicon ; }
public LDIFEntryReader ( final String ... ldifLines ) { super ( Arrays . asList ( ldifLines ) ) ; }
public LDIFEntryReader ( final String ... ldifLines ) { super ( Arrays . asList ( ldifLines ) ) ; }
public CGotoModule ( final Window parent , final CDebugPerspectiveModel debugPerspectiveModel , final MemoryModule module ) { super ( String . format ( STRING , module . getName ( ) ) ) ; m_parent = parent ; m_debugPerspectiveModel = debugPerspectiveModel ; m_module = module ; }
void saveResourceIndex ( String resourceType , String indexXML ) throws PolicyException , SSOException { Map newAttrs = new HashMap ( ) ; Set newSet = new HashSet ( ) ; newSet . add ( indexXML ) ; newAttrs . put ( RESOURCES_XML , newSet ) ; ServiceConfig resources = getResourcesServiceConfig ( _BOOL ) ; if ( resources != null ) { ServiceConfig leafConfig = null ; try { leafConfig = resources . getSubConfig ( resourceType ) ; if ( leafConfig == null ) { resources . addSubConfig ( resourceType , PolicyManager . RESOURCES_POLICY_ID , _NUM , newAttrs ) ; } else { leafConfig . setAttributes ( newAttrs ) ; } } catch ( SMSException e1 ) { throw new PolicyException ( e1 ) ; } } }
private boolean igContainsInitiators ( StorageSystem storage , CIMInstance igInstance , List < String > initiatorsInDb ) { CIMObjectPath igPath = igInstance . getObjectPath ( ) ; CloseableIterator < CIMInstance > initiatorsForIg = null ; try { initiatorsForIg = _helper . getAssociatorInstances ( storage , igPath , null , SmisConstants . CP_SE_STORAGE_HARDWARE_ID , null , null , SmisConstants . PS_STORAGE_ID ) ; if ( initiatorsForIg != null ) { while ( initiatorsForIg . hasNext ( ) ) { CIMInstance initiatorInstance = initiatorsForIg . next ( ) ; String initiatorPort = CIMPropertyFactory . getPropertyValue ( initiatorInstance , SmisConstants . CP_STORAGE_ID ) ; _log . info ( String . format ( STRING , igPath , initiatorPort ) ) ; if ( initiatorsInDb . contains ( initiatorPort ) ) { return _BOOL ; } } } } catch ( Exception e ) { } finally { if ( initiatorsForIg != null ) { initiatorsForIg . close ( ) ; } } return _BOOL ; }
private void populateDbOptions ( String dbProduct , Element dbOptionsElement , Map < String , String > dbOptionsMap ) { NodeList dbOptions = dbOptionsElement . getElementsByTagName ( STRING ) ; for ( int i = _NUM ; i < dbOptions . getLength ( ) ; i ++ ) { Element dbOption = ( Element ) dbOptions . item ( i ) ; if ( ! dbProduct . equalsIgnoreCase ( dbOption . getAttribute ( STRING ) ) ) { continue ; } dbOptionsMap . put ( dbOption . getAttribute ( STRING ) , dbOption . getAttribute ( STRING ) ) ; } }
public < AnnotationType extends Annotation > void register ( MethodBinder < AnnotationType > methodBinder ) { Set < AnnotatedMethod < AnnotationType > > annotatedMethods = AnnotatedMethods . get ( methodBinder . getAnnotationClass ( ) , annotatedType ) ; if ( ! annotatedMethods . isEmpty ( ) ) { objectBinders . add ( new AnnotatedMethodBinder < > ( methodBinder , annotatedMethods ) ) ; } }
public < AnnotationType extends Annotation > void register ( MethodBinder < AnnotationType > methodBinder ) { Set < AnnotatedMethod < AnnotationType > > annotatedMethods = AnnotatedMethods . get ( methodBinder . getAnnotationClass ( ) , annotatedType ) ; if ( ! annotatedMethods . isEmpty ( ) ) { objectBinders . add ( new AnnotatedMethodBinder < > ( methodBinder , annotatedMethods ) ) ; } }
public void tagSwapAndCopyFile ( ) throws Exception { BufferedReader br = null ; BufferedWriter bw = null ; try { FileInputStream fi = new FileInputStream ( getSourceFile ( ) ) ; InputStreamReader ir = new InputStreamReader ( fi , DEFAULT_ENCODING ) ; br = new BufferedReader ( ir ) ; FileOutputStream fo = new FileOutputStream ( getDestinationFile ( ) ) ; OutputStreamWriter ow = new OutputStreamWriter ( fo , DEFAULT_ENCODING ) ; bw = new BufferedWriter ( ow ) ; StringBuffer tokenQueue = new StringBuffer ( _NUM ) ; StringBuffer resultData = new StringBuffer ( ) ; String lineData = null ; while ( ( lineData = br . readLine ( ) ) != null ) { String transformedLine = scanAndReplaceTokens ( lineData , resultData , tokenQueue ) ; bw . write ( transformedLine ) ; } } catch ( Exception e ) { throw e ; } finally { if ( br != null ) { try { br . close ( ) ; } catch ( IOException ie ) { Debug . log ( STRING + STRING , ie ) ; } } if ( bw != null ) { try { bw . flush ( ) ; bw . close ( ) ; } catch ( IOException ie ) { Debug . log ( STRING + STRING , ie ) ; } } } }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; serviceID = new ServiceID ( in ) ; }
private void readObject ( ObjectInputStream in ) throws IOException , ClassNotFoundException { in . defaultReadObject ( ) ; serviceID = new ServiceID ( in ) ; }
@ Bean LocalContainerEntityManagerFactoryBean entityManagerFactory ( DataSource dataSource , Environment env ) { LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean ( ) ; entityManagerFactoryBean . setDataSource ( dataSource ) ; entityManagerFactoryBean . setJpaVendorAdapter ( new HibernateJpaVendorAdapter ( ) ) ; entityManagerFactoryBean . setPackagesToScan ( ENTITY_PACKAGES ) ; Properties jpaProperties = new Properties ( ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_DIALECT , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_DIALECT ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_HBM2DDL_AUTO , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_HBM2DDL_AUTO ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_NAMING_STRATEGY , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_NAMING_STRATEGY ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_SHOW_SQL , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_SHOW_SQL ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_FORMAT_SQL , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_FORMAT_SQL ) ) ; entityManagerFactoryBean . setJpaProperties ( jpaProperties ) ; return entityManagerFactoryBean ; }
@ Bean LocalContainerEntityManagerFactoryBean entityManagerFactory ( DataSource dataSource , Environment env ) { LocalContainerEntityManagerFactoryBean entityManagerFactoryBean = new LocalContainerEntityManagerFactoryBean ( ) ; entityManagerFactoryBean . setDataSource ( dataSource ) ; entityManagerFactoryBean . setJpaVendorAdapter ( new HibernateJpaVendorAdapter ( ) ) ; entityManagerFactoryBean . setPackagesToScan ( ENTITY_PACKAGES ) ; Properties jpaProperties = new Properties ( ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_DIALECT , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_DIALECT ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_HBM2DDL_AUTO , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_HBM2DDL_AUTO ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_NAMING_STRATEGY , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_NAMING_STRATEGY ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_SHOW_SQL , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_SHOW_SQL ) ) ; jpaProperties . put ( PROPERTY_NAME_HIBERNATE_FORMAT_SQL , env . getRequiredProperty ( PROPERTY_NAME_HIBERNATE_FORMAT_SQL ) ) ; entityManagerFactoryBean . setJpaProperties ( jpaProperties ) ; return entityManagerFactoryBean ; }
@ Override public void endOfStream ( ) throws AdeException , AdeFlowException { for ( Entry < String , PerodicityBounder > last : m_lastSeen . entrySet ( ) ) { final PerodicityBounder pb = last . getValue ( ) ; pb . train ( last . getKey ( ) ) ; } m_trained = _BOOL ; }
@ Override public void endOfStream ( ) throws AdeException , AdeFlowException { for ( Entry < String , PerodicityBounder > last : m_lastSeen . entrySet ( ) ) { final PerodicityBounder pb = last . getValue ( ) ; pb . train ( last . getKey ( ) ) ; } m_trained = _BOOL ; }
@ Override public void endOfStream ( ) throws AdeException , AdeFlowException { for ( Entry < String , PerodicityBounder > last : m_lastSeen . entrySet ( ) ) { final PerodicityBounder pb = last . getValue ( ) ; pb . train ( last . getKey ( ) ) ; } m_trained = _BOOL ; }
void copyValue ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ; System . arraycopy ( val , _NUM , value , _NUM , len ) ; intLen = len ; offset = _NUM ; }
void copyValue ( int [ ] val ) { int len = val . length ; if ( value . length < len ) value = new int [ len ] ; System . arraycopy ( val , _NUM , value , _NUM , len ) ; intLen = len ; offset = _NUM ; }
private int computeAlpha ( final ISItem item ) { return ( int ) ( _NUM - _NUM * Math . abs ( item . getzPosition ( ) ) ) ; }
public Builder addPhoto ( Photo photo ) { photos . add ( photo ) ; return this ; }
public Builder addPhoto ( Photo photo ) { photos . add ( photo ) ; return this ; }
public long timeSinceStart ( ) { long currentTime = System . currentTimeMillis ( ) ; return currentTime - startTime ; }
public static void startServices ( ServiceHost host , Class ... services ) throws InstantiationException , IllegalAccessException { checkArgument ( services != null , STRING ) ; for ( Class service : services ) { startService ( host , service ) ; } }
public int hashCode ( ) { int result = _NUM ; if ( isDestroyed ( ) ) { return result ; } result = _NUM * result + Arrays . hashCode ( getEncoded ( ) ) ; result = _NUM * result + getKeyType ( ) ; if ( principal != null ) { result = _NUM * result + principal . hashCode ( ) ; } return result * _NUM + versionNum ; }
public AbstractSurfaceObject ( ) { this . visible = _BOOL ; this . uniqueId = nextUniqueId ( ) ; this . lastModifiedTime = System . currentTimeMillis ( ) ; this . enableBatchPicking = _BOOL ; }
public AbstractSurfaceObject ( ) { this . visible = _BOOL ; this . uniqueId = nextUniqueId ( ) ; this . lastModifiedTime = System . currentTimeMillis ( ) ; this . enableBatchPicking = _BOOL ; }
public AbstractSurfaceObject ( ) { this . visible = _BOOL ; this . uniqueId = nextUniqueId ( ) ; this . lastModifiedTime = System . currentTimeMillis ( ) ; this . enableBatchPicking = _BOOL ; }
int size ( ) { return Integer . bitCount ( set ) ; }
int size ( ) { return Integer . bitCount ( set ) ; }
int size ( ) { return Integer . bitCount ( set ) ; }
@ Override public double evaluateAttribute ( int attribute ) throws Exception { return m_weights [ attribute ] ; }
@ Override public double evaluateAttribute ( int attribute ) throws Exception { return m_weights [ attribute ] ; }
@ Override public double evaluateAttribute ( int attribute ) throws Exception { return m_weights [ attribute ] ; }
@ Override public double evaluateAttribute ( int attribute ) throws Exception { return m_weights [ attribute ] ; }
public static long [ ] appendLong ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = _NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + _NUM ] ; System . arraycopy ( cur , _NUM , ret , _NUM , N ) ; ret [ N ] = val ; return ret ; }
public static long [ ] appendLong ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = _NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + _NUM ] ; System . arraycopy ( cur , _NUM , ret , _NUM , N ) ; ret [ N ] = val ; return ret ; }
public static long [ ] appendLong ( long [ ] cur , long val ) { if ( cur == null ) { return new long [ ] { val } ; } final int N = cur . length ; for ( int i = _NUM ; i < N ; i ++ ) { if ( cur [ i ] == val ) { return cur ; } } long [ ] ret = new long [ N + _NUM ] ; System . arraycopy ( cur , _NUM , ret , _NUM , N ) ; ret [ N ] = val ; return ret ; }
private static void addEntriesForInfrequentBlocks ( IR ir , LiveAnalysis live , HashMap < BasicBlockPair , HashSet < Register > > result ) { for ( Enumeration < BasicBlock > e = ir . getBasicBlocks ( ) ; e . hasMoreElements ( ) ; ) { BasicBlock bb = e . nextElement ( ) ; boolean bbInfrequent = bb . getInfrequent ( ) ; for ( Enumeration < BasicBlock > out = bb . getNormalOut ( ) ; out . hasMoreElements ( ) ; ) { BasicBlock dest = out . nextElement ( ) ; boolean destInfrequent = dest . getInfrequent ( ) ; if ( bbInfrequent ^ destInfrequent ) { HashSet < Register > liveRegisters = live . getLiveRegistersOnEdge ( bb , dest ) ; for ( Register r : liveRegisters ) { if ( r . isSymbolic ( ) ) { HashSet < Register > s = findOrCreateSplitSet ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
private static void addEntriesForInfrequentBlocks ( IR ir , LiveAnalysis live , HashMap < BasicBlockPair , HashSet < Register > > result ) { for ( Enumeration < BasicBlock > e = ir . getBasicBlocks ( ) ; e . hasMoreElements ( ) ; ) { BasicBlock bb = e . nextElement ( ) ; boolean bbInfrequent = bb . getInfrequent ( ) ; for ( Enumeration < BasicBlock > out = bb . getNormalOut ( ) ; out . hasMoreElements ( ) ; ) { BasicBlock dest = out . nextElement ( ) ; boolean destInfrequent = dest . getInfrequent ( ) ; if ( bbInfrequent ^ destInfrequent ) { HashSet < Register > liveRegisters = live . getLiveRegistersOnEdge ( bb , dest ) ; for ( Register r : liveRegisters ) { if ( r . isSymbolic ( ) ) { HashSet < Register > s = findOrCreateSplitSet ( result , bb , dest ) ; s . add ( r ) ; } } } } } }
public boolean remove ( String url , WebPage page ) throws IndexingException { for ( IndexCleaningFilter indexcleaningFilter : indexcleaningFilters ) { if ( indexcleaningFilter . remove ( url , page ) ) { return _BOOL ; } } return _BOOL ; }
private void deleteService ( SvcReg reg , long now ) { Item item = reg . item ; generateEvents ( item , null , now ) ; serviceByID . remove ( item . serviceID ) ; serviceByTime . remove ( reg ) ; deleteServiceFromTypes ( item . serviceType , reg ) ; EntryRep [ ] entries = item . attributeSets ; for ( int i = entries . length ; -- i >= _NUM ; ) { deleteAttrs ( reg , entries [ i ] , _BOOL ) ; } computeMaxLeases ( ) ; }
public static < T > T templateFor ( final Class < T > mixinType , Association < ? > association ) { NullArgumentException . validateNotNull ( STRING , mixinType ) ; NullArgumentException . validateNotNull ( STRING , association ) ; return mixinType . cast ( Proxy . newProxyInstance ( mixinType . getClassLoader ( ) , array ( mixinType ) , new TemplateHandler < T > ( null , association ( association ) , null , null ) ) ) ; }
public static < T > T templateFor ( final Class < T > mixinType , Association < ? > association ) { NullArgumentException . validateNotNull ( STRING , mixinType ) ; NullArgumentException . validateNotNull ( STRING , association ) ; return mixinType . cast ( Proxy . newProxyInstance ( mixinType . getClassLoader ( ) , array ( mixinType ) , new TemplateHandler < T > ( null , association ( association ) , null , null ) ) ) ; }
public static < T > T templateFor ( final Class < T > mixinType , Association < ? > association ) { NullArgumentException . validateNotNull ( STRING , mixinType ) ; NullArgumentException . validateNotNull ( STRING , association ) ; return mixinType . cast ( Proxy . newProxyInstance ( mixinType . getClassLoader ( ) , array ( mixinType ) , new TemplateHandler < T > ( null , association ( association ) , null , null ) ) ) ; }
protected void addTasksForVolumesAndCGs ( DbClient dbClient , List < Volume > addVols , List < Volume > removeVols , Set < URI > removeVolumeCGs , String taskId , TaskList taskList ) { if ( addVols != null && ! addVols . isEmpty ( ) ) { for ( Volume vol : addVols ) { addVolumeTask ( dbClient , vol , taskList , taskId , ResourceOperationTypeEnum . UPDATE_VOLUME_GROUP ) ; } } if ( removeVols != null && ! removeVols . isEmpty ( ) ) { for ( Volume vol : removeVols ) { addVolumeTask ( dbClient , vol , taskList , taskId , ResourceOperationTypeEnum . UPDATE_VOLUME_GROUP ) ; } } if ( removeVolumeCGs != null && ! removeVolumeCGs . isEmpty ( ) ) { for ( URI cg : removeVolumeCGs ) { addConsistencyGroupTask ( dbClient , cg , taskList , taskId , ResourceOperationTypeEnum . UPDATE_VOLUME_GROUP ) ; } } }
public void updateDrivesCache ( ) { if ( hasWorldObj ( ) && worldObj . isRemote ) return ; drives . clear ( ) ; prototypes . clear ( ) ; for ( TileEntityDriveBay tedb : driveBays ) { if ( tedb . isInvalid ( ) ) continue ; for ( ItemStack is : tedb ) { drives . add ( is ) ; ItemDrive id = ( ItemDrive ) is . getItem ( ) ; prototypes . addAll ( id . getPrototypes ( is ) ) ; } } Collections . sort ( drives , new DriveComparator ( ) ) ; }
private SynapseAdjustmentPanel ( final NetworkPanel networkPanel , final List < Synapse > synapses ) { this . networkPanel = networkPanel ; this . synapses = synapses ; if ( synapses . size ( ) == _NUM ) { return ; } setLayout ( new GridBagLayout ( ) ) ; extractWeightValues ( synapses ) ; initializeLayout ( ) ; }
public MailMessage addRecipientTo ( String address ) { if ( address != null ) { to . add ( address ) ; } return this ; }
public MailMessage addRecipientTo ( String address ) { if ( address != null ) { to . add ( address ) ; } return this ; }
private void polygonize ( ) { if ( polyList != null ) return ; polyList = new ArrayList ( ) ; if ( graph == null ) return ; dangles = graph . deleteDangles ( ) ; cutEdges = graph . deleteCutEdges ( ) ; List edgeRingList = graph . getEdgeRings ( ) ; List validEdgeRingList = new ArrayList ( ) ; invalidRingLines = new ArrayList ( ) ; if ( isCheckingRingsValid ) { findValidRings ( edgeRingList , validEdgeRingList , invalidRingLines ) ; } else { validEdgeRingList = edgeRingList ; } findShellsAndHoles ( validEdgeRingList ) ; assignHolesToShells ( holeList , shellList ) ; Collections . sort ( shellList , new EdgeRing . EnvelopeComparator ( ) ) ; boolean includeAll = _BOOL ; if ( extractOnlyPolygonal ) { findDisjointShells ( shellList ) ; includeAll = _BOOL ; } polyList = extractPolygons ( shellList , includeAll ) ; }
private boolean continueAfterAcceptFailure ( Throwable t ) { RMIFailureHandler fh = RMISocketFactory . getFailureHandler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new InvocationTargetException ( t ) ) ; } else { throttleLoopOnException ( ) ; return _BOOL ; } }
private boolean continueAfterAcceptFailure ( Throwable t ) { RMIFailureHandler fh = RMISocketFactory . getFailureHandler ( ) ; if ( fh != null ) { return fh . failure ( t instanceof Exception ? ( Exception ) t : new InvocationTargetException ( t ) ) ; } else { throttleLoopOnException ( ) ; return _BOOL ; } }
public void testSerialization ( ) throws Exception { Object targetObject = getTargetObject ( ) ; for ( int i = _NUM ; i < getVersions ( ) . length ; i ++ ) { String version = getVersions ( ) [ i ] ; verifyMatch ( targetObject , deserialize ( version , targetObject . getClass ( ) ) ) ; } }
public void testSerialization ( ) throws Exception { Object targetObject = getTargetObject ( ) ; for ( int i = _NUM ; i < getVersions ( ) . length ; i ++ ) { String version = getVersions ( ) [ i ] ; verifyMatch ( targetObject , deserialize ( version , targetObject . getClass ( ) ) ) ; } }
public boolean isDefending ( ) { return ( isBeingAttacked ( ) && ( System . currentTimeMillis ( ) - combatIconTime < _NUM * TURN_LENGTH ) ) ; }
public boolean isDefending ( ) { return ( isBeingAttacked ( ) && ( System . currentTimeMillis ( ) - combatIconTime < _NUM * TURN_LENGTH ) ) ; }
public static void write ( OMRect rect , Link link , LinkProperties props ) throws IOException { switch ( rect . getRenderType ( ) ) { case OMRect . RENDERTYPE_LATLON : LinkRectangle . write ( ( float ) rect . getNorthLat ( ) , ( float ) rect . getWestLon ( ) , ( float ) rect . getSouthLat ( ) , ( float ) rect . getEastLon ( ) , rect . getLineType ( ) , props , link . dos ) ; break ; case OMRect . RENDERTYPE_XY : LinkRectangle . write ( rect . getLeft ( ) , rect . getTop ( ) , rect . getRight ( ) , rect . getBottom ( ) , props , link . dos ) ; break ; case OMRect . RENDERTYPE_OFFSET : LinkRectangle . write ( ( float ) rect . getNorthLat ( ) , ( float ) rect . getWestLon ( ) , rect . getLeft ( ) , rect . getTop ( ) , rect . getRight ( ) , rect . getBottom ( ) , props , link . dos ) ; break ; default : Debug . error ( STRING ) ; } }
private IEntryHolder updateEntrySA ( Context context , IEntryHolder entry , ITemplateHolder template , boolean fromReplication , boolean origin , IServerTypeDesc typeDesc ) throws SAException { _cacheManager . insertToRecentUpdatesIfNeeded ( entry , _cacheManager . requiresEvictionReplicationProtection ( ) ? Long . MAX_VALUE : _NUM , null ) ; boolean shouldReplicate = _BOOL ; if ( isReplicated ( ) ) shouldReplicate = shouldReplicate ( ReplicationOperationType . UPDATE , typeDesc , _BOOL , fromReplication ) ; return _cacheManager . updateEntry ( context , entry , template , shouldReplicate , origin ) ; }
public List < Integer > rightSideView ( TreeNode root ) { if ( root == null ) { return null ; } List < Integer > res = new ArrayList < > ( ) ; Queue < TreeNode > queue = new ArrayDeque < > ( ) ; queue . offer ( root ) ; while ( ! queue . isEmpty ( ) ) { int size = queue . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { TreeNode node = queue . poll ( ) ; if ( node . left != null ) { queue . offer ( node . left ) ; } if ( node . right != null ) { queue . offer ( node . right ) ; } if ( i == size - _NUM ) { res . add ( node . val ) ; } } } return res ; }
public List < Integer > rightSideView ( TreeNode root ) { if ( root == null ) { return null ; } List < Integer > res = new ArrayList < > ( ) ; Queue < TreeNode > queue = new ArrayDeque < > ( ) ; queue . offer ( root ) ; while ( ! queue . isEmpty ( ) ) { int size = queue . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { TreeNode node = queue . poll ( ) ; if ( node . left != null ) { queue . offer ( node . left ) ; } if ( node . right != null ) { queue . offer ( node . right ) ; } if ( i == size - _NUM ) { res . add ( node . val ) ; } } } return res ; }
public final char currentChar ( CharSequence csq ) { return csq . charAt ( index ) ; }
public final char currentChar ( CharSequence csq ) { return csq . charAt ( index ) ; }
protected JavaType findSerializationType ( Annotated a , boolean useStaticTyping , JavaType declaredType ) { Class < ? > serClass = _annotationIntrospector . findSerializationType ( a ) ; if ( serClass != null ) { Class < ? > rawDeclared = declaredType . getRawClass ( ) ; if ( serClass . isAssignableFrom ( rawDeclared ) ) { declaredType = declaredType . widenBy ( serClass ) ; } else { if ( ! rawDeclared . isAssignableFrom ( serClass ) ) { throw new IllegalArgumentException ( STRING + a . getName ( ) + STRING + serClass . getName ( ) + STRING + rawDeclared . getName ( ) ) ; } declaredType = _config . constructSpecializedType ( declaredType , serClass ) ; } useStaticTyping = _BOOL ; } JavaType secondary = BeanSerializerFactory . modifySecondaryTypesByAnnotation ( _config , a , declaredType ) ; if ( secondary != declaredType ) { useStaticTyping = _BOOL ; declaredType = secondary ; } if ( ! useStaticTyping ) { JsonSerialize . Typing typing = _annotationIntrospector . findSerializationTyping ( a ) ; if ( typing != null ) { useStaticTyping = ( typing == JsonSerialize . Typing . STATIC ) ; } } return useStaticTyping ? declaredType : null ; }
protected JavaType findSerializationType ( Annotated a , boolean useStaticTyping , JavaType declaredType ) { Class < ? > serClass = _annotationIntrospector . findSerializationType ( a ) ; if ( serClass != null ) { Class < ? > rawDeclared = declaredType . getRawClass ( ) ; if ( serClass . isAssignableFrom ( rawDeclared ) ) { declaredType = declaredType . widenBy ( serClass ) ; } else { if ( ! rawDeclared . isAssignableFrom ( serClass ) ) { throw new IllegalArgumentException ( STRING + a . getName ( ) + STRING + serClass . getName ( ) + STRING + rawDeclared . getName ( ) ) ; } declaredType = _config . constructSpecializedType ( declaredType , serClass ) ; } useStaticTyping = _BOOL ; } JavaType secondary = BeanSerializerFactory . modifySecondaryTypesByAnnotation ( _config , a , declaredType ) ; if ( secondary != declaredType ) { useStaticTyping = _BOOL ; declaredType = secondary ; } if ( ! useStaticTyping ) { JsonSerialize . Typing typing = _annotationIntrospector . findSerializationTyping ( a ) ; if ( typing != null ) { useStaticTyping = ( typing == JsonSerialize . Typing . STATIC ) ; } } return useStaticTyping ? declaredType : null ; }
protected JavaType findSerializationType ( Annotated a , boolean useStaticTyping , JavaType declaredType ) { Class < ? > serClass = _annotationIntrospector . findSerializationType ( a ) ; if ( serClass != null ) { Class < ? > rawDeclared = declaredType . getRawClass ( ) ; if ( serClass . isAssignableFrom ( rawDeclared ) ) { declaredType = declaredType . widenBy ( serClass ) ; } else { if ( ! rawDeclared . isAssignableFrom ( serClass ) ) { throw new IllegalArgumentException ( STRING + a . getName ( ) + STRING + serClass . getName ( ) + STRING + rawDeclared . getName ( ) ) ; } declaredType = _config . constructSpecializedType ( declaredType , serClass ) ; } useStaticTyping = _BOOL ; } JavaType secondary = BeanSerializerFactory . modifySecondaryTypesByAnnotation ( _config , a , declaredType ) ; if ( secondary != declaredType ) { useStaticTyping = _BOOL ; declaredType = secondary ; } if ( ! useStaticTyping ) { JsonSerialize . Typing typing = _annotationIntrospector . findSerializationTyping ( a ) ; if ( typing != null ) { useStaticTyping = ( typing == JsonSerialize . Typing . STATIC ) ; } } return useStaticTyping ? declaredType : null ; }
public static void sort ( long [ ] array ) { DualPivotQuicksort . sort ( array ) ; }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return ID ; case _NUM : return PROPERTY ; default : return null ; } }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public SampleVcpc ( IndependenceTest independenceTest ) { if ( independenceTest == null ) { throw new NullPointerException ( ) ; } if ( ! ( independenceTest instanceof IndTestFisherZ ) ) { throw new IllegalArgumentException ( STRING ) ; } this . independenceTest = independenceTest ; this . dataSet = ( DataSet ) independenceTest . getData ( ) ; this . variables = dataSet . getVariables ( ) ; this . covMatrix = new CovarianceMatrix ( dataSet ) ; List < Node > nodes = covMatrix . getVariables ( ) ; this . indexMap = indexMap ( variables ) ; this . nameMap = mapNames ( variables ) ; this . nodesToVariables = new HashMap < > ( ) ; this . variablesToNodes = new HashMap < > ( ) ; }
public final Set < Class < ? extends Annotation > > loadExternalAnnotationClassesFromDirectory ( final String dirName ) { File rootDirectory = new File ( dirName ) ; Set < String > annoNames = getAnnotationNamesFromDirectory ( STRING , dirName , rootDirectory , JAVA_SUFFIX ) ; return loadAnnotationClasses ( annoNames ) ; }
public final Set < Class < ? extends Annotation > > loadExternalAnnotationClassesFromDirectory ( final String dirName ) { File rootDirectory = new File ( dirName ) ; Set < String > annoNames = getAnnotationNamesFromDirectory ( STRING , dirName , rootDirectory , JAVA_SUFFIX ) ; return loadAnnotationClasses ( annoNames ) ; }
public String readLine ( ) throws IOException { if ( finished ) throw new DccException ( DccException . Reason . ChatNotConnected , user , STRING ) ; String line = bufferedReader . readLine ( ) ; log . info ( INPUT_CHAT_MARKER , STRING + line ) ; return line ; }
protected void addBackupsToBackupRequestBuffer ( FbService service , ServiceRequestBuffer backupSPB ) throws SQLException { for ( Iterator < PathSizeStruct > iter = backupPaths . iterator ( ) ; iter . hasNext ( ) ; ) { PathSizeStruct pathSize = iter . next ( ) ; backupSPB . addArgument ( isc_spb_bkp_file , pathSize . getPath ( ) ) ; if ( iter . hasNext ( ) && pathSize . getSize ( ) == - _NUM ) { throw new SQLException ( STRING + pathSize . getPath ( ) ) ; } if ( iter . hasNext ( ) ) { backupSPB . addArgument ( isc_spb_bkp_length , pathSize . getSize ( ) ) ; } } }
public static boolean isNotEmpty ( final Collection < ? > collection ) { return collection != null && ! collection . isEmpty ( ) ; }
public static boolean isNotEmpty ( final Collection < ? > collection ) { return collection != null && ! collection . isEmpty ( ) ; }
public static boolean isNotEmpty ( final Collection < ? > collection ) { return collection != null && ! collection . isEmpty ( ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public void initialize ( Context context , String appIdentifier , String channeId ) { ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; DeviceInfoCapture . init ( context ) ; if ( searchNativeLib ( new File ( STRING + context . getPackageName ( ) ) , NATIVE_LIB_NAME ) ) { ArtisanLogUtil . debugLog ( STRING ) ; System . loadLibrary ( STRING ) ; initJniObject ( ) ; } else { ArtisanLogUtil . debugLog ( STRING ) ; } initialize ( context , appIdentifier , channeId , _BOOL ) ; ArtisanLogUtil . debugLog ( STRING + appIdentifier + STRING + channeId + STRING ) ; ArtisanLogUtil . print ( STRING ) ; }
public String toXML ( final Object obj ) { final Writer writer = new StringWriter ( ) ; toXML ( obj , writer ) ; return writer . toString ( ) ; }
public String toXML ( final Object obj ) { final Writer writer = new StringWriter ( ) ; toXML ( obj , writer ) ; return writer . toString ( ) ; }
public boolean isAlive ( ) { if ( hasSentData ) { if ( System . currentTimeMillis ( ) - lastSendTime < TIMEOUT ) return _BOOL ; return hasReceivedData && lastReceiveTime > lastSendTime ; } return _BOOL ; }
public boolean isAlive ( ) { if ( hasSentData ) { if ( System . currentTimeMillis ( ) - lastSendTime < TIMEOUT ) return _BOOL ; return hasReceivedData && lastReceiveTime > lastSendTime ; } return _BOOL ; }
public boolean isAlive ( ) { if ( hasSentData ) { if ( System . currentTimeMillis ( ) - lastSendTime < TIMEOUT ) return _BOOL ; return hasReceivedData && lastReceiveTime > lastSendTime ; } return _BOOL ; }
public ArrayList < MechSummary > generate ( int numRolls , String ratName ) { return generate ( numRolls , ratName , null ) ; }
public static byte [ ] encodingToBytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . getBytes ( encoding ) ; } catch ( final UnsupportedEncodingException e ) { throw new Error ( encoding + STRING + e ) ; } }
public static byte [ ] encodingToBytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . getBytes ( encoding ) ; } catch ( final UnsupportedEncodingException e ) { throw new Error ( encoding + STRING + e ) ; } }
public static byte [ ] encodingToBytes ( final String str , final String encoding ) { if ( str == null ) { return null ; } try { return str . getBytes ( encoding ) ; } catch ( final UnsupportedEncodingException e ) { throw new Error ( encoding + STRING + e ) ; } }
public int size ( ) { return m_RecentItems . size ( ) ; }
public int size ( ) { return m_RecentItems . size ( ) ; }
public JBBPOut Short ( final String str ) throws IOException { assertNotEnded ( ) ; if ( this . processCommands ) { for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { _writeShort ( str . charAt ( i ) ) ; } } return this ; }
public JBBPOut Short ( final String str ) throws IOException { assertNotEnded ( ) ; if ( this . processCommands ) { for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { _writeShort ( str . charAt ( i ) ) ; } } return this ; }
public void takePicture ( ) throws NullPointerException { Intent takePictureIntent = new Intent ( MediaStore . ACTION_IMAGE_CAPTURE ) ; if ( takePictureIntent . resolveActivity ( activity . getPackageManager ( ) ) != null ) { File photoFile = Utils . createImageFile ( context , dirName , imageName , imageType ) ; if ( photoFile != null ) { cameraBitmapPath = photoFile . getAbsolutePath ( ) ; takePictureIntent . putExtra ( MediaStore . EXTRA_OUTPUT , Uri . fromFile ( photoFile ) ) ; activity . startActivityForResult ( takePictureIntent , REQUEST_TAKE_PHOTO ) ; } else { throw new NullPointerException ( STRING ) ; } } else { throw new NullPointerException ( STRING ) ; } }
public void testBadSegment ( ) throws IOException { Directory dir = newDirectory ( ) ; IndexWriter iw = new IndexWriter ( dir , newIndexWriterConfig ( new MockAnalyzer ( random ( ) ) ) ) ; Document document = new Document ( ) ; FieldType customType = new FieldType ( TextField . TYPE_NOT_STORED ) ; customType . setStoreTermVectors ( _BOOL ) ; document . add ( newField ( STRING , STRING , customType ) ) ; iw . addDocument ( document ) ; iw . close ( ) ; dir . close ( ) ; }
public int depth ( ) { return pointer ; }
public static void writeLittleEndianInt ( DataOutputStream dataStream , int val ) throws IOException { int mask = _NUM ; for ( int shift = _NUM ; shift < _NUM ; shift += _NUM ) { dataStream . writeByte ( mask & ( val > > shift ) ) ; } }
public ServiceEndpoint ( String name , String endpoint , String binding ) { ValidateUtil . validateNotEmpty ( endpoint , STRING ) ; ValidateUtil . validateNotEmpty ( binding , STRING ) ; if ( name == null || name . isEmpty ( ) ) { name = endpoint ; } this . name = name ; this . endpoint = endpoint ; this . binding = binding ; }
public void actionPerformed ( ActionEvent e ) { navigateToPriorDemo ( ) ; }
protected boolean cleanState ( String topologyName , SchedulerStateManagerAdaptor statemgr ) { LOG . fine ( STRING ) ; Boolean result ; result = statemgr . deleteTMasterLocation ( topologyName ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . deletePackingPlan ( topologyName ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . deletePhysicalPlan ( topologyName ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . deleteSchedulerLocation ( topologyName ) ; if ( result == null || ! result ) { LOG . warning ( STRING ) ; } result = statemgr . deleteExecutionState ( topologyName ) ; if ( result == null || ! result ) { LOG . severe ( STRING ) ; return _BOOL ; } result = statemgr . deleteTopology ( topologyName ) ; if ( result == null || ! result ) { LOG . severe ( STRING ) ; return _BOOL ; } LOG . fine ( STRING ) ; return _BOOL ; }
protected void doPing ( @ NotNull String app , @ NotNull String version , @ Nullable final Map < String , String > extras ) { final String nApp = normalizeAppName ( app ) ; final String nVersion = normalizeVersion ( version ) ; if ( ! mStore . isPingOptIn ( ) ) { return ; } long now = System . currentTimeMillis ( ) ; long then = mStore . getPingTime ( app ) ; if ( now - then < PING_INTERVAL_MSEC ) { return ; } mStore . setPingTime ( app , now ) ; try { URL url = createPingUrl ( nApp , nVersion , INSTALLATION_ID , extras ) ; actuallySendPing ( url ) ; } catch ( Exception e ) { LOG . warn ( STRING , e ) ; } }
protected void doPing ( @ NotNull String app , @ NotNull String version , @ Nullable final Map < String , String > extras ) { final String nApp = normalizeAppName ( app ) ; final String nVersion = normalizeVersion ( version ) ; if ( ! mStore . isPingOptIn ( ) ) { return ; } long now = System . currentTimeMillis ( ) ; long then = mStore . getPingTime ( app ) ; if ( now - then < PING_INTERVAL_MSEC ) { return ; } mStore . setPingTime ( app , now ) ; try { URL url = createPingUrl ( nApp , nVersion , INSTALLATION_ID , extras ) ; actuallySendPing ( url ) ; } catch ( Exception e ) { LOG . warn ( STRING , e ) ; } }
private byte [ ] entityToBytes ( HttpEntity entity , Request request ) throws IOException , ServerError { PoolingByteArrayOutputStream bytes = new PoolingByteArrayOutputStream ( mPool , ( int ) entity . getContentLength ( ) ) ; byte [ ] buffer = null ; try { InputStream in = entity . getContent ( ) ; if ( in == null ) { throw new ServerError ( ) ; } buffer = mPool . getBuf ( _NUM ) ; int progress = _NUM ; int count ; while ( ( count = in . read ( buffer ) ) != - _NUM ) { bytes . write ( buffer , _NUM , count ) ; progress += count ; request . progressUpdate ( progress ) ; } return bytes . toByteArray ( ) ; } finally { try { entity . consumeContent ( ) ; } catch ( IOException e ) { VinciLog . d ( STRING ) ; } mPool . returnBuf ( buffer ) ; bytes . close ( ) ; } }
public static Long toLong ( boolean b ) { return Long . valueOf ( toLongValue ( b ) ) ; }
public boolean epsilonEquals ( float x , float y , float z , float epsilon ) { if ( Math . abs ( x - this . x ) > epsilon ) return _BOOL ; if ( Math . abs ( y - this . y ) > epsilon ) return _BOOL ; if ( Math . abs ( z - this . z ) > epsilon ) return _BOOL ; return _BOOL ; }
@ ObjectiveCName ( STRING ) private boolean isDiscardAck ( Message message ) { Event event = Event . getEvent ( message . data [ _NUM ] ) ; if ( event == Event . MESSAGE_DENIED && Actions . getAction ( message . data [ _NUM ] ) == Actions . DELETE ) { return _BOOL ; } Actions action = Actions . getAction ( message . data [ _NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ ObjectiveCName ( STRING ) private boolean isDiscardAck ( Message message ) { Event event = Event . getEvent ( message . data [ _NUM ] ) ; if ( event == Event . MESSAGE_DENIED && Actions . getAction ( message . data [ _NUM ] ) == Actions . DELETE ) { return _BOOL ; } Actions action = Actions . getAction ( message . data [ _NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ ObjectiveCName ( STRING ) private boolean isDiscardAck ( Message message ) { Event event = Event . getEvent ( message . data [ _NUM ] ) ; if ( event == Event . MESSAGE_DENIED && Actions . getAction ( message . data [ _NUM ] ) == Actions . DELETE ) { return _BOOL ; } Actions action = Actions . getAction ( message . data [ _NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ ObjectiveCName ( STRING ) private boolean isDiscardAck ( Message message ) { Event event = Event . getEvent ( message . data [ _NUM ] ) ; if ( event == Event . MESSAGE_DENIED && Actions . getAction ( message . data [ _NUM ] ) == Actions . DELETE ) { return _BOOL ; } Actions action = Actions . getAction ( message . data [ _NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
@ ObjectiveCName ( STRING ) private boolean isDiscardAck ( Message message ) { Event event = Event . getEvent ( message . data [ _NUM ] ) ; if ( event == Event . MESSAGE_DENIED && Actions . getAction ( message . data [ _NUM ] ) == Actions . DELETE ) { return _BOOL ; } Actions action = Actions . getAction ( message . data [ _NUM ] ) ; return action == Actions . DELETE || action == Actions . UNSUBSCRIBE ; }
public void testBooleanOptions ( ) throws Exception { DatabaseMetaData dbmd = con . getMetaData ( ) ; assertTrue ( STRING , dbmd . locatorsUpdateCopy ( ) ) ; assertTrue ( STRING , dbmd . supportsGetGeneratedKeys ( ) ) ; assertTrue ( STRING , dbmd . supportsMultipleOpenResults ( ) ) ; assertTrue ( STRING , dbmd . supportsNamedParameters ( ) ) ; assertFalse ( STRING , dbmd . supportsResultSetHoldability ( ResultSet . HOLD_CURSORS_OVER_COMMIT ) ) ; assertFalse ( STRING , dbmd . supportsResultSetHoldability ( ResultSet . CLOSE_CURSORS_AT_COMMIT ) ) ; assertTrue ( STRING , dbmd . supportsSavepoints ( ) ) ; assertTrue ( STRING , dbmd . supportsStatementPooling ( ) ) ; }
public void testBooleanOptions ( ) throws Exception { DatabaseMetaData dbmd = con . getMetaData ( ) ; assertTrue ( STRING , dbmd . locatorsUpdateCopy ( ) ) ; assertTrue ( STRING , dbmd . supportsGetGeneratedKeys ( ) ) ; assertTrue ( STRING , dbmd . supportsMultipleOpenResults ( ) ) ; assertTrue ( STRING , dbmd . supportsNamedParameters ( ) ) ; assertFalse ( STRING , dbmd . supportsResultSetHoldability ( ResultSet . HOLD_CURSORS_OVER_COMMIT ) ) ; assertFalse ( STRING , dbmd . supportsResultSetHoldability ( ResultSet . CLOSE_CURSORS_AT_COMMIT ) ) ; assertTrue ( STRING , dbmd . supportsSavepoints ( ) ) ; assertTrue ( STRING , dbmd . supportsStatementPooling ( ) ) ; }
public static void replaceStyles ( List < ShapeRecord > shapeRecords , int lineStyleIndex , int fillStyle0Index , int fillStyle1Index ) { if ( shapeRecords != null && shapeRecords . size ( ) > _NUM ) { for ( int i = _NUM ; i < shapeRecords . size ( ) ; i ++ ) { ShapeRecord record = shapeRecords . get ( i ) ; if ( record instanceof StyleChangeRecord ) { StyleChangeRecord old_scr = ( StyleChangeRecord ) record ; StyleChangeRecord new_scr = new StyleChangeRecord ( ) ; if ( fillStyle0Index > _NUM ) new_scr . setFillStyle0 ( fillStyle0Index ) ; if ( fillStyle1Index > _NUM ) new_scr . setFillStyle1 ( fillStyle1Index ) ; if ( ( ! old_scr . stateLineStyle ) && ( lineStyleIndex > _NUM ) ) new_scr . setLinestyle ( lineStyleIndex ) ; else new_scr . setLinestyle ( old_scr . linestyle ) ; if ( old_scr . stateMoveTo ) new_scr . setMove ( old_scr . moveDeltaX , old_scr . moveDeltaY ) ; shapeRecords . set ( i , new_scr ) ; } } } }
public static void replaceStyles ( List < ShapeRecord > shapeRecords , int lineStyleIndex , int fillStyle0Index , int fillStyle1Index ) { if ( shapeRecords != null && shapeRecords . size ( ) > _NUM ) { for ( int i = _NUM ; i < shapeRecords . size ( ) ; i ++ ) { ShapeRecord record = shapeRecords . get ( i ) ; if ( record instanceof StyleChangeRecord ) { StyleChangeRecord old_scr = ( StyleChangeRecord ) record ; StyleChangeRecord new_scr = new StyleChangeRecord ( ) ; if ( fillStyle0Index > _NUM ) new_scr . setFillStyle0 ( fillStyle0Index ) ; if ( fillStyle1Index > _NUM ) new_scr . setFillStyle1 ( fillStyle1Index ) ; if ( ( ! old_scr . stateLineStyle ) && ( lineStyleIndex > _NUM ) ) new_scr . setLinestyle ( lineStyleIndex ) ; else new_scr . setLinestyle ( old_scr . linestyle ) ; if ( old_scr . stateMoveTo ) new_scr . setMove ( old_scr . moveDeltaX , old_scr . moveDeltaY ) ; shapeRecords . set ( i , new_scr ) ; } } } }
PrimerPack ( ByteProvider byteProvider , KLVPacket . Header header ) throws IOException { this . header = header ; this . localTagEntryBatch = new LocalTagEntryBatch ( byteProvider ) ; }
public static String toJson ( final Object object ) { return toJson ( object , _BOOL ) ; }
public static String toJson ( final Object object ) { return toJson ( object , _BOOL ) ; }
public boolean contains ( String name ) { return indexOf ( name ) != - _NUM ; }
public boolean contains ( String name ) { return indexOf ( name ) != - _NUM ; }
public void incrementRenewedTokens ( String tenant ) { logger . trace ( STRING , tenant ) ; try { AtomicInteger count ; synchronized ( this ) { if ( ( count = renewedTokensMap . get ( tenant ) ) == null ) { renewedTokensMap . put ( tenant , new AtomicInteger ( _NUM ) ) ; } else { count . incrementAndGet ( ) ; } } logger . trace ( STRING , tenant , renewedTokensMap . get ( tenant ) ) ; incrementTotalRenewed ( ) ; } catch ( Exception e ) { logger . error ( STRING , e ) ; } }
public void incrementRenewedTokens ( String tenant ) { logger . trace ( STRING , tenant ) ; try { AtomicInteger count ; synchronized ( this ) { if ( ( count = renewedTokensMap . get ( tenant ) ) == null ) { renewedTokensMap . put ( tenant , new AtomicInteger ( _NUM ) ) ; } else { count . incrementAndGet ( ) ; } } logger . trace ( STRING , tenant , renewedTokensMap . get ( tenant ) ) ; incrementTotalRenewed ( ) ; } catch ( Exception e ) { logger . error ( STRING , e ) ; } }
@ Nullable public static String extractClassName ( @ NotNull String string ) { StringBuilder sb = new StringBuilder ( string . length ( ) ) ; int n = string . length ( ) ; int i = _NUM ; for ( ; i < n ; i ++ ) { char c = Character . toUpperCase ( string . charAt ( i ) ) ; if ( Character . isJavaIdentifierStart ( c ) ) { sb . append ( c ) ; i ++ ; break ; } } if ( sb . length ( ) > _NUM ) { for ( ; i < n ; i ++ ) { char c = string . charAt ( i ) ; if ( Character . isJavaIdentifierPart ( c ) ) { sb . append ( c ) ; } } return sb . toString ( ) ; } return null ; }
protected static Dfp [ ] split ( final DfpField field , final String a ) { Dfp result [ ] = new Dfp [ _NUM ] ; char [ ] buf ; boolean leading = _BOOL ; int sp = _NUM ; int sig = _NUM ; buf = new char [ a . length ( ) ] ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = _BOOL ; } if ( buf [ i ] == STRING ) { sig += ( _NUM - sig ) % _NUM ; leading = _BOOL ; } if ( sig == ( field . getRadixDigits ( ) / _NUM ) * _NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ _NUM ] = field . newDfp ( new String ( buf , _NUM , sp ) ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ _NUM ] = field . newDfp ( new String ( buf ) ) ; return result ; }
protected static Dfp [ ] split ( final DfpField field , final String a ) { Dfp result [ ] = new Dfp [ _NUM ] ; char [ ] buf ; boolean leading = _BOOL ; int sp = _NUM ; int sig = _NUM ; buf = new char [ a . length ( ) ] ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = _BOOL ; } if ( buf [ i ] == STRING ) { sig += ( _NUM - sig ) % _NUM ; leading = _BOOL ; } if ( sig == ( field . getRadixDigits ( ) / _NUM ) * _NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ _NUM ] = field . newDfp ( new String ( buf , _NUM , sp ) ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ _NUM ] = field . newDfp ( new String ( buf ) ) ; return result ; }
protected static Dfp [ ] split ( final DfpField field , final String a ) { Dfp result [ ] = new Dfp [ _NUM ] ; char [ ] buf ; boolean leading = _BOOL ; int sp = _NUM ; int sig = _NUM ; buf = new char [ a . length ( ) ] ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING ) { leading = _BOOL ; } if ( buf [ i ] == STRING ) { sig += ( _NUM - sig ) % _NUM ; leading = _BOOL ; } if ( sig == ( field . getRadixDigits ( ) / _NUM ) * _NUM ) { sp = i ; break ; } if ( buf [ i ] >= STRING && buf [ i ] <= STRING && ! leading ) { sig ++ ; } } result [ _NUM ] = field . newDfp ( new String ( buf , _NUM , sp ) ) ; for ( int i = _NUM ; i < buf . length ; i ++ ) { buf [ i ] = a . charAt ( i ) ; if ( buf [ i ] >= STRING && buf [ i ] <= STRING && i < sp ) { buf [ i ] = STRING ; } } result [ _NUM ] = field . newDfp ( new String ( buf ) ) ; return result ; }
synchronized boolean expire ( long threshold ) { Iterator < ConnectionDesc > iter = conns . iterator ( ) ; ConnectionDesc entry ; while ( iter . hasNext ( ) ) { entry = iter . next ( ) ; if ( entry . expire ( threshold ) ) { d ( STRING , entry ) ; td ( STRING , entry ) ; iter . remove ( ) ; } } return conns . isEmpty ( ) ; }
synchronized boolean expire ( long threshold ) { Iterator < ConnectionDesc > iter = conns . iterator ( ) ; ConnectionDesc entry ; while ( iter . hasNext ( ) ) { entry = iter . next ( ) ; if ( entry . expire ( threshold ) ) { d ( STRING , entry ) ; td ( STRING , entry ) ; iter . remove ( ) ; } } return conns . isEmpty ( ) ; }
public static int hash ( int hash , double item ) { long l = Double . doubleToLongBits ( item ) ; return seed * prime + ( int ) ( l ^ ( l > > > _NUM ) ) ; }
@ Override public < T > void inject ( T bean ) { Objects . requireNonNull ( bean ) ; ConfigStub stub = new ConfigStub ( bean . getClass ( ) ) ; stub . inject ( bean , this ) ; }
private void beforeKey ( ) throws JSONException { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY_OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY_OBJECT ) { throw new JSONException ( STRING ) ; } newline ( ) ; replaceTop ( Scope . DANGLING_KEY ) ; }
private void beforeKey ( ) throws JSONException { Scope context = peek ( ) ; if ( context == Scope . NONEMPTY_OBJECT ) { out . append ( STRING ) ; } else if ( context != Scope . EMPTY_OBJECT ) { throw new JSONException ( STRING ) ; } newline ( ) ; replaceTop ( Scope . DANGLING_KEY ) ; }
public void addAttribute ( TagMetaDataAttr attr ) { attrs . add ( attr ) ; }
public static String correctFileName ( String f ) { f = f . replace ( STRING , STRING ) ; if ( f . startsWith ( STRING ) ) { f = f . substring ( _NUM ) ; } return f ; }
public static void installMouseListenerOnAllComponents ( MouseListener m , Container c ) { c . addMouseListener ( m ) ; Component [ ] components = c . getComponents ( ) ; for ( int i = _NUM ; i < components . length ; i ++ ) { if ( components [ i ] instanceof Container ) { MouseInputAdapterInstaller . installMouseListenerOnAllComponents ( m , ( Container ) components [ i ] ) ; } else { c . addMouseListener ( m ) ; } } }
public final String toString ( String codeset ) { StringBuffer sb = new StringBuffer ( ) ; if ( doctype != null ) sb . append ( doctype . toString ( getCodeset ( ) ) ) ; sb . append ( html . toString ( getCodeset ( ) ) ) ; return ( sb . toString ( ) ) ; }
public final String toString ( String codeset ) { StringBuffer sb = new StringBuffer ( ) ; if ( doctype != null ) sb . append ( doctype . toString ( getCodeset ( ) ) ) ; sb . append ( html . toString ( getCodeset ( ) ) ) ; return ( sb . toString ( ) ) ; }
private static List < TextRange > addPreviousComma ( PsiElement e , int cursorOffset ) { PsiElement prevSibling = e . getPrevSibling ( ) ; TextRange textRange = e . getTextRange ( ) ; TextRange offsetRange = null ; if ( prevSibling != null ) { if ( prevSibling instanceof PsiWhiteSpace ) { PsiElement prevCommaSibling = prevSibling . getPrevSibling ( ) ; if ( prevCommaSibling != null ) { ASTNode node = prevCommaSibling . getNode ( ) ; if ( node != null ) { IElementType commaType = node . getElementType ( ) ; if ( commaType == PyTokenTypes . COMMA ) { offsetRange = new TextRange ( textRange . getStartOffset ( ) - _NUM , textRange . getEndOffset ( ) ) ; if ( offsetRange . contains ( cursorOffset ) && offsetRange . getLength ( ) > _NUM ) { return Collections . singletonList ( offsetRange ) ; } } } } } else { ASTNode node = prevSibling . getNode ( ) ; if ( node != null ) { IElementType commaType = node . getElementType ( ) ; if ( commaType == PyTokenTypes . COMMA ) { offsetRange = new TextRange ( textRange . getStartOffset ( ) - _NUM , textRange . getEndOffset ( ) ) ; } } } if ( offsetRange != null ) { if ( offsetRange . contains ( cursorOffset ) && offsetRange . getLength ( ) > _NUM ) { return Collections . singletonList ( offsetRange ) ; } } } return Collections . emptyList ( ) ; }
public void deleteColumns ( int start , int len ) throws TableException { int ncol = this . arrays . length ; if ( start < _NUM || len < _NUM || start + len > ncol ) { throw new TableException ( STRING + start + STRING + len + STRING + ncol + STRING ) ; } if ( len == _NUM ) { return ; } int ocol = ncol ; ncol -= len ; Object [ ] newArrays = new Object [ ncol ] ; int [ ] newSizes = new int [ ncol ] ; Class < ? > [ ] newBases = new Class < ? > [ ncol ] ; char [ ] newTypes = new char [ ncol ] ; System . arraycopy ( this . arrays , _NUM , newArrays , _NUM , start ) ; System . arraycopy ( this . sizes , _NUM , newSizes , _NUM , start ) ; System . arraycopy ( this . bases , _NUM , newBases , _NUM , start ) ; System . arraycopy ( this . types , _NUM , newTypes , _NUM , start ) ; int rem = ocol - ( start + len ) ; System . arraycopy ( this . arrays , start + len , newArrays , start , rem ) ; System . arraycopy ( this . sizes , start + len , newSizes , start , rem ) ; System . arraycopy ( this . bases , start + len , newBases , start , rem ) ; System . arraycopy ( this . types , start + len , newTypes , start , rem ) ; this . arrays = newArrays ; this . sizes = newSizes ; this . bases = newBases ; this . types = newTypes ; initializePointers ( ) ; }
public void load ( Path propertiesPath ) { if ( propertiesPath != null ) { mPropertiesPath = propertiesPath ; InputStream in = null ; try { in = new FileInputStream ( propertiesPath . toString ( ) ) ; } catch ( FileNotFoundException e ) { mLog . error ( STRING + STRING , e ) ; } if ( in != null ) { try { mProperties . load ( in ) ; } catch ( IOException e ) { mLog . error ( STRING + STRING , e ) ; } finally { try { in . close ( ) ; } catch ( IOException e ) { } } } } mLog . info ( STRING + propertiesPath . toString ( ) + STRING ) ; }
public boolean isAttackedBy ( final IEntity attacker ) { return attackers . contains ( attacker ) ; }
public boolean isAttackedBy ( final IEntity attacker ) { return attackers . contains ( attacker ) ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
public final boolean removeElement ( int s ) { for ( int i = _NUM ; i < m_firstFree ; i ++ ) { if ( m_map [ i ] == s ) { if ( ( i + _NUM ) < m_firstFree ) System . arraycopy ( m_map , i + _NUM , m_map , i - _NUM , m_firstFree - i ) ; else m_map [ i ] = java . lang . Integer . MIN_VALUE ; m_firstFree -- ; return _BOOL ; } } return _BOOL ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { if ( isNullSeperateMultipleValues ( ) ) { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { if ( isNullSeperateMultipleValues ( ) ) { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { if ( isNullSeperateMultipleValues ( ) ) { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
private ByteBuffer writeString ( CharsetEncoder encoder , String next , int i , int noOfValues ) throws CharacterCodingException { ByteBuffer bb ; if ( ( i + _NUM ) == noOfValues ) { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } else { if ( isNullSeperateMultipleValues ( ) ) { bb = encoder . encode ( CharBuffer . wrap ( next + STRING ) ) ; } else { bb = encoder . encode ( CharBuffer . wrap ( next ) ) ; } } bb . rewind ( ) ; return bb ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > OutputBits . getNumOutputBits ( ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > InputBits . getNumInputBits ( ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > OutputBits . getNumOutputBits ( ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > InputBits . getNumInputBits ( ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > OutputBits . getNumOutputBits ( ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > InputBits . getNumInputBits ( ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
public final int first_common_layer ( BrdItem p_other ) { int max_first_layer = Math . max ( first_layer ( ) , p_other . first_layer ( ) ) ; int min_last_layer = Math . min ( last_layer ( ) , p_other . last_layer ( ) ) ; if ( max_first_layer > min_last_layer ) { return - _NUM ; } return max_first_layer ; }
private void checkThinEnabledResult ( VPlexVirtualVolumeInfo info , boolean thinEnabled , String taskId ) { if ( thinEnabled && ( null != info ) && ! info . isThinEnabled ( ) ) { _log . warn ( String . format ( STRING + STRING + STRING , info . getName ( ) , taskId ) ) ; } }
protected static final int centimeterAsPixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * _NUM / _NUM ) ; }
protected static final int centimeterAsPixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * _NUM / _NUM ) ; }
protected static final int centimeterAsPixel ( double cm , int dpi ) { return ( int ) Math . round ( dpi * cm * _NUM / _NUM ) ; }
public static void putLongLE ( byte [ ] arr , long off , long val ) { if ( UNALIGNED ) UNSAFE . putLong ( arr , off , Long . reverseBytes ( val ) ) ; else putLongByByte ( arr , off , val , _BOOL ) ; }
void close ( String name ) { if ( jmx ) { try { Utils . callStaticMethod ( STRING , name ) ; } catch ( Exception e ) { throw DbException . get ( ErrorCode . FEATURE_NOT_SUPPORTED_1 , e , STRING ) ; } } DATABASES . remove ( name ) ; }
public MemoryExampleTable ( List < Attribute > attributes ) { super ( attributes ) ; this . columns = attributes . size ( ) ; }
private void insertExpectedPoolSettingsPerTier ( CIMObjectPath capabilitiesPath , Map < String , Object > keyMap ) { List < String > expectedPoolSettingsTier = ( List < String > ) keyMap . get ( Constants . VNXPOOLCAPABILITIES_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . NO_DATA_MOVEMENT ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . AUTO_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . HIGH_AVAILABLE_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . LOW_AVAILABLE_TIER ) ; expectedPoolSettingsTier . add ( capabilitiesPath . toString ( ) + Constants . HYPHEN + Constants . START_HIGH_THEN_AUTO_TIER ) ; }
public void testExceptionally_normalCompletion ( ) { for ( boolean createIncomplete : new boolean [ ] { _BOOL , _BOOL } ) for ( Integer v1 : new Integer [ ] { _NUM , null } ) { final AtomicInteger a = new AtomicInteger ( _NUM ) ; final CompletableFuture < Integer > f = new CompletableFuture < > ( ) ; if ( ! createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; final CompletableFuture < Integer > g = f . exceptionally ( null ) ; if ( createIncomplete ) assertTrue ( f . complete ( v1 ) ) ; checkCompletedNormally ( g , v1 ) ; checkCompletedNormally ( f , v1 ) ; assertEquals ( _NUM , a . get ( ) ) ; } }
private void postBufferAccess ( ) { _lock . lock ( ) ; try { if ( -- _bufferUseCount == _NUM ) { _flushReady . signalAll ( ) ; } } finally { _lock . unlock ( ) ; } }
protected long copyCollection ( CollectionId collectionId , long timestamp ) throws InterruptedException { AtomicLong docCount = new AtomicLong ( ) ; primaryClient . executeBlocking ( STRING + collectionId + STRING , null ) ; return docCount . get ( ) ; }
protected long copyCollection ( CollectionId collectionId , long timestamp ) throws InterruptedException { AtomicLong docCount = new AtomicLong ( ) ; primaryClient . executeBlocking ( STRING + collectionId + STRING , null ) ; return docCount . get ( ) ; }
protected void reduceParseTree ( CompilationUnitDeclaration unit ) { TypeDeclaration [ ] types = unit . types ; for ( int i = _NUM , l = types . length ; i < l ; i ++ ) purgeMethodStatements ( types [ i ] , _BOOL ) ; }
protected void reduceParseTree ( CompilationUnitDeclaration unit ) { TypeDeclaration [ ] types = unit . types ; for ( int i = _NUM , l = types . length ; i < l ; i ++ ) purgeMethodStatements ( types [ i ] , _BOOL ) ; }
private < T > void addProvider ( @ NotNull Provider < T > provider ) throws ProviderConflictException { Class < T > type = provider . type ( ) ; Annotation qualifier = provider . getQualifier ( ) ; String key = PokeHelper . makeProviderKey ( type , qualifier ) ; addNewKeyToComponent ( key , this ) ; provider . setComponent ( this ) ; providers . put ( key , provider ) ; }
public static double length ( double x , double y , double z ) { return Math . sqrt ( x * x + y * y + z * z ) ; }
public void loadSomeData ( Repository repo ) throws Exception { RepositoryConnection cxn = repo . getConnection ( ) ; cxn . setAutoCommit ( _BOOL ) ; try { Resource s = new URIImpl ( STRING ) ; URI p = new URIImpl ( STRING ) ; Value o = new URIImpl ( STRING ) ; Statement stmt = new StatementImpl ( s , p , o ) ; cxn . add ( stmt ) ; cxn . commit ( ) ; } catch ( Exception ex ) { cxn . rollback ( ) ; throw ex ; } finally { cxn . close ( ) ; } }
public static Object [ ] mergeNativeArrays ( Object [ ] dst , Object [ ] src , int dstPosition , boolean doPowerOf2 ) { if ( dstPosition < _NUM ) dstPosition = dst . length ; Object [ ] result = resizeIfNeeded ( dst , dstPosition + src . length , doPowerOf2 ) ; System . arraycopy ( src , _NUM , result , dstPosition , src . length ) ; return result ; }
private List < Type > parseTypeList ( List < Map < String , Object > > types , List < TypeParameter > typeParams ) { List < Type > ts = new ArrayList < Type > ( types . size ( ) ) ; for ( Map < String , Object > st : types ) { ts . add ( getTypeFromJson ( st , null , typeParams ) ) ; } return ts ; }
@ Override public void onDetach ( ) { synchronized ( mThread ) { mProgressBar = null ; mReady = _BOOL ; mThread . notify ( ) ; } super . onDetach ( ) ; }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; } }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; } }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; } }
public void dispose ( ) { logDebug ( STRING ) ; mSetupDone = _BOOL ; if ( mServiceConn != null ) { logDebug ( STRING ) ; if ( mContext != null ) mContext . unbindService ( mServiceConn ) ; mServiceConn = null ; mService = null ; mPurchaseListener = null ; } }
private void calculateLineHeight ( ) { lineHeight = maxAscent = _NUM ; for ( int i = _NUM ; i < syntaxScheme . styles . length ; i ++ ) { Style ss = syntaxScheme . styles [ i ] ; if ( ss != null && ss . font != null ) { FontMetrics fm = getFontMetrics ( ss . font ) ; int height = fm . getHeight ( ) ; if ( height > lineHeight ) lineHeight = height ; int ascent = fm . getMaxAscent ( ) ; if ( ascent > maxAscent ) maxAscent = ascent ; } } Font temp = getFont ( ) ; FontMetrics fm = getFontMetrics ( temp ) ; int height = fm . getHeight ( ) ; if ( height > lineHeight ) { lineHeight = height ; } int ascent = fm . getMaxAscent ( ) ; if ( ascent > maxAscent ) { maxAscent = ascent ; } }
private static int write ( int fd , byte [ ] src , int pos , int len ) throws IOException { int bytes = FileSystem . writeBytes ( fd , src , pos , len ) ; if ( bytes < _NUM ) throw new IOException ( STRING + Integer . toString ( bytes ) ) ; return bytes ; }
public KafkaCluster addBrokers ( int count ) { if ( running ) throw new IllegalStateException ( STRING ) ; AtomicLong added = new AtomicLong ( ) ; while ( added . intValue ( ) < count ) { kafkaServers . computeIfAbsent ( new Integer ( added . intValue ( ) + _NUM ) , null ) ; } return this ; }
protected void addServiceListener ( SMSEntryUpdateListener updateListener ) { serviceObjects . add ( updateListener ) ; }
protected void addServiceListener ( SMSEntryUpdateListener updateListener ) { serviceObjects . add ( updateListener ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
public boolean isComparing ( PdfIndirectReference cmpObject , PdfIndirectReference outObject ) { return indirects . contains ( new IndirectPathItem ( cmpObject , outObject ) ) ; }
void put ( RowCursor cursor ) { boolean isValid ; do { isValid = _BOOL ; try ( JournalOutputStream os = openItem ( ) ) { os . write ( CODE_PUT ) ; cursor . writeJournal ( os ) ; isValid = os . complete ( ) ; } catch ( IOException e ) { log . log ( Level . FINER , e . toString ( ) , e ) ; } } while ( ! isValid ) ; }
public List < ColourChange > sampleConditionalMigrationEvents2 ( int parentColour , double parentHeight , int childColour , double childHeight , double [ ] m ) { List < ColourChange > colourChanges = new ArrayList < ColourChange > ( ) ; if ( parentHeight < childHeight ) { throw new IllegalArgumentException ( STRING + parentHeight + STRING + childHeight + STRING ) ; } try { int currentColour = parentColour ; double currentHeight = parentHeight ; while ( _BOOL ) { ColourChange nextEvent = randomConditionalMigrationEvent ( currentColour , currentHeight , childColour , childHeight , m ) ; currentHeight = nextEvent . getTime ( ) ; currentColour = nextEvent . getColourAbove ( ) ; colourChanges . add ( nextEvent ) ; } } catch ( NoEventException nee ) { } reverseColourChangeList ( colourChanges , parentColour ) ; return colourChanges ; }
public void stop ( ) { logger . info ( STRING ) ; if ( thriftServer != null ) thriftServer . stop ( ) ; if ( nativeServer != null ) nativeServer . stop ( ) ; if ( FBUtilities . isWindows ( ) ) System . exit ( _NUM ) ; if ( jmxServer != null ) { try { jmxServer . stop ( ) ; } catch ( IOException e ) { logger . error ( STRING , e ) ; } } }
public void stop ( ) { logger . info ( STRING ) ; if ( thriftServer != null ) thriftServer . stop ( ) ; if ( nativeServer != null ) nativeServer . stop ( ) ; if ( FBUtilities . isWindows ( ) ) System . exit ( _NUM ) ; if ( jmxServer != null ) { try { jmxServer . stop ( ) ; } catch ( IOException e ) { logger . error ( STRING , e ) ; } } }
public void drawText ( @ NonNull Canvas canvas , RectF bounds , float percentComplete ) { if ( mText != null && mText . length ( ) > _NUM ) { mPaintText . setTextSize ( _NUM * percentComplete ) ; mPaintText . setAlpha ( MAX_ALPHA ) ; final float startFadePercent = _NUM ; if ( percentComplete > startFadePercent ) { int alphaText = ( int ) ( MAX_ALPHA - ( MAX_ALPHA * ( ( percentComplete - startFadePercent ) / ( _NUM - startFadePercent ) ) ) ) ; mPaintText . setAlpha ( alphaText ) ; } final float xPos = bounds . left + ( bounds . width ( ) / _NUM ) ; final float yPos = ( bounds . top + ( bounds . height ( ) / _NUM ) ) - ( ( mPaintText . descent ( ) + mPaintText . ascent ( ) ) / _NUM ) ; canvas . drawText ( mText , xPos , yPos , mPaintText ) ; } }
@ Override public void stopAllMutators ( ) { Trace . trace ( Item . SCHEDULER , STRING ) ; synchronized ( trigger ) { setState ( BLOCKING ) ; trigger . notifyAll ( ) ; } waitForGCStart ( ) ; Trace . trace ( Item . SCHEDULER , STRING ) ; }
public static void createDestinationFolder ( String path ) { File fpath = new File ( path ) ; fpath . mkdirs ( ) ; }
private void buildLinearModel ( int [ ] indices ) throws Exception { Instances reducedInst = new Instances ( m_instances ) ; Remove attributeFilter = new Remove ( ) ; attributeFilter . setInvertSelection ( _BOOL ) ; attributeFilter . setAttributeIndicesArray ( indices ) ; attributeFilter . setInputFormat ( reducedInst ) ; reducedInst = Filter . useFilter ( reducedInst , attributeFilter ) ; LinearRegression temp = new LinearRegression ( ) ; temp . buildClassifier ( reducedInst ) ; double [ ] lmCoeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m_instances . numAttributes ( ) ] ; for ( int i = _NUM ; i < lmCoeffs . length - _NUM ; i ++ ) { if ( indices [ i ] != m_classIndex ) { coeffs [ indices [ i ] ] = lmCoeffs [ i ] ; } } m_nodeModel = new PreConstructedLinearModel ( coeffs , lmCoeffs [ lmCoeffs . length - _NUM ] ) ; m_nodeModel . buildClassifier ( m_instances ) ; }
private void buildLinearModel ( int [ ] indices ) throws Exception { Instances reducedInst = new Instances ( m_instances ) ; Remove attributeFilter = new Remove ( ) ; attributeFilter . setInvertSelection ( _BOOL ) ; attributeFilter . setAttributeIndicesArray ( indices ) ; attributeFilter . setInputFormat ( reducedInst ) ; reducedInst = Filter . useFilter ( reducedInst , attributeFilter ) ; LinearRegression temp = new LinearRegression ( ) ; temp . buildClassifier ( reducedInst ) ; double [ ] lmCoeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m_instances . numAttributes ( ) ] ; for ( int i = _NUM ; i < lmCoeffs . length - _NUM ; i ++ ) { if ( indices [ i ] != m_classIndex ) { coeffs [ indices [ i ] ] = lmCoeffs [ i ] ; } } m_nodeModel = new PreConstructedLinearModel ( coeffs , lmCoeffs [ lmCoeffs . length - _NUM ] ) ; m_nodeModel . buildClassifier ( m_instances ) ; }
private void buildLinearModel ( int [ ] indices ) throws Exception { Instances reducedInst = new Instances ( m_instances ) ; Remove attributeFilter = new Remove ( ) ; attributeFilter . setInvertSelection ( _BOOL ) ; attributeFilter . setAttributeIndicesArray ( indices ) ; attributeFilter . setInputFormat ( reducedInst ) ; reducedInst = Filter . useFilter ( reducedInst , attributeFilter ) ; LinearRegression temp = new LinearRegression ( ) ; temp . buildClassifier ( reducedInst ) ; double [ ] lmCoeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m_instances . numAttributes ( ) ] ; for ( int i = _NUM ; i < lmCoeffs . length - _NUM ; i ++ ) { if ( indices [ i ] != m_classIndex ) { coeffs [ indices [ i ] ] = lmCoeffs [ i ] ; } } m_nodeModel = new PreConstructedLinearModel ( coeffs , lmCoeffs [ lmCoeffs . length - _NUM ] ) ; m_nodeModel . buildClassifier ( m_instances ) ; }
private void buildLinearModel ( int [ ] indices ) throws Exception { Instances reducedInst = new Instances ( m_instances ) ; Remove attributeFilter = new Remove ( ) ; attributeFilter . setInvertSelection ( _BOOL ) ; attributeFilter . setAttributeIndicesArray ( indices ) ; attributeFilter . setInputFormat ( reducedInst ) ; reducedInst = Filter . useFilter ( reducedInst , attributeFilter ) ; LinearRegression temp = new LinearRegression ( ) ; temp . buildClassifier ( reducedInst ) ; double [ ] lmCoeffs = temp . coefficients ( ) ; double [ ] coeffs = new double [ m_instances . numAttributes ( ) ] ; for ( int i = _NUM ; i < lmCoeffs . length - _NUM ; i ++ ) { if ( indices [ i ] != m_classIndex ) { coeffs [ indices [ i ] ] = lmCoeffs [ i ] ; } } m_nodeModel = new PreConstructedLinearModel ( coeffs , lmCoeffs [ lmCoeffs . length - _NUM ] ) ; m_nodeModel . buildClassifier ( m_instances ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
private void paintDirectly ( Graphics2D g , JComponent c , int w , int h , Object [ ] extendedCacheKeys ) { g = ( Graphics2D ) g . create ( ) ; configureGraphics ( g ) ; doPaint ( g , c , w , h , extendedCacheKeys ) ; g . dispose ( ) ; }
public Date parse ( String text ) throws ParserException { text = text . trim ( ) ; int length = text . length ( ) ; if ( length == LONG_DATE_FORMAT . length ( ) ) { return parse ( text , LONG_DATE_FORMAT ) ; } if ( length == MEDIUM_DATE_FORMAT . length ( ) ) { return parse ( text , MEDIUM_DATE_FORMAT ) ; } return parse ( text , SHORT_DATE_FORMAT ) ; }
private boolean removeGroupsInt ( String [ ] oldGroups ) { boolean removed = _BOOL ; for ( int i = _NUM ; i < oldGroups . length ; i ++ ) { removed |= groups . remove ( oldGroups [ i ] ) ; } return removed ; }
private boolean removeGroupsInt ( String [ ] oldGroups ) { boolean removed = _BOOL ; for ( int i = _NUM ; i < oldGroups . length ; i ++ ) { removed |= groups . remove ( oldGroups [ i ] ) ; } return removed ; }
private DD computeEByTaylorSeries ( ) { DD s = DD . valueOf ( _NUM ) ; DD t = DD . valueOf ( _NUM ) ; double n = _NUM ; int i = _NUM ; while ( t . doubleValue ( ) > DD . EPS ) { i ++ ; n += _NUM ; t = t . divide ( DD . valueOf ( n ) ) ; s = s . add ( t ) ; } return s ; }
private DD computeEByTaylorSeries ( ) { DD s = DD . valueOf ( _NUM ) ; DD t = DD . valueOf ( _NUM ) ; double n = _NUM ; int i = _NUM ; while ( t . doubleValue ( ) > DD . EPS ) { i ++ ; n += _NUM ; t = t . divide ( DD . valueOf ( n ) ) ; s = s . add ( t ) ; } return s ; }
public static EventBean [ ] addToArray ( EventBean [ ] array , EventBean eventToAdd ) { EventBean [ ] newArray = new EventBean [ array . length + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , array . length ) ; newArray [ newArray . length - _NUM ] = eventToAdd ; return newArray ; }
public static EventBean [ ] addToArray ( EventBean [ ] array , EventBean eventToAdd ) { EventBean [ ] newArray = new EventBean [ array . length + _NUM ] ; System . arraycopy ( array , _NUM , newArray , _NUM , array . length ) ; newArray [ newArray . length - _NUM ] = eventToAdd ; return newArray ; }
public Vector < Report > resolveAction ( IGame game ) { Vector < Report > reports = new Vector < Report > ( ) ; Report r ; if ( ! isPossible ( game ) ) { r = new Report ( _NUM ) ; r . subject = getEntityId ( ) ; r . newlines = _NUM ; reports . addElement ( r ) ; return reports ; } final Entity attacker = getEntity ( game ) ; final Coords apos = attacker . getPosition ( ) ; final Targetable target = getTarget ( game ) ; final Coords tpos = target . getPosition ( ) ; if ( attacker . usedSearchlight ( ) ) { r = new Report ( _NUM ) ; r . subject = getEntityId ( ) ; r . add ( attacker . getDisplayName ( ) ) ; r . newlines = _NUM ; reports . addElement ( r ) ; return reports ; } attacker . setUsedSearchlight ( _BOOL ) ; ArrayList < Coords > in = Coords . intervening ( apos , tpos ) ; for ( Coords c : in ) { for ( Entity en : game . getEntitiesVector ( c ) ) { LosEffects los = LosEffects . calculateLos ( game , getEntityId ( ) , en ) ; if ( los . canSee ( ) ) { en . setIlluminated ( _BOOL ) ; r = new Report ( _NUM ) ; r . subject = getEntityId ( ) ; r . newlines = _NUM ; r . add ( en . getDisplayName ( ) ) ; r . add ( attacker . getDisplayName ( ) ) ; reports . addElement ( r ) ; } } } return reports ; }
private JsonScope peek ( ) { return stack . get ( stack . size ( ) - _NUM ) ; }
private JsonScope peek ( ) { return stack . get ( stack . size ( ) - _NUM ) ; }
@ Override public UpdateRequest routing ( String routing ) { if ( routing != null && routing . length ( ) == _NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
@ Override public UpdateRequest routing ( String routing ) { if ( routing != null && routing . length ( ) == _NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
@ Override public UpdateRequest routing ( String routing ) { if ( routing != null && routing . length ( ) == _NUM ) { this . routing = null ; } else { this . routing = routing ; } return this ; }
private void initialize ( ) throws IOException { if ( _secondaryJoiners != null ) { return ; } _primaryJoinersChkUp = new ArrayList < Joiner > ( _NUM ) ; _primaryJoinersChkDel = new ArrayList < Joiner > ( _NUM ) ; _primaryJoinersDoUp = new ArrayList < Joiner > ( _NUM ) ; _primaryJoinersDoDel = new ArrayList < Joiner > ( _NUM ) ; _primaryJoinersDoNull = new ArrayList < Joiner > ( _NUM ) ; _secondaryJoiners = new ArrayList < Joiner > ( _NUM ) ; for ( IndexImpl idx : _table . getIndexes ( ) ) { IndexImpl . ForeignKeyReference ref = idx . getReference ( ) ; if ( ref != null ) { Joiner joiner = Joiner . create ( idx ) ; if ( ref . isPrimaryTable ( ) ) { if ( ref . isCascadeUpdates ( ) ) { _primaryJoinersDoUp . add ( joiner ) ; } else { _primaryJoinersChkUp . add ( joiner ) ; } if ( ref . isCascadeDeletes ( ) ) { _primaryJoinersDoDel . add ( joiner ) ; } else if ( ref . isCascadeNullOnDelete ( ) ) { _primaryJoinersDoNull . add ( joiner ) ; } else { _primaryJoinersChkDel . add ( joiner ) ; } } else { _secondaryJoiners . add ( joiner ) ; } } } }
public Builder addListenUrls ( List < String > urls ) { List < String > needAdd = new ArrayList < String > ( ) ; for ( String url : urls ) { if ( ! UrlUtil . isUrl ( url ) ) { continue ; } needAdd . add ( url ) ; } if ( ! CollectionUtil . isEmpty ( needAdd ) ) { if ( mListenUrls == null ) { mListenUrls = new HashSet < String > ( ) ; } mListenUrls . addAll ( needAdd ) ; } return this ; }
void drawBall ( ) { Ball ball = mBall ; float savedX = ball . getXPosition ( ) ; float savedY = ball . getYPosition ( ) ; float radius = ball . getRadius ( ) ; float xpos = BORDER_WIDTH * _NUM + radius ; float ypos = BORDER_WIDTH + radius ; int lives = mLivesRemaining ; boolean ballIsLive = ( mGamePlayState != GAME_INITIALIZING && mGamePlayState != GAME_READY ) ; if ( ballIsLive ) { lives -- ; } for ( int i = _NUM ; i < lives ; i ++ ) { float jitterX = _NUM ; float jitterY = _NUM ; if ( mLiveBrickCount > _NUM && mLiveBrickCount < _NUM ) { jitterX = ( float ) ( ( _NUM - mLiveBrickCount ) * ( Math . random ( ) - _NUM ) * _NUM ) ; jitterY = ( float ) ( ( _NUM - mLiveBrickCount ) * ( Math . random ( ) - _NUM ) * _NUM ) ; } ball . setPosition ( xpos + jitterX , ypos + jitterY ) ; ball . draw ( ) ; xpos += radius * _NUM ; } ball . setPosition ( savedX , savedY ) ; if ( ballIsLive ) { ball . draw ( ) ; } }
private Iterator < Date > std_lower_bound ( final Date date ) { final List < Date > ldates = new ArrayList < Date > ( ) ; if ( dates_ . size ( ) > _NUM ) { int index = - _NUM ; for ( int i = _NUM ; i < dates_ . size ( ) ; i ++ ) { final Date d = dates_ . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > _NUM ) { for ( int i = index ; i < dates_ . size ( ) ; i ++ ) { ldates . add ( dates_ . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std_lower_bound ( final Date date ) { final List < Date > ldates = new ArrayList < Date > ( ) ; if ( dates_ . size ( ) > _NUM ) { int index = - _NUM ; for ( int i = _NUM ; i < dates_ . size ( ) ; i ++ ) { final Date d = dates_ . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > _NUM ) { for ( int i = index ; i < dates_ . size ( ) ; i ++ ) { ldates . add ( dates_ . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std_lower_bound ( final Date date ) { final List < Date > ldates = new ArrayList < Date > ( ) ; if ( dates_ . size ( ) > _NUM ) { int index = - _NUM ; for ( int i = _NUM ; i < dates_ . size ( ) ; i ++ ) { final Date d = dates_ . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > _NUM ) { for ( int i = index ; i < dates_ . size ( ) ; i ++ ) { ldates . add ( dates_ . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
private Iterator < Date > std_lower_bound ( final Date date ) { final List < Date > ldates = new ArrayList < Date > ( ) ; if ( dates_ . size ( ) > _NUM ) { int index = - _NUM ; for ( int i = _NUM ; i < dates_ . size ( ) ; i ++ ) { final Date d = dates_ . get ( i ) ; if ( d . equals ( date ) ) { index = i ; break ; } } if ( index > _NUM ) { for ( int i = index ; i < dates_ . size ( ) ; i ++ ) { ldates . add ( dates_ . get ( i ) ) ; } return ldates . iterator ( ) ; } } return ldates . iterator ( ) ; }
public AccessToken ( final String token , final String type , final long initialValidSeconds , final Date validUntil ) { this ( token , type , initialValidSeconds , validUntil , System . currentTimeMillis ( ) ) ; }
@ SuppressWarnings ( { STRING } ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return _BOOL ; } else return _BOOL ; return _BOOL ; }
@ SuppressWarnings ( { STRING } ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return _BOOL ; } else return _BOOL ; return _BOOL ; }
@ SuppressWarnings ( { STRING } ) public static boolean containsAll ( Map < ? , ? > base , Map < ? , ? > map ) { assert base != null ; assert map != null ; for ( Map . Entry < ? , ? > entry : map . entrySet ( ) ) if ( base . containsKey ( entry . getKey ( ) ) ) { Object val = base . get ( entry . getKey ( ) ) ; if ( val == null && entry . getValue ( ) == null ) continue ; if ( val == null || entry . getValue ( ) == null || ! val . equals ( entry . getValue ( ) ) ) return _BOOL ; } else return _BOOL ; return _BOOL ; }
public BoyerMoore ( String pat ) { this . R = _NUM ; this . pat = pat ; right = new int [ R ] ; for ( int c = _NUM ; c < R ; c ++ ) right [ c ] = - _NUM ; for ( int j = _NUM ; j < pat . length ( ) ; j ++ ) right [ pat . charAt ( j ) ] = j ; }
private void drawXTick ( Graphics grahics ) { grahics . setFont ( scale . getFont ( ) ) ; for ( int i = _NUM ; i < tickLabelPositions . size ( ) ; i ++ ) { if ( tickVisibilities . get ( i ) == _BOOL ) { String text = tickLabels . get ( i ) ; int fontWidth = FigureUtilities . getTextExtents ( text , getFont ( ) ) . width ; int x = ( int ) Math . ceil ( tickLabelPositions . get ( i ) - fontWidth / _NUM ) ; grahics . drawText ( text , x , _NUM ) ; } } }
public < E , D > void addMappedEntityClass ( Class < E > entityClass , Class < D > dtoClass , JpaMapper < E , D > mapper ) { checkNotInitialized ( ) ; if ( mappings . containsKey ( dtoClass ) ) { throw new IllegalArgumentException ( dtoClass . getName ( ) + STRING ) ; } mappings . put ( dtoClass , new MappedRegistration < > ( entityClass , dtoClass , mapper ) ) ; }
public < E , D > void addMappedEntityClass ( Class < E > entityClass , Class < D > dtoClass , JpaMapper < E , D > mapper ) { checkNotInitialized ( ) ; if ( mappings . containsKey ( dtoClass ) ) { throw new IllegalArgumentException ( dtoClass . getName ( ) + STRING ) ; } mappings . put ( dtoClass , new MappedRegistration < > ( entityClass , dtoClass , mapper ) ) ; }
private void updateWaveFileSize ( ) throws IOException { ByteBuffer buffer = getUnsignedIntegerBuffer ( mFileChannel . size ( ) - _NUM ) ; mFileChannel . write ( buffer , _NUM ) ; ByteBuffer buffer2 = getUnsignedIntegerBuffer ( mFileChannel . size ( ) - _NUM ) ; mFileChannel . write ( buffer2 , _NUM ) ; }
private void sceneRecognize ( ) { Log . d ( TAG , STRING ) ; mAction = VisionAction . SceneRecognition ; lockFocus ( ) ; }
public void initialize ( UimaContext aContext ) { annotate_tokens = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_TOKENS ) ; annotate_sentences = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_SENTENCES ) ; annotate_partofspeech = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_PARTOFSPEECH ) ; model_path = ( String ) aContext . getConfigParameterValue ( PARAM_MODEL_PATH ) ; config_path = ( String ) aContext . getConfigParameterValue ( PARAM_CONFIG_PATH ) ; if ( model_path == null ) { Logger . printError ( component , STRING ) ; System . exit ( - _NUM ) ; } try { if ( config_path != null ) { FileInputStream isr = new FileInputStream ( config_path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new MaxentTagger ( model_path , new TaggerConfig ( props ) , _BOOL ) ; } else { mt = new MaxentTagger ( model_path , new TaggerConfig ( STRING , model_path ) , _BOOL ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; Logger . printError ( component , STRING + model_path + STRING + config_path + STRING ) ; System . exit ( - _NUM ) ; } }
public void initialize ( UimaContext aContext ) { annotate_tokens = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_TOKENS ) ; annotate_sentences = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_SENTENCES ) ; annotate_partofspeech = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_PARTOFSPEECH ) ; model_path = ( String ) aContext . getConfigParameterValue ( PARAM_MODEL_PATH ) ; config_path = ( String ) aContext . getConfigParameterValue ( PARAM_CONFIG_PATH ) ; if ( model_path == null ) { Logger . printError ( component , STRING ) ; System . exit ( - _NUM ) ; } try { if ( config_path != null ) { FileInputStream isr = new FileInputStream ( config_path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new MaxentTagger ( model_path , new TaggerConfig ( props ) , _BOOL ) ; } else { mt = new MaxentTagger ( model_path , new TaggerConfig ( STRING , model_path ) , _BOOL ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; Logger . printError ( component , STRING + model_path + STRING + config_path + STRING ) ; System . exit ( - _NUM ) ; } }
public void initialize ( UimaContext aContext ) { annotate_tokens = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_TOKENS ) ; annotate_sentences = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_SENTENCES ) ; annotate_partofspeech = ( Boolean ) aContext . getConfigParameterValue ( PARAM_ANNOTATE_PARTOFSPEECH ) ; model_path = ( String ) aContext . getConfigParameterValue ( PARAM_MODEL_PATH ) ; config_path = ( String ) aContext . getConfigParameterValue ( PARAM_CONFIG_PATH ) ; if ( model_path == null ) { Logger . printError ( component , STRING ) ; System . exit ( - _NUM ) ; } try { if ( config_path != null ) { FileInputStream isr = new FileInputStream ( config_path ) ; Properties props = new Properties ( ) ; props . load ( isr ) ; mt = new MaxentTagger ( model_path , new TaggerConfig ( props ) , _BOOL ) ; } else { mt = new MaxentTagger ( model_path , new TaggerConfig ( STRING , model_path ) , _BOOL ) ; } } catch ( Exception e ) { e . printStackTrace ( ) ; Logger . printError ( component , STRING + model_path + STRING + config_path + STRING ) ; System . exit ( - _NUM ) ; } }
public String encode ( byte [ ] input , boolean addQuotes ) { int inputEnd = input . length ; StringBuilder sb ; { int outputLen = inputEnd + ( inputEnd > > _NUM ) + ( inputEnd > > _NUM ) ; sb = new StringBuilder ( outputLen ) ; } if ( addQuotes ) { sb . append ( STRING ) ; } int chunksBeforeLF = getMaxLineLength ( ) > > _NUM ; int inputPtr = _NUM ; int safeInputEnd = inputEnd - _NUM ; while ( inputPtr <= safeInputEnd ) { int b24 = ( ( int ) input [ inputPtr ++ ] ) << _NUM ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & _NUM ; b24 = ( b24 << _NUM ) | ( ( ( int ) input [ inputPtr ++ ] ) & _NUM ) ; encodeBase64Chunk ( sb , b24 ) ; if ( -- chunksBeforeLF <= _NUM ) { sb . append ( STRING ) ; sb . append ( STRING ) ; chunksBeforeLF = getMaxLineLength ( ) > > _NUM ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > _NUM ) { int b24 = ( ( int ) input [ inputPtr ++ ] ) << _NUM ; if ( inputLeft == _NUM ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & _NUM ) << _NUM ; } encodeBase64Partial ( sb , b24 , inputLeft ) ; } if ( addQuotes ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public String encode ( byte [ ] input , boolean addQuotes ) { int inputEnd = input . length ; StringBuilder sb ; { int outputLen = inputEnd + ( inputEnd > > _NUM ) + ( inputEnd > > _NUM ) ; sb = new StringBuilder ( outputLen ) ; } if ( addQuotes ) { sb . append ( STRING ) ; } int chunksBeforeLF = getMaxLineLength ( ) > > _NUM ; int inputPtr = _NUM ; int safeInputEnd = inputEnd - _NUM ; while ( inputPtr <= safeInputEnd ) { int b24 = ( ( int ) input [ inputPtr ++ ] ) << _NUM ; b24 |= ( ( int ) input [ inputPtr ++ ] ) & _NUM ; b24 = ( b24 << _NUM ) | ( ( ( int ) input [ inputPtr ++ ] ) & _NUM ) ; encodeBase64Chunk ( sb , b24 ) ; if ( -- chunksBeforeLF <= _NUM ) { sb . append ( STRING ) ; sb . append ( STRING ) ; chunksBeforeLF = getMaxLineLength ( ) > > _NUM ; } } int inputLeft = inputEnd - inputPtr ; if ( inputLeft > _NUM ) { int b24 = ( ( int ) input [ inputPtr ++ ] ) << _NUM ; if ( inputLeft == _NUM ) { b24 |= ( ( ( int ) input [ inputPtr ++ ] ) & _NUM ) << _NUM ; } encodeBase64Partial ( sb , b24 , inputLeft ) ; } if ( addQuotes ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public void addEditPopUpMenu ( JMenuItem menu ) { if ( ! editAdditionalMenu . contains ( menu ) ) { editAdditionalMenu . add ( menu ) ; } }
public void addEditPopUpMenu ( JMenuItem menu ) { if ( ! editAdditionalMenu . contains ( menu ) ) { editAdditionalMenu . add ( menu ) ; } }
protected void handleRenderException ( FacesContext context , Exception e ) throws IOException { if ( LOGGER . isLoggable ( Level . SEVERE ) ) { UIViewRoot root = context . getViewRoot ( ) ; StringBuffer sb = new StringBuffer ( _NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . getViewId ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . toString ( ) , e ) ; } if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else if ( e instanceof IOException ) { throw ( IOException ) e ; } else { throw new FacesException ( e . getMessage ( ) , e ) ; } }
protected void handleRenderException ( FacesContext context , Exception e ) throws IOException { if ( LOGGER . isLoggable ( Level . SEVERE ) ) { UIViewRoot root = context . getViewRoot ( ) ; StringBuffer sb = new StringBuffer ( _NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . getViewId ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . toString ( ) , e ) ; } if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else if ( e instanceof IOException ) { throw ( IOException ) e ; } else { throw new FacesException ( e . getMessage ( ) , e ) ; } }
protected void handleRenderException ( FacesContext context , Exception e ) throws IOException { if ( LOGGER . isLoggable ( Level . SEVERE ) ) { UIViewRoot root = context . getViewRoot ( ) ; StringBuffer sb = new StringBuffer ( _NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . getViewId ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . toString ( ) , e ) ; } if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else if ( e instanceof IOException ) { throw ( IOException ) e ; } else { throw new FacesException ( e . getMessage ( ) , e ) ; } }
protected void handleRenderException ( FacesContext context , Exception e ) throws IOException { if ( LOGGER . isLoggable ( Level . SEVERE ) ) { UIViewRoot root = context . getViewRoot ( ) ; StringBuffer sb = new StringBuffer ( _NUM ) ; sb . append ( STRING ) ; if ( root != null ) { sb . append ( STRING ) ; sb . append ( root . getViewId ( ) ) ; sb . append ( STRING ) ; } LOGGER . log ( Level . SEVERE , sb . toString ( ) , e ) ; } if ( e instanceof RuntimeException ) { throw ( RuntimeException ) e ; } else if ( e instanceof IOException ) { throw ( IOException ) e ; } else { throw new FacesException ( e . getMessage ( ) , e ) ; } }
@ Override public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { String newPath ; if ( userPath == null ) return _root . fsWalk ( getPath ( ) , newAttributes , STRING ) ; int length = userPath . length ( ) ; int colon = userPath . indexOf ( STRING ) ; int slash = userPath . indexOf ( STRING ) ; int query = userPath . indexOf ( STRING ) ; if ( colon != - _NUM && ( colon < slash || slash == - _NUM ) ) return super . lookupImpl ( userPath , newAttributes , isAllowRoot ) ; if ( slash == _NUM && length > _NUM && userPath . charAt ( _NUM ) == STRING ) return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; else if ( slash == _NUM ) { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( STRING , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } else { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( _pathname , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } return _root . fsWalk ( userPath , newAttributes , newPath ) ; }
@ Override public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { String newPath ; if ( userPath == null ) return _root . fsWalk ( getPath ( ) , newAttributes , STRING ) ; int length = userPath . length ( ) ; int colon = userPath . indexOf ( STRING ) ; int slash = userPath . indexOf ( STRING ) ; int query = userPath . indexOf ( STRING ) ; if ( colon != - _NUM && ( colon < slash || slash == - _NUM ) ) return super . lookupImpl ( userPath , newAttributes , isAllowRoot ) ; if ( slash == _NUM && length > _NUM && userPath . charAt ( _NUM ) == STRING ) return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; else if ( slash == _NUM ) { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( STRING , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } else { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( _pathname , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } return _root . fsWalk ( userPath , newAttributes , newPath ) ; }
@ Override public PathImpl lookupImpl ( String userPath , Map < String , Object > newAttributes , boolean isAllowRoot ) { String newPath ; if ( userPath == null ) return _root . fsWalk ( getPath ( ) , newAttributes , STRING ) ; int length = userPath . length ( ) ; int colon = userPath . indexOf ( STRING ) ; int slash = userPath . indexOf ( STRING ) ; int query = userPath . indexOf ( STRING ) ; if ( colon != - _NUM && ( colon < slash || slash == - _NUM ) ) return super . lookupImpl ( userPath , newAttributes , isAllowRoot ) ; if ( slash == _NUM && length > _NUM && userPath . charAt ( _NUM ) == STRING ) return schemeWalk ( userPath , newAttributes , userPath , _NUM ) ; else if ( slash == _NUM ) { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( STRING , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } else { String queryString = STRING ; if ( query >= _NUM ) { queryString = userPath . substring ( query ) ; userPath = userPath . substring ( _NUM , query ) ; } newPath = normalizePath ( _pathname , userPath , _NUM , STRING ) ; if ( query >= _NUM ) newPath += queryString ; } return _root . fsWalk ( userPath , newAttributes , newPath ) ; }
@ Override public boolean batchFinished ( ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } Instances toFilter = getInputFormat ( ) ; int cutOff = ( int ) Math . round ( toFilter . numInstances ( ) * m_Percentage / _NUM ) ; if ( m_Inverse ) { for ( int i = _NUM ; i < cutOff ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } else { for ( int i = cutOff ; i < toFilter . numInstances ( ) ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } flushInput ( ) ; m_NewBatch = _BOOL ; m_FirstBatchDone = _BOOL ; return ( numPendingOutput ( ) != _NUM ) ; }
@ Override public boolean batchFinished ( ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } Instances toFilter = getInputFormat ( ) ; int cutOff = ( int ) Math . round ( toFilter . numInstances ( ) * m_Percentage / _NUM ) ; if ( m_Inverse ) { for ( int i = _NUM ; i < cutOff ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } else { for ( int i = cutOff ; i < toFilter . numInstances ( ) ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } flushInput ( ) ; m_NewBatch = _BOOL ; m_FirstBatchDone = _BOOL ; return ( numPendingOutput ( ) != _NUM ) ; }
@ Override public boolean batchFinished ( ) { if ( getInputFormat ( ) == null ) { throw new IllegalStateException ( STRING ) ; } Instances toFilter = getInputFormat ( ) ; int cutOff = ( int ) Math . round ( toFilter . numInstances ( ) * m_Percentage / _NUM ) ; if ( m_Inverse ) { for ( int i = _NUM ; i < cutOff ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } else { for ( int i = cutOff ; i < toFilter . numInstances ( ) ; i ++ ) { push ( toFilter . instance ( i ) ) ; } } flushInput ( ) ; m_NewBatch = _BOOL ; m_FirstBatchDone = _BOOL ; return ( numPendingOutput ( ) != _NUM ) ; }
public TopNMetric ( TopNMetricType type , String previousStop ) { this . type = type ; this . metricName = Optional . empty ( ) ; this . nested = Optional . empty ( ) ; this . previousStop = Optional . of ( previousStop ) ; }
public void init ( ) { m_csv = new File ( m_filename ) ; try { m_csv . createNewFile ( ) ; m_fw = new FileWriter ( m_csv ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; return ; } }
public ZkConnection ( String zkServers , int sessionTimeOut , String authStr ) { _servers = zkServers ; _sessionTimeOut = sessionTimeOut ; _authStr = authStr ; }
public Result ( double gSquare , double pValue , int df , boolean isIndep ) { this . gSquare = gSquare ; this . pValue = pValue ; this . df = df ; this . isIndep = isIndep ; }
public void addMeasureItem ( MatchRecognizeMeasureItem item ) { measures . add ( item ) ; }
public static SecretKeys keys ( String keysStr ) throws InvalidKeyException { String [ ] keysArr = keysStr . split ( STRING ) ; if ( keysArr . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } else { byte [ ] confidentialityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( confidentialityKey . length != AES_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + AES_KEY_LENGTH_BITS + STRING ) ; } byte [ ] integrityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( integrityKey . length != HMAC_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + HMAC_KEY_LENGTH_BITS + STRING ) ; } SecretKeys secretKeys = new SecretKeys ( ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( ) ; secretKeySpec . generate ( confidentialityKey , _NUM , confidentialityKey . length , CIPHER ) ; SecretKeySpec secretKeySpec1 = new SecretKeySpec ( ) ; secretKeySpec1 . generate ( integrityKey , HMAC_ALGORITHM ) ; secretKeys . setConfidentialityKey ( secretKeySpec ) ; secretKeys . setIntegrityKey ( secretKeySpec1 ) ; return secretKeys ; } }
public static SecretKeys keys ( String keysStr ) throws InvalidKeyException { String [ ] keysArr = keysStr . split ( STRING ) ; if ( keysArr . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } else { byte [ ] confidentialityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( confidentialityKey . length != AES_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + AES_KEY_LENGTH_BITS + STRING ) ; } byte [ ] integrityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( integrityKey . length != HMAC_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + HMAC_KEY_LENGTH_BITS + STRING ) ; } SecretKeys secretKeys = new SecretKeys ( ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( ) ; secretKeySpec . generate ( confidentialityKey , _NUM , confidentialityKey . length , CIPHER ) ; SecretKeySpec secretKeySpec1 = new SecretKeySpec ( ) ; secretKeySpec1 . generate ( integrityKey , HMAC_ALGORITHM ) ; secretKeys . setConfidentialityKey ( secretKeySpec ) ; secretKeys . setIntegrityKey ( secretKeySpec1 ) ; return secretKeys ; } }
public static SecretKeys keys ( String keysStr ) throws InvalidKeyException { String [ ] keysArr = keysStr . split ( STRING ) ; if ( keysArr . length != _NUM ) { throw new IllegalArgumentException ( STRING ) ; } else { byte [ ] confidentialityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( confidentialityKey . length != AES_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + AES_KEY_LENGTH_BITS + STRING ) ; } byte [ ] integrityKey = Base64 . decode ( keysArr [ _NUM ] , BASE64_FLAGS ) ; if ( integrityKey . length != HMAC_KEY_LENGTH_BITS / _NUM ) { throw new InvalidKeyException ( STRING + HMAC_KEY_LENGTH_BITS + STRING ) ; } SecretKeys secretKeys = new SecretKeys ( ) ; SecretKeySpec secretKeySpec = new SecretKeySpec ( ) ; secretKeySpec . generate ( confidentialityKey , _NUM , confidentialityKey . length , CIPHER ) ; SecretKeySpec secretKeySpec1 = new SecretKeySpec ( ) ; secretKeySpec1 . generate ( integrityKey , HMAC_ALGORITHM ) ; secretKeys . setConfidentialityKey ( secretKeySpec ) ; secretKeys . setIntegrityKey ( secretKeySpec1 ) ; return secretKeys ; } }
public void actionPerformed ( ActionEvent ae ) { long currentTime = System . nanoTime ( ) / _NUM ; long totalTime = currentTime - cycleStart ; if ( totalTime > CYCLE_TIME ) { cycleStart = currentTime ; } float fraction = ( float ) totalTime / CYCLE_TIME ; fraction = Math . min ( _NUM , fraction ) ; fraction = _NUM - Math . abs ( _NUM - ( _NUM * fraction ) ) ; animate ( fraction ) ; }
public boolean addAll ( Collection c ) { Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; System . arraycopy ( a , _NUM , elementData , size , numNew ) ; size += numNew ; return numNew != _NUM ; }
public boolean addAll ( Collection c ) { Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; System . arraycopy ( a , _NUM , elementData , size , numNew ) ; size += numNew ; return numNew != _NUM ; }
public boolean addAll ( Collection c ) { Object [ ] a = c . toArray ( ) ; int numNew = a . length ; ensureCapacity ( size + numNew ) ; System . arraycopy ( a , _NUM , elementData , size , numNew ) ; size += numNew ; return numNew != _NUM ; }
private static void serializeToDiskSynchronously ( String cacheKey , String controllerJson ) { OutputStream outputStream = null ; try { outputStream = controllerDiskCache . openPutStream ( cacheKey ) ; outputStream . write ( controllerJson . getBytes ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( outputStream != null ) { Utility . closeQuietly ( outputStream ) ; } } }
private static void serializeToDiskSynchronously ( String cacheKey , String controllerJson ) { OutputStream outputStream = null ; try { outputStream = controllerDiskCache . openPutStream ( cacheKey ) ; outputStream . write ( controllerJson . getBytes ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( outputStream != null ) { Utility . closeQuietly ( outputStream ) ; } } }
private static void serializeToDiskSynchronously ( String cacheKey , String controllerJson ) { OutputStream outputStream = null ; try { outputStream = controllerDiskCache . openPutStream ( cacheKey ) ; outputStream . write ( controllerJson . getBytes ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( outputStream != null ) { Utility . closeQuietly ( outputStream ) ; } } }
private static void serializeToDiskSynchronously ( String cacheKey , String controllerJson ) { OutputStream outputStream = null ; try { outputStream = controllerDiskCache . openPutStream ( cacheKey ) ; outputStream . write ( controllerJson . getBytes ( ) ) ; } catch ( IOException e ) { Log . e ( TAG , STRING , e ) ; } finally { if ( outputStream != null ) { Utility . closeQuietly ( outputStream ) ; } } }
public boolean verifyClientEvidenceMessage ( BigInteger clientM1 ) throws CryptoException { if ( ( this . A == null ) || ( this . B == null ) || ( this . S == null ) ) { throw new CryptoException ( STRING + STRING ) ; } BigInteger computedM1 = SRP6Util . calculateM1 ( digest , N , A , B , S ) ; if ( computedM1 . equals ( clientM1 ) ) { this . M1 = clientM1 ; return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == _NUM ) return ; Collection < ParsingException > errors = new ArrayList < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( ParsingException e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingFailed ( marker . position ( ) , errors , STRING ) ; }
@ SuppressWarnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == _NUM ) return ; Collection < ParsingException > errors = new ArrayList < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( ParsingException e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingFailed ( marker . position ( ) , errors , STRING ) ; }
@ SuppressWarnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == _NUM ) return ; Collection < ParsingException > errors = new ArrayList < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( ParsingException e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingFailed ( marker . position ( ) , errors , STRING ) ; }
@ SuppressWarnings ( STRING ) protected void sequentially ( Consumer < Marker > ... functions ) { if ( functions == null || functions . length == _NUM ) return ; Collection < ParsingException > errors = new ArrayList < > ( ) ; Marker marker = tokens . mark ( ) ; for ( Consumer < Marker > function : functions ) { try { function . accept ( marker ) ; return ; } catch ( ParsingException e ) { errors . add ( e ) ; tokens . rewind ( marker ) ; } } parsingFailed ( marker . position ( ) , errors , STRING ) ; }
public static SSLServerSocketFactory makeSSLSocketFactory ( KeyStore loadedKeyStore , KeyManager [ ] keyManagers ) throws IOException { SSLServerSocketFactory res = null ; try { TrustManagerFactory trustManagerFactory = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; trustManagerFactory . init ( loadedKeyStore ) ; SSLContext ctx = SSLContext . getInstance ( STRING ) ; ctx . init ( keyManagers , trustManagerFactory . getTrustManagers ( ) , null ) ; res = ctx . getServerSocketFactory ( ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } return res ; }
private boolean addWorker ( Runnable firstTask , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs == SHUTDOWN ) { if ( workQueue . isEmpty ( ) ) return _BOOL ; c = ctl . get ( ) ; } int wc = workerCountOf ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? corePoolSize : maximumPoolSize ) ) return _BOOL ; if ( ctl . compareAndSet ( c , ctlOf ( rs , wc + _NUM ) ) ) break ; } Worker w = new Worker ( firstTask ) ; Thread t = w . thread ; if ( t == null ) { decrementWorkerCount ( ) ; tryTerminate2 ( ) ; return _BOOL ; } final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largestPoolSize ) largestPoolSize = s ; } finally { mainLock . unlock ( ) ; } t . start ( ) ; return _BOOL ; }
private boolean addWorker ( Runnable firstTask , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs == SHUTDOWN ) { if ( workQueue . isEmpty ( ) ) return _BOOL ; c = ctl . get ( ) ; } int wc = workerCountOf ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? corePoolSize : maximumPoolSize ) ) return _BOOL ; if ( ctl . compareAndSet ( c , ctlOf ( rs , wc + _NUM ) ) ) break ; } Worker w = new Worker ( firstTask ) ; Thread t = w . thread ; if ( t == null ) { decrementWorkerCount ( ) ; tryTerminate2 ( ) ; return _BOOL ; } final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largestPoolSize ) largestPoolSize = s ; } finally { mainLock . unlock ( ) ; } t . start ( ) ; return _BOOL ; }
private boolean addWorker ( Runnable firstTask , boolean core ) { for ( ; ; ) { int c = ctl . get ( ) ; int rs = runStateOf ( c ) ; if ( rs == SHUTDOWN ) { if ( workQueue . isEmpty ( ) ) return _BOOL ; c = ctl . get ( ) ; } int wc = workerCountOf ( c ) ; if ( rs > SHUTDOWN || wc >= CAPACITY || wc >= ( core ? corePoolSize : maximumPoolSize ) ) return _BOOL ; if ( ctl . compareAndSet ( c , ctlOf ( rs , wc + _NUM ) ) ) break ; } Worker w = new Worker ( firstTask ) ; Thread t = w . thread ; if ( t == null ) { decrementWorkerCount ( ) ; tryTerminate2 ( ) ; return _BOOL ; } final ReentrantLock mainLock = this . mainLock ; mainLock . lock ( ) ; try { workers . add ( w ) ; int s = workers . size ( ) ; if ( s > largestPoolSize ) largestPoolSize = s ; } finally { mainLock . unlock ( ) ; } t . start ( ) ; return _BOOL ; }
public Element removeElementFromRegistry ( String hashcode ) { registry . remove ( hashcode ) ; registryList . removeElement ( hashcode ) ; return ( this ) ; }
public void removeSelectionChangeListener ( final SelectionChangeListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( selectionChangeListeners == null ) { return ; } selectionChangeListeners . remove ( listener ) ; }
public void removeSelectionChangeListener ( final SelectionChangeListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( selectionChangeListeners == null ) { return ; } selectionChangeListeners . remove ( listener ) ; }
public void removeSelectionChangeListener ( final SelectionChangeListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( selectionChangeListeners == null ) { return ; } selectionChangeListeners . remove ( listener ) ; }
public void removeSelectionChangeListener ( final SelectionChangeListener listener ) { checkWidget ( ) ; if ( listener == null ) { SWT . error ( SWT . ERROR_NULL_ARGUMENT ) ; } if ( selectionChangeListeners == null ) { return ; } selectionChangeListeners . remove ( listener ) ; }
public int hashCode ( ) { int hash = Float . floatToIntBits ( width ) ; hash = hash * _NUM + join ; hash = hash * _NUM + cap ; hash = hash * _NUM + Float . floatToIntBits ( miterlimit ) ; if ( dash != null ) { hash = hash * _NUM + Float . floatToIntBits ( dash_phase ) ; for ( int i = _NUM ; i < dash . length ; i ++ ) { hash = hash * _NUM + Float . floatToIntBits ( dash [ i ] ) ; } } return hash ; }
public static boolean [ ] parseString ( String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = _NUM ; i < result . length ; i ++ ) { result [ i ] = parseString ( values [ i ] ) ; } return result ; }
public static boolean [ ] parseString ( String [ ] values ) { boolean [ ] result = new boolean [ values . length ] ; for ( int i = _NUM ; i < result . length ; i ++ ) { result [ i ] = parseString ( values [ i ] ) ; } return result ; }
protected final void refreshLoadingViewsSize ( ) { final int maximumPullScroll = ( int ) ( getMaximumPullScroll ( ) * _NUM ) ; int pLeft = getPaddingLeft ( ) ; int pTop = getPaddingTop ( ) ; int pRight = getPaddingRight ( ) ; int pBottom = getPaddingBottom ( ) ; switch ( getPullToRefreshScrollDirection ( ) ) { case HORIZONTAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setWidth ( maximumPullScroll ) ; pLeft = - maximumPullScroll ; } else { pLeft = _NUM ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setWidth ( maximumPullScroll ) ; pRight = - maximumPullScroll ; } else { pRight = _NUM ; } break ; case VERTICAL : if ( mMode . showHeaderLoadingLayout ( ) ) { mHeaderLayout . setHeight ( maximumPullScroll ) ; pTop = - maximumPullScroll ; } else { pTop = _NUM ; } if ( mMode . showFooterLoadingLayout ( ) ) { mFooterLayout . setHeight ( maximumPullScroll ) ; pBottom = - maximumPullScroll ; } else { pBottom = _NUM ; } break ; } if ( DEBUG ) { Log . d ( LOG_TAG , String . format ( STRING , pLeft , pTop , pRight , pBottom ) ) ; } setPadding ( pLeft , pTop , pRight , pBottom ) ; }
public Vector2f ( float x , float y ) { this . x = x ; this . y = y ; }
public synchronized void syncAll ( ) throws SOSFailure { final String methodName = STRING ; log . trace ( methodName + STRING ) ; _fileCosIdList = null ; _blockCosIdList = null ; _blockCosDetailList = null ; _fileCosDetailList = null ; log . trace ( methodName + STRING ) ; }
private void updatePendingNodes ( final int newLandmarkIndex , final RouterPriorityQueue < Node > pendingNodes ) { final List < Double > newEstRemTravCosts = new ArrayList < > ( ) ; final List < Node > nodesToBeUpdated = new ArrayList < > ( ) ; final InternalLandmarkData landmarkData = new InternalLandmarkData ( ) ; for ( Node node : pendingNodes ) { final AStarNodeData role = getData ( node ) ; final PreProcessLandmarks . LandmarksData ppRole = preprocess . getNodeData ( node ) ; landmarkData . setDelegate ( ppRole ) ; final double newEstRemTravCost = estimateRemainingTravelCost ( landmarkData , newLandmarkIndex ) ; if ( newEstRemTravCost > role . getExpectedRemainingCost ( ) ) { nodesToBeUpdated . add ( node ) ; newEstRemTravCosts . add ( newEstRemTravCost ) ; } } for ( Node node : nodesToBeUpdated ) { pendingNodes . remove ( node ) ; } for ( int i = _NUM ; i < nodesToBeUpdated . size ( ) ; i ++ ) { final Node node = nodesToBeUpdated . get ( i ) ; final AStarNodeData data = getData ( node ) ; data . setExpectedRemainingCost ( newEstRemTravCosts . get ( i ) ) ; pendingNodes . add ( node , getPriority ( data ) ) ; } }
private void updatePendingNodes ( final int newLandmarkIndex , final RouterPriorityQueue < Node > pendingNodes ) { final List < Double > newEstRemTravCosts = new ArrayList < > ( ) ; final List < Node > nodesToBeUpdated = new ArrayList < > ( ) ; final InternalLandmarkData landmarkData = new InternalLandmarkData ( ) ; for ( Node node : pendingNodes ) { final AStarNodeData role = getData ( node ) ; final PreProcessLandmarks . LandmarksData ppRole = preprocess . getNodeData ( node ) ; landmarkData . setDelegate ( ppRole ) ; final double newEstRemTravCost = estimateRemainingTravelCost ( landmarkData , newLandmarkIndex ) ; if ( newEstRemTravCost > role . getExpectedRemainingCost ( ) ) { nodesToBeUpdated . add ( node ) ; newEstRemTravCosts . add ( newEstRemTravCost ) ; } } for ( Node node : nodesToBeUpdated ) { pendingNodes . remove ( node ) ; } for ( int i = _NUM ; i < nodesToBeUpdated . size ( ) ; i ++ ) { final Node node = nodesToBeUpdated . get ( i ) ; final AStarNodeData data = getData ( node ) ; data . setExpectedRemainingCost ( newEstRemTravCosts . get ( i ) ) ; pendingNodes . add ( node , getPriority ( data ) ) ; } }
private void updatePendingNodes ( final int newLandmarkIndex , final RouterPriorityQueue < Node > pendingNodes ) { final List < Double > newEstRemTravCosts = new ArrayList < > ( ) ; final List < Node > nodesToBeUpdated = new ArrayList < > ( ) ; final InternalLandmarkData landmarkData = new InternalLandmarkData ( ) ; for ( Node node : pendingNodes ) { final AStarNodeData role = getData ( node ) ; final PreProcessLandmarks . LandmarksData ppRole = preprocess . getNodeData ( node ) ; landmarkData . setDelegate ( ppRole ) ; final double newEstRemTravCost = estimateRemainingTravelCost ( landmarkData , newLandmarkIndex ) ; if ( newEstRemTravCost > role . getExpectedRemainingCost ( ) ) { nodesToBeUpdated . add ( node ) ; newEstRemTravCosts . add ( newEstRemTravCost ) ; } } for ( Node node : nodesToBeUpdated ) { pendingNodes . remove ( node ) ; } for ( int i = _NUM ; i < nodesToBeUpdated . size ( ) ; i ++ ) { final Node node = nodesToBeUpdated . get ( i ) ; final AStarNodeData data = getData ( node ) ; data . setExpectedRemainingCost ( newEstRemTravCosts . get ( i ) ) ; pendingNodes . add ( node , getPriority ( data ) ) ; } }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
@ Override protected void createButtonsForButtonBar ( final Composite parent ) { for ( final Iterator it = buttonDescriptions . iterator ( ) ; it . hasNext ( ) ; ) { final ButtonDescription buttonDescription = ( ButtonDescription ) it . next ( ) ; createButton ( parent , buttonDescription . buttonId , buttonDescription . buttonLabel , buttonDescription . isDefault ) ; } if ( includeDefaultButtons ) { super . createButtonsForButtonBar ( parent ) ; } hookAfterButtonsCreated ( ) ; }
public static boolean hasSuppressed ( @ Nullable Throwable t , @ Nullable Class < ? extends Throwable > cls ) { if ( t == null || cls == null ) return _BOOL ; if ( t . getSuppressed ( ) != null ) { for ( Throwable th : t . getSuppressed ( ) ) { if ( cls . isAssignableFrom ( th . getClass ( ) ) ) return _BOOL ; if ( hasSuppressed ( th , cls ) ) return _BOOL ; } } return _BOOL ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
static public double log10 ( double inValue ) { return Math . log ( inValue ) / Math . log ( _NUM ) ; }
protected HttpServerProvider ( ) { SecurityManager sm = System . getSecurityManager ( ) ; if ( sm != null ) sm . checkPermission ( new RuntimePermission ( STRING ) ) ; }
public REProgram compile ( String pattern ) throws RESyntaxException { this . pattern = pattern ; len = pattern . length ( ) ; idx = _NUM ; lenInstruction = _NUM ; parens = _NUM ; int [ ] flags = { NODE_TOPLEVEL } ; expr ( flags ) ; if ( idx != len ) { if ( pattern . charAt ( idx ) == STRING ) { syntaxError ( STRING ) ; } syntaxError ( STRING ) ; } char [ ] ins = new char [ lenInstruction ] ; System . arraycopy ( instruction , _NUM , ins , _NUM , lenInstruction ) ; return new REProgram ( parens , ins ) ; }
public REProgram compile ( String pattern ) throws RESyntaxException { this . pattern = pattern ; len = pattern . length ( ) ; idx = _NUM ; lenInstruction = _NUM ; parens = _NUM ; int [ ] flags = { NODE_TOPLEVEL } ; expr ( flags ) ; if ( idx != len ) { if ( pattern . charAt ( idx ) == STRING ) { syntaxError ( STRING ) ; } syntaxError ( STRING ) ; } char [ ] ins = new char [ lenInstruction ] ; System . arraycopy ( instruction , _NUM , ins , _NUM , lenInstruction ) ; return new REProgram ( parens , ins ) ; }
public void updateShapeShadowsToCurrentTime ( boolean updateMinutes , boolean updateHours , int currentMinute , int currentHour ) { if ( updateMinutes ) { int tens = ( int ) Math . floor ( currentMinute / _NUM ) ; int units = ( int ) Math . floor ( currentMinute % _NUM ) ; if ( minutesTens . getCurrentValue ( ) != tens ) { String mt = String . format ( STRING , tens ) ; mt = mt . concat ( STRING ) ; Log . d ( TAG , STRING + mt ) ; minutesTens . parseJSON ( mt ) ; } if ( minutesUnits . getCurrentValue ( ) != units ) { String mu = String . format ( STRING , units ) ; mu = mu . concat ( STRING ) ; Log . d ( TAG , STRING + mu ) ; minutesUnits . parseJSON ( mu ) ; } } if ( updateHours ) { int tens = ( int ) Math . floor ( currentHour / _NUM ) ; int units = ( int ) Math . floor ( currentHour % _NUM ) ; if ( hoursTens . getCurrentValue ( ) != tens ) { String ht = String . format ( STRING , tens ) ; ht = ht . concat ( STRING ) ; Log . d ( TAG , STRING + ht ) ; hoursTens . parseJSON ( ht ) ; } if ( hoursUnits . getCurrentValue ( ) != units ) { String hu = String . format ( STRING , units ) ; hu = hu . concat ( STRING ) ; Log . d ( TAG , STRING + hu ) ; hoursUnits . parseJSON ( hu ) ; } } }
public static char [ ] join ( char [ ] arrayA , char ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } char [ ] array = new char [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
public static char [ ] join ( char [ ] arrayA , char ... arrayB ) { if ( ( arrayB == null ) || ( arrayB . length == _NUM ) ) { return arrayA ; } if ( ( arrayA == null ) || ( arrayA . length == _NUM ) ) { return arrayB ; } char [ ] array = new char [ arrayA . length + arrayB . length ] ; System . arraycopy ( arrayA , _NUM , array , _NUM , arrayA . length ) ; System . arraycopy ( arrayB , _NUM , array , arrayA . length , arrayB . length ) ; return array ; }
void write ( ) { clearAttributes ( ) ; if ( termAttribute . length ( ) < buffer . length ( ) ) { termAttribute . resizeBuffer ( buffer . length ( ) ) ; } char termbuffer [ ] = termAttribute . buffer ( ) ; buffer . getChars ( _NUM , buffer . length ( ) , termbuffer , _NUM ) ; termAttribute . setLength ( buffer . length ( ) ) ; if ( hasIllegalOffsets ) { offsetAttribute . setOffset ( savedStartOffset , savedEndOffset ) ; } else { offsetAttribute . setOffset ( startOffset , endOffset ) ; } posIncAttribute . setPositionIncrement ( position ( _BOOL ) ) ; typeAttribute . setType ( savedType ) ; accumPosInc = _NUM ; }
private static String createJsMethodInvocationExpression ( String methodName , boolean isStatic , String ... paramNames ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( isStatic ? WND : THIS ) ; sb . append ( STRING ) ; sb . append ( methodName ) ; sb . append ( STRING ) ; for ( int i = _NUM ; i < paramNames . length ; i ++ ) { if ( i != _NUM ) { sb . append ( STRING ) ; } sb . append ( paramNames [ i ] ) ; } sb . append ( STRING ) ; return sb . toString ( ) ; }
public void initializeWriter ( ) throws CarbonDataWriterException { initFileCount ( ) ; String carbonDataFileName = carbonTablePath . getCarbonDataFileName ( fileCount , carbonDataFileAttributes . getTaskId ( ) , carbonDataFileAttributes . getFactTimeStamp ( ) ) ; String actualFileNameVal = carbonDataFileName + CarbonCommonConstants . FILE_INPROGRESS_STATUS ; FileData fileData = new FileData ( actualFileNameVal , this . storeLocation ) ; fileManager . add ( fileData ) ; this . fileName = storeLocation + File . separator + carbonDataFileName + CarbonCommonConstants . FILE_INPROGRESS_STATUS ; this . fileCount ++ ; try { fileOutputStream = new FileOutputStream ( this . fileName , _BOOL ) ; this . fileChannel = fileOutputStream . getChannel ( ) ; } catch ( FileNotFoundException fileNotFoundException ) { throw new CarbonDataWriterException ( STRING , fileNotFoundException ) ; } }
protected void stopJobAcquisitionThread ( ) { if ( asyncJobAcquisitionThread != null ) { try { asyncJobAcquisitionThread . join ( ) ; } catch ( InterruptedException e ) { log . warn ( STRING , e ) ; } asyncJobAcquisitionThread = null ; } }
private CaseInsensitiveChar ( String s ) { this ( s . charAt ( _NUM ) ) ; }
private void backupScreens ( BackupDataOutput data ) throws IOException { ContentResolver cr = mContext . getContentResolver ( ) ; Cursor cursor = cr . query ( WorkspaceScreens . CONTENT_URI , SCREEN_PROJECTION , null , null , null ) ; try { cursor . moveToPosition ( - _NUM ) ; if ( DEBUG ) Log . d ( TAG , STRING + mLastBackupRestoreTime ) ; while ( cursor . moveToNext ( ) ) { final long id = cursor . getLong ( ID_INDEX ) ; final long updateTime = cursor . getLong ( ID_MODIFIED ) ; Key key = getKey ( Key . SCREEN , id ) ; mKeys . add ( key ) ; final String backupKey = keyToBackupKey ( key ) ; if ( ! mExistingKeys . contains ( backupKey ) || updateTime >= mLastBackupRestoreTime ) { writeRowToBackup ( key , packScreen ( cursor ) , data ) ; } else { if ( VERBOSE ) Log . v ( TAG , STRING + id ) ; } } } finally { cursor . close ( ) ; } }
public DBasicConstraints ( JDialog parent , byte [ ] value ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
@ Override public final void writeChars ( String s ) throws IOException { int len = s . length ( ) ; for ( int i = _NUM ; i < len ; i ++ ) { writeChar ( s . charAt ( i ) ) ; } }
public static double round ( double number ) { return ( double ) Math . round ( number * Math . pow ( _NUM , _NUM ) ) / Math . pow ( _NUM , _NUM ) ; }
@ Override public LogSeqNum writeToLog ( ) { List < Constant > rec = buildRecord ( ) ; return logMgr . append ( rec . toArray ( new Constant [ rec . size ( ) ] ) ) ; }
@ Override public LogSeqNum writeToLog ( ) { List < Constant > rec = buildRecord ( ) ; return logMgr . append ( rec . toArray ( new Constant [ rec . size ( ) ] ) ) ; }
public void clear ( ) { size = _NUM ; items . clear ( ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . toString ( n ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . toString ( n ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . toString ( n ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public static final void writeByteArrayXml ( byte [ ] val , String name , XmlSerializer out ) throws XmlPullParserException , java . io . IOException { if ( val == null ) { out . startTag ( null , STRING ) ; out . endTag ( null , STRING ) ; return ; } out . startTag ( null , STRING ) ; if ( name != null ) { out . attribute ( null , STRING , name ) ; } final int n = val . length ; out . attribute ( null , STRING , Integer . toString ( n ) ) ; StringBuilder sb = new StringBuilder ( val . length * _NUM ) ; for ( int i = _NUM ; i < n ; i ++ ) { int b = val [ i ] ; int h = b > > _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; h = b & _NUM ; sb . append ( h >= _NUM ? ( STRING + h - _NUM ) : ( STRING + h ) ) ; } out . text ( sb . toString ( ) ) ; out . endTag ( null , STRING ) ; }
public byte [ ] toByteArray ( ) { final int outLen = _NUM * ( Short . SIZE / Byte . SIZE ) + keyProviderIdLen_ + keyProviderInfoLen_ + encryptedKeyLen_ ; final ByteBuffer out = ByteBuffer . allocate ( outLen ) ; out . putShort ( keyProviderIdLen_ ) ; out . put ( keyProviderId_ , _NUM , keyProviderIdLen_ ) ; out . putShort ( keyProviderInfoLen_ ) ; out . put ( keyProviderInfo_ , _NUM , keyProviderInfoLen_ ) ; out . putShort ( encryptedKeyLen_ ) ; out . put ( encryptedKey_ , _NUM , encryptedKeyLen_ ) ; return out . array ( ) ; }
protected void loadMaps ( ) { Set clientTypes = mergedClientData . keySet ( ) ; Iterator keys = clientTypes . iterator ( ) ; String clientType = null ; Map clientDataMap = null ; while ( keys . hasNext ( ) ) { clientType = ( String ) keys . next ( ) ; clientDataMap = ( Map ) mergedClientData . get ( clientType ) ; setParentStyles ( clientDataMap ) ; } keys = clientTypes . iterator ( ) ; while ( keys . hasNext ( ) ) { clientType = ( String ) keys . next ( ) ; clientDataMap = ( Map ) mergedClientData . get ( clientType ) ; addToClientMap ( clientType , clientDataMap ) ; } }
public static byte [ ] hexStringToBytes ( String hexString ) { if ( hexString == null || hexString . equals ( STRING ) ) { return null ; } hexString = hexString . toUpperCase ( ) ; int length = hexString . length ( ) / _NUM ; char [ ] hexChars = hexString . toCharArray ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = _NUM ; i < length ; i ++ ) { int pos = i * _NUM ; d [ i ] = ( byte ) ( charToByte ( hexChars [ pos ] ) << _NUM | charToByte ( hexChars [ pos + _NUM ] ) ) ; } return d ; }
public static byte [ ] hexStringToBytes ( String hexString ) { if ( hexString == null || hexString . equals ( STRING ) ) { return null ; } hexString = hexString . toUpperCase ( ) ; int length = hexString . length ( ) / _NUM ; char [ ] hexChars = hexString . toCharArray ( ) ; byte [ ] d = new byte [ length ] ; for ( int i = _NUM ; i < length ; i ++ ) { int pos = i * _NUM ; d [ i ] = ( byte ) ( charToByte ( hexChars [ pos ] ) << _NUM | charToByte ( hexChars [ pos + _NUM ] ) ) ; } return d ; }
public TrustManagerBuilder add ( TrustManager ... mgrs ) { for ( TrustManager tm : mgrs ) { if ( tm instanceof X509TrustManager ) { mgr . add ( ( X509TrustManager ) tm ) ; } } return ( this ) ; }
public TrustManagerBuilder add ( TrustManager ... mgrs ) { for ( TrustManager tm : mgrs ) { if ( tm instanceof X509TrustManager ) { mgr . add ( ( X509TrustManager ) tm ) ; } } return ( this ) ; }
public TrustManagerBuilder add ( TrustManager ... mgrs ) { for ( TrustManager tm : mgrs ) { if ( tm instanceof X509TrustManager ) { mgr . add ( ( X509TrustManager ) tm ) ; } } return ( this ) ; }
private void onResized ( ) { Dimension screenSize = stendhal . getDisplaySize ( ) ; sw = getWidth ( ) ; sh = getHeight ( ) ; if ( useScaling ) { double xScale = sw / screenSize . getWidth ( ) ; double yScale = sh / screenSize . getHeight ( ) ; scale = Math . max ( xScale , yScale ) ; if ( Math . abs ( scale - _NUM ) > _NUM ) { useTripleBuffer = _BOOL ; } else { useTripleBuffer = _BOOL ; buffer = null ; } } else { sw = Math . min ( sw , screenSize . width ) ; sh = Math . min ( sh , screenSize . height ) ; useTripleBuffer = _BOOL ; buffer = null ; } calculateView ( x , y ) ; center ( ) ; }
public static String repeat ( String sourceString , int factor ) { if ( factor < _NUM ) { return STRING ; } if ( factor == _NUM ) { return sourceString ; } StringBuilder sb = new StringBuilder ( factor * sourceString . length ( ) ) ; while ( factor > _NUM ) { sb . append ( sourceString ) ; factor -- ; } return sb . toString ( ) ; }
public boolean isAbsolute ( ) { return path . length ( ) > _NUM && path . charAt ( _NUM ) == separatorChar ; }
public boolean isAbsolute ( ) { return path . length ( ) > _NUM && path . charAt ( _NUM ) == separatorChar ; }
public static boolean isDataUri ( String text ) { return text . startsWith ( DATA_URI_PREFIX ) ; }
public static String toPinyin ( char c ) { if ( isChinese ( c ) ) { if ( c == PinyinData . CHAR_12295 ) { return PinyinData . PINYIN_12295 ; } else { return PinyinData . PINYIN_TABLE [ getPinyinCode ( c ) ] ; } } else { return String . valueOf ( c ) ; } }
public void testRandom ( ) { ExtremityMonitor monitor = new ExtremityMonitor ( ) ; Random random = new Random ( _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { monitor . update ( random . nextDouble ( ) ) ; } assertTrue ( monitor . getMin ( ) < _NUM ) ; assertTrue ( monitor . getMax ( ) < _NUM ) ; assertTrue ( monitor . getMin ( ) >= _NUM ) ; assertTrue ( monitor . getMax ( ) > _NUM ) ; }
public void testRandom ( ) { ExtremityMonitor monitor = new ExtremityMonitor ( ) ; Random random = new Random ( _NUM ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { monitor . update ( random . nextDouble ( ) ) ; } assertTrue ( monitor . getMin ( ) < _NUM ) ; assertTrue ( monitor . getMax ( ) < _NUM ) ; assertTrue ( monitor . getMin ( ) >= _NUM ) ; assertTrue ( monitor . getMax ( ) > _NUM ) ; }
public static String toUpperCase ( String src ) { if ( src == null ) { return null ; } else { return src . toUpperCase ( ) ; } }
public static String toUpperCase ( String src ) { if ( src == null ) { return null ; } else { return src . toUpperCase ( ) ; } }
public static String toUpperCase ( String src ) { if ( src == null ) { return null ; } else { return src . toUpperCase ( ) ; } }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
public boolean isIncrementalBuild ( ) { return incrementalBuild ; }
@ Override public Object valueForSearch ( Object value ) { Long val = value ( value ) ; if ( val == null ) { return null ; } return longToIp ( val ) ; }
public boolean exists ( String path ) { try { ZipEntry entry = getZipEntry ( path ) ; return entry != null ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } return _BOOL ; }
public boolean exists ( String path ) { try { ZipEntry entry = getZipEntry ( path ) ; return entry != null ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } return _BOOL ; }
protected void addAuthConfigListener ( String service , String name ) { Set < String > set = authConfigListenerMap . get ( service ) ; if ( set == null ) { set = new CopyOnWriteArraySet < > ( ) ; set . add ( name ) ; authConfigListenerMap . put ( service , set ) ; } else { set . add ( name ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new NullPointerException ( STRING ) ; } int bufferSize = Math . max ( MIN_BUFFER_SIZE , Math . min ( DEFAULT_BUFFER_SIZE , string . length ( ) ) ) ; try { parse ( new StringReader ( string ) , bufferSize ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new NullPointerException ( STRING ) ; } int bufferSize = Math . max ( MIN_BUFFER_SIZE , Math . min ( DEFAULT_BUFFER_SIZE , string . length ( ) ) ) ; try { parse ( new StringReader ( string ) , bufferSize ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new NullPointerException ( STRING ) ; } int bufferSize = Math . max ( MIN_BUFFER_SIZE , Math . min ( DEFAULT_BUFFER_SIZE , string . length ( ) ) ) ; try { parse ( new StringReader ( string ) , bufferSize ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } }
public void parse ( String string ) { if ( string == null ) { throw new NullPointerException ( STRING ) ; } int bufferSize = Math . max ( MIN_BUFFER_SIZE , Math . min ( DEFAULT_BUFFER_SIZE , string . length ( ) ) ) ; try { parse ( new StringReader ( string ) , bufferSize ) ; } catch ( IOException exception ) { throw new RuntimeException ( exception ) ; } }
public static void buildEventsFromCursor ( ArrayList < Event > events , Cursor cEvents , Context context , int startDay , int endDay ) { if ( cEvents == null || events == null ) { Log . e ( TAG , STRING ) ; return ; } int count = cEvents . getCount ( ) ; if ( count == _NUM ) { return ; } Resources res = context . getResources ( ) ; mNoTitleString = res . getString ( R . string . no_title_label ) ; mNoColorColor = res . getColor ( R . color . event_center ) ; cEvents . moveToPosition ( - _NUM ) ; while ( cEvents . moveToNext ( ) ) { Event e = generateEventFromCursor ( cEvents ) ; if ( e . startDay > endDay || e . endDay < startDay ) { continue ; } events . add ( e ) ; } }
public synchronized boolean shouldExecute ( KeySelect keySelect ) { if ( slowQueries == null ) return _BOOL ; String queryKey = keySelect . generateKey ( ) ; Long pendingQueryInvocation = pendingQueries . get ( queryKey ) ; if ( pendingQueryInvocation != null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + queryKey ) ; } return _BOOL ; } Long slowQueryInvocation = slowQueries . get ( queryKey ) ; if ( slowQueryInvocation != null ) { keySelect . setLastInvocation ( slowQueryInvocation ) ; long sinceLastMillis = System . currentTimeMillis ( ) - slowQueryInvocation ; if ( sinceLastMillis < ( slowQueryCacheDuration * _NUM ) ) { slowQueries . put ( queryKey , System . currentTimeMillis ( ) ) ; return _BOOL ; } } pendingQueries . put ( queryKey , System . currentTimeMillis ( ) ) ; return _BOOL ; }
public static Map < String , String > convertOAuthResponse ( String responseOauthRequest ) { Map < String , String > responseElements = new HashMap < > ( ) ; String [ ] elements = responseOauthRequest . split ( STRING ) ; for ( String element : elements ) { String [ ] keyValue = element . split ( STRING ) ; responseElements . put ( keyValue [ _NUM ] , keyValue [ _NUM ] ) ; } return responseElements ; }
public static Map < String , String > convertOAuthResponse ( String responseOauthRequest ) { Map < String , String > responseElements = new HashMap < > ( ) ; String [ ] elements = responseOauthRequest . split ( STRING ) ; for ( String element : elements ) { String [ ] keyValue = element . split ( STRING ) ; responseElements . put ( keyValue [ _NUM ] , keyValue [ _NUM ] ) ; } return responseElements ; }
public static boolean canDockSouth ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canDockSouth ( ) ) return _BOOL ; } return _BOOL ; }
public static boolean canDockSouth ( List constraints ) { for ( Iterator iter = constraints . iterator ( ) ; iter . hasNext ( ) ; ) { DockConstraint dc = ( DockConstraint ) iter . next ( ) ; if ( ! dc . canDockSouth ( ) ) return _BOOL ; } return _BOOL ; }
void flushText ( ) { String flush = ( committedText != null ? committedText : STRING ) ; if ( composedText != null ) { flush += composedText . toString ( ) ; } if ( ! flush . equals ( STRING ) ) { AttributedString attrstr = new AttributedString ( flush ) ; postInputMethodEvent ( InputMethodEvent . INPUT_METHOD_TEXT_CHANGED , attrstr . getIterator ( ) , flush . length ( ) , null , null , EventQueue . getMostRecentEventTime ( ) ) ; composedText = null ; committedText = null ; } }
public T computeIfAbsent ( final Supplier < T > lazy ) { final T val = get ( ) ; if ( val == UNSET ) return setOnceFromSupplier ( lazy ) ; return val ; }
public synchronized void deleteObserver ( Observer observer ) { observers . remove ( observer ) ; }
public synchronized void deleteObserver ( Observer observer ) { observers . remove ( observer ) ; }
private String detailBase ( final Method method ) { final Class < ? > clazz = method . getDeclaringClass ( ) ; final String detailBase = MessageUtils . bundleNameForClass ( clazz ) ; if ( isBlank ( detailBase ) ) { throw new IllegalStateException ( STRING + clazz ) ; } return detailBase ; }
private String detailBase ( final Method method ) { final Class < ? > clazz = method . getDeclaringClass ( ) ; final String detailBase = MessageUtils . bundleNameForClass ( clazz ) ; if ( isBlank ( detailBase ) ) { throw new IllegalStateException ( STRING + clazz ) ; } return detailBase ; }
private static final void showCorruptionError ( Throwable err ) { err . printStackTrace ( ) ; StringWriter sw = new StringWriter ( ) ; PrintWriter pw = new PrintWriter ( sw ) ; pw . println ( STRING + FrostWireUtils . getFrostWireVersion ( ) ) ; pw . print ( STRING ) ; pw . print ( System . getProperty ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . println ( System . getProperty ( STRING , STRING ) ) ; pw . print ( System . getProperty ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . print ( System . getProperty ( STRING , STRING ) ) ; pw . print ( STRING ) ; pw . println ( System . getProperty ( STRING , STRING ) ) ; Runtime runtime = Runtime . getRuntime ( ) ; pw . println ( STRING + runtime . freeMemory ( ) + STRING + runtime . totalMemory ( ) ) ; pw . println ( ) ; err . printStackTrace ( pw ) ; pw . println ( ) ; pw . println ( STRING ) ; pw . println ( ) ; File propsFile = new File ( getUserSettingsDir ( ) , STRING ) ; Properties props = new Properties ( ) ; try { FileInputStream fis = new FileInputStream ( propsFile ) ; props . load ( fis ) ; fis . close ( ) ; props . list ( pw ) ; } catch ( FileNotFoundException fnfe ) { } catch ( IOException ioe ) { } pw . flush ( ) ; displayError ( sw . toString ( ) ) ; }
public int action ( String fault , String action ) { Integer current = get ( fault ) ; if ( current == null ) throw new IllegalArgumentException ( fault ) ; boolean no = action . startsWith ( STRING ) ; if ( no ) action = action . substring ( _NUM ) ; Integer bit = getAction ( action ) ; if ( bit == null ) throw new IllegalArgumentException ( action ) ; int old = current . intValue ( ) ; int mask = bit . intValue ( ) ; int n = ( old & ( ~ mask ) ) ; n = ( no ) ? n : ( n | mask ) ; put ( fault , new Integer ( n ) ) ; return n ; }
public void save ( ) throws IOException { try { Process . checkIfSavable ( this ) ; } catch ( Exception e ) { throw new IOException ( e . getMessage ( ) ) ; } if ( processLocation != null ) { this . isProcessConverted = _BOOL ; processLocation . store ( this , null ) ; } else { throw new IOException ( STRING ) ; } }
public void assertJoined ( final UUID serviceId ) { m_triggers . add ( new QuorumEventInvariant ( QuorumEventEnum . SERVICE_LEAVE , serviceId ) ) ; assertMembership ( m_quorum . getJoined ( ) , serviceId ) ; }
private HashtableEntry < K , V > [ ] doubleCapacity ( ) { HashtableEntry < K , V > [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { return oldTable ; } int newCapacity = oldCapacity * _NUM ; HashtableEntry < K , V > [ ] newTable = makeTable ( newCapacity ) ; if ( size == _NUM ) { return newTable ; } for ( int j = _NUM ; j < oldCapacity ; j ++ ) { HashtableEntry < K , V > e = oldTable [ j ] ; if ( e == null ) { continue ; } int highBit = e . hash & oldCapacity ; HashtableEntry < K , V > broken = null ; newTable [ j | highBit ] = e ; for ( HashtableEntry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int nextHighBit = n . hash & oldCapacity ; if ( nextHighBit != highBit ) { if ( broken == null ) newTable [ j | nextHighBit ] = n ; else broken . next = n ; broken = e ; highBit = nextHighBit ; } } if ( broken != null ) broken . next = null ; } return newTable ; }
private HashtableEntry < K , V > [ ] doubleCapacity ( ) { HashtableEntry < K , V > [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { return oldTable ; } int newCapacity = oldCapacity * _NUM ; HashtableEntry < K , V > [ ] newTable = makeTable ( newCapacity ) ; if ( size == _NUM ) { return newTable ; } for ( int j = _NUM ; j < oldCapacity ; j ++ ) { HashtableEntry < K , V > e = oldTable [ j ] ; if ( e == null ) { continue ; } int highBit = e . hash & oldCapacity ; HashtableEntry < K , V > broken = null ; newTable [ j | highBit ] = e ; for ( HashtableEntry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int nextHighBit = n . hash & oldCapacity ; if ( nextHighBit != highBit ) { if ( broken == null ) newTable [ j | nextHighBit ] = n ; else broken . next = n ; broken = e ; highBit = nextHighBit ; } } if ( broken != null ) broken . next = null ; } return newTable ; }
private HashtableEntry < K , V > [ ] doubleCapacity ( ) { HashtableEntry < K , V > [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { return oldTable ; } int newCapacity = oldCapacity * _NUM ; HashtableEntry < K , V > [ ] newTable = makeTable ( newCapacity ) ; if ( size == _NUM ) { return newTable ; } for ( int j = _NUM ; j < oldCapacity ; j ++ ) { HashtableEntry < K , V > e = oldTable [ j ] ; if ( e == null ) { continue ; } int highBit = e . hash & oldCapacity ; HashtableEntry < K , V > broken = null ; newTable [ j | highBit ] = e ; for ( HashtableEntry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int nextHighBit = n . hash & oldCapacity ; if ( nextHighBit != highBit ) { if ( broken == null ) newTable [ j | nextHighBit ] = n ; else broken . next = n ; broken = e ; highBit = nextHighBit ; } } if ( broken != null ) broken . next = null ; } return newTable ; }
private HashtableEntry < K , V > [ ] doubleCapacity ( ) { HashtableEntry < K , V > [ ] oldTable = table ; int oldCapacity = oldTable . length ; if ( oldCapacity == MAXIMUM_CAPACITY ) { return oldTable ; } int newCapacity = oldCapacity * _NUM ; HashtableEntry < K , V > [ ] newTable = makeTable ( newCapacity ) ; if ( size == _NUM ) { return newTable ; } for ( int j = _NUM ; j < oldCapacity ; j ++ ) { HashtableEntry < K , V > e = oldTable [ j ] ; if ( e == null ) { continue ; } int highBit = e . hash & oldCapacity ; HashtableEntry < K , V > broken = null ; newTable [ j | highBit ] = e ; for ( HashtableEntry < K , V > n = e . next ; n != null ; e = n , n = n . next ) { int nextHighBit = n . hash & oldCapacity ; if ( nextHighBit != highBit ) { if ( broken == null ) newTable [ j | nextHighBit ] = n ; else broken . next = n ; broken = e ; highBit = nextHighBit ; } } if ( broken != null ) broken . next = null ; } return newTable ; }
private void replaceCollapsedEdges ( ) { List newEdges = new ArrayList ( ) ; for ( Iterator it = edgeList . iterator ( ) ; it . hasNext ( ) ; ) { Edge e = ( Edge ) it . next ( ) ; if ( e . isCollapsed ( ) ) { it . remove ( ) ; newEdges . add ( e . getCollapsedEdge ( ) ) ; } } edgeList . addAll ( newEdges ) ; }
private void replaceCollapsedEdges ( ) { List newEdges = new ArrayList ( ) ; for ( Iterator it = edgeList . iterator ( ) ; it . hasNext ( ) ; ) { Edge e = ( Edge ) it . next ( ) ; if ( e . isCollapsed ( ) ) { it . remove ( ) ; newEdges . add ( e . getCollapsedEdge ( ) ) ; } } edgeList . addAll ( newEdges ) ; }
private CPluginOutputDialog ( ) { super ( ( JFrame ) null , STRING ) ; new CDialogEscaper ( this ) ; setLayout ( new BorderLayout ( ) ) ; m_textArea . setEditable ( _BOOL ) ; m_textArea . setFont ( GuiHelper . MONOSPACED_FONT ) ; add ( new JScrollPane ( m_textArea ) ) ; final JPanel bottomPanel = new JPanel ( new BorderLayout ( ) ) ; bottomPanel . add ( new JButton ( new ClearAction ( ) ) , BorderLayout . WEST ) ; bottomPanel . add ( new JButton ( new CloseAction ( ) ) , BorderLayout . EAST ) ; add ( bottomPanel , BorderLayout . SOUTH ) ; setAlwaysOnTop ( _BOOL ) ; setJMenuBar ( new CLogConsoleMenuBar ( ) ) ; m_textArea . addMouseListener ( new InternalMouseListener ( ) ) ; setSize ( _NUM , _NUM ) ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( MutableDateTime ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
private void readObject ( ObjectInputStream oos ) throws IOException , ClassNotFoundException { iInstant = ( MutableDateTime ) oos . readObject ( ) ; DateTimeFieldType type = ( DateTimeFieldType ) oos . readObject ( ) ; iField = type . getField ( iInstant . getChronology ( ) ) ; }
@ Override public int hashCode ( ) { int result = _NUM ; for ( int i = _NUM ; i < vals . length ; i ++ ) result = _NUM * result + Float . floatToIntBits ( vals [ i ] ) ; return result ; }
public void removeChild ( Group theGroup ) { mChildren . remove ( theGroup ) ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
public JSONArray names ( ) { JSONArray ja = new JSONArray ( ) ; Iterator keys = keys ( ) ; while ( keys . hasNext ( ) ) { ja . put ( keys . next ( ) ) ; } return ja . length ( ) == _NUM ? null : ja ; }
public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = _NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . charAt ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . charAt ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; } return lst ; }
public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = _NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . charAt ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . charAt ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; } return lst ; }
public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = _NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . charAt ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . charAt ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; } return lst ; }
public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = _NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . charAt ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . charAt ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; } return lst ; }
public static List < String > splitSmart ( String s , String separator , boolean decode ) { ArrayList < String > lst = new ArrayList < > ( _NUM ) ; StringBuilder sb = new StringBuilder ( ) ; int pos = _NUM , end = s . length ( ) ; while ( pos < end ) { if ( s . startsWith ( separator , pos ) ) { if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; sb = new StringBuilder ( ) ; } pos += separator . length ( ) ; continue ; } char ch = s . charAt ( pos ++ ) ; if ( ch == STRING ) { if ( ! decode ) sb . append ( ch ) ; if ( pos >= end ) break ; ch = s . charAt ( pos ++ ) ; if ( decode ) { switch ( ch ) { case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; case STRING : ch = STRING ; break ; } } } sb . append ( ch ) ; } if ( sb . length ( ) > _NUM ) { lst . add ( sb . toString ( ) ) ; } return lst ; }
public static final byte [ ] decode ( BufferedReader reader ) throws IOException , Base64DecodingException { byte [ ] retBytes = null ; UnsyncByteArrayOutputStream baos = null ; try { baos = new UnsyncByteArrayOutputStream ( ) ; String line ; while ( null != ( line = reader . readLine ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } retBytes = baos . toByteArray ( ) ; } finally { baos . close ( ) ; } return retBytes ; }
public static final byte [ ] decode ( BufferedReader reader ) throws IOException , Base64DecodingException { byte [ ] retBytes = null ; UnsyncByteArrayOutputStream baos = null ; try { baos = new UnsyncByteArrayOutputStream ( ) ; String line ; while ( null != ( line = reader . readLine ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } retBytes = baos . toByteArray ( ) ; } finally { baos . close ( ) ; } return retBytes ; }
public static final byte [ ] decode ( BufferedReader reader ) throws IOException , Base64DecodingException { byte [ ] retBytes = null ; UnsyncByteArrayOutputStream baos = null ; try { baos = new UnsyncByteArrayOutputStream ( ) ; String line ; while ( null != ( line = reader . readLine ( ) ) ) { byte [ ] bytes = decode ( line ) ; baos . write ( bytes ) ; } retBytes = baos . toByteArray ( ) ; } finally { baos . close ( ) ; } return retBytes ; }
public void expectSuccess ( MessageInfo messageInfo ) { expectedApiCalls . add ( new ApiCall ( SUCCESS , new Object [ ] { messageInfo . getOrigin ( ) , messageInfo . getClient ( ) , messageInfo . getService ( ) } ) ) ; }
public long contentLength ( ) { long size ; try { size = Long . parseLong ( request . getHeader ( FileUpload . CONTENT_LENGTH ) ) ; } catch ( NumberFormatException e ) { size = request . getContentLength ( ) ; } return size ; }
public DbSchemaChanger addAnnotation ( String methodName , String annotationName , Map < String , Object > values ) throws Exception { CtMethod methodDescriptor = cc . getDeclaredMethod ( methodName ) ; ClassFile ccFile = cc . getClassFile ( ) ; ccFile . setVersionToJava5 ( ) ; ConstPool constpool = ccFile . getConstPool ( ) ; MethodInfo minfo = methodDescriptor . getMethodInfo ( ) ; AnnotationsAttribute attr = ( AnnotationsAttribute ) minfo . getAttribute ( AnnotationsAttribute . visibleTag ) ; if ( attr == null ) { attr = new AnnotationsAttribute ( constpool , AnnotationsAttribute . visibleTag ) ; } Annotation annot = new Annotation ( annotationName , constpool ) ; Set < Map . Entry < String , Object > > entries = values . entrySet ( ) ; for ( Map . Entry < String , Object > entry : entries ) { String attrName = entry . getKey ( ) ; Object attrValue = entry . getValue ( ) ; if ( attrValue instanceof String ) { annot . addMemberValue ( attrName , new StringMemberValue ( ( String ) attrValue , ccFile . getConstPool ( ) ) ) ; } else { throw new RuntimeException ( String . format ( STRING , attrName , attrValue ) ) ; } } attr . addAnnotation ( annot ) ; minfo . addAttribute ( attr ) ; log . info ( STRING , attr , methodDescriptor ) ; return this ; }
public static void premain ( String agentArgs , Instrumentation inst ) { instrumentation = inst ; LOGGER . info ( STRING ) ; checkForCorrectSetup ( ) ; try { @ SuppressWarnings ( STRING ) InspectItClassLoader classLoader = new InspectItClassLoader ( new URL [ _NUM ] ) ; Class < ? > agentClazz = classLoader . loadClass ( INSPECTIT_AGENT ) ; Constructor < ? > constructor = agentClazz . getConstructor ( File . class ) ; Object realAgent = constructor . newInstance ( getInspectItAgentJarFileLocation ( ) ) ; Agent . agent = ( IAgent ) realAgent ; preloadClasses ( ) ; LOGGER . info ( STRING ) ; analyzeAlreadyLoadedClasses ( ) ; inst . addTransformer ( new JavaAgent ( ) ) ; } catch ( Exception e ) { LOGGER . severe ( STRING ) ; e . printStackTrace ( ) ; } }
private static void insertNativeEdge ( final List < ReilBlock > nodes , final List < ReilEdge > edges , final ICodeEdge < ? > nativeEdge , final ReilInstruction sourceReilInstruction , final ReilInstruction targetReilInstruction ) { for ( final ReilBlock node : nodes ) { if ( ( sourceReilInstruction == getLastInstruction ( node ) ) && ! hasEdge ( nodes , node , targetReilInstruction ) ) { final EdgeType edgeType = ReilHelpers . isJump ( sourceReilInstruction ) ? nativeEdge . getType ( ) : EdgeType . JUMP_UNCONDITIONAL ; final ReilBlock targetNode = getNode ( targetReilInstruction , nodes ) ; final ReilEdge newEdge = new ReilEdge ( node , targetNode , edgeType ) ; ReilBlock . link ( node , targetNode , newEdge ) ; edges . add ( newEdge ) ; } } }
private boolean contains ( String ids [ ] , String id ) { for ( int i = _NUM ; i < ids . length ; i ++ ) { if ( Operator . compare ( ids [ i ] , id ) == _NUM ) return _BOOL ; } return _BOOL ; }
private boolean contains ( String ids [ ] , String id ) { for ( int i = _NUM ; i < ids . length ; i ++ ) { if ( Operator . compare ( ids [ i ] , id ) == _NUM ) return _BOOL ; } return _BOOL ; }
public static void checkForExportRuleToDelete ( HashMap < String , ExportRule > sourceExportRuleMap , HashMap < String , ExportRule > targetExportRuleMap , List < ExportRule > exportRulesToDelete ) { for ( String secFlavour : targetExportRuleMap . keySet ( ) ) { if ( ! sourceExportRuleMap . containsKey ( secFlavour ) ) { exportRulesToDelete . add ( targetExportRuleMap . get ( secFlavour ) ) ; } } }
public FluxMapFuseable ( Publisher < ? extends T > source , Function < ? super T , ? extends R > mapper ) { super ( source ) ; this . mapper = Objects . requireNonNull ( mapper , STRING ) ; }
@ VisibleForTesting public void processEnableFullscreenRunnableForTest ( ) { if ( mHandler . hasMessages ( MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD ) ) { mHandler . removeMessages ( MSG_ID_ENABLE_FULLSCREEN_AFTER_LOAD ) ; enableFullscreenAfterLoad ( ) ; } }
private void fillText ( InputNode from ) throws Exception { EventNode event = reader . peek ( ) ; if ( event . isText ( ) ) { String data = event . getValue ( ) ; text . append ( data ) ; } }
private void fillText ( InputNode from ) throws Exception { EventNode event = reader . peek ( ) ; if ( event . isText ( ) ) { String data = event . getValue ( ) ; text . append ( data ) ; } }
private void fillText ( InputNode from ) throws Exception { EventNode event = reader . peek ( ) ; if ( event . isText ( ) ) { String data = event . getValue ( ) ; text . append ( data ) ; } }
private void fillText ( InputNode from ) throws Exception { EventNode event = reader . peek ( ) ; if ( event . isText ( ) ) { String data = event . getValue ( ) ; text . append ( data ) ; } }
public static int javaNew ( int luaState , Class clazz ) throws LuaException { LuaState L = LuaStateFactory . getExistingState ( luaState ) ; synchronized ( L ) { Object ret = getObjInstance ( L , clazz ) ; L . pushJavaObject ( ret ) ; return _NUM ; } }
public static int javaNew ( int luaState , Class clazz ) throws LuaException { LuaState L = LuaStateFactory . getExistingState ( luaState ) ; synchronized ( L ) { Object ret = getObjInstance ( L , clazz ) ; L . pushJavaObject ( ret ) ; return _NUM ; } }
public static byte [ ] loadImageFile ( File imageLoc ) throws IOException { FileInputStream fis = new FileInputStream ( imageLoc ) ; byte [ ] read = new byte [ fis . available ( ) ] ; fis . read ( read ) ; fis . close ( ) ; return read ; }
public static byte [ ] loadImageFile ( File imageLoc ) throws IOException { FileInputStream fis = new FileInputStream ( imageLoc ) ; byte [ ] read = new byte [ fis . available ( ) ] ; fis . read ( read ) ; fis . close ( ) ; return read ; }
public static final String makeCompoundField ( String delimiter , String ... term ) { StringBuilder sb = new StringBuilder ( ) ; for ( String s : term ) { if ( s . length ( ) != _NUM ) { if ( delimiter != null && sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( s ) ; } } return sb . toString ( ) ; }
public static final String makeCompoundField ( String delimiter , String ... term ) { StringBuilder sb = new StringBuilder ( ) ; for ( String s : term ) { if ( s . length ( ) != _NUM ) { if ( delimiter != null && sb . length ( ) != _NUM ) { sb . append ( delimiter ) ; } sb . append ( s ) ; } } return sb . toString ( ) ; }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
@ Override public AlarmEvent evaluate ( AlarmPoint alarm , String trigger ) { if ( trigger . equals ( AlarmPoint . TRIGGER_ACTIVATE ) ) { return activation ( alarm ) ; } else if ( trigger . equals ( AlarmPoint . TRIGGER_DEACTIVATE ) ) { return deactivation ( alarm ) ; } else { throw new IllegalArgumentException ( STRING + trigger + STRING ) ; } }
private static void fixPrng ( ) { if ( ! prngFixed . get ( ) ) { synchronized ( PrngFixes . class ) { if ( ! prngFixed . get ( ) ) { PrngFixes . apply ( ) ; prngFixed . set ( _BOOL ) ; } } } }
private static void fixPrng ( ) { if ( ! prngFixed . get ( ) ) { synchronized ( PrngFixes . class ) { if ( ! prngFixed . get ( ) ) { PrngFixes . apply ( ) ; prngFixed . set ( _BOOL ) ; } } } }
private static void fixPrng ( ) { if ( ! prngFixed . get ( ) ) { synchronized ( PrngFixes . class ) { if ( ! prngFixed . get ( ) ) { PrngFixes . apply ( ) ; prngFixed . set ( _BOOL ) ; } } } }
public void appendResults ( List < SearchResult > searchResults ) { mSearchResults . addAll ( searchResults ) ; for ( SearchResult searchResult : searchResults ) { final ProviderIdentifier id = searchResult . getIdentifier ( ) ; final List < String > songs = searchResult . getSongsList ( ) ; final List < String > artists = searchResult . getArtistList ( ) ; final List < String > playlists = searchResult . getPlaylistList ( ) ; final List < String > albums = searchResult . getAlbumsList ( ) ; for ( String song : songs ) { SearchEntry entry = new SearchEntry ( song , id ) ; if ( ! mAllSongs . contains ( entry ) ) { mAllSongs . add ( entry ) ; } } for ( String artist : artists ) { SearchEntry entry = new SearchEntry ( artist , id ) ; if ( ! mAllArtists . contains ( entry ) ) { mAllArtists . add ( entry ) ; } } for ( String playlist : playlists ) { SearchEntry entry = new SearchEntry ( playlist , id ) ; if ( ! mAllPlaylists . contains ( entry ) ) { mAllPlaylists . add ( entry ) ; } } for ( String album : albums ) { SearchEntry entry = new SearchEntry ( album , id ) ; if ( ! mAllAlbums . contains ( entry ) ) { mAllAlbums . add ( entry ) ; } } } computeResultsList ( ) ; }
protected static ArrayList < GeoPoint > parseKmlCoordinates ( String input ) { LinkedList < GeoPoint > tmpCoords = new LinkedList < GeoPoint > ( ) ; int i = _NUM ; int tupleStart = _NUM ; int length = input . length ( ) ; boolean startReadingTuple = _BOOL ; while ( i < length ) { char c = input . charAt ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( startReadingTuple ) { String tuple = input . substring ( tupleStart , i ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; startReadingTuple = _BOOL ; } } else { if ( ! startReadingTuple ) { startReadingTuple = _BOOL ; tupleStart = i ; } if ( i == length - _NUM ) { String tuple = input . substring ( tupleStart , i + _NUM ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; } } i ++ ; } ArrayList < GeoPoint > coordinates = new ArrayList < GeoPoint > ( tmpCoords . size ( ) ) ; coordinates . addAll ( tmpCoords ) ; return coordinates ; }
protected static ArrayList < GeoPoint > parseKmlCoordinates ( String input ) { LinkedList < GeoPoint > tmpCoords = new LinkedList < GeoPoint > ( ) ; int i = _NUM ; int tupleStart = _NUM ; int length = input . length ( ) ; boolean startReadingTuple = _BOOL ; while ( i < length ) { char c = input . charAt ( i ) ; if ( c == STRING || c == STRING || c == STRING ) { if ( startReadingTuple ) { String tuple = input . substring ( tupleStart , i ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; startReadingTuple = _BOOL ; } } else { if ( ! startReadingTuple ) { startReadingTuple = _BOOL ; tupleStart = i ; } if ( i == length - _NUM ) { String tuple = input . substring ( tupleStart , i + _NUM ) ; GeoPoint p = parseKmlCoord ( tuple ) ; if ( p != null ) tmpCoords . add ( p ) ; } } i ++ ; } ArrayList < GeoPoint > coordinates = new ArrayList < GeoPoint > ( tmpCoords . size ( ) ) ; coordinates . addAll ( tmpCoords ) ; return coordinates ; }
public void enterSource ( NodeHandler handler , Context context ) { NodeInfo curr = context . getContextNodeInfo ( ) ; final String path = Navigator . getPath ( curr ) ; if ( TRACE ) { trace ( indent + STRING + path + STRING + curr . getLineNumber ( ) + STRING + getModeName ( context ) + STRING ) ; indent += STRING ; } myDebugger . pushSource ( new SaxonSourceFrame ( myDebugger . getSourceFrame ( ) , curr ) ) ; }
public static String extractResponse ( String samlRequestParameter ) throws Exception { Inflater decompresser = new Inflater ( _BOOL ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; InflaterOutputStream inflaterOutputStream = new InflaterOutputStream ( byteArrayOutputStream , decompresser ) ; inflaterOutputStream . write ( Base64 . decode ( samlRequestParameter ) ) ; inflaterOutputStream . close ( ) ; String outputString = new String ( byteArrayOutputStream . toByteArray ( ) , STRING ) ; return outputString ; }
public static String extractResponse ( String samlRequestParameter ) throws Exception { Inflater decompresser = new Inflater ( _BOOL ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; InflaterOutputStream inflaterOutputStream = new InflaterOutputStream ( byteArrayOutputStream , decompresser ) ; inflaterOutputStream . write ( Base64 . decode ( samlRequestParameter ) ) ; inflaterOutputStream . close ( ) ; String outputString = new String ( byteArrayOutputStream . toByteArray ( ) , STRING ) ; return outputString ; }
public static String extractResponse ( String samlRequestParameter ) throws Exception { Inflater decompresser = new Inflater ( _BOOL ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; InflaterOutputStream inflaterOutputStream = new InflaterOutputStream ( byteArrayOutputStream , decompresser ) ; inflaterOutputStream . write ( Base64 . decode ( samlRequestParameter ) ) ; inflaterOutputStream . close ( ) ; String outputString = new String ( byteArrayOutputStream . toByteArray ( ) , STRING ) ; return outputString ; }
public static String extractResponse ( String samlRequestParameter ) throws Exception { Inflater decompresser = new Inflater ( _BOOL ) ; ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream ( ) ; InflaterOutputStream inflaterOutputStream = new InflaterOutputStream ( byteArrayOutputStream , decompresser ) ; inflaterOutputStream . write ( Base64 . decode ( samlRequestParameter ) ) ; inflaterOutputStream . close ( ) ; String outputString = new String ( byteArrayOutputStream . toByteArray ( ) , STRING ) ; return outputString ; }
public int read ( ) throws IOException { int val ; if ( ( val = is . read ( ) ) < _NUM ) { return - _NUM ; } if ( bo == STRING ) { val = ( char ) ( ( val << _NUM ) | ( is . read ( ) & _NUM ) ) ; } else { val = ( char ) ( ( is . read ( ) << _NUM ) | ( val & _NUM ) ) ; } return val ; }
private ChronoLocalDate ofWeekBasedYear ( Chronology chrono , int yowby , int wowby , int dow ) { ChronoLocalDate date = chrono . date ( yowby , _NUM , _NUM ) ; int ldow = localizedDayOfWeek ( date ) ; int offset = startOfWeekOffset ( _NUM , ldow ) ; int yearLen = date . lengthOfYear ( ) ; int newYearWeek = computeWeek ( offset , yearLen + weekDef . getMinimalDaysInFirstWeek ( ) ) ; wowby = Math . min ( wowby , newYearWeek - _NUM ) ; int days = - offset + ( dow - _NUM ) + ( wowby - _NUM ) * _NUM ; return date . plus ( days , DAYS ) ; }
public ShapeTileSimplex remove_border_line ( int p_no ) { if ( p_no < _NUM || p_no >= lines_size ( ) ) { return this ; } ArrayList < PlaLineInt > new_arr = new ArrayList < PlaLineInt > ( lines_size ( ) ) ; new_arr . addAll ( lines_list ) ; new_arr . remove ( p_no ) ; return new ShapeTileSimplex ( new_arr ) ; }
public ShapeTileSimplex remove_border_line ( int p_no ) { if ( p_no < _NUM || p_no >= lines_size ( ) ) { return this ; } ArrayList < PlaLineInt > new_arr = new ArrayList < PlaLineInt > ( lines_size ( ) ) ; new_arr . addAll ( lines_list ) ; new_arr . remove ( p_no ) ; return new ShapeTileSimplex ( new_arr ) ; }
public ShapeTileSimplex remove_border_line ( int p_no ) { if ( p_no < _NUM || p_no >= lines_size ( ) ) { return this ; } ArrayList < PlaLineInt > new_arr = new ArrayList < PlaLineInt > ( lines_size ( ) ) ; new_arr . addAll ( lines_list ) ; new_arr . remove ( p_no ) ; return new ShapeTileSimplex ( new_arr ) ; }
final void appendPrintString ( StringBuffer buffer ) { NaiveASTFlattener printer = new NaiveASTFlattener ( ) ; accept ( printer ) ; buffer . append ( printer . getResult ( ) ) ; }
@ Override public void agg ( Object newVal ) { valueSetForObj . add ( newVal ) ; }
@ Override public void agg ( Object newVal ) { valueSetForObj . add ( newVal ) ; }
public synchronized void addNewFile ( long seqno , String fileName ) { logger . info ( STRING + fileName + STRING + seqno ) ; index . add ( new LogIndexEntry ( seqno , Long . MAX_VALUE , fileName ) ) ; if ( retentionMillis > _NUM ) { String activeFile = getFile ( activeSeqno ) ; File [ ] purgeCandidates = FileCommands . filesOverRetentionAndInactive ( logDir , filePrefix , _NUM , activeFile ) ; File [ ] filesToPurge = FileCommands . filesOverModDate ( purgeCandidates , new Interval ( retentionMillis ) ) ; if ( filesToPurge . length > _NUM ) { for ( File file : filesToPurge ) removeFile ( file . getName ( ) ) ; FileCommands . deleteFiles ( filesToPurge , _BOOL ) ; } } }
@ Override public AxisState draw ( Graphics2D g2 , double cursor , Rectangle2D plotArea , Rectangle2D dataArea , RectangleEdge edge , PlotRenderingInfo plotState ) { if ( ! isVisible ( ) ) { return new AxisState ( cursor ) ; } if ( isAxisLineVisible ( ) ) { drawAxisLine ( g2 , cursor , dataArea , edge ) ; } AxisState state = new AxisState ( cursor ) ; state = drawSubCategoryLabels ( g2 , plotArea , dataArea , edge , state , plotState ) ; state = drawCategoryLabels ( g2 , plotArea , dataArea , edge , state , plotState ) ; if ( getAttributedLabel ( ) != null ) { state = drawAttributedLabel ( getAttributedLabel ( ) , g2 , plotArea , dataArea , edge , state ) ; } else { state = drawLabel ( getLabel ( ) , g2 , plotArea , dataArea , edge , state ) ; } return state ; }
@ Override public AxisState draw ( Graphics2D g2 , double cursor , Rectangle2D plotArea , Rectangle2D dataArea , RectangleEdge edge , PlotRenderingInfo plotState ) { if ( ! isVisible ( ) ) { return new AxisState ( cursor ) ; } if ( isAxisLineVisible ( ) ) { drawAxisLine ( g2 , cursor , dataArea , edge ) ; } AxisState state = new AxisState ( cursor ) ; state = drawSubCategoryLabels ( g2 , plotArea , dataArea , edge , state , plotState ) ; state = drawCategoryLabels ( g2 , plotArea , dataArea , edge , state , plotState ) ; if ( getAttributedLabel ( ) != null ) { state = drawAttributedLabel ( getAttributedLabel ( ) , g2 , plotArea , dataArea , edge , state ) ; } else { state = drawLabel ( getLabel ( ) , g2 , plotArea , dataArea , edge , state ) ; } return state ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static Credentials acquireServiceCreds ( String service , Credentials ccreds ) throws KrbException , IOException { return CredentialsUtil . acquireServiceCreds ( service , ccreds ) ; }
public static ControlTagCacheObject createTestSubEquipmentAlive ( ) { ControlTagCacheObject cacheObject = new ControlTagCacheObject ( new Long ( _NUM ) , STRING , STRING , DataTagConstants . MODE_TEST ) ; cacheObject . setDescription ( STRING ) ; cacheObject . setLogged ( _BOOL ) ; cacheObject . setUnit ( STRING ) ; cacheObject . setDipAddress ( STRING ) ; cacheObject . setJapcAddress ( STRING ) ; cacheObject . setValue ( new Long ( System . currentTimeMillis ( ) ) ) ; cacheObject . setValueDescription ( STRING ) ; cacheObject . setSimulated ( _BOOL ) ; cacheObject . setMinValue ( Long . MIN_VALUE ) ; cacheObject . setMaxValue ( Long . MAX_VALUE ) ; cacheObject . setValueDictionary ( new DataTagValueDictionary ( ) ) ; cacheObject . setAddress ( new DataTagAddress ( ) ) ; cacheObject . setDataTagQuality ( createValidQuality ( ) ) ; cacheObject . setCacheTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; cacheObject . setDaqTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; cacheObject . setSourceTimestamp ( new Timestamp ( System . currentTimeMillis ( ) ) ) ; return cacheObject ; }
protected double categoryUtility ( ) throws Exception { if ( m_children == null ) { throw new Exception ( STRING ) ; } double totalCU = _NUM ; for ( int i = _NUM ; i < m_children . size ( ) ; i ++ ) { CNode child = m_children . get ( i ) ; totalCU += categoryUtilityChild ( child ) ; } totalCU /= m_children . size ( ) ; return totalCU ; }
public void write ( int b ) throws IOException { _file . write ( b ) ; }
public void write ( int b ) throws IOException { _file . write ( b ) ; }
@ SuppressWarnings ( STRING ) public UrlCritter addUrl ( String url , Context context ) { List < String > urls = urlManager . getUrls ( context ) ; if ( ! urls . contains ( url ) ) { urls . add ( url ) ; urlManager . saveUrls ( context , urls ) ; } return this ; }
public int addMana ( int mana , boolean tell ) { int old_mana = getMana ( ) ; int new_mana = old_mana + mana ; int given = _NUM ; new_mana = Math . max ( new_mana , _NUM ) ; new_mana = Math . min ( new_mana , getBaseMana ( ) ) ; given = new_mana - old_mana ; if ( tell ) { } setMana ( new_mana ) ; return given ; }
public TrainingSetPanel ( ) { final JSplitPane split = new JSplitPane ( JSplitPane . HORIZONTAL_SPLIT ) ; JPanel filler1 = new JPanel ( ) ; filler1 . setBackground ( Color . lightGray ) ; JPanel filler2 = new JPanel ( ) ; filler2 . setBackground ( Color . lightGray ) ; split . setLeftComponent ( filler1 ) ; split . setRightComponent ( filler2 ) ; split . setResizeWeight ( _NUM ) ; split . setBorder ( null ) ; setLayout ( new GridBagLayout ( ) ) ; GridBagConstraints wholePanelConstraints = new GridBagConstraints ( ) ; wholePanelConstraints . fill = GridBagConstraints . BOTH ; wholePanelConstraints . weightx = _NUM ; wholePanelConstraints . weighty = _NUM ; wholePanelConstraints . gridx = _NUM ; wholePanelConstraints . gridy = _NUM ; add ( split , wholePanelConstraints ) ; }
public LicenseHeaderStep ( File licenseFile , Charset encoding , String delimiter ) throws IOException { this ( new String ( Files . readAllBytes ( licenseFile . toPath ( ) ) , encoding ) , delimiter ) ; }
final public void println ( char [ ] s ) { Writer out = this . out ; if ( out == null ) return ; try { out . write ( s , _NUM , s . length ) ; out . write ( _newline , _NUM , _newline . length ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public final boolean hasTag ( Tag t ) { return allTags . contains ( t ) ; }
public final boolean hasTag ( Tag t ) { return allTags . contains ( t ) ; }
protected static Vector convertToVector ( final Object [ ] anArray ) { if ( anArray == null ) { return null ; } final Vector v = new Vector ( anArray . length ) ; for ( final Object element : anArray ) { v . addElement ( element ) ; } return v ; }
protected static Vector convertToVector ( final Object [ ] anArray ) { if ( anArray == null ) { return null ; } final Vector v = new Vector ( anArray . length ) ; for ( final Object element : anArray ) { v . addElement ( element ) ; } return v ; }
public void removeAllTrailers ( ) { trailer . clear ( ) ; firePropertyChange ( TRAILER , null , trailer ) ; }
void addFieldValue ( Map < TemporalField , Long > fieldValues , ChronoField field , long value ) { Long old = fieldValues . get ( field ) ; if ( old != null && old . longValue ( ) != value ) { throw new DateTimeException ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } fieldValues . put ( field , value ) ; }
void addFieldValue ( Map < TemporalField , Long > fieldValues , ChronoField field , long value ) { Long old = fieldValues . get ( field ) ; if ( old != null && old . longValue ( ) != value ) { throw new DateTimeException ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } fieldValues . put ( field , value ) ; }
void addFieldValue ( Map < TemporalField , Long > fieldValues , ChronoField field , long value ) { Long old = fieldValues . get ( field ) ; if ( old != null && old . longValue ( ) != value ) { throw new DateTimeException ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } fieldValues . put ( field , value ) ; }
void addFieldValue ( Map < TemporalField , Long > fieldValues , ChronoField field , long value ) { Long old = fieldValues . get ( field ) ; if ( old != null && old . longValue ( ) != value ) { throw new DateTimeException ( STRING + field + STRING + old + STRING + field + STRING + value ) ; } fieldValues . put ( field , value ) ; }
public static String stripFileExtension ( String name ) { int pos = name . lastIndexOf ( STRING ) ; if ( pos > _NUM & pos < name . length ( ) - _NUM ) return name . substring ( _NUM , pos ) ; return name ; }
private void onTtsReady ( ) { Locale locale = Locale . getDefault ( ) ; int languageAvailability = tts . isLanguageAvailable ( locale ) ; if ( languageAvailability == TextToSpeech . LANG_MISSING_DATA || languageAvailability == TextToSpeech . LANG_NOT_SUPPORTED ) { Log . w ( TAG , STRING ) ; locale = Locale . ENGLISH ; } tts . setLanguage ( locale ) ; tts . setSpeechRate ( TTS_SPEECH_RATE ) ; tts . setOnUtteranceCompletedListener ( utteranceListener ) ; }
public static void doWithFields ( Class < ? > clazz , FieldCallback fc , FieldFilter ff ) throws IllegalArgumentException { Class < ? > targetClass = clazz ; do { Field [ ] fields = targetClass . getDeclaredFields ( ) ; for ( Field field : fields ) { if ( ff != null && ! ff . matches ( field ) ) { continue ; } try { fc . doWith ( field ) ; } catch ( IllegalAccessException ex ) { throw new IllegalStateException ( STRING + field . getName ( ) + STRING + ex ) ; } } targetClass = targetClass . getSuperclass ( ) ; } while ( targetClass != null && targetClass != Object . class ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
public static void exit ( int code ) { RUNTIME . exit ( code ) ; }
@ SafeVarargs public static < T > Substitution < T > forArgs ( List < TypeVariable > parameters , T ... arguments ) { if ( parameters . size ( ) != arguments . length ) { throw new IllegalArgumentException ( STRING + parameters . size ( ) + STRING + arguments . length ) ; } Substitution < T > s = new Substitution < > ( ) ; for ( int i = _NUM ; i < parameters . size ( ) ; i ++ ) { s . put ( parameters . get ( i ) , arguments [ i ] ) ; } return s ; }
public static void createUploadDir ( Server server , String uploadDir ) throws DockerJSONException { File uploadFolder = new File ( uploadDir + STRING + server . getContainerID ( ) ) ; if ( ! uploadFolder . exists ( ) ) { uploadFolder . mkdir ( ) ; } }
private void addService ( SvcReg reg ) { serviceByID . put ( reg . item . serviceID , reg ) ; serviceByTime . put ( reg , reg ) ; addServiceByTypes ( reg . item . serviceType , reg ) ; EntryRep [ ] entries = reg . item . attributeSets ; for ( int i = entries . length ; -- i >= _NUM ; ) { addAttrs ( reg , entries [ i ] ) ; } computeMaxLeases ( ) ; }
private void addService ( SvcReg reg ) { serviceByID . put ( reg . item . serviceID , reg ) ; serviceByTime . put ( reg , reg ) ; addServiceByTypes ( reg . item . serviceType , reg ) ; EntryRep [ ] entries = reg . item . attributeSets ; for ( int i = entries . length ; -- i >= _NUM ; ) { addAttrs ( reg , entries [ i ] ) ; } computeMaxLeases ( ) ; }
private void addService ( SvcReg reg ) { serviceByID . put ( reg . item . serviceID , reg ) ; serviceByTime . put ( reg , reg ) ; addServiceByTypes ( reg . item . serviceType , reg ) ; EntryRep [ ] entries = reg . item . attributeSets ; for ( int i = entries . length ; -- i >= _NUM ; ) { addAttrs ( reg , entries [ i ] ) ; } computeMaxLeases ( ) ; }
public void removeAttribute ( String name ) { attributes . remove ( name ) ; }
public void removeAttribute ( String name ) { attributes . remove ( name ) ; }
public boolean showColorsNick ( ) { return preferences . getBoolean ( resources . getString ( R . string . key_show_colors_nick ) , Boolean . parseBoolean ( resources . getString ( R . string . default_show_colors_nick ) ) ) ; }
private void makeExcitatory ( final Neuron source , List < Synapse > syns , boolean looseSynapses ) { for ( Neuron target : getNeuronsInRadius ( source , excitatoryRadius ) ) { if ( ! sourceNeurons . contains ( target ) ) { continue ; } if ( Network . getSynapse ( source , target ) != null ) { continue ; } if ( ! allowSelfConnections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatoryProbability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . setStrength ( _NUM ) ; if ( looseSynapses ) { network . addSynapse ( synapse ) ; } syns . add ( synapse ) ; } network . fireSynapsesUpdated ( ) ; } }
private void makeExcitatory ( final Neuron source , List < Synapse > syns , boolean looseSynapses ) { for ( Neuron target : getNeuronsInRadius ( source , excitatoryRadius ) ) { if ( ! sourceNeurons . contains ( target ) ) { continue ; } if ( Network . getSynapse ( source , target ) != null ) { continue ; } if ( ! allowSelfConnections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatoryProbability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . setStrength ( _NUM ) ; if ( looseSynapses ) { network . addSynapse ( synapse ) ; } syns . add ( synapse ) ; } network . fireSynapsesUpdated ( ) ; } }
private void makeExcitatory ( final Neuron source , List < Synapse > syns , boolean looseSynapses ) { for ( Neuron target : getNeuronsInRadius ( source , excitatoryRadius ) ) { if ( ! sourceNeurons . contains ( target ) ) { continue ; } if ( Network . getSynapse ( source , target ) != null ) { continue ; } if ( ! allowSelfConnections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatoryProbability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . setStrength ( _NUM ) ; if ( looseSynapses ) { network . addSynapse ( synapse ) ; } syns . add ( synapse ) ; } network . fireSynapsesUpdated ( ) ; } }
private void makeExcitatory ( final Neuron source , List < Synapse > syns , boolean looseSynapses ) { for ( Neuron target : getNeuronsInRadius ( source , excitatoryRadius ) ) { if ( ! sourceNeurons . contains ( target ) ) { continue ; } if ( Network . getSynapse ( source , target ) != null ) { continue ; } if ( ! allowSelfConnections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatoryProbability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . setStrength ( _NUM ) ; if ( looseSynapses ) { network . addSynapse ( synapse ) ; } syns . add ( synapse ) ; } network . fireSynapsesUpdated ( ) ; } }
private void makeExcitatory ( final Neuron source , List < Synapse > syns , boolean looseSynapses ) { for ( Neuron target : getNeuronsInRadius ( source , excitatoryRadius ) ) { if ( ! sourceNeurons . contains ( target ) ) { continue ; } if ( Network . getSynapse ( source , target ) != null ) { continue ; } if ( ! allowSelfConnections ) { if ( source == target ) { continue ; } } if ( Math . random ( ) < excitatoryProbability ) { Synapse synapse = new Synapse ( source , target ) ; synapse . setStrength ( _NUM ) ; if ( looseSynapses ) { network . addSynapse ( synapse ) ; } syns . add ( synapse ) ; } network . fireSynapsesUpdated ( ) ; } }
void recomposeIncludes ( Stylesheet including ) { int n = including . getIncludeCount ( ) ; if ( n > _NUM ) { if ( null == m_includesComposed ) m_includesComposed = new Vector ( ) ; for ( int i = _NUM ; i < n ; i ++ ) { Stylesheet included = including . getInclude ( i ) ; m_includesComposed . addElement ( included ) ; recomposeIncludes ( included ) ; } } }
private String addListModel ( HashMap < String , SwaggerModel > models , Class < ? > model , String modelName ) { SwaggerModel swaggerModel = new SwaggerModel ( ) ; swaggerModel . setId ( modelName ) ; swaggerModel . setName ( modelName ) ; SwaggerModelProperty modelProperty = new SwaggerModelProperty ( ) ; modelProperty . setType ( STRING ) ; modelProperty . setRequired ( _BOOL ) ; HashMap < String , String > items = new HashMap < > ( ) ; items . put ( REFERENCE_TYPE , model . getSimpleName ( ) ) ; modelProperty . setItems ( items ) ; HashMap < String , SwaggerModelProperty > modelProperties = new HashMap ( ) ; modelProperties . put ( STRING , modelProperty ) ; swaggerModel . setProperties ( modelProperties ) ; String listModelName = String . format ( STRING , modelName , model . getSimpleName ( ) ) ; models . put ( listModelName , swaggerModel ) ; return listModelName ; }
private String addListModel ( HashMap < String , SwaggerModel > models , Class < ? > model , String modelName ) { SwaggerModel swaggerModel = new SwaggerModel ( ) ; swaggerModel . setId ( modelName ) ; swaggerModel . setName ( modelName ) ; SwaggerModelProperty modelProperty = new SwaggerModelProperty ( ) ; modelProperty . setType ( STRING ) ; modelProperty . setRequired ( _BOOL ) ; HashMap < String , String > items = new HashMap < > ( ) ; items . put ( REFERENCE_TYPE , model . getSimpleName ( ) ) ; modelProperty . setItems ( items ) ; HashMap < String , SwaggerModelProperty > modelProperties = new HashMap ( ) ; modelProperties . put ( STRING , modelProperty ) ; swaggerModel . setProperties ( modelProperties ) ; String listModelName = String . format ( STRING , modelName , model . getSimpleName ( ) ) ; models . put ( listModelName , swaggerModel ) ; return listModelName ; }
private boolean isKnownVersion ( long version ) { if ( version > currentVersion || version < _NUM ) { return _BOOL ; } if ( version == currentVersion || chunks . size ( ) == _NUM ) { return _BOOL ; } Chunk c = getChunkForVersion ( version ) ; if ( c == null ) { return _BOOL ; } MVMap < String , String > oldMeta = getMetaMap ( version ) ; if ( oldMeta == null ) { return _BOOL ; } try { for ( Iterator < String > it = oldMeta . keyIterator ( STRING ) ; it . hasNext ( ) ; ) { String chunkKey = it . next ( ) ; if ( ! chunkKey . startsWith ( STRING ) ) { break ; } if ( ! meta . containsKey ( chunkKey ) ) { String s = oldMeta . get ( chunkKey ) ; Chunk c2 = Chunk . fromString ( s ) ; Chunk test = readChunkHeaderAndFooter ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return _BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( IllegalStateException e ) { return _BOOL ; } return _BOOL ; }
private boolean isKnownVersion ( long version ) { if ( version > currentVersion || version < _NUM ) { return _BOOL ; } if ( version == currentVersion || chunks . size ( ) == _NUM ) { return _BOOL ; } Chunk c = getChunkForVersion ( version ) ; if ( c == null ) { return _BOOL ; } MVMap < String , String > oldMeta = getMetaMap ( version ) ; if ( oldMeta == null ) { return _BOOL ; } try { for ( Iterator < String > it = oldMeta . keyIterator ( STRING ) ; it . hasNext ( ) ; ) { String chunkKey = it . next ( ) ; if ( ! chunkKey . startsWith ( STRING ) ) { break ; } if ( ! meta . containsKey ( chunkKey ) ) { String s = oldMeta . get ( chunkKey ) ; Chunk c2 = Chunk . fromString ( s ) ; Chunk test = readChunkHeaderAndFooter ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return _BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( IllegalStateException e ) { return _BOOL ; } return _BOOL ; }
private boolean isKnownVersion ( long version ) { if ( version > currentVersion || version < _NUM ) { return _BOOL ; } if ( version == currentVersion || chunks . size ( ) == _NUM ) { return _BOOL ; } Chunk c = getChunkForVersion ( version ) ; if ( c == null ) { return _BOOL ; } MVMap < String , String > oldMeta = getMetaMap ( version ) ; if ( oldMeta == null ) { return _BOOL ; } try { for ( Iterator < String > it = oldMeta . keyIterator ( STRING ) ; it . hasNext ( ) ; ) { String chunkKey = it . next ( ) ; if ( ! chunkKey . startsWith ( STRING ) ) { break ; } if ( ! meta . containsKey ( chunkKey ) ) { String s = oldMeta . get ( chunkKey ) ; Chunk c2 = Chunk . fromString ( s ) ; Chunk test = readChunkHeaderAndFooter ( c2 . block ) ; if ( test == null || test . id != c2 . id ) { return _BOOL ; } chunks . put ( c2 . id , c2 ) ; } } } catch ( IllegalStateException e ) { return _BOOL ; } return _BOOL ; }
static public String formatDate ( Date d ) { if ( timeFormatter == null ) { try { return Long . toString ( d . getTime ( ) ) ; } catch ( Exception ignore ) { return STRING ; } } try { synchronized ( timeFormatter ) { return timeFormatter . format ( d ) ; } } catch ( Exception e1 ) { try { return d . toString ( ) ; } catch ( Exception e2 ) { try { return Long . toString ( d . getTime ( ) ) ; } catch ( Exception e3 ) { return STRING ; } } } }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = Math . max ( pos + _NUM , mKeys . length * _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = Math . max ( pos + _NUM , mKeys . length * _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mGarbage && mSize >= mKeys . length ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = Math . max ( pos + _NUM , mKeys . length * _NUM ) ; int [ ] nkeys = new int [ n ] ; Object [ ] nvalues = new Object [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = value ; mSize = pos + _NUM ; }
void registerLocalSymbol ( String sourceFile , String fullLocalName , String requiredNamespace , String localName ) { valueRewrite . put ( sourceFile , fullLocalName , localName ) ; typeRewrite . put ( sourceFile , fullLocalName , localName ) ; typeRewrite . put ( sourceFile , requiredNamespace , localName ) ; }
void add ( int n ) { if ( v == null ) { v = new int [ INIT_SIZE ] ; v [ _NUM ] = n ; len = _NUM ; return ; } if ( len == v . length ) { int [ ] newv = new int [ len * _NUM ] ; System . arraycopy ( v , _NUM , newv , _NUM , len ) ; v = newv ; } if ( n > v [ len - _NUM ] ) { v [ len ++ ] = n ; return ; } int i = _NUM ; for ( ; i < len ; i ++ ) { if ( n <= v [ i ] ) { if ( n == v [ i ] ) return ; break ; } } for ( int j = len ; j >= i ; j -- ) v [ j + _NUM ] = v [ j ] ; v [ i ] = n ; ++ len ; }
public static String deserializeString ( byte [ ] buffer , MutableInt offset ) { int length = deserializeInt ( buffer , offset ) ; String val = new String ( buffer , offset . intValue ( ) , length ) ; offset . add ( length ) ; return val ; }
public static boolean beenDone ( @ Scope int scope , String tag , CountChecker numberOfTimes ) { List < Long > tagSeenDates = tagLastSeenMap . get ( tag ) ; if ( tagSeenDates . isEmpty ( ) ) { return _BOOL ; } if ( scope == THIS_APP_INSTALL ) { return numberOfTimes . check ( tagSeenDates . size ( ) ) ; } else if ( scope == THIS_APP_SESSION ) { int counter = _NUM ; for ( String tagFromList : sessionList ) { if ( tagFromList . equals ( tag ) ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } else { int counter = _NUM ; for ( Long seenDate : tagSeenDates ) { if ( seenDate > lastAppUpdatedTime ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } }
public static boolean beenDone ( @ Scope int scope , String tag , CountChecker numberOfTimes ) { List < Long > tagSeenDates = tagLastSeenMap . get ( tag ) ; if ( tagSeenDates . isEmpty ( ) ) { return _BOOL ; } if ( scope == THIS_APP_INSTALL ) { return numberOfTimes . check ( tagSeenDates . size ( ) ) ; } else if ( scope == THIS_APP_SESSION ) { int counter = _NUM ; for ( String tagFromList : sessionList ) { if ( tagFromList . equals ( tag ) ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } else { int counter = _NUM ; for ( Long seenDate : tagSeenDates ) { if ( seenDate > lastAppUpdatedTime ) { counter ++ ; } } return numberOfTimes . check ( counter ) ; } }
public static < K , V > ConcurrentMap < K , V > newConcurrentMapWithAggressiveConcurrency ( ) { return new ConcurrentHashMap < > ( _NUM , _NUM , aggressiveConcurrencyLevel ) ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public boolean updateStatsAndReturnWhetherAllowed ( ) { long now = SystemClock . elapsedRealtime ( ) ; long deltaMs = now - mLastRequestMs ; if ( deltaMs < mDelayMs ) return _BOOL ; mLastRequestMs = now ; if ( deltaMs < _NUM * mDelayMs ) { mDelayMs = Math . min ( MAX_DELAY , mDelayMs * _NUM ) ; } else { mDelayMs = MIN_DELAY ; } return _BOOL ; }
public void addUINodes ( Node ... nodes ) { for ( Node node : nodes ) addUINode ( node ) ; }
private double [ ] [ ] determineBasis ( double [ ] alpha ) { final int dim = alpha . length ; double [ ] nn = new double [ dim + _NUM ] ; for ( int i = _NUM ; i < nn . length ; i ++ ) { double alpha_i = i == alpha . length ? _NUM : alpha [ i ] ; nn [ i ] = sinusProduct ( _NUM , i , alpha ) * StrictMath . cos ( alpha_i ) ; } timesEquals ( nn , _NUM / euclideanLength ( nn ) ) ; double [ ] [ ] basis = new double [ dim ] [ ] ; int found = _NUM ; for ( int i = _NUM ; i < nn . length && found < dim ; i ++ ) { final double [ ] e_i = new double [ nn . length ] ; e_i [ i ] = _NUM ; minusTimesEquals ( e_i , nn , scalarProduct ( e_i , nn ) ) ; double len = euclideanLength ( e_i ) ; for ( int j = _NUM ; j < found ; j ++ ) { if ( len < _NUM ) { break ; } minusTimesEquals ( e_i , basis [ j ] , scalarProduct ( e_i , basis [ j ] ) ) ; len = euclideanLength ( e_i ) ; } if ( len < _NUM ) { continue ; } timesEquals ( e_i , _NUM / len ) ; basis [ found ++ ] = e_i ; } if ( found < dim ) { for ( int i = found ; i < dim ; i ++ ) { basis [ i ] = new double [ nn . length ] ; } } return transpose ( basis ) ; }
private double [ ] [ ] determineBasis ( double [ ] alpha ) { final int dim = alpha . length ; double [ ] nn = new double [ dim + _NUM ] ; for ( int i = _NUM ; i < nn . length ; i ++ ) { double alpha_i = i == alpha . length ? _NUM : alpha [ i ] ; nn [ i ] = sinusProduct ( _NUM , i , alpha ) * StrictMath . cos ( alpha_i ) ; } timesEquals ( nn , _NUM / euclideanLength ( nn ) ) ; double [ ] [ ] basis = new double [ dim ] [ ] ; int found = _NUM ; for ( int i = _NUM ; i < nn . length && found < dim ; i ++ ) { final double [ ] e_i = new double [ nn . length ] ; e_i [ i ] = _NUM ; minusTimesEquals ( e_i , nn , scalarProduct ( e_i , nn ) ) ; double len = euclideanLength ( e_i ) ; for ( int j = _NUM ; j < found ; j ++ ) { if ( len < _NUM ) { break ; } minusTimesEquals ( e_i , basis [ j ] , scalarProduct ( e_i , basis [ j ] ) ) ; len = euclideanLength ( e_i ) ; } if ( len < _NUM ) { continue ; } timesEquals ( e_i , _NUM / len ) ; basis [ found ++ ] = e_i ; } if ( found < dim ) { for ( int i = found ; i < dim ; i ++ ) { basis [ i ] = new double [ nn . length ] ; } } return transpose ( basis ) ; }
@ Override public boolean status ( ) { return opened ; }
protected AbstractSkeleton ( Class apiClass ) { _apiClass = apiClass ; Method [ ] methodList = apiClass . getMethods ( ) ; for ( int i = _NUM ; i < methodList . length ; i ++ ) { Method method = methodList [ i ] ; if ( _methodMap . get ( method . getName ( ) ) == null ) _methodMap . put ( method . getName ( ) , methodList [ i ] ) ; Class [ ] param = method . getParameterTypes ( ) ; String mangledName = method . getName ( ) + STRING + param . length ; _methodMap . put ( mangledName , methodList [ i ] ) ; _methodMap . put ( mangleName ( method , _BOOL ) , methodList [ i ] ) ; } }
private JMenu createFileMenu ( ) { JMenu fileMenu = new JMenu ( STRING ) ; fileMenu . addMenuListener ( menuListener ) ; for ( Action action : actionManager . getOpenSaveWorkspaceActions ( ) ) { fileMenu . add ( action ) ; } fileMenu . addSeparator ( ) ; fileMenu . add ( actionManager . getClearWorkspaceAction ( ) ) ; fileMenu . addSeparator ( ) ; fileMenu . add ( actionManager . getOpenNetworkAction ( ) ) ; JMenu worldSubMenu = new JMenu ( STRING ) ; for ( Action action : actionManager . getOpenWorldActions ( ) ) { worldSubMenu . add ( action ) ; } fileMenu . add ( worldSubMenu ) ; fileMenu . addSeparator ( ) ; fileMenu . add ( actionManager . getShowUpdaterDialog ( ) ) ; fileMenu . add ( actionManager . getShowPropertyDialogAction ( ) ) ; fileMenu . addSeparator ( ) ; fileMenu . add ( actionManager . getQuitWorkspaceAction ( ) ) ; return fileMenu ; }
public static boolean hasTokenInformation ( Bundle bundle ) { if ( bundle == null ) { return _BOOL ; } String token = bundle . getString ( TOKEN_KEY ) ; if ( ( token == null ) || ( token . length ( ) == _NUM ) ) { return _BOOL ; } long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , _NUM ) ; if ( expiresMilliseconds == _NUM ) { return _BOOL ; } return _BOOL ; }
public static boolean hasTokenInformation ( Bundle bundle ) { if ( bundle == null ) { return _BOOL ; } String token = bundle . getString ( TOKEN_KEY ) ; if ( ( token == null ) || ( token . length ( ) == _NUM ) ) { return _BOOL ; } long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , _NUM ) ; if ( expiresMilliseconds == _NUM ) { return _BOOL ; } return _BOOL ; }
public static boolean hasTokenInformation ( Bundle bundle ) { if ( bundle == null ) { return _BOOL ; } String token = bundle . getString ( TOKEN_KEY ) ; if ( ( token == null ) || ( token . length ( ) == _NUM ) ) { return _BOOL ; } long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , _NUM ) ; if ( expiresMilliseconds == _NUM ) { return _BOOL ; } return _BOOL ; }
public static boolean hasTokenInformation ( Bundle bundle ) { if ( bundle == null ) { return _BOOL ; } String token = bundle . getString ( TOKEN_KEY ) ; if ( ( token == null ) || ( token . length ( ) == _NUM ) ) { return _BOOL ; } long expiresMilliseconds = bundle . getLong ( EXPIRATION_DATE_KEY , _NUM ) ; if ( expiresMilliseconds == _NUM ) { return _BOOL ; } return _BOOL ; }
public void addEdge ( Dependency dependency ) { if ( ! edges . contains ( dependency ) ) { edges . add ( dependency ) ; Set < Dependency > outboundEdges = vertices . get ( dependency . getDepender ( ) ) ; if ( outboundEdges == null ) { outboundEdges = new HashSet ( ) ; vertices . put ( dependency . getDepender ( ) , outboundEdges ) ; } outboundEdges . add ( dependency ) ; if ( vertices . get ( dependency . getDependsOn ( ) ) == null ) { vertices . put ( dependency . getDependsOn ( ) , new HashSet ( ) ) ; } } }
public org . w3c . dom . Element signXML ( org . w3c . dom . Document doc , java . lang . String certAlias , java . lang . String algorithm , java . lang . String id ) throws XMLSignatureException { return signXML ( doc , certAlias , algorithm , DEF_ID_ATTRIBUTE , id , _BOOL , null ) ; }
private int adjustColumn ( int row , int col ) { if ( col < _NUM ) { return _NUM ; } if ( row == getRowCount ( ) - _NUM ) { int lastRowCount = model . getByteCount ( ) % _NUM ; if ( lastRowCount == _NUM ) { lastRowCount = _NUM ; } if ( lastRowCount < _NUM ) { return Math . min ( col , ( model . getByteCount ( ) % _NUM ) - _NUM ) ; } } return Math . min ( col , getColumnCount ( ) - _NUM - _NUM ) ; }
private int adjustColumn ( int row , int col ) { if ( col < _NUM ) { return _NUM ; } if ( row == getRowCount ( ) - _NUM ) { int lastRowCount = model . getByteCount ( ) % _NUM ; if ( lastRowCount == _NUM ) { lastRowCount = _NUM ; } if ( lastRowCount < _NUM ) { return Math . min ( col , ( model . getByteCount ( ) % _NUM ) - _NUM ) ; } } return Math . min ( col , getColumnCount ( ) - _NUM - _NUM ) ; }
private int adjustColumn ( int row , int col ) { if ( col < _NUM ) { return _NUM ; } if ( row == getRowCount ( ) - _NUM ) { int lastRowCount = model . getByteCount ( ) % _NUM ; if ( lastRowCount == _NUM ) { lastRowCount = _NUM ; } if ( lastRowCount < _NUM ) { return Math . min ( col , ( model . getByteCount ( ) % _NUM ) - _NUM ) ; } } return Math . min ( col , getColumnCount ( ) - _NUM - _NUM ) ; }
public void addTerm ( SplitCondition condition ) { terms . add ( condition ) ; }
@ Override public double valueToJava2D ( double value , Rectangle2D dataArea , RectangleEdge edge ) { Range range = getRange ( ) ; double vmin = range . getLowerBound ( ) ; double vmax = range . getUpperBound ( ) ; double vp = getCycleBound ( ) ; if ( ( value < vmin ) || ( value > vmax ) ) { return Double . NaN ; } double jmin = _NUM ; double jmax = _NUM ; if ( RectangleEdge . isTopOrBottom ( edge ) ) { jmin = dataArea . getMinX ( ) ; jmax = dataArea . getMaxX ( ) ; } else if ( RectangleEdge . isLeftOrRight ( edge ) ) { jmax = dataArea . getMinY ( ) ; jmin = dataArea . getMaxY ( ) ; } if ( isInverted ( ) ) { if ( value == vp ) { return this . boundMappedToLastCycle ? jmin : jmax ; } else if ( value > vp ) { return jmax - ( value - vp ) * ( jmax - jmin ) / this . period ; } else { return jmin + ( vp - value ) * ( jmax - jmin ) / this . period ; } } else { if ( value == vp ) { return this . boundMappedToLastCycle ? jmax : jmin ; } else if ( value >= vp ) { return jmin + ( value - vp ) * ( jmax - jmin ) / this . period ; } else { return jmax - ( vp - value ) * ( jmax - jmin ) / this . period ; } } }
public static String hex ( byte b ) { return String . format ( STRING , b ) ; }
public static String hex ( byte b ) { return String . format ( STRING , b ) ; }
public static String removeTrailingZeros ( final String str ) { String result = str ; if ( str != null && str . length ( ) != _NUM ) { int endIndex = str . length ( ) ; while ( endIndex > _NUM ) { final char ch = str . charAt ( endIndex - _NUM ) ; if ( ch != STRING ) { break ; } endIndex -- ; } if ( endIndex < str . length ( ) ) { result = str . substring ( _NUM , endIndex ) ; } } return result ; }
public static boolean isXMLNameNS ( String name ) { if ( name . length ( ) > _NUM && ( ! isNameStartChar ( name . charAt ( _NUM ) ) || name . charAt ( _NUM ) == STRING ) ) { return _BOOL ; } for ( int i = _NUM ; i < name . length ( ) ; i ++ ) { if ( ! isNameChar ( name . charAt ( i ) ) || name . charAt ( i ) == STRING ) { return _BOOL ; } } return _BOOL ; }
public static boolean isXMLNameNS ( String name ) { if ( name . length ( ) > _NUM && ( ! isNameStartChar ( name . charAt ( _NUM ) ) || name . charAt ( _NUM ) == STRING ) ) { return _BOOL ; } for ( int i = _NUM ; i < name . length ( ) ; i ++ ) { if ( ! isNameChar ( name . charAt ( i ) ) || name . charAt ( i ) == STRING ) { return _BOOL ; } } return _BOOL ; }
public static boolean isXMLNameNS ( String name ) { if ( name . length ( ) > _NUM && ( ! isNameStartChar ( name . charAt ( _NUM ) ) || name . charAt ( _NUM ) == STRING ) ) { return _BOOL ; } for ( int i = _NUM ; i < name . length ( ) ; i ++ ) { if ( ! isNameChar ( name . charAt ( i ) ) || name . charAt ( i ) == STRING ) { return _BOOL ; } } return _BOOL ; }
@ SuppressWarnings ( STRING ) public List < V > values ( ) { int found = _NUM ; ArrayList < V > result = new ArrayList < V > ( m_size ) ; for ( OsmElement v : m_data ) { if ( v != FREE_KEY && v != removedKey ) { result . add ( ( V ) v ) ; found ++ ; if ( found >= m_size ) { break ; } } } return result ; }
public int scheduledQueueSize ( ) { return schedulerQueueSize . get ( ) ; }
private void adjustForRightFadingEdge ( View childInSelectedRow , int leftSelectionPixel , int rightSelectionPixel ) { if ( childInSelectedRow . getRight ( ) > rightSelectionPixel ) { int spaceToLeft = childInSelectedRow . getLeft ( ) - leftSelectionPixel ; int spaceToRight = childInSelectedRow . getRight ( ) - rightSelectionPixel ; int offset = Math . min ( spaceToLeft , spaceToRight ) ; offsetChildrenLeftAndRight ( - offset ) ; } }
private void adjustForRightFadingEdge ( View childInSelectedRow , int leftSelectionPixel , int rightSelectionPixel ) { if ( childInSelectedRow . getRight ( ) > rightSelectionPixel ) { int spaceToLeft = childInSelectedRow . getLeft ( ) - leftSelectionPixel ; int spaceToRight = childInSelectedRow . getRight ( ) - rightSelectionPixel ; int offset = Math . min ( spaceToLeft , spaceToRight ) ; offsetChildrenLeftAndRight ( - offset ) ; } }
private void adjustForRightFadingEdge ( View childInSelectedRow , int leftSelectionPixel , int rightSelectionPixel ) { if ( childInSelectedRow . getRight ( ) > rightSelectionPixel ) { int spaceToLeft = childInSelectedRow . getLeft ( ) - leftSelectionPixel ; int spaceToRight = childInSelectedRow . getRight ( ) - rightSelectionPixel ; int offset = Math . min ( spaceToLeft , spaceToRight ) ; offsetChildrenLeftAndRight ( - offset ) ; } }
private void adjustForRightFadingEdge ( View childInSelectedRow , int leftSelectionPixel , int rightSelectionPixel ) { if ( childInSelectedRow . getRight ( ) > rightSelectionPixel ) { int spaceToLeft = childInSelectedRow . getLeft ( ) - leftSelectionPixel ; int spaceToRight = childInSelectedRow . getRight ( ) - rightSelectionPixel ; int offset = Math . min ( spaceToLeft , spaceToRight ) ; offsetChildrenLeftAndRight ( - offset ) ; } }
private void adjustForRightFadingEdge ( View childInSelectedRow , int leftSelectionPixel , int rightSelectionPixel ) { if ( childInSelectedRow . getRight ( ) > rightSelectionPixel ) { int spaceToLeft = childInSelectedRow . getLeft ( ) - leftSelectionPixel ; int spaceToRight = childInSelectedRow . getRight ( ) - rightSelectionPixel ; int offset = Math . min ( spaceToLeft , spaceToRight ) ; offsetChildrenLeftAndRight ( - offset ) ; } }
public void doneWithInvalidResponse ( InvalidResponseException e ) { lock . lock ( ) ; try { illegalResponseException = e ; condition . signal ( ) ; } finally { lock . unlock ( ) ; } }
public void addCharOption ( LocalizableMessage c , LocalizableMessage description , MenuCallback < T > callback ) { charKeys . add ( c ) ; charSynopsis . add ( description ) ; charCallbacks . add ( callback ) ; }
public void edit ( File file ) throws IOException { checkAWTPermission ( ) ; checkExec ( ) ; checkActionSupport ( Action . EDIT ) ; file . canWrite ( ) ; checkFileValidation ( file ) ; peer . edit ( file ) ; }
public void edit ( File file ) throws IOException { checkAWTPermission ( ) ; checkExec ( ) ; checkActionSupport ( Action . EDIT ) ; file . canWrite ( ) ; checkFileValidation ( file ) ; peer . edit ( file ) ; }
@ Override public void endDocument ( ) throws SAXException { writeText4Links ( ) ; write ( STRING ) ; super . endDocument ( ) ; try { flush ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
@ Override public void endDocument ( ) throws SAXException { writeText4Links ( ) ; write ( STRING ) ; super . endDocument ( ) ; try { flush ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
@ Override public void endDocument ( ) throws SAXException { writeText4Links ( ) ; write ( STRING ) ; super . endDocument ( ) ; try { flush ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
@ Override public void endDocument ( ) throws SAXException { writeText4Links ( ) ; write ( STRING ) ; super . endDocument ( ) ; try { flush ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
@ Override public void endDocument ( ) throws SAXException { writeText4Links ( ) ; write ( STRING ) ; super . endDocument ( ) ; try { flush ( ) ; } catch ( IOException e ) { throw new SAXException ( e ) ; } }
private static final Set < File > encode ( String src ) { if ( src == null || src . length ( ) == _NUM ) return new HashSet < File > ( ) ; StringTokenizer tokenizer = new StringTokenizer ( src , STRING ) ; int size = tokenizer . countTokens ( ) ; Set < File > set = new HashSet < File > ( ) ; for ( int i = _NUM ; i < size ; i ++ ) set . add ( new File ( tokenizer . nextToken ( ) ) ) ; return set ; }
private void scrollToPosition ( final long position ) { m_scrollbar . setValue ( ( int ) position / ( _NUM * m_bytesPerRow ) ) ; }
private void scrollToPosition ( final long position ) { m_scrollbar . setValue ( ( int ) position / ( _NUM * m_bytesPerRow ) ) ; }
protected String toValString ( Enumeration en ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = _BOOL ; while ( en . hasMoreElements ( ) ) { String val = ( String ) en . nextElement ( ) ; val = encodeVal ( val ) ; if ( first ) { first = _BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . toString ( ) ; }
protected String toValString ( Enumeration en ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = _BOOL ; while ( en . hasMoreElements ( ) ) { String val = ( String ) en . nextElement ( ) ; val = encodeVal ( val ) ; if ( first ) { first = _BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . toString ( ) ; }
protected String toValString ( Enumeration en ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = _BOOL ; while ( en . hasMoreElements ( ) ) { String val = ( String ) en . nextElement ( ) ; val = encodeVal ( val ) ; if ( first ) { first = _BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . toString ( ) ; }
protected String toValString ( Enumeration en ) { StringBuilder sb = new StringBuilder ( ) ; boolean first = _BOOL ; while ( en . hasMoreElements ( ) ) { String val = ( String ) en . nextElement ( ) ; val = encodeVal ( val ) ; if ( first ) { first = _BOOL ; } else { sb . append ( STRING ) ; } sb . append ( val ) ; } return sb . toString ( ) ; }
public ExtensionForcedUser ( ) { super ( ) ; initialize ( ) ; }
public void addNode ( EvalFactoryNode node ) { activeNodes . add ( node ) ; }
public static void appendLengthAndMask ( ByteBuffer buffer , int length , byte mask [ ] ) { if ( mask != null ) { appendLength ( buffer , length , _BOOL ) ; buffer . put ( mask ) ; } else { appendLength ( buffer , length , _BOOL ) ; } }
public boolean checkColumnNameEquality ( String fromSchema , String specified ) { if ( fromSchema . equals ( specified ) ) { return _BOOL ; } if ( fromSchema . contains ( STRING ) ) { String [ ] splits = fromSchema . split ( STRING ) ; String schemaColName = splits [ _NUM ] ; return schemaColName . equals ( specified ) ; } return _BOOL ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
protected int decodeLinePrefix ( PushbackInputStream aStream , OutputStream bStream ) throws IOException { return ( bytesPerLine ( ) ) ; }
public static String timestamp ( DateTime ts ) { return Long . toString ( ts . getMillis ( ) / _NUM ) ; }
private void writeFile ( File file , byte [ ] input , CompressionMode mode ) throws IOException { try ( OutputStream os = getOutputStreamForMode ( mode , new FileOutputStream ( file ) ) ) { os . write ( input ) ; } }
public static void main ( String [ ] args ) { final File pathToThisJar = new File ( findPathTo ( CheckerMain . class , _BOOL ) ) ; ArrayList < String > alargs = new ArrayList < > ( args . length ) ; alargs . addAll ( Arrays . asList ( args ) ) ; final CheckerMain program = new CheckerMain ( pathToThisJar , alargs ) ; final int exitStatus = program . invokeCompiler ( ) ; System . exit ( exitStatus ) ; }
public Builder deleteProfileUrl ( ) { deleteFields . add ( STRING ) ; return this ; }
public String decode ( String pString , String charset ) throws DecoderException , UnsupportedEncodingException { if ( pString == null ) { return null ; } return new String ( decode ( pString . getBytes ( StringEncodings . US_ASCII ) ) , charset ) ; }
public Response newFixedLengthResponse ( String msg ) { return newFixedLengthResponse ( Response . Status . OK , NanoHTTPD . MIME_HTML , msg ) ; }
public void removeSrcClass ( SootClass clz ) { srcClasses . remove ( clz . getName ( ) ) ; }
static public void assertRightAligned ( View first , View second , int margin ) { int [ ] xy = new int [ _NUM ] ; first . getLocationOnScreen ( xy ) ; int firstRight = xy [ _NUM ] + first . getMeasuredWidth ( ) ; second . getLocationOnScreen ( xy ) ; int secondRight = xy [ _NUM ] + second . getMeasuredWidth ( ) ; assertEquals ( STRING , Math . abs ( firstRight - secondRight ) , margin ) ; }
public static void enumerateResources ( VerificationHost host , boolean isMock , String resourcePoolLink , String computeHostLinkDescription , String computeHostLink , String testCase ) throws Throwable { enumerateResources ( host , null , isMock ? EnumSet . of ( TaskOption . IS_MOCK ) : null , resourcePoolLink , computeHostLinkDescription , computeHostLink , testCase , null ) ; }
public static void enumerateResources ( VerificationHost host , boolean isMock , String resourcePoolLink , String computeHostLinkDescription , String computeHostLink , String testCase ) throws Throwable { enumerateResources ( host , null , isMock ? EnumSet . of ( TaskOption . IS_MOCK ) : null , resourcePoolLink , computeHostLinkDescription , computeHostLink , testCase , null ) ; }
public URIName ( String name ) throws IOException { try { uri = new URI ( name ) ; } catch ( URISyntaxException use ) { throw new IOException ( STRING + name , use ) ; } if ( uri . getScheme ( ) == null ) { throw new IOException ( STRING + name ) ; } host = uri . getHost ( ) ; if ( host != null ) { if ( host . charAt ( _NUM ) == STRING ) { String ipV6Host = host . substring ( _NUM , host . length ( ) - _NUM ) ; try { hostIP = new IPAddressName ( ipV6Host ) ; } catch ( IOException ioe ) { throw new IOException ( STRING + STRING + name ) ; } } else { try { hostDNS = new DNSName ( host ) ; } catch ( IOException ioe ) { try { hostIP = new IPAddressName ( host ) ; } catch ( Exception ioe2 ) { throw new IOException ( STRING + STRING + STRING + name ) ; } } } } }
public static Director newProject ( ) { return newProject ( _BOOL ) ; }
public static String convertSystemNameToAlternate ( String systemName ) { if ( ! validSystemNameFormat ( systemName , systemName . charAt ( _NUM ) , STRING ) ) { return STRING ; } String altName = STRING ; altName = systemName ; return altName ; }
public static String convertSystemNameToAlternate ( String systemName ) { if ( ! validSystemNameFormat ( systemName , systemName . charAt ( _NUM ) , STRING ) ) { return STRING ; } String altName = STRING ; altName = systemName ; return altName ; }
public static String convertSystemNameToAlternate ( String systemName ) { if ( ! validSystemNameFormat ( systemName , systemName . charAt ( _NUM ) , STRING ) ) { return STRING ; } String altName = STRING ; altName = systemName ; return altName ; }
protected void update ( OMGraphicList list , Projection proj ) { BufferedImage currentImageBuffer = null ; if ( proj != null && layer != null ) { int w = proj . getWidth ( ) ; int h = proj . getHeight ( ) ; currentImageBuffer = getImageBuffer ( ) ; BufferedImage bufferedImage = scrubOrGetNewBufferedImage ( currentImageBuffer , w , h ) ; if ( bufferedImage != null ) { if ( currentImageBuffer != null ) { currentImageBuffer . flush ( ) ; } currentImageBuffer = bufferedImage ; } Graphics2D g2d = ( Graphics2D ) currentImageBuffer . getGraphics ( ) ; setRenderingHints ( g2d ) ; if ( list != null ) { list . render ( g2d ) ; } g2d . dispose ( ) ; setImageRaster ( updateRaster ( currentImageBuffer , proj ) ) ; } setImageBuffer ( currentImageBuffer ) ; currentProjection = proj ; }
public JValueSlider ( String title , Number min , Number max , Number value ) { m_min = min ; m_max = max ; m_value = value ; m_slider = new JSlider ( ) ; m_label = new JLabel ( title ) ; m_field = new JTextField ( ) ; m_listeners = new ArrayList ( ) ; m_field . setBorder ( null ) ; setSliderValue ( ) ; setFieldValue ( ) ; initUI ( ) ; }
public ScaleIOSnapshotVolumeResponse snapshotMultiVolume ( Map < String , String > id2snapshot , String systemId ) throws Exception { String uri = ScaleIOConstants . getSnapshotVolumesURI ( systemId ) ; ScaleIOSnapshotVolumes spVol = new ScaleIOSnapshotVolumes ( ) ; for ( Map . Entry < String , String > entry : id2snapshot . entrySet ( ) ) { spVol . addSnapshot ( entry . getKey ( ) , entry . getValue ( ) ) ; } ClientResponse response = post ( URI . create ( uri ) , getJsonForEntity ( spVol ) ) ; return getResponseObject ( ScaleIOSnapshotVolumeResponse . class , response ) ; }
public ScaleIOSnapshotVolumeResponse snapshotMultiVolume ( Map < String , String > id2snapshot , String systemId ) throws Exception { String uri = ScaleIOConstants . getSnapshotVolumesURI ( systemId ) ; ScaleIOSnapshotVolumes spVol = new ScaleIOSnapshotVolumes ( ) ; for ( Map . Entry < String , String > entry : id2snapshot . entrySet ( ) ) { spVol . addSnapshot ( entry . getKey ( ) , entry . getValue ( ) ) ; } ClientResponse response = post ( URI . create ( uri ) , getJsonForEntity ( spVol ) ) ; return getResponseObject ( ScaleIOSnapshotVolumeResponse . class , response ) ; }
private void extractProtoSources ( Set < String > extracted , String protoFile ) { if ( ! extracted . add ( protoFile ) ) { return ; } String content = copyTestData ( protoFile ) ; Matcher matcher = PROTO_IMPORT_PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extractProtoSources ( extracted , matcher . group ( _NUM ) ) ; } }
private void extractProtoSources ( Set < String > extracted , String protoFile ) { if ( ! extracted . add ( protoFile ) ) { return ; } String content = copyTestData ( protoFile ) ; Matcher matcher = PROTO_IMPORT_PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extractProtoSources ( extracted , matcher . group ( _NUM ) ) ; } }
private void extractProtoSources ( Set < String > extracted , String protoFile ) { if ( ! extracted . add ( protoFile ) ) { return ; } String content = copyTestData ( protoFile ) ; Matcher matcher = PROTO_IMPORT_PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extractProtoSources ( extracted , matcher . group ( _NUM ) ) ; } }
private void extractProtoSources ( Set < String > extracted , String protoFile ) { if ( ! extracted . add ( protoFile ) ) { return ; } String content = copyTestData ( protoFile ) ; Matcher matcher = PROTO_IMPORT_PATTERN . matcher ( content ) ; while ( matcher . find ( ) ) { extractProtoSources ( extracted , matcher . group ( _NUM ) ) ; } }
public DPolicyConstraints ( JDialog parent ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; initComponents ( ) ; }
private static void dumpConfigurationProperties ( InstallLog installLog , Map < String , Object > properties ) { SortedMap < String , Object > sortedProperties = new TreeMap < String , Object > ( String . CASE_INSENSITIVE_ORDER ) ; sortedProperties . putAll ( properties ) ; for ( String key : sortedProperties . keySet ( ) ) { if ( CONFIG_ITEMS_TO_HASH_LIST . contains ( key ) ) { installLog . write ( key + STRING + STRING ) ; } else { installLog . write ( key + STRING + sortedProperties . get ( key ) + STRING ) ; } } }
private static void dumpConfigurationProperties ( InstallLog installLog , Map < String , Object > properties ) { SortedMap < String , Object > sortedProperties = new TreeMap < String , Object > ( String . CASE_INSENSITIVE_ORDER ) ; sortedProperties . putAll ( properties ) ; for ( String key : sortedProperties . keySet ( ) ) { if ( CONFIG_ITEMS_TO_HASH_LIST . contains ( key ) ) { installLog . write ( key + STRING + STRING ) ; } else { installLog . write ( key + STRING + sortedProperties . get ( key ) + STRING ) ; } } }
@ Override public void mousePressed ( MouseEvent e ) { if ( e . getClickCount ( ) == _NUM && SwingUtilities . isLeftMouseButton ( e ) ) { String url = getUrl ( e ) ; if ( url != null && ! isUrlDeleted ( e ) ) { if ( linkListener != null ) { linkListener . linkClicked ( url ) ; } return ; } User user = getUser ( e ) ; if ( user != null ) { for ( UserListener listener : userListener ) { listener . userClicked ( user , e ) ; } return ; } EmoticonImage emote = getEmoticon ( e ) ; if ( emote != null ) { for ( UserListener listener : userListener ) { listener . emoteClicked ( emote . getEmoticon ( ) , e ) ; } return ; } Usericon usericon = getUsericon ( e ) ; if ( usericon != null ) { for ( UserListener listener : userListener ) { listener . usericonClicked ( usericon , e ) ; } } } else if ( e . isPopupTrigger ( ) ) { openContextMenu ( e ) ; } }
@ Override public void mousePressed ( MouseEvent e ) { if ( e . getClickCount ( ) == _NUM && SwingUtilities . isLeftMouseButton ( e ) ) { String url = getUrl ( e ) ; if ( url != null && ! isUrlDeleted ( e ) ) { if ( linkListener != null ) { linkListener . linkClicked ( url ) ; } return ; } User user = getUser ( e ) ; if ( user != null ) { for ( UserListener listener : userListener ) { listener . userClicked ( user , e ) ; } return ; } EmoticonImage emote = getEmoticon ( e ) ; if ( emote != null ) { for ( UserListener listener : userListener ) { listener . emoteClicked ( emote . getEmoticon ( ) , e ) ; } return ; } Usericon usericon = getUsericon ( e ) ; if ( usericon != null ) { for ( UserListener listener : userListener ) { listener . usericonClicked ( usericon , e ) ; } } } else if ( e . isPopupTrigger ( ) ) { openContextMenu ( e ) ; } }
public boolean isBlacklisted ( String name ) { if ( getBlacklistEnabled ( ) == _BOOL ) { return _BOOL ; } return isOnList ( blacklist , name ) ; }
public synchronized void clear ( ) { int i ; int len = password . length ; for ( i = _NUM ; i < len ; i ++ ) { password [ i ] = _NUM ; } cleared = _BOOL ; }
public synchronized void clear ( ) { int i ; int len = password . length ; for ( i = _NUM ; i < len ; i ++ ) { password [ i ] = _NUM ; } cleared = _BOOL ; }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
protected void bflash_ws ( ) throws SAXException { if ( mBuffIdx >= _NUM ) { mHandCont . characters ( mBuff , _NUM , ( mBuffIdx + _NUM ) ) ; mBuffIdx = - _NUM ; } }
public ComboBoxCellRenderer ( JComboBox < String > comboBox ) { this . combo = new JComboBox < String > ( ) ; for ( int i = _NUM ; i < comboBox . getItemCount ( ) ; i ++ ) { combo . addItem ( comboBox . getItemAt ( i ) ) ; } }
private void checkAndCreateDirectory ( final String directoryName ) { try { final File dir = new File ( directoryName ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { _logger . debug ( STRING ) ; } } catch ( Exception ex ) { _logger . error ( STRING , ex . getMessage ( ) ) ; } }
private void checkAndCreateDirectory ( final String directoryName ) { try { final File dir = new File ( directoryName ) ; if ( ! dir . exists ( ) && dir . mkdirs ( ) ) { _logger . debug ( STRING ) ; } } catch ( Exception ex ) { _logger . error ( STRING , ex . getMessage ( ) ) ; } }
protected static int createSerialNumber ( ) { return serialNumberSequencer . incrementAndGet ( ) ; }
protected static int createSerialNumber ( ) { return serialNumberSequencer . incrementAndGet ( ) ; }
private void calcCurrentItem ( ) { int pointerAngle = ( mCurrentItemAngle + _NUM + mPieRotation ) % _NUM ; for ( int i = _NUM ; i < mData . size ( ) ; ++ i ) { Item it = mData . get ( i ) ; if ( it . mStartAngle <= pointerAngle && pointerAngle <= it . mEndAngle ) { if ( i != mCurrentItem ) { setCurrentItem ( i , _BOOL ) ; } break ; } } }
private void checkPostsDisplayOnRecyclerView ( List < Shot > shotsToCheck , int position ) { int columnCount = _NUM ; int size = shotsToCheck . size ( ) + position ; int pos = _NUM ; for ( int i = position ; i < size ; i ++ ) { checkItemAtPosition ( i , shotsToCheck . get ( pos ) ) ; if ( ( ( i + _NUM ) % columnCount ) == _NUM ) { int nextRowStart = i + columnCount ; int nextRowEnd = nextRowStart - columnCount + _NUM ; for ( int n = nextRowStart ; n >= nextRowEnd ; n -- ) { checkItemAtPosition ( n , shotsToCheck . get ( n - position ) ) ; } i = i + columnCount ; } pos ++ ; } }
private void checkPostsDisplayOnRecyclerView ( List < Shot > shotsToCheck , int position ) { int columnCount = _NUM ; int size = shotsToCheck . size ( ) + position ; int pos = _NUM ; for ( int i = position ; i < size ; i ++ ) { checkItemAtPosition ( i , shotsToCheck . get ( pos ) ) ; if ( ( ( i + _NUM ) % columnCount ) == _NUM ) { int nextRowStart = i + columnCount ; int nextRowEnd = nextRowStart - columnCount + _NUM ; for ( int n = nextRowStart ; n >= nextRowEnd ; n -- ) { checkItemAtPosition ( n , shotsToCheck . get ( n - position ) ) ; } i = i + columnCount ; } pos ++ ; } }
private void checkPostsDisplayOnRecyclerView ( List < Shot > shotsToCheck , int position ) { int columnCount = _NUM ; int size = shotsToCheck . size ( ) + position ; int pos = _NUM ; for ( int i = position ; i < size ; i ++ ) { checkItemAtPosition ( i , shotsToCheck . get ( pos ) ) ; if ( ( ( i + _NUM ) % columnCount ) == _NUM ) { int nextRowStart = i + columnCount ; int nextRowEnd = nextRowStart - columnCount + _NUM ; for ( int n = nextRowStart ; n >= nextRowEnd ; n -- ) { checkItemAtPosition ( n , shotsToCheck . get ( n - position ) ) ; } i = i + columnCount ; } pos ++ ; } }
private void checkPostsDisplayOnRecyclerView ( List < Shot > shotsToCheck , int position ) { int columnCount = _NUM ; int size = shotsToCheck . size ( ) + position ; int pos = _NUM ; for ( int i = position ; i < size ; i ++ ) { checkItemAtPosition ( i , shotsToCheck . get ( pos ) ) ; if ( ( ( i + _NUM ) % columnCount ) == _NUM ) { int nextRowStart = i + columnCount ; int nextRowEnd = nextRowStart - columnCount + _NUM ; for ( int n = nextRowStart ; n >= nextRowEnd ; n -- ) { checkItemAtPosition ( n , shotsToCheck . get ( n - position ) ) ; } i = i + columnCount ; } pos ++ ; } }
void locateClassFailed ( Throwable ex , String adapterName , Object o ) { log . error ( ex . getMessage ( ) + STRING + adapterName ) ; if ( log . isDebugEnabled ( ) ) { ex . printStackTrace ( ) ; } }
void locateClassFailed ( Throwable ex , String adapterName , Object o ) { log . error ( ex . getMessage ( ) + STRING + adapterName ) ; if ( log . isDebugEnabled ( ) ) { ex . printStackTrace ( ) ; } }
public void addChildren ( final ReadDataLevelNode parent ) { parent . add ( new ReadDataNode ( parent . getData ( ) ) ) ; }
@ Override public int countAll ( ) { Long count = ( Long ) finderCache . getResult ( FINDER_PATH_COUNT_ALL , FINDER_ARGS_EMPTY , this ) ; if ( count == null ) { Session session = null ; try { session = openSession ( ) ; Query q = session . createQuery ( _SQL_COUNT_FOO ) ; count = ( Long ) q . uniqueResult ( ) ; finderCache . putResult ( FINDER_PATH_COUNT_ALL , FINDER_ARGS_EMPTY , count ) ; } catch ( Exception e ) { finderCache . removeResult ( FINDER_PATH_COUNT_ALL , FINDER_ARGS_EMPTY ) ; throw processException ( e ) ; } finally { closeSession ( session ) ; } } return count . intValue ( ) ; }
public static ArrayList < Stock > fromJson ( JSONArray jsonQuotes ) throws JSONException { ArrayList < Stock > stocks = new ArrayList < Stock > ( ) ; for ( int i = _NUM ; i < jsonQuotes . length ( ) ; i ++ ) { JSONObject jsonQuoteItem = ( JSONObject ) jsonQuotes . get ( i ) ; stocks . add ( new Stock ( jsonQuoteItem ) ) ; } return stocks ; }
public static ArrayList < Stock > fromJson ( JSONArray jsonQuotes ) throws JSONException { ArrayList < Stock > stocks = new ArrayList < Stock > ( ) ; for ( int i = _NUM ; i < jsonQuotes . length ( ) ; i ++ ) { JSONObject jsonQuoteItem = ( JSONObject ) jsonQuotes . get ( i ) ; stocks . add ( new Stock ( jsonQuoteItem ) ) ; } return stocks ; }
public static boolean checkCaller ( ) { return checkCaller ; }
public void annotationChanged ( Annotation annotation ) { changedAnnotations . add ( annotation ) ; }
public void annotationChanged ( Annotation annotation ) { changedAnnotations . add ( annotation ) ; }
public void annotationChanged ( Annotation annotation ) { changedAnnotations . add ( annotation ) ; }
public void annotationChanged ( Annotation annotation ) { changedAnnotations . add ( annotation ) ; }
private ContentElement parseContentElement ( SpanManager sm , ContentElementParsingParameters cepp , Span lineSpan ) { LinkedList < Span > lineSpans = new LinkedList < Span > ( ) ; lineSpans . add ( lineSpan ) ; return parseContentElement ( sm , cepp , lineSpans , new ContentElement ( ) ) ; }
public static double [ ] genPulseFromFourierMag ( double [ ] mag , double f0 ) { int numHarm = mag . length ; int currentF0 = ( int ) Math . round ( f0 ) ; int T ; if ( currentF0 < _NUM ) T = _NUM ; else T = _NUM ; int T2 = _NUM * T ; double [ ] pulse = new double [ T ] ; double [ ] real = new double [ T2 ] ; double [ ] imag = new double [ T2 ] ; real [ _NUM ] = real [ T ] = _NUM ; for ( int i = _NUM ; i <= numHarm ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = mag [ i - _NUM ] ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = _NUM ; } for ( int i = ( numHarm + _NUM ) ; i < ( T - numHarm ) ; i ++ ) { real [ i ] = real [ T - i ] = real [ T + i ] = real [ T2 - i ] = _NUM ; imag [ i ] = imag [ T - i ] = imag [ T + i ] = imag [ T2 - i ] = _NUM ; } FFT . transform ( real , imag , _BOOL ) ; double sqrt_f0 = Math . sqrt ( currentF0 ) ; for ( int i = _NUM ; i < T ; i ++ ) pulse [ i ] = real [ ( i - numHarm ) % T ] * sqrt_f0 ; return pulse ; }
public void testPathMode ( ) throws Exception { pathModes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL_SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL_ASYNC ; setSecondaryFs = _BOOL ; startUp ( ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PROXY ) ; checkMode ( STRING , DUAL_SYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , DUAL_ASYNC ) ; }
public void testPathMode ( ) throws Exception { pathModes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL_SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL_ASYNC ; setSecondaryFs = _BOOL ; startUp ( ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PROXY ) ; checkMode ( STRING , DUAL_SYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , DUAL_ASYNC ) ; }
public void testPathMode ( ) throws Exception { pathModes ( F . t ( STRING , PROXY ) , F . t ( STRING , DUAL_SYNC ) , F . t ( STRING , PRIMARY ) , F . t ( STRING , PRIMARY ) ) ; mode = DUAL_ASYNC ; setSecondaryFs = _BOOL ; startUp ( ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PROXY ) ; checkMode ( STRING , DUAL_SYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , PRIMARY ) ; checkMode ( STRING , DUAL_ASYNC ) ; checkMode ( STRING , DUAL_ASYNC ) ; }
ArrayList < SourceFile > trimFileList ( ArrayList < SourceFile > files ) { HashMap < String , String > names = new HashMap < String , String > ( ) ; ArrayList < SourceFile > list = new ArrayList < SourceFile > ( ) ; int size = files . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { boolean addIt = _BOOL ; SourceFile fi = files . get ( i ) ; String fName = fi . getRawName ( ) ; if ( m_swfFilter == null ) { if ( names . get ( fName ) == null ) addIt = _BOOL ; } else { addIt = m_swfFilter . containsSource ( fi ) ; } if ( addIt ) { names . put ( fName , fName ) ; list . add ( fi ) ; } } return list ; }
ArrayList < SourceFile > trimFileList ( ArrayList < SourceFile > files ) { HashMap < String , String > names = new HashMap < String , String > ( ) ; ArrayList < SourceFile > list = new ArrayList < SourceFile > ( ) ; int size = files . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { boolean addIt = _BOOL ; SourceFile fi = files . get ( i ) ; String fName = fi . getRawName ( ) ; if ( m_swfFilter == null ) { if ( names . get ( fName ) == null ) addIt = _BOOL ; } else { addIt = m_swfFilter . containsSource ( fi ) ; } if ( addIt ) { names . put ( fName , fName ) ; list . add ( fi ) ; } } return list ; }
public boolean sendTCPString ( String message ) { byte [ ] bytes = message . getBytes ( ) ; return sendTCPBytes ( bytes ) ; }
@ Override public List < Period > generateRollingPeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; dateTimeUnit = cal . minusDays ( dateTimeUnit , _NUM ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , null ) ) ; dateTimeUnit = cal . plusDays ( dateTimeUnit , _NUM ) ; } return periods ; }
@ Override public List < Period > generateRollingPeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; dateTimeUnit = cal . minusDays ( dateTimeUnit , _NUM ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , null ) ) ; dateTimeUnit = cal . plusDays ( dateTimeUnit , _NUM ) ; } return periods ; }
@ Override public List < Period > generateRollingPeriods ( DateTimeUnit dateTimeUnit ) { Calendar cal = getCalendar ( ) ; dateTimeUnit = cal . minusDays ( dateTimeUnit , _NUM ) ; List < Period > periods = Lists . newArrayList ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { periods . add ( createPeriod ( dateTimeUnit , null ) ) ; dateTimeUnit = cal . plusDays ( dateTimeUnit , _NUM ) ; } return periods ; }
public static int normalize ( char [ ] src , int srcStart , int srcLimit , char [ ] dest , int destStart , int destLimit , Mode mode , int options ) { int length = mode . normalize ( src , srcStart , srcLimit , dest , destStart , destLimit , options ) ; if ( length <= ( destLimit - destStart ) ) { return length ; } else { throw new IndexOutOfBoundsException ( Integer . toString ( length ) ) ; } }
public static int normalize ( char [ ] src , int srcStart , int srcLimit , char [ ] dest , int destStart , int destLimit , Mode mode , int options ) { int length = mode . normalize ( src , srcStart , srcLimit , dest , destStart , destLimit , options ) ; if ( length <= ( destLimit - destStart ) ) { return length ; } else { throw new IndexOutOfBoundsException ( Integer . toString ( length ) ) ; } }
private static boolean jwtHasAudienceClaim ( JwtClaimsSet jwtClaims ) throws AuthLoginException { List < String > audienceClaim = jwtClaims . getAudience ( ) ; return ( audienceClaim != null && ! audienceClaim . isEmpty ( ) ) ; }
private static boolean jwtHasAudienceClaim ( JwtClaimsSet jwtClaims ) throws AuthLoginException { List < String > audienceClaim = jwtClaims . getAudience ( ) ; return ( audienceClaim != null && ! audienceClaim . isEmpty ( ) ) ; }
public void write ( byte [ ] b , int off , int len , long pos ) throws IOException { if ( b == null ) { throw new NullPointerException ( STRING ) ; } if ( ( off < _NUM ) || ( len < _NUM ) || ( pos < _NUM ) || ( off + len > b . length ) || ( off + len < _NUM ) ) { throw new IndexOutOfBoundsException ( ) ; } long lastPos = pos + len - _NUM ; if ( lastPos >= length ) { pad ( lastPos ) ; length = lastPos + _NUM ; } int offset = ( int ) ( pos % BUFFER_LENGTH ) ; while ( len > _NUM ) { byte [ ] buf = getCacheBlock ( pos / BUFFER_LENGTH ) ; int nbytes = Math . min ( len , BUFFER_LENGTH - offset ) ; System . arraycopy ( b , off , buf , offset , nbytes ) ; pos += nbytes ; off += nbytes ; len -= nbytes ; offset = _NUM ; } }
public static void generateBinaryOperationFlags ( final ITranslationEnvironment environment , final long nextOffset , final String result , final OperandSize resultSize , final List < ReilInstruction > instructions ) throws IllegalArgumentException { Preconditions . checkNotNull ( environment , STRING ) ; Preconditions . checkNotNull ( result , STRING ) ; Preconditions . checkNotNull ( resultSize , STRING ) ; Preconditions . checkNotNull ( instructions , STRING ) ; final long baseOffset = nextOffset - instructions . size ( ) ; long offset = nextOffset ; generateSignFlagCode ( environment , offset , result , resultSize , instructions ) ; offset = ( baseOffset + instructions . size ( ) ) - _NUM ; instructions . add ( ReilHelpers . createBisz ( offset + _NUM , resultSize , result , OperandSize . BYTE , Helpers . ZERO_FLAG ) ) ; instructions . add ( ReilHelpers . createStr ( offset + _NUM , OperandSize . BYTE , STRING , OperandSize . BYTE , Helpers . CARRY_FLAG ) ) ; instructions . add ( ReilHelpers . createStr ( offset + _NUM , OperandSize . BYTE , STRING , OperandSize . BYTE , Helpers . OVERFLOW_FLAG ) ) ; }
public void draw ( Graphics g , Shape s ) { if ( decorations . isEmpty ( ) ) return ; PathIterator pi = s . getPathIterator ( null , FLATNESS ) ; int segType ; double [ ] segCoords = new double [ _NUM ] ; LinkedList < Point2D > points = new LinkedList < Point2D > ( ) ; Point2D firstPoint = null ; Point2D point ; do { segType = pi . currentSegment ( segCoords ) ; point = new Point2D . Double ( segCoords [ _NUM ] , segCoords [ _NUM ] ) ; switch ( segType ) { case PathIterator . SEG_MOVETO : if ( firstPoint == null ) firstPoint = point ; if ( ! points . isEmpty ( ) ) { draw ( g , points ) ; } points . clear ( ) ; points . add ( point ) ; break ; case PathIterator . SEG_LINETO : points . add ( point ) ; break ; case PathIterator . SEG_CLOSE : points . add ( firstPoint ) ; break ; } pi . next ( ) ; } while ( ! pi . isDone ( ) ) ; if ( ! points . isEmpty ( ) ) { draw ( g , points ) ; } }
public KeyChange ( String newKeyData , DSAPublicKey changeKey , boolean allowsUnsignedChanges , boolean allowsPublicVisibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . newKeyData = newKeyData ; this . newChangeKey = changeKey ; this . allowsUnsignedChanges = allowsUnsignedChanges ; this . allowsPublicVisibility = allowsPublicVisibility ; this . msg = msg == null ? null : Arrays . copyOf ( msg , msg . length ) ; this . sig = sig == null ? null : Arrays . copyOf ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ; Logging . log ( STRING + Arrays . toString ( this . sig ) ) ; }
public KeyChange ( String newKeyData , DSAPublicKey changeKey , boolean allowsUnsignedChanges , boolean allowsPublicVisibility , byte [ ] msg , byte [ ] sig , long epoch , long counter ) { this . newKeyData = newKeyData ; this . newChangeKey = changeKey ; this . allowsUnsignedChanges = allowsUnsignedChanges ; this . allowsPublicVisibility = allowsPublicVisibility ; this . msg = msg == null ? null : Arrays . copyOf ( msg , msg . length ) ; this . sig = sig == null ? null : Arrays . copyOf ( sig , sig . length ) ; this . epoch = epoch ; this . counter = counter ; Logging . log ( STRING + Arrays . toString ( this . sig ) ) ; }
private void buildTasksLoadsRectangles ( List < Load > partition , int ypos ) { List < Offset > offsets = getDefaultOffsets ( ) ; Iterator < Load > loads = partition . iterator ( ) ; while ( loads . hasNext ( ) ) { final Load nextLoad = loads . next ( ) ; final Date nextStart = nextLoad . startDate ; final Date nextEnd = nextLoad . endDate ; final Rectangle nextRect = createRectangle ( offsets , nextStart , nextEnd , ypos ) ; if ( nextRect == null ) { continue ; } String style ; if ( nextLoad . load < _NUM ) { style = STRING ; } else if ( nextLoad . load > _NUM ) { style = STRING ; } else { style = STRING ; } style += STRING ; nextRect . setStyle ( style ) ; nextRect . setModelObject ( new ResourceLoad ( nextLoad . load ) ) ; createLoadText ( nextRect , nextLoad ) ; } }
private void buildTasksLoadsRectangles ( List < Load > partition , int ypos ) { List < Offset > offsets = getDefaultOffsets ( ) ; Iterator < Load > loads = partition . iterator ( ) ; while ( loads . hasNext ( ) ) { final Load nextLoad = loads . next ( ) ; final Date nextStart = nextLoad . startDate ; final Date nextEnd = nextLoad . endDate ; final Rectangle nextRect = createRectangle ( offsets , nextStart , nextEnd , ypos ) ; if ( nextRect == null ) { continue ; } String style ; if ( nextLoad . load < _NUM ) { style = STRING ; } else if ( nextLoad . load > _NUM ) { style = STRING ; } else { style = STRING ; } style += STRING ; nextRect . setStyle ( style ) ; nextRect . setModelObject ( new ResourceLoad ( nextLoad . load ) ) ; createLoadText ( nextRect , nextLoad ) ; } }
public static void shutdownActive ( ExitCode exitCode , String msg ) { shutdownActive ( ShutdownModeAmp . GRACEFUL , exitCode , msg , null ) ; }
@ SuppressWarnings ( STRING ) public < U > SimpleReactStream < U > from ( final Iterator < U > iterator ) { return from ( StreamSupport . stream ( Spliterators . spliteratorUnknownSize ( iterator , Spliterator . ORDERED ) , _BOOL ) ) ; }
public Asn1Dump ( ) { indentSequence = new IndentSequence ( IndentChar . SPACE , _NUM ) ; }
public Asn1Dump ( ) { indentSequence = new IndentSequence ( IndentChar . SPACE , _NUM ) ; }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public final void close ( GsServerPacket closePacket , boolean forced ) { synchronized ( guard ) { if ( isWriteDisabled ( ) ) { return ; } pendingClose = _BOOL ; isForcedClosing = forced ; sendMsgQueue . clear ( ) ; sendMsgQueue . addLast ( closePacket ) ; enableWriteInterest ( ) ; } }
public static synchronized void doDeferredSpecializations ( ) { if ( specializationInProgress ) { return ; } specializationInProgress = _BOOL ; Iterator < SpecializedMethod > methods = deferredMethods . iterator ( ) ; while ( methods . hasNext ( ) ) { SpecializedMethod m = methods . next ( ) ; if ( m . getCompiledMethod ( ) == null ) { m . compile ( ) ; registerCompiledMethod ( m ) ; } deferredMethods . remove ( m ) ; methods = deferredMethods . iterator ( ) ; } specializationInProgress = _BOOL ; }
private int convertHexToInt ( String hexValue ) { int value ; try { value = Integer . parseInt ( hexValue , _NUM ) ; } catch ( NumberFormatException e ) { logger . error ( STRING + hexValue + STRING , e ) ; return _NUM ; } return value ; }
private int convertHexToInt ( String hexValue ) { int value ; try { value = Integer . parseInt ( hexValue , _NUM ) ; } catch ( NumberFormatException e ) { logger . error ( STRING + hexValue + STRING , e ) ; return _NUM ; } return value ; }
public static boolean isGameLoop ( ) { return Thread . currentThread ( ) == get ( ) . loopThread ; }
public ParallelAnimator add ( Combinable combinable ) { combinableList . add ( combinable ) ; return this ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix3f ) || o == null ) { return _BOOL ; } if ( this == o ) { return _BOOL ; } Matrix3f comp = ( Matrix3f ) o ; if ( Float . compare ( m00 , comp . m00 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != _NUM ) { return _BOOL ; } return _BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix3f ) || o == null ) { return _BOOL ; } if ( this == o ) { return _BOOL ; } Matrix3f comp = ( Matrix3f ) o ; if ( Float . compare ( m00 , comp . m00 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != _NUM ) { return _BOOL ; } return _BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix3f ) || o == null ) { return _BOOL ; } if ( this == o ) { return _BOOL ; } Matrix3f comp = ( Matrix3f ) o ; if ( Float . compare ( m00 , comp . m00 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != _NUM ) { return _BOOL ; } return _BOOL ; }
public boolean equals ( Object o ) { if ( ! ( o instanceof Matrix3f ) || o == null ) { return _BOOL ; } if ( this == o ) { return _BOOL ; } Matrix3f comp = ( Matrix3f ) o ; if ( Float . compare ( m00 , comp . m00 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m01 , comp . m01 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m02 , comp . m02 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m10 , comp . m10 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m11 , comp . m11 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m12 , comp . m12 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m20 , comp . m20 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m21 , comp . m21 ) != _NUM ) { return _BOOL ; } if ( Float . compare ( m22 , comp . m22 ) != _NUM ) { return _BOOL ; } return _BOOL ; }
public boolean remove_if_cycle ( BrdTracep p_trace ) { if ( ! p_trace . is_on_the_board ( ) ) return _BOOL ; if ( ! p_trace . has_cycle ( ) ) return _BOOL ; int curr_layer = p_trace . get_layer ( ) ; PlaPoint [ ] end_corners = new PlaPoint [ _NUM ] ; end_corners [ _NUM ] = p_trace . corner_first ( ) ; end_corners [ _NUM ] = p_trace . corner_last ( ) ; boolean [ ] tail_at_endpoint_before = new boolean [ _NUM ] ; for ( int index = _NUM ; index < _NUM ; ++ index ) { BrdTracep tail = get_trace_tail ( end_corners [ index ] , curr_layer , p_trace . net_nos ) ; tail_at_endpoint_before [ index ] = ( tail != null ) ; } Set < BrdItem > connection_items = p_trace . get_connection_items ( ) ; remove_items_unfixed ( connection_items ) ; for ( int index = _NUM ; index < _NUM ; ++ index ) { if ( tail_at_endpoint_before [ index ] ) continue ; BrdTracep tail = get_trace_tail ( end_corners [ index ] , curr_layer , p_trace . net_nos ) ; if ( tail == null ) continue ; remove_items_unfixed ( tail . get_connection_items ( ) ) ; } return _BOOL ; }
public void append ( String string ) { for ( int i = _NUM ; i < string . length ( ) ; i ++ ) append ( string . charAt ( i ) ) ; }
public static long readLong ( final JSONObject jsonObject , final String key , final boolean required , final boolean notNull ) throws JSONException { if ( required ) { return jsonObject . getLong ( key ) ; } if ( notNull && jsonObject . isNull ( key ) ) { throw new JSONException ( String . format ( Locale . US , NULL_VALUE_FORMAT_OBJECT , key ) ) ; } long value = _NUM ; if ( ! jsonObject . isNull ( key ) ) { value = jsonObject . getLong ( key ) ; } return value ; }
public static String pluralCreature ( final String noun ) { if ( noun . equals ( STRING ) ) { return STRING ; } return plural ( noun ) ; }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( _NUM ) ; v . addElement ( this ) ; return v . elements ( ) ; }
public Enumeration < ? extends Principal > members ( ) { Vector < Principal > v = new Vector < Principal > ( _NUM ) ; v . addElement ( this ) ; return v . elements ( ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public Enumeration listOptions ( ) { Vector newVector = new Vector ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public int compareTo ( XMLString xstr ) { int len1 = m_length ; int len2 = xstr . length ( ) ; int n = Math . min ( len1 , len2 ) ; FastStringBuffer fsb = fsb ( ) ; int i = m_start ; int j = _NUM ; while ( n -- != _NUM ) { char c1 = fsb . charAt ( i ) ; char c2 = xstr . charAt ( j ) ; if ( c1 != c2 ) { return c1 - c2 ; } i ++ ; j ++ ; } return len1 - len2 ; }
public Version ( @ NonNull String version ) throws ParseException { final String [ ] numberStrings = version . split ( STRING ) ; final int versionsCount = Math . min ( NUMBERS_COUNT , numberStrings . length ) ; for ( int i = _NUM ; i < versionsCount ; i ++ ) { final String numberString = numberStrings [ i ] ; final char firstChar = numberString . charAt ( _NUM ) ; if ( firstChar == STRING || firstChar == STRING ) { throw new VersionParseException ( _NUM ) ; } try { numbers [ i ] = Integer . parseInt ( numberString ) ; } catch ( NumberFormatException e ) { throw new VersionParseException ( version . indexOf ( numberString ) ) ; } } }
public void testCreateDocument1 ( ) throws Throwable { String namespaceURI = STRING ; String malformedName = STRING ; Document doc ; DocumentType docType = null ; DOMImplementation domImpl ; doc = ( Document ) load ( STRING , builder ) ; domImpl = doc . getImplementation ( ) ; boolean success = _BOOL ; try { domImpl . createDocument ( namespaceURI , malformedName , docType ) ; } catch ( DOMException ex ) { success = ( ex . code == DOMException . NAMESPACE_ERR ) ; } assertTrue ( STRING , success ) ; }
public AbstractResource ( String mimetype ) { this ( mimetype , System . currentTimeMillis ( ) ) ; }
public AbstractResource ( String mimetype ) { this ( mimetype , System . currentTimeMillis ( ) ) ; }
public synchronized void removeSection ( String section ) { String sectionDot = section + STRING ; if ( isSectionDefined ( section ) ) { LinkedHashSet < String > keys = new LinkedHashSet < String > ( options . keySet ( ) ) ; for ( String key : keys ) { if ( key . startsWith ( sectionDot ) ) { removeOption ( key ) ; } } } }
public synchronized void removeSection ( String section ) { String sectionDot = section + STRING ; if ( isSectionDefined ( section ) ) { LinkedHashSet < String > keys = new LinkedHashSet < String > ( options . keySet ( ) ) ; for ( String key : keys ) { if ( key . startsWith ( sectionDot ) ) { removeOption ( key ) ; } } } }
public IdsQueryBuilder addIds ( String ... ids ) { values . addAll ( Arrays . asList ( ids ) ) ; return this ; }
public static Object eval ( String script ) throws ScriptException { requireLoad ( ) ; checkSupported ( ) ; return engine . eval ( script ) ; }
public static Object eval ( String script ) throws ScriptException { requireLoad ( ) ; checkSupported ( ) ; return engine . eval ( script ) ; }
public static Object eval ( String script ) throws ScriptException { requireLoad ( ) ; checkSupported ( ) ; return engine . eval ( script ) ; }
public boolean hasBreakpoint ( final BreakpointType type , final BreakpointAddress address ) { checkArguments ( type , address ) ; switch ( type ) { case REGULAR : return indexedBreakpointStorage . get ( address ) != null ; case ECHO : return echoBreakpointStorage . get ( address ) != null ; case STEP : return stepBreakpointStorage . get ( address ) != null ; default : throw new IllegalStateException ( String . format ( STRING , type ) ) ; } }
public boolean hasBreakpoint ( final BreakpointType type , final BreakpointAddress address ) { checkArguments ( type , address ) ; switch ( type ) { case REGULAR : return indexedBreakpointStorage . get ( address ) != null ; case ECHO : return echoBreakpointStorage . get ( address ) != null ; case STEP : return stepBreakpointStorage . get ( address ) != null ; default : throw new IllegalStateException ( String . format ( STRING , type ) ) ; } }
public static void init ( Context context ) { if ( sInstance == null ) { final ExecutorService service = Executors . newSingleThreadExecutor ( ) ; sTrainingTaskFuture = service . submit ( new TrainingTask ( context ) ) ; } else { throw new IllegalStateException ( STRING + STRING ) ; } }
public static void init ( Context context ) { if ( sInstance == null ) { final ExecutorService service = Executors . newSingleThreadExecutor ( ) ; sTrainingTaskFuture = service . submit ( new TrainingTask ( context ) ) ; } else { throw new IllegalStateException ( STRING + STRING ) ; } }
public static void init ( Context context ) { if ( sInstance == null ) { final ExecutorService service = Executors . newSingleThreadExecutor ( ) ; sTrainingTaskFuture = service . submit ( new TrainingTask ( context ) ) ; } else { throw new IllegalStateException ( STRING + STRING ) ; } }
static void write ( SocketChannel chan , byte [ ] data ) throws TimeoutException , IOException { write ( chan , data , - _NUM , DdmPreferences . getTimeOut ( ) ) ; }
protected Monitor pollFor ( Map < String , Monitor > map , String name , long timeLimit ) throws MonitorException { Monitor monitor = null ; log ( STRING + lvmid + STRING + name + STRING ) ; pollForEntry = nextEntry ; while ( ( monitor = map . get ( name ) ) == null ) { log ( STRING ) ; try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { } long t = System . currentTimeMillis ( ) ; if ( ( t > timeLimit ) || ( overflow . intValue ( ) > _NUM ) ) { lognl ( STRING + lvmid + STRING + name ) ; dumpAll ( map , lvmid ) ; throw new MonitorException ( STRING ) ; } getNewMonitors ( map ) ; } lognl ( STRING + lvmid + STRING + name ) ; return monitor ; }
public Multimap < String , String > assembleAllWatchKeys ( String appId , String clusterName , Set < String > namespaces , String dataCenter ) { Multimap < String , String > watchedKeysMap = assembleWatchKeys ( appId , clusterName , namespaces , dataCenter ) ; if ( ! ( namespaces . size ( ) == _NUM && namespaces . contains ( ConfigConsts . NAMESPACE_APPLICATION ) ) ) { Set < String > namespacesBelongToAppId = namespacesBelongToAppId ( appId , namespaces ) ; Set < String > publicNamespaces = Sets . difference ( namespaces , namespacesBelongToAppId ) ; if ( ! publicNamespaces . isEmpty ( ) ) { watchedKeysMap . putAll ( findPublicConfigWatchKeys ( appId , clusterName , publicNamespaces , dataCenter ) ) ; } } return watchedKeysMap ; }
public static File saveFile ( String logData ) { File dir = getLogDir ( ) ; if ( dir == null ) { return null ; } FileWriter fileWriter = null ; File output = null ; try { output = new File ( dir , getLogFileName ( ) ) ; fileWriter = new FileWriter ( output , _BOOL ) ; fileWriter . write ( logData ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } finally { if ( fileWriter != null ) { try { fileWriter . close ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } } return output ; }
public static Vector3 azElToPoint ( double az , double el , Vector3 result ) { if ( result == null ) { result = new Vector3 ( ) ; } Matrix3 mat = Matrix3 . fetchTempInstance ( ) ; mat . fromAngleAxis ( az , Vector3 . NEG_UNIT_Z ) ; Matrix3 mat2 = Matrix3 . fetchTempInstance ( ) ; mat2 . fromAngleAxis ( el , Vector3 . UNIT_X ) ; mat . multiplyLocal ( mat2 ) ; result . set ( Vector3 . UNIT_Y ) ; mat . applyPost ( result , result ) ; Matrix3 . releaseTempInstance ( mat ) ; Matrix3 . releaseTempInstance ( mat2 ) ; return ( result ) ; }
public static Vector3 azElToPoint ( double az , double el , Vector3 result ) { if ( result == null ) { result = new Vector3 ( ) ; } Matrix3 mat = Matrix3 . fetchTempInstance ( ) ; mat . fromAngleAxis ( az , Vector3 . NEG_UNIT_Z ) ; Matrix3 mat2 = Matrix3 . fetchTempInstance ( ) ; mat2 . fromAngleAxis ( el , Vector3 . UNIT_X ) ; mat . multiplyLocal ( mat2 ) ; result . set ( Vector3 . UNIT_Y ) ; mat . applyPost ( result , result ) ; Matrix3 . releaseTempInstance ( mat ) ; Matrix3 . releaseTempInstance ( mat2 ) ; return ( result ) ; }
public static < U > Function < U , Predicate < U > > notSelf ( ) { return null ; }
public Double read ( String value ) { return Double . valueOf ( value ) ; }
public Double read ( String value ) { return Double . valueOf ( value ) ; }
public Double read ( String value ) { return Double . valueOf ( value ) ; }
public void writeListEnd ( ) throws IOException { os . write ( STRING ) ; }
private byte [ ] encode ( final RevisionCodecData codecData , final Diff diff ) throws UnsupportedEncodingException , EncodingException { this . data = new BitWriter ( codecData . totalSizeInBits ( ) ) ; encodeCodecData ( codecData ) ; DiffPart part ; Iterator < DiffPart > partIt = diff . iterator ( ) ; while ( partIt . hasNext ( ) ) { part = partIt . next ( ) ; switch ( part . getAction ( ) ) { case FULL_REVISION_UNCOMPRESSED : encodeFullRevisionUncompressed ( part ) ; break ; case INSERT : encodeInsert ( part ) ; break ; case DELETE : encodeDelete ( part ) ; break ; case REPLACE : encodeReplace ( part ) ; break ; case CUT : encodeCut ( part ) ; break ; case PASTE : encodePaste ( part ) ; break ; default : throw new RuntimeException ( ) ; } } return data . toByteArray ( ) ; }
private byte [ ] encode ( final RevisionCodecData codecData , final Diff diff ) throws UnsupportedEncodingException , EncodingException { this . data = new BitWriter ( codecData . totalSizeInBits ( ) ) ; encodeCodecData ( codecData ) ; DiffPart part ; Iterator < DiffPart > partIt = diff . iterator ( ) ; while ( partIt . hasNext ( ) ) { part = partIt . next ( ) ; switch ( part . getAction ( ) ) { case FULL_REVISION_UNCOMPRESSED : encodeFullRevisionUncompressed ( part ) ; break ; case INSERT : encodeInsert ( part ) ; break ; case DELETE : encodeDelete ( part ) ; break ; case REPLACE : encodeReplace ( part ) ; break ; case CUT : encodeCut ( part ) ; break ; case PASTE : encodePaste ( part ) ; break ; default : throw new RuntimeException ( ) ; } } return data . toByteArray ( ) ; }
public IPAddressName ( DerValue derValue ) throws IOException { this ( derValue . getOctetString ( ) ) ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m_Indices . length ] ; for ( i = _NUM ; i < m_Indices . length ; i ++ ) { values [ i ] = instance . value ( m_Indices [ i ] ) ; } result = new DenseInstance ( instance . weight ( ) , values ) ; result . setDataset ( getOutputFormat ( ) ) ; copyValues ( result , _BOOL , instance . dataset ( ) , getOutputFormat ( ) ) ; result . setDataset ( getOutputFormat ( ) ) ; return result ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m_Indices . length ] ; for ( i = _NUM ; i < m_Indices . length ; i ++ ) { values [ i ] = instance . value ( m_Indices [ i ] ) ; } result = new DenseInstance ( instance . weight ( ) , values ) ; result . setDataset ( getOutputFormat ( ) ) ; copyValues ( result , _BOOL , instance . dataset ( ) , getOutputFormat ( ) ) ; result . setDataset ( getOutputFormat ( ) ) ; return result ; }
@ Override protected Instance process ( Instance instance ) throws Exception { Instance result ; double [ ] values ; int i ; values = new double [ m_Indices . length ] ; for ( i = _NUM ; i < m_Indices . length ; i ++ ) { values [ i ] = instance . value ( m_Indices [ i ] ) ; } result = new DenseInstance ( instance . weight ( ) , values ) ; result . setDataset ( getOutputFormat ( ) ) ; copyValues ( result , _BOOL , instance . dataset ( ) , getOutputFormat ( ) ) ; result . setDataset ( getOutputFormat ( ) ) ; return result ; }
@ Override public void endPrefixMapping ( String str ) throws SAXException { }
public void putGrammar ( Grammar grammar ) { if ( ! fPoolIsLocked ) { synchronized ( fGrammars ) { XMLGrammarDescription desc = grammar . getGrammarDescription ( ) ; int hash = hashCode ( desc ) ; int index = ( hash & _NUM ) % fGrammars . length ; for ( Entry entry = fGrammars [ index ] ; entry != null ; entry = entry . next ) { if ( entry . hash == hash && equals ( entry . desc , desc ) ) { entry . grammar = grammar ; return ; } } Entry entry = new Entry ( hash , desc , grammar , fGrammars [ index ] ) ; fGrammars [ index ] = entry ; fGrammarCount ++ ; } } }
public void output ( PrintWriter out ) { out . write ( versionDecl ) ; for ( int i = _NUM ; i < prolog . size ( ) ; i ++ ) { ConcreteElement e = ( ConcreteElement ) prolog . elementAt ( i ) ; e . output ( out ) ; } if ( content != null ) content . output ( out ) ; }
public void addText ( String text ) { if ( null != text ) { texts . add ( new TextProperties ( text , currentSize , currentColor ) ) ; reclampText ( ) ; invalidate ( ) ; } }
public void addText ( String text ) { if ( null != text ) { texts . add ( new TextProperties ( text , currentSize , currentColor ) ) ; reclampText ( ) ; invalidate ( ) ; } }
public void addText ( String text ) { if ( null != text ) { texts . add ( new TextProperties ( text , currentSize , currentColor ) ) ; reclampText ( ) ; invalidate ( ) ; } }
public void addText ( String text ) { if ( null != text ) { texts . add ( new TextProperties ( text , currentSize , currentColor ) ) ; reclampText ( ) ; invalidate ( ) ; } }
public int size ( ) { return bits . cardinality ( ) ; }
@ SuppressWarnings ( STRING ) public ThrowingMockTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; String exceptionClassName = args . get ( STRING ) ; if ( exceptionClassName == null ) { throw new RuntimeException ( STRING ) ; } try { exceptionClass = ( Class < ? extends RuntimeException > ) Class . forName ( exceptionClassName ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
@ SuppressWarnings ( STRING ) public ThrowingMockTokenFilterFactory ( Map < String , String > args ) { super ( args ) ; String exceptionClassName = args . get ( STRING ) ; if ( exceptionClassName == null ) { throw new RuntimeException ( STRING ) ; } try { exceptionClass = ( Class < ? extends RuntimeException > ) Class . forName ( exceptionClassName ) ; } catch ( ClassNotFoundException e ) { throw new RuntimeException ( e ) ; } }
public String attributeCaseFix ( String columnName ) { if ( m_checkForUpperCaseNames ) { String ucname = columnName . toUpperCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toUpperCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toUpperCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toUpperCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else if ( m_checkForLowerCaseNames ) { String ucname = columnName . toLowerCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toLowerCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toLowerCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toLowerCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else { return columnName ; } }
public String attributeCaseFix ( String columnName ) { if ( m_checkForUpperCaseNames ) { String ucname = columnName . toUpperCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toUpperCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toUpperCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toUpperCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else if ( m_checkForLowerCaseNames ) { String ucname = columnName . toLowerCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toLowerCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toLowerCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toLowerCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else { return columnName ; } }
public String attributeCaseFix ( String columnName ) { if ( m_checkForUpperCaseNames ) { String ucname = columnName . toUpperCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toUpperCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toUpperCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toUpperCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else if ( m_checkForLowerCaseNames ) { String ucname = columnName . toLowerCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toLowerCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toLowerCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toLowerCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else { return columnName ; } }
public String attributeCaseFix ( String columnName ) { if ( m_checkForUpperCaseNames ) { String ucname = columnName . toUpperCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toUpperCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toUpperCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toUpperCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else if ( m_checkForLowerCaseNames ) { String ucname = columnName . toLowerCase ( ) ; if ( ucname . equals ( EXP_TYPE_COL . toLowerCase ( ) ) ) { return EXP_TYPE_COL ; } else if ( ucname . equals ( EXP_SETUP_COL . toLowerCase ( ) ) ) { return EXP_SETUP_COL ; } else if ( ucname . equals ( EXP_RESULT_COL . toLowerCase ( ) ) ) { return EXP_RESULT_COL ; } else { return columnName ; } } else { return columnName ; } }
public int addSecondaryEquations ( final SecondaryODE secondary ) { components . add ( secondary ) ; mapper = new EquationsMapper ( mapper , secondary . getDimension ( ) ) ; return components . size ( ) ; }
public PublicKey loadPublicKey ( int id ) throws Exception { if ( defaultKeys ) { return getPublicKeyFromString ( RSAKeyLoader . DEFAULT_UKEY ) ; } FileReader f = new FileReader ( path + STRING + id ) ; BufferedReader r = new BufferedReader ( f ) ; String tmp = STRING ; String key = STRING ; while ( ( tmp = r . readLine ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; PublicKey ret = getPublicKeyFromString ( key ) ; return ret ; }
public static String convertMethodSignature ( String className , String methodName , String methodSig , String pkgName ) { StringBuilder args = new StringBuilder ( ) ; SignatureConverter converter = new SignatureConverter ( methodSig ) ; converter . skip ( ) ; args . append ( STRING ) ; while ( converter . getFirst ( ) != STRING ) { if ( args . length ( ) > _NUM ) { args . append ( STRING ) ; } args . append ( shorten ( pkgName , converter . parseNext ( ) ) ) ; } converter . skip ( ) ; args . append ( STRING ) ; StringBuilder result = new StringBuilder ( ) ; result . append ( className ) ; result . append ( STRING ) ; result . append ( methodName ) ; result . append ( args . toString ( ) ) ; return result . toString ( ) ; }
public final void removeModelListener ( final VisionWorldModelListener listener ) { listenerList . remove ( VisionWorldModelListener . class , listener ) ; }
public void service ( Mail mail ) throws MailetException { MimeMessage message ; try { message = mail . getMessage ( ) ; } catch ( MessagingException e ) { throw new MailetException ( STRING , e ) ; } try { if ( message . isMimeType ( STRING ) ) { analyseMultipartPartMessage ( message , mail ) ; } } catch ( MessagingException e ) { throw new MailetException ( STRING , e ) ; } catch ( Exception e ) { throw new MailetException ( STRING , e ) ; } }
public void service ( Mail mail ) throws MailetException { MimeMessage message ; try { message = mail . getMessage ( ) ; } catch ( MessagingException e ) { throw new MailetException ( STRING , e ) ; } try { if ( message . isMimeType ( STRING ) ) { analyseMultipartPartMessage ( message , mail ) ; } } catch ( MessagingException e ) { throw new MailetException ( STRING , e ) ; } catch ( Exception e ) { throw new MailetException ( STRING , e ) ; } }
@ Override protected void executionStarted ( ) { m_ButtonStart . setEnabled ( _BOOL ) ; m_ButtonStop . setEnabled ( _BOOL ) ; }
public Red5 ( IConnection conn ) { this . conn = conn ; }
public Red5 ( IConnection conn ) { this . conn = conn ; }
private List < Race > parseRaces ( String json ) { List < Race > result = new ArrayList < > ( ) ; if ( json == null ) { return null ; } JSONParser parser = new JSONParser ( ) ; try { JSONObject root = ( JSONObject ) parser . parse ( json . trim ( ) ) ; JSONArray races = ( JSONArray ) root . get ( STRING ) ; for ( Object o : races ) { if ( o instanceof JSONObject ) { Race race = parseRace ( ( JSONObject ) o ) ; if ( race != null ) { result . add ( race ) ; } } } } catch ( ParseException | ClassCastException | NullPointerException ex ) { LOGGER . warning ( STRING + ex ) ; return null ; } return result ; }
public Set < String > addContent ( ProbDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( ProbDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
public Set < String > addContent ( ProbDistribution distrib ) { if ( ! paused ) { curState . addToState ( distrib ) ; return update ( ) ; } else { log . info ( STRING + distrib ) ; return Collections . emptySet ( ) ; } }
private Cell detectAndAddHit ( float x , float y ) { final Cell cell = checkForNewHit ( x , y ) ; if ( cell != null ) { Cell fillInGapCell = null ; final ArrayList < Cell > pattern = mPattern ; if ( ! pattern . isEmpty ( ) ) { final Cell lastCell = pattern . get ( pattern . size ( ) - _NUM ) ; int dRow = cell . row - lastCell . row ; int dColumn = cell . column - lastCell . column ; int fillInRow = lastCell . row ; int fillInColumn = lastCell . column ; if ( Math . abs ( dRow ) == _NUM && Math . abs ( dColumn ) != _NUM ) { fillInRow = lastCell . row + ( ( dRow > _NUM ) ? _NUM : - _NUM ) ; } if ( Math . abs ( dColumn ) == _NUM && Math . abs ( dRow ) != _NUM ) { fillInColumn = lastCell . column + ( ( dColumn > _NUM ) ? _NUM : - _NUM ) ; } fillInGapCell = Cell . of ( fillInRow , fillInColumn ) ; } if ( fillInGapCell != null && ! mPatternDrawLookup [ fillInGapCell . row ] [ fillInGapCell . column ] ) { addCellToPattern ( fillInGapCell ) ; } addCellToPattern ( cell ) ; return cell ; } return null ; }
private Cell detectAndAddHit ( float x , float y ) { final Cell cell = checkForNewHit ( x , y ) ; if ( cell != null ) { Cell fillInGapCell = null ; final ArrayList < Cell > pattern = mPattern ; if ( ! pattern . isEmpty ( ) ) { final Cell lastCell = pattern . get ( pattern . size ( ) - _NUM ) ; int dRow = cell . row - lastCell . row ; int dColumn = cell . column - lastCell . column ; int fillInRow = lastCell . row ; int fillInColumn = lastCell . column ; if ( Math . abs ( dRow ) == _NUM && Math . abs ( dColumn ) != _NUM ) { fillInRow = lastCell . row + ( ( dRow > _NUM ) ? _NUM : - _NUM ) ; } if ( Math . abs ( dColumn ) == _NUM && Math . abs ( dRow ) != _NUM ) { fillInColumn = lastCell . column + ( ( dColumn > _NUM ) ? _NUM : - _NUM ) ; } fillInGapCell = Cell . of ( fillInRow , fillInColumn ) ; } if ( fillInGapCell != null && ! mPatternDrawLookup [ fillInGapCell . row ] [ fillInGapCell . column ] ) { addCellToPattern ( fillInGapCell ) ; } addCellToPattern ( cell ) ; return cell ; } return null ; }
private Cell detectAndAddHit ( float x , float y ) { final Cell cell = checkForNewHit ( x , y ) ; if ( cell != null ) { Cell fillInGapCell = null ; final ArrayList < Cell > pattern = mPattern ; if ( ! pattern . isEmpty ( ) ) { final Cell lastCell = pattern . get ( pattern . size ( ) - _NUM ) ; int dRow = cell . row - lastCell . row ; int dColumn = cell . column - lastCell . column ; int fillInRow = lastCell . row ; int fillInColumn = lastCell . column ; if ( Math . abs ( dRow ) == _NUM && Math . abs ( dColumn ) != _NUM ) { fillInRow = lastCell . row + ( ( dRow > _NUM ) ? _NUM : - _NUM ) ; } if ( Math . abs ( dColumn ) == _NUM && Math . abs ( dRow ) != _NUM ) { fillInColumn = lastCell . column + ( ( dColumn > _NUM ) ? _NUM : - _NUM ) ; } fillInGapCell = Cell . of ( fillInRow , fillInColumn ) ; } if ( fillInGapCell != null && ! mPatternDrawLookup [ fillInGapCell . row ] [ fillInGapCell . column ] ) { addCellToPattern ( fillInGapCell ) ; } addCellToPattern ( cell ) ; return cell ; } return null ; }
private Cell detectAndAddHit ( float x , float y ) { final Cell cell = checkForNewHit ( x , y ) ; if ( cell != null ) { Cell fillInGapCell = null ; final ArrayList < Cell > pattern = mPattern ; if ( ! pattern . isEmpty ( ) ) { final Cell lastCell = pattern . get ( pattern . size ( ) - _NUM ) ; int dRow = cell . row - lastCell . row ; int dColumn = cell . column - lastCell . column ; int fillInRow = lastCell . row ; int fillInColumn = lastCell . column ; if ( Math . abs ( dRow ) == _NUM && Math . abs ( dColumn ) != _NUM ) { fillInRow = lastCell . row + ( ( dRow > _NUM ) ? _NUM : - _NUM ) ; } if ( Math . abs ( dColumn ) == _NUM && Math . abs ( dRow ) != _NUM ) { fillInColumn = lastCell . column + ( ( dColumn > _NUM ) ? _NUM : - _NUM ) ; } fillInGapCell = Cell . of ( fillInRow , fillInColumn ) ; } if ( fillInGapCell != null && ! mPatternDrawLookup [ fillInGapCell . row ] [ fillInGapCell . column ] ) { addCellToPattern ( fillInGapCell ) ; } addCellToPattern ( cell ) ; return cell ; } return null ; }
private void applyDependentCoupling ( SingleChannelElement target , ChannelElement cce , int index ) { IndividualChannelStream ics = cce . ch [ _NUM ] . ics ; int offsets [ ] = ics . swbOffset ; float dest [ ] = target . coeffs ; float src [ ] = cce . ch [ _NUM ] . coeffs ; int idx = _NUM ; if ( ac . oc [ _NUM ] . m4ac . objectType == AOT_AAC_LTP ) { log . error ( String . format ( STRING ) ) ; return ; } int destOffset = _NUM ; int srcOffset = _NUM ; for ( int g = _NUM ; g < ics . numWindowGroups ; g ++ ) { for ( int i = _NUM ; i < ics . maxSfb ; i ++ , idx ++ ) { if ( cce . ch [ _NUM ] . bandType [ idx ] != ZERO_BT ) { final float gain = cce . coup . gain [ index ] [ idx ] ; for ( int group = _NUM ; group < ics . groupLen [ g ] ; group ++ ) { for ( int k = offsets [ i ] ; k < offsets [ i + _NUM ] ; k ++ ) { dest [ destOffset + group * _NUM + k ] += gain * src [ srcOffset + group * _NUM + k ] ; } } } } destOffset += ics . groupLen [ g ] * _NUM ; srcOffset += ics . groupLen [ g ] * _NUM ; } }
public int releaseExtraResources ( ) { synchronized ( lock ) { int numReleasedResources = _NUM ; if ( requestsQueue . isEmpty ( ) ) { log . debug ( STRING ) ; if ( hostAffinityEnabled ) { List < String > allocatedHosts = getAllocatedHosts ( ) ; for ( String host : allocatedHosts ) { numReleasedResources += releaseResourcesForHost ( host ) ; } } else { numReleasedResources += releaseResourcesForHost ( ANY_HOST ) ; } clearState ( ) ; } return numReleasedResources ; } }
public int releaseExtraResources ( ) { synchronized ( lock ) { int numReleasedResources = _NUM ; if ( requestsQueue . isEmpty ( ) ) { log . debug ( STRING ) ; if ( hostAffinityEnabled ) { List < String > allocatedHosts = getAllocatedHosts ( ) ; for ( String host : allocatedHosts ) { numReleasedResources += releaseResourcesForHost ( host ) ; } } else { numReleasedResources += releaseResourcesForHost ( ANY_HOST ) ; } clearState ( ) ; } return numReleasedResources ; } }
public void warning ( SAXParseException e ) throws SAXException { addValidationException ( e ) ; }
public void warning ( SAXParseException e ) throws SAXException { addValidationException ( e ) ; }
private void collectOsrPointsAndBarriers ( IR ir ) { osrPoints = new LinkedList < Instruction > ( ) ; osrBarriers = new LinkedList < Instruction > ( ) ; Enumeration < Instruction > instenum = ir . forwardInstrEnumerator ( ) ; while ( instenum . hasMoreElements ( ) ) { Instruction inst = instenum . nextElement ( ) ; if ( OsrPoint . conforms ( inst ) ) { osrPoints . add ( inst ) ; } else if ( inst . operator ( ) == OSR_BARRIER ) { osrBarriers . add ( inst ) ; } } }
void expandCapacity ( int minimumCapacity ) { int newCapacity = value . length * _NUM + _NUM ; if ( newCapacity - minimumCapacity < _NUM ) newCapacity = minimumCapacity ; if ( newCapacity < _NUM ) { if ( minimumCapacity < _NUM ) throw new OutOfMemoryError ( ) ; newCapacity = Integer . MAX_VALUE ; } value = Arrays . copyOf ( value , newCapacity ) ; }
void expandCapacity ( int minimumCapacity ) { int newCapacity = value . length * _NUM + _NUM ; if ( newCapacity - minimumCapacity < _NUM ) newCapacity = minimumCapacity ; if ( newCapacity < _NUM ) { if ( minimumCapacity < _NUM ) throw new OutOfMemoryError ( ) ; newCapacity = Integer . MAX_VALUE ; } value = Arrays . copyOf ( value , newCapacity ) ; }
void expandCapacity ( int minimumCapacity ) { int newCapacity = value . length * _NUM + _NUM ; if ( newCapacity - minimumCapacity < _NUM ) newCapacity = minimumCapacity ; if ( newCapacity < _NUM ) { if ( minimumCapacity < _NUM ) throw new OutOfMemoryError ( ) ; newCapacity = Integer . MAX_VALUE ; } value = Arrays . copyOf ( value , newCapacity ) ; }
public void fireEvent ( Object event ) { if ( event == null ) { throw new IllegalArgumentException ( STRING ) ; } mTaskQueue . offer ( Task . obtainTask ( Task . CODE_FIRE_EVENT , event , - _NUM ) ) ; if ( ! mQueueProcessed ) processTaskQueue ( ) ; }
public ListenKey startListening ( ) throws IOException { return startListening ( null , _NUM ) ; }
public ListenKey startListening ( ) throws IOException { return startListening ( null , _NUM ) ; }
public StrBuilder deleteAll ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; while ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; index = indexOf ( str , index ) ; } } return this ; }
public StrBuilder deleteAll ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; while ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; index = indexOf ( str , index ) ; } } return this ; }
public StrBuilder deleteAll ( final String str ) { final int len = ( str == null ? _NUM : str . length ( ) ) ; if ( len > _NUM ) { int index = indexOf ( str , _NUM ) ; while ( index >= _NUM ) { deleteImpl ( index , index + len , len ) ; index = indexOf ( str , index ) ; } } return this ; }
public static void gc ( ) { RUNTIME . gc ( ) ; }
private synchronized void initRegistry ( boolean force ) throws MatlabConnectionException { if ( _registry == null || force ) { try { _registry = LocalHostRMIHelper . createRegistry ( _options . getPort ( ) ) ; } catch ( Exception e ) { try { _registry = LocalHostRMIHelper . getRegistry ( _options . getPort ( ) ) ; } catch ( Exception ex ) { throw new MatlabConnectionException ( STRING , ex ) ; } } } }
private synchronized void initRegistry ( boolean force ) throws MatlabConnectionException { if ( _registry == null || force ) { try { _registry = LocalHostRMIHelper . createRegistry ( _options . getPort ( ) ) ; } catch ( Exception e ) { try { _registry = LocalHostRMIHelper . getRegistry ( _options . getPort ( ) ) ; } catch ( Exception ex ) { throw new MatlabConnectionException ( STRING , ex ) ; } } } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public void addBaudRate ( double baudRate ) { if ( baudRates == null ) { return ; } baudRates . add ( new Double ( baudRate ) ) ; if ( bandwidth < _NUM || baudRate < bandwidth ) { bandwidth = baudRate ; } }
public synchronized void addChannelToHistory ( String channel ) { if ( ! settings . getBoolean ( STRING ) ) { return ; } channel = prepareChannel ( channel ) ; if ( channel == null ) { return ; } settings . mapPut ( HISTORY_SETTING , channel , System . currentTimeMillis ( ) ) ; settings . setSettingChanged ( STRING ) ; }
protected void listenToLayers ( Layer [ ] newLayers ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { listenToLayersFromEDT ( newLayers ) ; } else { SwingUtilities . invokeLater ( new MyWorker ( newLayers ) ) ; } }
protected void listenToLayers ( Layer [ ] newLayers ) { if ( SwingUtilities . isEventDispatchThread ( ) ) { listenToLayersFromEDT ( newLayers ) ; } else { SwingUtilities . invokeLater ( new MyWorker ( newLayers ) ) ; } }
static File createSegmentFile ( String name , File directory , long id , long version ) { return new File ( directory , String . format ( STRING , Assert . notNull ( name , STRING ) , id , version ) ) ; }
public boolean evaluateIsZero ( final Vector v ) { return Math . abs ( evaluate ( v ) ) < MINIMUM_RESOLUTION ; }
public static String normalizeInet4Address ( String ip4String ) { final int [ ] octets = parseInet4Address ( ip4String ) ; if ( octets == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i > _NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . toString ( ) ; }
public static String normalizeInet4Address ( String ip4String ) { final int [ ] octets = parseInet4Address ( ip4String ) ; if ( octets == null ) { return null ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < _NUM ; i ++ ) { if ( i > _NUM ) { sb . append ( STRING ) ; } sb . append ( octets [ i ] ) ; } return sb . toString ( ) ; }
public void removeCookie ( String url ) { cookieJar . remove ( url ) ; }
public void addDataSet ( T d ) { if ( d == null ) return ; calcMinMax ( d ) ; mDataSets . add ( d ) ; }
public void addDataSet ( T d ) { if ( d == null ) return ; calcMinMax ( d ) ; mDataSets . add ( d ) ; }
void create ( OutputStream out , Manifest manifest ) throws IOException { ZipOutputStream zos = new JarOutputStream ( out ) ; if ( flag0 ) { zos . setMethod ( ZipOutputStream . STORED ) ; } if ( manifest != null ) { if ( vflag ) { output ( getMsg ( STRING ) ) ; } ZipEntry e = new ZipEntry ( MANIFEST_DIR ) ; e . setTime ( System . currentTimeMillis ( ) ) ; e . setSize ( _NUM ) ; e . setCrc ( _NUM ) ; zos . putNextEntry ( e ) ; e = new ZipEntry ( MANIFEST_NAME ) ; e . setTime ( System . currentTimeMillis ( ) ) ; if ( flag0 ) { crc32Manifest ( e , manifest ) ; } zos . putNextEntry ( e ) ; manifest . write ( zos ) ; zos . closeEntry ( ) ; } for ( File file : entries ) { addFile ( zos , file ) ; } zos . close ( ) ; }
public static boolean isLocalResourceUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_RESOURCE_SCHEME . equals ( scheme ) ; }
public static boolean isLocalResourceUri ( Uri uri ) { final String scheme = getSchemeOrNull ( uri ) ; return LOCAL_RESOURCE_SCHEME . equals ( scheme ) ; }
public void addGroups ( String [ ] newGroups ) throws IOException { testArrayForNullElement ( newGroups ) ; checkGroups ( newGroups ) ; synchronized ( registrars ) { if ( terminated ) throw new IllegalStateException ( STRING ) ; if ( groups == null ) throw new UnsupportedOperationException ( STRING ) ; Collection req = new ArrayList ( newGroups . length ) ; for ( int i = _NUM ; i < newGroups . length ; i ++ ) { if ( groups . add ( newGroups [ i ] ) ) req . add ( newGroups [ i ] ) ; } if ( ! req . isEmpty ( ) ) requestGroups ( req ) ; } }
public void addGroups ( String [ ] newGroups ) throws IOException { testArrayForNullElement ( newGroups ) ; checkGroups ( newGroups ) ; synchronized ( registrars ) { if ( terminated ) throw new IllegalStateException ( STRING ) ; if ( groups == null ) throw new UnsupportedOperationException ( STRING ) ; Collection req = new ArrayList ( newGroups . length ) ; for ( int i = _NUM ; i < newGroups . length ; i ++ ) { if ( groups . add ( newGroups [ i ] ) ) req . add ( newGroups [ i ] ) ; } if ( ! req . isEmpty ( ) ) requestGroups ( req ) ; } }
public void addGroups ( String [ ] newGroups ) throws IOException { testArrayForNullElement ( newGroups ) ; checkGroups ( newGroups ) ; synchronized ( registrars ) { if ( terminated ) throw new IllegalStateException ( STRING ) ; if ( groups == null ) throw new UnsupportedOperationException ( STRING ) ; Collection req = new ArrayList ( newGroups . length ) ; for ( int i = _NUM ; i < newGroups . length ; i ++ ) { if ( groups . add ( newGroups [ i ] ) ) req . add ( newGroups [ i ] ) ; } if ( ! req . isEmpty ( ) ) requestGroups ( req ) ; } }
private void addReminder ( ) { if ( mDefaultReminderMinutes == GeneralPreferences . NO_REMINDER ) { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( GeneralPreferences . REMINDER_DEFAULT_TIME ) , mModel . mCalendarMaxReminders , null ) ; } else { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( mDefaultReminderMinutes ) , mModel . mCalendarMaxReminders , null ) ; } updateRemindersVisibility ( mReminderItems . size ( ) ) ; EventViewUtils . updateAddReminderButton ( mView , mReminderItems , mModel . mCalendarMaxReminders ) ; }
private void addReminder ( ) { if ( mDefaultReminderMinutes == GeneralPreferences . NO_REMINDER ) { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( GeneralPreferences . REMINDER_DEFAULT_TIME ) , mModel . mCalendarMaxReminders , null ) ; } else { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( mDefaultReminderMinutes ) , mModel . mCalendarMaxReminders , null ) ; } updateRemindersVisibility ( mReminderItems . size ( ) ) ; EventViewUtils . updateAddReminderButton ( mView , mReminderItems , mModel . mCalendarMaxReminders ) ; }
private void addReminder ( ) { if ( mDefaultReminderMinutes == GeneralPreferences . NO_REMINDER ) { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( GeneralPreferences . REMINDER_DEFAULT_TIME ) , mModel . mCalendarMaxReminders , null ) ; } else { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( mDefaultReminderMinutes ) , mModel . mCalendarMaxReminders , null ) ; } updateRemindersVisibility ( mReminderItems . size ( ) ) ; EventViewUtils . updateAddReminderButton ( mView , mReminderItems , mModel . mCalendarMaxReminders ) ; }
private void addReminder ( ) { if ( mDefaultReminderMinutes == GeneralPreferences . NO_REMINDER ) { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( GeneralPreferences . REMINDER_DEFAULT_TIME ) , mModel . mCalendarMaxReminders , null ) ; } else { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( mDefaultReminderMinutes ) , mModel . mCalendarMaxReminders , null ) ; } updateRemindersVisibility ( mReminderItems . size ( ) ) ; EventViewUtils . updateAddReminderButton ( mView , mReminderItems , mModel . mCalendarMaxReminders ) ; }
private void addReminder ( ) { if ( mDefaultReminderMinutes == GeneralPreferences . NO_REMINDER ) { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( GeneralPreferences . REMINDER_DEFAULT_TIME ) , mModel . mCalendarMaxReminders , null ) ; } else { EventViewUtils . addReminder ( mActivity , mScrollView , this , mReminderItems , mReminderMinuteValues , mReminderMinuteLabels , mReminderMethodValues , mReminderMethodLabels , ReminderEntry . valueOf ( mDefaultReminderMinutes ) , mModel . mCalendarMaxReminders , null ) ; } updateRemindersVisibility ( mReminderItems . size ( ) ) ; EventViewUtils . updateAddReminderButton ( mView , mReminderItems , mModel . mCalendarMaxReminders ) ; }
public Second ( Date time , TimeZone zone , Locale locale ) { Calendar calendar = Calendar . getInstance ( zone , locale ) ; calendar . setTime ( time ) ; this . second = ( byte ) calendar . get ( Calendar . SECOND ) ; this . minute = ( byte ) calendar . get ( Calendar . MINUTE ) ; this . hour = ( byte ) calendar . get ( Calendar . HOUR_OF_DAY ) ; this . day = new Day ( time , zone , locale ) ; peg ( calendar ) ; }
public StrBuilder replaceAll ( String searchStr , String replaceStr ) { int searchLen = ( searchStr == null ? _NUM : searchStr . length ( ) ) ; if ( searchLen > _NUM ) { int replaceLen = ( replaceStr == null ? _NUM : replaceStr . length ( ) ) ; int index = indexOf ( searchStr , _NUM ) ; while ( index >= _NUM ) { replaceImpl ( index , index + searchLen , searchLen , replaceStr , replaceLen ) ; index = indexOf ( searchStr , index + replaceLen ) ; } } return this ; }
public StrBuilder replaceAll ( String searchStr , String replaceStr ) { int searchLen = ( searchStr == null ? _NUM : searchStr . length ( ) ) ; if ( searchLen > _NUM ) { int replaceLen = ( replaceStr == null ? _NUM : replaceStr . length ( ) ) ; int index = indexOf ( searchStr , _NUM ) ; while ( index >= _NUM ) { replaceImpl ( index , index + searchLen , searchLen , replaceStr , replaceLen ) ; index = indexOf ( searchStr , index + replaceLen ) ; } } return this ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
public RecordedRequest takeRequest ( ) throws InterruptedException { return requestQueue . take ( ) ; }
public StringConverter ( final int lengthLimit ) { this ( Collections . synchronizedMap ( new WeakCache < String , String > ( ) ) , lengthLimit ) ; }
public StringConverter ( final int lengthLimit ) { this ( Collections . synchronizedMap ( new WeakCache < String , String > ( ) ) , lengthLimit ) ; }
public StringConverter ( final int lengthLimit ) { this ( Collections . synchronizedMap ( new WeakCache < String , String > ( ) ) , lengthLimit ) ; }
public StringConverter ( final int lengthLimit ) { this ( Collections . synchronizedMap ( new WeakCache < String , String > ( ) ) , lengthLimit ) ; }
public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( ValidationErrorObject error : errors ) { stringBuilder . append ( error . toString ( ) ) ; } return stringBuilder . toString ( ) ; }
public String toString ( ) { StringBuilder stringBuilder = new StringBuilder ( ) ; for ( ValidationErrorObject error : errors ) { stringBuilder . append ( error . toString ( ) ) ; } return stringBuilder . toString ( ) ; }
private static void readDataFromBinlog ( ReplicatorRuntime runtime , BinlogReader binlog , byte [ ] data , int offset , int length , int timeout ) throws IOException , ReplicatorException , InterruptedException { boolean alreadyLogged = _BOOL ; int spentTime = _NUM ; int timeoutInMs = timeout * _NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! alreadyLogged ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . getFileName ( ) + STRING ) ; } alreadyLogged = _BOOL ; } try { if ( spentTime < timeoutInMs ) { Thread . sleep ( _NUM ) ; spentTime ++ ; } else throw new MySQLExtractException ( STRING + timeout + STRING + length + STRING ) ; } catch ( InterruptedException e ) { } } binlog . read ( data , offset , length ) ; }
private static void readDataFromBinlog ( ReplicatorRuntime runtime , BinlogReader binlog , byte [ ] data , int offset , int length , int timeout ) throws IOException , ReplicatorException , InterruptedException { boolean alreadyLogged = _BOOL ; int spentTime = _NUM ; int timeoutInMs = timeout * _NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! alreadyLogged ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . getFileName ( ) + STRING ) ; } alreadyLogged = _BOOL ; } try { if ( spentTime < timeoutInMs ) { Thread . sleep ( _NUM ) ; spentTime ++ ; } else throw new MySQLExtractException ( STRING + timeout + STRING + length + STRING ) ; } catch ( InterruptedException e ) { } } binlog . read ( data , offset , length ) ; }
private static void readDataFromBinlog ( ReplicatorRuntime runtime , BinlogReader binlog , byte [ ] data , int offset , int length , int timeout ) throws IOException , ReplicatorException , InterruptedException { boolean alreadyLogged = _BOOL ; int spentTime = _NUM ; int timeoutInMs = timeout * _NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! alreadyLogged ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . getFileName ( ) + STRING ) ; } alreadyLogged = _BOOL ; } try { if ( spentTime < timeoutInMs ) { Thread . sleep ( _NUM ) ; spentTime ++ ; } else throw new MySQLExtractException ( STRING + timeout + STRING + length + STRING ) ; } catch ( InterruptedException e ) { } } binlog . read ( data , offset , length ) ; }
private static void readDataFromBinlog ( ReplicatorRuntime runtime , BinlogReader binlog , byte [ ] data , int offset , int length , int timeout ) throws IOException , ReplicatorException , InterruptedException { boolean alreadyLogged = _BOOL ; int spentTime = _NUM ; int timeoutInMs = timeout * _NUM ; long available ; while ( ( available = binlog . available ( ) ) < ( long ) length ) { if ( ! alreadyLogged ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING + length + STRING + available + STRING + binlog . getFileName ( ) + STRING ) ; } alreadyLogged = _BOOL ; } try { if ( spentTime < timeoutInMs ) { Thread . sleep ( _NUM ) ; spentTime ++ ; } else throw new MySQLExtractException ( STRING + timeout + STRING + length + STRING ) ; } catch ( InterruptedException e ) { } } binlog . read ( data , offset , length ) ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { AssertionError ae = new AssertionError ( prefix + message ) ; CompositeException ce = new CompositeException ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . addSuppressed ( new NullPointerException ( STRING ) ) ; } else { ce . addSuppressed ( e ) ; } } ae . initCause ( ce ) ; isPassing = _BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { AssertionError ae = new AssertionError ( prefix + message ) ; CompositeException ce = new CompositeException ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . addSuppressed ( new NullPointerException ( STRING ) ) ; } else { ce . addSuppressed ( e ) ; } } ae . initCause ( ce ) ; isPassing = _BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { AssertionError ae = new AssertionError ( prefix + message ) ; CompositeException ce = new CompositeException ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . addSuppressed ( new NullPointerException ( STRING ) ) ; } else { ce . addSuppressed ( e ) ; } } ae . initCause ( ce ) ; isPassing = _BOOL ; }
private void fail ( String prefix , String message , Iterable < ? extends Throwable > errors ) { AssertionError ae = new AssertionError ( prefix + message ) ; CompositeException ce = new CompositeException ( ) ; for ( Throwable e : errors ) { if ( e == null ) { ce . addSuppressed ( new NullPointerException ( STRING ) ) ; } else { ce . addSuppressed ( e ) ; } } ae . initCause ( ce ) ; isPassing = _BOOL ; }
public void declareDimension ( final int dimensionType , final int scale , final int pixelperscale , final int offset , final Long colorNaming , final Long colorScale , final String name ) { this . scales [ dimensionType ] = Math . max ( _NUM , scale ) ; this . pixels [ dimensionType ] = pixelperscale ; this . offsets [ dimensionType ] = offset ; this . colnames [ dimensionType ] = colorNaming ; this . colscale [ dimensionType ] = colorScale ; this . tablenames [ dimensionType ] = name ; if ( ( dimensionType == DIMENSION_LEFT ) || ( dimensionType == DIMENSION_RIGHT ) ) { drawVerticalScale ( ( dimensionType == DIMENSION_LEFT ) , scale , pixelperscale , offset , colorNaming , colorScale , name ) ; } if ( ( dimensionType == DIMENSION_TOP ) || ( dimensionType == DIMENSION_BOTTOM ) ) { drawHorizontalScale ( ( dimensionType == DIMENSION_TOP ) , scale , pixelperscale , offset , colorNaming , colorScale , name ) ; } }
protected boolean postlexicalRules ( Element token , AllophoneSet allophoneSet ) { return _BOOL ; }
protected boolean postlexicalRules ( Element token , AllophoneSet allophoneSet ) { return _BOOL ; }
public static boolean somePermissionPermanentlyDenied ( Object object , List < String > deniedPermissions ) { for ( String deniedPermission : deniedPermissions ) { if ( permissionPermanentlyDenied ( object , deniedPermission ) ) { return _BOOL ; } } return _BOOL ; }
public static void globalsPutAll ( TemplateHashModel hashModel , Set < String > inExKeys , Boolean include , Environment env ) throws TemplateModelException { varsPutAll ( hashModel , inExKeys , include , new GlobalFtlVarHandler ( env ) , env ) ; }
protected void addSourceCodeRemark ( TestSolution testSolution , Element element , String messageCode , EvidenceElement evidenceElement ) { if ( evidenceElement != null ) { Collection < EvidenceElement > evidenceElementList = new ArrayList < > ( ) ; evidenceElementList . add ( evidenceElement ) ; processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode , evidenceElementList ) ; } else { processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode ) ; } }
protected void addSourceCodeRemark ( TestSolution testSolution , Element element , String messageCode , EvidenceElement evidenceElement ) { if ( evidenceElement != null ) { Collection < EvidenceElement > evidenceElementList = new ArrayList < > ( ) ; evidenceElementList . add ( evidenceElement ) ; processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode , evidenceElementList ) ; } else { processRemarkService . addSourceCodeRemarkOnElement ( testSolution , element , messageCode ) ; } }
public String search ( ) throws Exception { executeQuery ( ) ; return SUCCESS ; }
public void addChild ( Component child ) { components . add ( child ) ; child . setParent ( this ) ; }
public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; }
public static URI changeScheme ( URI bindAddr , String scheme ) throws URISyntaxException { return new URI ( scheme , bindAddr . getUserInfo ( ) , bindAddr . getHost ( ) , bindAddr . getPort ( ) , bindAddr . getPath ( ) , bindAddr . getQuery ( ) , bindAddr . getFragment ( ) ) ; }
public synchronized void drawMap ( ) { lastDrawMapReq = System . currentTimeMillis ( ) ; SwingUtilities . invokeLater ( drawMapable ) ; }
public synchronized void drawMap ( ) { lastDrawMapReq = System . currentTimeMillis ( ) ; SwingUtilities . invokeLater ( drawMapable ) ; }
public void addValue ( int v ) { incrementValue ( Long . valueOf ( v ) , _NUM ) ; }
void implReset ( ) { System . arraycopy ( initialHashes , _NUM , state , _NUM , state . length ) ; }
private UnManagedConsistencyGroup createUnManagedCG ( String unManagedCGNativeGuid , XtremIOConsistencyGroup consistencyGroup , URI storageSystemURI , DbClient dbClient ) { UnManagedConsistencyGroup unManagedCG = new UnManagedConsistencyGroup ( ) ; unManagedCG . setId ( URIUtil . createId ( UnManagedConsistencyGroup . class ) ) ; unManagedCG . setLabel ( consistencyGroup . getName ( ) ) ; unManagedCG . setName ( consistencyGroup . getName ( ) ) ; unManagedCG . setNativeGuid ( unManagedCGNativeGuid ) ; unManagedCG . setStorageSystemUri ( storageSystemURI ) ; unManagedCG . setNumberOfVols ( consistencyGroup . getNumOfVols ( ) ) ; dbClient . createObject ( unManagedCG ) ; return unManagedCG ; }
private UnManagedConsistencyGroup createUnManagedCG ( String unManagedCGNativeGuid , XtremIOConsistencyGroup consistencyGroup , URI storageSystemURI , DbClient dbClient ) { UnManagedConsistencyGroup unManagedCG = new UnManagedConsistencyGroup ( ) ; unManagedCG . setId ( URIUtil . createId ( UnManagedConsistencyGroup . class ) ) ; unManagedCG . setLabel ( consistencyGroup . getName ( ) ) ; unManagedCG . setName ( consistencyGroup . getName ( ) ) ; unManagedCG . setNativeGuid ( unManagedCGNativeGuid ) ; unManagedCG . setStorageSystemUri ( storageSystemURI ) ; unManagedCG . setNumberOfVols ( consistencyGroup . getNumOfVols ( ) ) ; dbClient . createObject ( unManagedCG ) ; return unManagedCG ; }
public void startElement ( String uri , String name , String qName , Attributes atts ) throws SAXException { if ( name . equalsIgnoreCase ( GMLConstants . GML_POLYGON ) ) { currGeomHandler = new GMLHandler ( fact , null ) ; } if ( currGeomHandler != null ) currGeomHandler . startElement ( uri , name , qName , atts ) ; if ( currGeomHandler == null ) { lastEltName = name ; } }
public void startElement ( String uri , String name , String qName , Attributes atts ) throws SAXException { if ( name . equalsIgnoreCase ( GMLConstants . GML_POLYGON ) ) { currGeomHandler = new GMLHandler ( fact , null ) ; } if ( currGeomHandler != null ) currGeomHandler . startElement ( uri , name , qName , atts ) ; if ( currGeomHandler == null ) { lastEltName = name ; } }
public void startElement ( String uri , String name , String qName , Attributes atts ) throws SAXException { if ( name . equalsIgnoreCase ( GMLConstants . GML_POLYGON ) ) { currGeomHandler = new GMLHandler ( fact , null ) ; } if ( currGeomHandler != null ) currGeomHandler . startElement ( uri , name , qName , atts ) ; if ( currGeomHandler == null ) { lastEltName = name ; } }
private boolean initEventCursor ( ) { if ( ( mEventCursor == null ) || ( mEventCursor . getCount ( ) == _NUM ) ) { return _BOOL ; } mEventCursor . moveToFirst ( ) ; mEventId = mEventCursor . getInt ( EVENT_INDEX_ID ) ; String rRule = mEventCursor . getString ( EVENT_INDEX_RRULE ) ; mIsRepeating = ! TextUtils . isEmpty ( rRule ) ; mHasAlarm = ( mEventCursor . getInt ( EVENT_INDEX_HAS_ALARM ) == _NUM ) ? _BOOL : ( mReminders != null && mReminders . size ( ) > _NUM ) ; mMaxReminders = mEventCursor . getInt ( EVENT_INDEX_MAX_REMINDERS ) ; mCalendarAllowedReminders = mEventCursor . getString ( EVENT_INDEX_ALLOWED_REMINDERS ) ; return _BOOL ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
public void add ( Gondola gondola ) { extras . add ( gondola ) ; }
private String splitNameWithoutGzipExtension ( String split ) throws IOException { if ( split == null ) { throw new IOException ( STRING ) ; } if ( split . endsWith ( STRING ) ) { return split . substring ( _NUM , split . length ( ) - _NUM ) ; } return split ; }
private String splitNameWithoutGzipExtension ( String split ) throws IOException { if ( split == null ) { throw new IOException ( STRING ) ; } if ( split . endsWith ( STRING ) ) { return split . substring ( _NUM , split . length ( ) - _NUM ) ; } return split ; }
private String splitNameWithoutGzipExtension ( String split ) throws IOException { if ( split == null ) { throw new IOException ( STRING ) ; } if ( split . endsWith ( STRING ) ) { return split . substring ( _NUM , split . length ( ) - _NUM ) ; } return split ; }
private String splitNameWithoutGzipExtension ( String split ) throws IOException { if ( split == null ) { throw new IOException ( STRING ) ; } if ( split . endsWith ( STRING ) ) { return split . substring ( _NUM , split . length ( ) - _NUM ) ; } return split ; }
private String splitNameWithoutGzipExtension ( String split ) throws IOException { if ( split == null ) { throw new IOException ( STRING ) ; } if ( split . endsWith ( STRING ) ) { return split . substring ( _NUM , split . length ( ) - _NUM ) ; } return split ; }
private void readHeader ( ) throws IOException { byte [ ] signatureBytes = new byte [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) signatureBytes [ i ] = plogStream . readByte ( ) ; String stringifiedHeader = new String ( signatureBytes , STRING ) ; if ( ! stringifiedHeader . equals ( STRING ) ) { throw new IOException ( STRING ) ; } int major_file_version = readSwappedInteger ( plogStream ) ; int minor_file_version = readSwappedInteger ( plogStream ) ; if ( major_file_version != _NUM || minor_file_version != _NUM ) { throw new IOException ( STRING + major_file_version + STRING + minor_file_version + STRING ) ; } logger . info ( STRING ) ; return ; }
private void readHeader ( ) throws IOException { byte [ ] signatureBytes = new byte [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) signatureBytes [ i ] = plogStream . readByte ( ) ; String stringifiedHeader = new String ( signatureBytes , STRING ) ; if ( ! stringifiedHeader . equals ( STRING ) ) { throw new IOException ( STRING ) ; } int major_file_version = readSwappedInteger ( plogStream ) ; int minor_file_version = readSwappedInteger ( plogStream ) ; if ( major_file_version != _NUM || minor_file_version != _NUM ) { throw new IOException ( STRING + major_file_version + STRING + minor_file_version + STRING ) ; } logger . info ( STRING ) ; return ; }
public Request cookie ( String key , String value ) { Objects . requireNonNull ( key ) ; Objects . requireNonNull ( value ) ; _cookies . put ( key , value ) ; return this ; }
public static NetworkInfo fromFriendlyName ( final String friendlyName ) { switch ( friendlyName ) { case STRING : return NetworkInfos . getMainNetworkInfo ( ) ; case STRING : return NetworkInfos . getTestNetworkInfo ( ) ; case STRING : return NetworkInfos . getMijinNetworkInfo ( ) ; } throw new IllegalArgumentException ( String . format ( STRING , friendlyName ) ) ; }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public Object2IntOpenHashMap < int [ ] > supportMap ( ) { List < ItemSet > itemSets = learn ( ) ; Object2IntOpenHashMap < int [ ] > confidenceMap = new Object2IntOpenHashMap < > ( itemSets . size ( ) ) ; for ( ItemSet itemSet : itemSets ) { confidenceMap . put ( itemSet . items , itemSet . support ) ; } return confidenceMap ; }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_lang_Runtime_execInternal ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public void simulateMethod ( SootMethod method , ReferenceVariable thisVar , ReferenceVariable returnVar , ReferenceVariable params [ ] ) { String subSignature = method . getSubSignature ( ) ; if ( subSignature . equals ( STRING ) ) { java_lang_Runtime_execInternal ( method , thisVar , returnVar , params ) ; return ; } else { defaultMethod ( method , thisVar , returnVar , params ) ; return ; } }
public void notifyDevelopers ( String subject , String message ) throws JPlagException { NodeList userList = rootElement . getElementsByTagName ( STRING ) ; for ( int i = _NUM ; i < userList . getLength ( ) ; i ++ ) { Element elem = ( Element ) userList . item ( i ) ; if ( ( parseInt ( elem , STRING ) & MASK_DEVELOPER ) != _NUM ) sendMail ( elem . getAttribute ( STRING ) , subject , message ) ; } }
private LogicalMetric extractMetric ( Matcher tokenizedQuery , MetricDictionary metricDictionary ) throws BadHavingException { String metricName = tokenizedQuery . group ( _NUM ) ; LogicalMetric extractedMetric = metricDictionary . get ( metricName ) ; if ( extractedMetric == null ) { LOG . debug ( HAVING_METRIC_UNDEFINED . logFormat ( metricName ) ) ; throw new BadHavingException ( HAVING_METRIC_UNDEFINED . logFormat ( metricName ) ) ; } return extractedMetric ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
public static void waitForProcessOutput ( Process self , Appendable output , Appendable error ) { Thread tout = consumeProcessOutputStream ( self , output ) ; Thread terr = consumeProcessErrorStream ( self , error ) ; try { tout . join ( ) ; } catch ( InterruptedException ignore ) { } try { terr . join ( ) ; } catch ( InterruptedException ignore ) { } try { self . waitFor ( ) ; } catch ( InterruptedException ignore ) { } closeStreams ( self ) ; }
@ RequestMapping ( value = STRING , method = RequestMethod . GET ) public String updateAllPodcasts ( ModelMap model ) { LOG . debug ( STRING ) ; Integer numberOfWorkerThreads = Integer . valueOf ( configBean . get ( STRING ) ) ; if ( numberOfWorkerThreads == null ) { numberOfWorkerThreads = DEFAULT_NO_WORKER_THREADS_FOR_UPDATE_ALL_PODCASTS ; } Integer totalNumberOfPodcasts = readService . getNumberOfPodcasts ( ) ; Integer mod = totalNumberOfPodcasts % numberOfWorkerThreads ; Integer chunkSize = totalNumberOfPodcasts / numberOfWorkerThreads ; for ( int i = _NUM ; i < numberOfWorkerThreads ; i ++ ) { int startRow = i * chunkSize ; if ( i == numberOfWorkerThreads - _NUM ) { chunkSize = chunkSize + mod ; LOG . debug ( STRING + i + STRING + startRow + STRING + chunkSize + STRING ) ; Future < String > future = batchUpdateService . updatePodcastsFromRange ( startRow , chunkSize ) ; } else { LOG . debug ( STRING + i + STRING + startRow + STRING + chunkSize + STRING ) ; batchUpdateService . updatePodcastsFromRange ( startRow , chunkSize ) ; } } restClient . invokeRefreshAllCaches ( ) ; return STRING ; }
private void captureDifferentSet ( Set < String > oldSet , Set < String > newSet , Map < String , Set < String > > map , String appName ) { Reject . ifNull ( appName ) ; Reject . ifNull ( map ) ; if ( oldSet == null && newSet == null ) { map . put ( appName , Collections . < String > emptySet ( ) ) ; } else if ( newSet != null && ! newSet . equals ( oldSet ) ) { map . put ( appName , newSet ) ; } }
@ SuppressWarnings ( STRING ) public static AbstractLiteralIV createInlineIV ( final BigInteger value ) { if ( value . compareTo ( MAX_UNSIGNED_LONG_AS_BIGINT ) >= _NUM ) { return new XSDIntegerIV ( value ) ; } return createInlineIV ( value . longValue ( ) ) ; }
@ SuppressWarnings ( STRING ) public static AbstractLiteralIV createInlineIV ( final BigInteger value ) { if ( value . compareTo ( MAX_UNSIGNED_LONG_AS_BIGINT ) >= _NUM ) { return new XSDIntegerIV ( value ) ; } return createInlineIV ( value . longValue ( ) ) ; }
@ SuppressWarnings ( STRING ) public static AbstractLiteralIV createInlineIV ( final BigInteger value ) { if ( value . compareTo ( MAX_UNSIGNED_LONG_AS_BIGINT ) >= _NUM ) { return new XSDIntegerIV ( value ) ; } return createInlineIV ( value . longValue ( ) ) ; }
public String toXMLString ( boolean includeNS , boolean declareNS ) throws FSMsgException { return toXMLString ( includeNS , declareNS , _BOOL ) ; }
public String toXMLString ( boolean includeNS , boolean declareNS ) throws FSMsgException { return toXMLString ( includeNS , declareNS , _BOOL ) ; }
public String toXMLString ( boolean includeNS , boolean declareNS ) throws FSMsgException { return toXMLString ( includeNS , declareNS , _BOOL ) ; }
public HttpRequest ( Method method , HttpURI uri ) { this ( method , uri , _BOOL ) ; }
public void onWifiConnectivityChanged ( boolean connected , final String networkSsid ) { LOGD ( TAG , STRING + ( connected ? STRING : STRING ) ) ; if ( connected && ! mWifiConnectivity ) { mWifiConnectivity = _BOOL ; if ( mCastManager . isFeatureEnabled ( BaseCastManager . FEATURE_WIFI_RECONNECT ) ) { mCastManager . startCastDiscovery ( ) ; mCastManager . reconnectSessionIfPossible ( RECONNECTION_ATTEMPT_PERIOD_S , networkSsid ) ; } } else { mWifiConnectivity = connected ; } }
public void onWifiConnectivityChanged ( boolean connected , final String networkSsid ) { LOGD ( TAG , STRING + ( connected ? STRING : STRING ) ) ; if ( connected && ! mWifiConnectivity ) { mWifiConnectivity = _BOOL ; if ( mCastManager . isFeatureEnabled ( BaseCastManager . FEATURE_WIFI_RECONNECT ) ) { mCastManager . startCastDiscovery ( ) ; mCastManager . reconnectSessionIfPossible ( RECONNECTION_ATTEMPT_PERIOD_S , networkSsid ) ; } } else { mWifiConnectivity = connected ; } }
public static < T1 , T2 > void forEachInBoth ( List < T1 > list1 , List < T2 > list2 , Procedure2 < ? super T1 , ? super T2 > procedure ) { if ( list1 != null && list2 != null ) { if ( list1 . size ( ) == list2 . size ( ) ) { if ( list1 instanceof RandomAccess && list2 instanceof RandomAccess ) { RandomAccessListIterate . forEachInBoth ( list1 , list2 , procedure ) ; } else { Iterator < T1 > iterator1 = list1 . iterator ( ) ; Iterator < T2 > iterator2 = list2 . iterator ( ) ; int size = list2 . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { procedure . value ( iterator1 . next ( ) , iterator2 . next ( ) ) ; } } } else { throw new RuntimeException ( STRING + list1 . size ( ) + STRING + list2 . size ( ) ) ; } } }
public LogStream print ( long l ) { if ( ps != null ) { indent ( ) ; lineBuffer . append ( l ) ; } return this ; }
public void updateLocations ( Iterator iIter ) { if ( ContainerList != null ) ContainerList . clear ( ) ; ContainerList = new ArrayList ( ) ; while ( iIter . hasNext ( ) ) ContainerList . add ( ( Location ) iIter . next ( ) ) ; addBehaviour ( new MigrateBehaviour ( ) ) ; }
private void add ( AnnotateBlock aBlock ) { int size = blocks . size ( ) ; if ( size == _NUM ) { blocks . add ( aBlock ) ; } else { AnnotateBlock lastBlock = ( AnnotateBlock ) blocks . get ( size - _NUM ) ; if ( lastBlock . getRevision ( ) == aBlock . getRevision ( ) ) { lastBlock . setEndLine ( aBlock . getStartLine ( ) ) ; } else { blocks . add ( aBlock ) ; } } }
private void add ( AnnotateBlock aBlock ) { int size = blocks . size ( ) ; if ( size == _NUM ) { blocks . add ( aBlock ) ; } else { AnnotateBlock lastBlock = ( AnnotateBlock ) blocks . get ( size - _NUM ) ; if ( lastBlock . getRevision ( ) == aBlock . getRevision ( ) ) { lastBlock . setEndLine ( aBlock . getStartLine ( ) ) ; } else { blocks . add ( aBlock ) ; } } }
private void add ( AnnotateBlock aBlock ) { int size = blocks . size ( ) ; if ( size == _NUM ) { blocks . add ( aBlock ) ; } else { AnnotateBlock lastBlock = ( AnnotateBlock ) blocks . get ( size - _NUM ) ; if ( lastBlock . getRevision ( ) == aBlock . getRevision ( ) ) { lastBlock . setEndLine ( aBlock . getStartLine ( ) ) ; } else { blocks . add ( aBlock ) ; } } }
public void addWatcher ( AngularObjectWatcher watcher ) { synchronized ( watchers ) { watchers . add ( watcher ) ; } }
protected boolean existsInRange ( String x , int minLength , int maxLength ) { x = StringUtils . trimToNull ( x ) ; return x != null && x . length ( ) >= minLength && x . length ( ) <= maxLength ; }
protected boolean existsInRange ( String x , int minLength , int maxLength ) { x = StringUtils . trimToNull ( x ) ; return x != null && x . length ( ) >= minLength && x . length ( ) <= maxLength ; }
public byte [ ] decode ( String s ) { byte [ ] b = new byte [ ( s . length ( ) / _NUM ) * _NUM ] ; int cycle = _NUM ; int combined = _NUM ; int j = _NUM ; int len = s . length ( ) ; int dummies = _NUM ; for ( int i = _NUM ; i < len ; i ++ ) { int c = s . charAt ( i ) ; int value = ( c <= _NUM ) ? charToValue [ c ] : IGNORE ; switch ( value ) { case IGNORE : break ; case PAD : value = _NUM ; dummies ++ ; default : switch ( cycle ) { case _NUM : combined = value ; cycle = _NUM ; break ; case _NUM : combined <<= _NUM ; combined |= value ; cycle = _NUM ; break ; case _NUM : combined <<= _NUM ; combined |= value ; cycle = _NUM ; break ; case _NUM : combined <<= _NUM ; combined |= value ; b [ j + _NUM ] = ( byte ) combined ; combined >>>= _NUM ; b [ j + _NUM ] = ( byte ) combined ; combined >>>= _NUM ; b [ j ] = ( byte ) combined ; j += _NUM ; cycle = _NUM ; break ; } break ; } } if ( cycle != _NUM ) { throw new ArrayIndexOutOfBoundsException ( STRING ) ; } j -= dummies ; if ( b . length != j ) { byte [ ] b2 = new byte [ j ] ; System . arraycopy ( b , _NUM , b2 , _NUM , j ) ; b = b2 ; } return b ; }
public static boolean validSystemNameConfig ( String systemName , char type , SerialTrafficController tc ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } SerialNode node = ( SerialNode ) getNodeFromSystemName ( systemName , tc ) ; if ( node == null ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > ( node . numOutputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > ( node . numInputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type , SerialTrafficController tc ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } SerialNode node = ( SerialNode ) getNodeFromSystemName ( systemName , tc ) ; if ( node == null ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > ( node . numOutputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > ( node . numInputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
public static boolean validSystemNameConfig ( String systemName , char type , SerialTrafficController tc ) { if ( ! validSystemNameFormat ( systemName , type ) ) { return _BOOL ; } SerialNode node = ( SerialNode ) getNodeFromSystemName ( systemName , tc ) ; if ( node == null ) { return _BOOL ; } int bit = getBitFromSystemName ( systemName ) ; if ( ( type == STRING ) || ( type == STRING ) ) { if ( ( bit <= _NUM ) || ( bit > ( node . numOutputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else if ( type == STRING ) { if ( ( bit <= _NUM ) || ( bit > ( node . numInputCards ( ) * node . getNumBitsPerCard ( ) ) ) ) { return _BOOL ; } } else { log . error ( STRING ) ; return _BOOL ; } return _BOOL ; }
private static File stream2file ( InputStream in , String suffix ) throws IOException { final File tempFile = File . createTempFile ( PREFIX , suffix ) ; try ( FileOutputStream out = new FileOutputStream ( tempFile ) ) { IOUtils . copy ( in , out ) ; } return tempFile ; }
public static boolean hasTokenFile ( File tokenFile ) throws IOException { return hasToken ( tokenFile . getParentFile ( ) , tokenFile . getName ( ) ) ; }
public static boolean hasTokenFile ( File tokenFile ) throws IOException { return hasToken ( tokenFile . getParentFile ( ) , tokenFile . getName ( ) ) ; }
public synchronized void resizeMatrix ( int newsize ) throws IOException { if ( newsize >= _NUM ) { throw new RuntimeException ( STRING ) ; } if ( ! array . isWritable ( ) ) { throw new IOException ( STRING ) ; } array . resizeFile ( arraysize ( newsize ) ) ; this . matrixsize = newsize ; ByteBuffer header = array . getExtraHeader ( ) ; header . putInt ( this . matrixsize ) ; }
public synchronized void resizeMatrix ( int newsize ) throws IOException { if ( newsize >= _NUM ) { throw new RuntimeException ( STRING ) ; } if ( ! array . isWritable ( ) ) { throw new IOException ( STRING ) ; } array . resizeFile ( arraysize ( newsize ) ) ; this . matrixsize = newsize ; ByteBuffer header = array . getExtraHeader ( ) ; header . putInt ( this . matrixsize ) ; }
public static String decodeCharset ( String s , String charset ) { if ( s == null ) { return null ; } try { byte buf [ ] = s . getBytes ( ASCII_CHARSET ) ; return ( new String ( buf , _NUM , buf . length , charset ) ) ; } catch ( UnsupportedEncodingException uee ) { return s ; } }
public void adjust ( Collection < MapNode > nodes ) { for ( MapNode node : nodes ) { if ( Float . isNaN ( latMin ) ) { latMin = latMax = node . getLat ( ) ; lonMin = lonMax = node . getLon ( ) ; } else if ( node . hasPosition ( ) ) { if ( node . getLat ( ) < latMin ) latMin = node . getLat ( ) ; else if ( node . getLat ( ) > latMax ) latMax = node . getLat ( ) ; if ( node . getLon ( ) < lonMin ) lonMin = node . getLon ( ) ; else if ( node . getLon ( ) > lonMax ) lonMax = node . getLon ( ) ; } } }
public void adjust ( Collection < MapNode > nodes ) { for ( MapNode node : nodes ) { if ( Float . isNaN ( latMin ) ) { latMin = latMax = node . getLat ( ) ; lonMin = lonMax = node . getLon ( ) ; } else if ( node . hasPosition ( ) ) { if ( node . getLat ( ) < latMin ) latMin = node . getLat ( ) ; else if ( node . getLat ( ) > latMax ) latMax = node . getLat ( ) ; if ( node . getLon ( ) < lonMin ) lonMin = node . getLon ( ) ; else if ( node . getLon ( ) > lonMax ) lonMax = node . getLon ( ) ; } } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
private void readObject ( ObjectInputStream s ) throws IOException , ClassNotFoundException { s . defaultReadObject ( ) ; if ( semIms == null ) { throw new NullPointerException ( ) ; } }
public void startEntity ( String name , XMLResourceIdentifier identifier , String encoding , Augmentations augs ) throws XNIException { if ( fEntityDepth == fEntityStack . length ) { int [ ] entityarray = new int [ fEntityStack . length * _NUM ] ; System . arraycopy ( fEntityStack , _NUM , entityarray , _NUM , fEntityStack . length ) ; fEntityStack = entityarray ; } fEntityStack [ fEntityDepth ] = fMarkupDepth ; super . startEntity ( name , identifier , encoding , augs ) ; if ( fStandalone && fEntityManager . isEntityDeclInExternalSubset ( name ) ) { reportFatalError ( STRING , new Object [ ] { name } ) ; } if ( fDocumentHandler != null && ! fScanningAttribute ) { if ( ! name . equals ( STRING ) ) { fDocumentHandler . startGeneralEntity ( name , identifier , encoding , augs ) ; } } }
public void startEntity ( String name , XMLResourceIdentifier identifier , String encoding , Augmentations augs ) throws XNIException { if ( fEntityDepth == fEntityStack . length ) { int [ ] entityarray = new int [ fEntityStack . length * _NUM ] ; System . arraycopy ( fEntityStack , _NUM , entityarray , _NUM , fEntityStack . length ) ; fEntityStack = entityarray ; } fEntityStack [ fEntityDepth ] = fMarkupDepth ; super . startEntity ( name , identifier , encoding , augs ) ; if ( fStandalone && fEntityManager . isEntityDeclInExternalSubset ( name ) ) { reportFatalError ( STRING , new Object [ ] { name } ) ; } if ( fDocumentHandler != null && ! fScanningAttribute ) { if ( ! name . equals ( STRING ) ) { fDocumentHandler . startGeneralEntity ( name , identifier , encoding , augs ) ; } } }
public void startEntity ( String name , XMLResourceIdentifier identifier , String encoding , Augmentations augs ) throws XNIException { if ( fEntityDepth == fEntityStack . length ) { int [ ] entityarray = new int [ fEntityStack . length * _NUM ] ; System . arraycopy ( fEntityStack , _NUM , entityarray , _NUM , fEntityStack . length ) ; fEntityStack = entityarray ; } fEntityStack [ fEntityDepth ] = fMarkupDepth ; super . startEntity ( name , identifier , encoding , augs ) ; if ( fStandalone && fEntityManager . isEntityDeclInExternalSubset ( name ) ) { reportFatalError ( STRING , new Object [ ] { name } ) ; } if ( fDocumentHandler != null && ! fScanningAttribute ) { if ( ! name . equals ( STRING ) ) { fDocumentHandler . startGeneralEntity ( name , identifier , encoding , augs ) ; } } }
public synchronized void add ( final ClassLoader classLoader ) { cleanup ( ) ; if ( classLoader != null ) { addInternal ( classLoader ) ; } }
private static JList < String > createFileList ( List < String > fileNames ) { JList < String > fileList = new JList < String > ( fileNames . toArray ( new String [ _NUM ] ) ) ; fileList . setVisibleRowCount ( _NUM ) ; fileList . setCellRenderer ( new FileNameListCellRenderer ( ) ) ; fileList . setFocusable ( _BOOL ) ; return fileList ; }
private static JList < String > createFileList ( List < String > fileNames ) { JList < String > fileList = new JList < String > ( fileNames . toArray ( new String [ _NUM ] ) ) ; fileList . setVisibleRowCount ( _NUM ) ; fileList . setCellRenderer ( new FileNameListCellRenderer ( ) ) ; fileList . setFocusable ( _BOOL ) ; return fileList ; }
private void updateMinMax ( Instance instance ) { for ( int j = _NUM ; j < m_instances . numAttributes ( ) ; j ++ ) { if ( ! instance . isMissing ( j ) ) { if ( Double . isNaN ( m_Min [ j ] ) ) { m_Min [ j ] = instance . value ( j ) ; m_Max [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) < m_Min [ j ] ) { m_Min [ j ] = instance . value ( j ) ; } else if ( instance . value ( j ) > m_Max [ j ] ) { m_Max [ j ] = instance . value ( j ) ; } } } }
public ChainIterable < T > addItem ( @ NotNull T item ) { return ( ChainIterable < T > ) super . add ( Collections . < T > singleton ( item ) ) ; }
public boolean isPronounceable ( String word ) { String lowerCaseWord = word . toLowerCase ( ) ; return ( prefixFSM . accept ( lowerCaseWord ) && suffixFSM . accept ( lowerCaseWord ) ) ; }
public boolean isPronounceable ( String word ) { String lowerCaseWord = word . toLowerCase ( ) ; return ( prefixFSM . accept ( lowerCaseWord ) && suffixFSM . accept ( lowerCaseWord ) ) ; }
public void generateSearchPage ( List < ApiService > services ) { List < ApiMethod > allMethods = new ArrayList < ApiMethod > ( ) ; for ( ApiService service : services ) { allMethods . addAll ( service . methods ) ; } int key = _NUM ; for ( ApiMethod method : allMethods ) { method . indexKey = STRING + key ++ ; } Map < String , Object > parameters = new HashMap < String , Object > ( ) ; parameters . put ( STRING , allMethods ) ; parameters . put ( STRING , STRING ) ; addCommonTemplateParameters ( parameters ) ; TemplateEngine . generateFileFromTemplate ( KnownPaths . getTemplateFile ( SEARCH_TEMPLATE ) , KnownPaths . getHtmlOutputFile ( SEARCH_TEMPLATE ) , parameters ) ; }
void update ( long time , int rows ) { count ++ ; executionTimeMin = Math . min ( time , executionTimeMin ) ; executionTimeMax = Math . max ( time , executionTimeMax ) ; rowCountMin = Math . min ( rows , rowCountMin ) ; rowCountMax = Math . max ( rows , rowCountMax ) ; double delta = rows - rowCountMean ; rowCountMean += delta / count ; rowCountM2 += delta * ( rows - rowCountMean ) ; delta = time - executionTimeMean ; executionTimeMean += delta / count ; executionTimeM2 += delta * ( time - executionTimeMean ) ; executionTimeCumulative += time ; rowCountCumulative += rows ; lastUpdateTime = System . currentTimeMillis ( ) ; }
public boolean markTimeIfDelay ( World world , long delay ) { if ( world == null ) { return _BOOL ; } long currentTime = world . getTotalWorldTime ( ) ; if ( currentTime < lastMark ) { lastMark = currentTime ; return _BOOL ; } else if ( lastMark + delay + lastRandomDelay <= currentTime ) { duration = currentTime - lastMark ; lastMark = currentTime ; lastRandomDelay = ( int ) ( Math . random ( ) * randomRange ) ; return _BOOL ; } else { return _BOOL ; } }
public boolean markTimeIfDelay ( World world , long delay ) { if ( world == null ) { return _BOOL ; } long currentTime = world . getTotalWorldTime ( ) ; if ( currentTime < lastMark ) { lastMark = currentTime ; return _BOOL ; } else if ( lastMark + delay + lastRandomDelay <= currentTime ) { duration = currentTime - lastMark ; lastMark = currentTime ; lastRandomDelay = ( int ) ( Math . random ( ) * randomRange ) ; return _BOOL ; } else { return _BOOL ; } }
public void addUrlFeatures ( NutchDocument doc , String urlString ) { try { URL url = new URL ( urlString ) ; StringTokenizer names = new StringTokenizer ( url . getPath ( ) , STRING ) ; if ( names . hasMoreTokens ( ) ) names . nextToken ( ) ; while ( names . hasMoreTokens ( ) ) { String feature = names . nextToken ( ) ; addFeature ( doc , feature ) ; } } catch ( MalformedURLException e ) { if ( LOG . isWarnEnabled ( ) ) { LOG . warn ( STRING + urlString + STRING + e ) ; } } }
public void addActionWithAccelleratorKey ( GPAction action ) { if ( action != null ) { for ( KeyStroke ks : GPAction . getAllKeyStrokes ( action . getID ( ) ) ) { addAction ( action , ks ) ; } } }
public static OutputCatcher start ( ) { return new OutputCatcher ( ) ; }
public RemoverManager track ( Remover remover ) { if ( handlers == null ) { handlers = new ArrayList < > ( ) ; } handlers . add ( remover ) ; return this ; }
public RemoverManager track ( Remover remover ) { if ( handlers == null ) { handlers = new ArrayList < > ( ) ; } handlers . add ( remover ) ; return this ; }
protected Boolean replayCompletion ( Participant participant ) throws IllegalStateException { if ( ! replayStack_ . contains ( participant ) ) { replayStack_ . push ( participant ) ; } return committed_ ; }
protected Boolean replayCompletion ( Participant participant ) throws IllegalStateException { if ( ! replayStack_ . contains ( participant ) ) { replayStack_ . push ( participant ) ; } return committed_ ; }
public long next ( long fromTime ) { if ( getCurrentCount ( ) == _NUM || fromTime == _NUM || fromTime == startDate . getTime ( ) ) { return first ( ) ; } if ( Debug . verboseOn ( ) ) { Debug . logVerbose ( STRING + ( rDateList == null ? _NUM : rDateList . size ( ) ) , module ) ; Debug . logVerbose ( STRING + ( rRulesList == null ? _NUM : rRulesList . size ( ) ) , module ) ; } if ( rDateList == null && rRulesList == null ) { return _NUM ; } long nextRuleTime = fromTime ; boolean hasNext = _BOOL ; Iterator < RecurrenceRule > rulesIterator = getRecurrenceRuleIterator ( ) ; while ( rulesIterator . hasNext ( ) ) { RecurrenceRule rule = rulesIterator . next ( ) ; while ( hasNext ) { nextRuleTime = getNextTime ( rule , nextRuleTime ) ; if ( nextRuleTime == _NUM || isValid ( nextRuleTime ) ) { hasNext = _BOOL ; } } } return nextRuleTime ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mSize >= mKeys . length && ( mGarbage || hasReclaimedRefs ( ) ) ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; WeakReference < ? > [ ] nvalues = new WeakReference [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = new WeakReference ( value ) ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mSize >= mKeys . length && ( mGarbage || hasReclaimedRefs ( ) ) ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; WeakReference < ? > [ ] nvalues = new WeakReference [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = new WeakReference ( value ) ; mSize = pos + _NUM ; }
public void append ( int key , E value ) { if ( mSize != _NUM && key <= mKeys [ mSize - _NUM ] ) { put ( key , value ) ; return ; } if ( mSize >= mKeys . length && ( mGarbage || hasReclaimedRefs ( ) ) ) { gc ( ) ; } int pos = mSize ; if ( pos >= mKeys . length ) { int n = ArrayUtils . idealIntArraySize ( pos + _NUM ) ; int [ ] nkeys = new int [ n ] ; WeakReference < ? > [ ] nvalues = new WeakReference [ n ] ; System . arraycopy ( mKeys , _NUM , nkeys , _NUM , mKeys . length ) ; System . arraycopy ( mValues , _NUM , nvalues , _NUM , mValues . length ) ; mKeys = nkeys ; mValues = nvalues ; } mKeys [ pos ] = key ; mValues [ pos ] = new WeakReference ( value ) ; mSize = pos + _NUM ; }
public void start ( ) { _start = System . nanoTime ( ) ; }
private static String _read_all ( final InputStream is , final int buffer_size ) { final char [ ] buffer = new char [ buffer_size ] ; final StringBuilder out = new StringBuilder ( ) ; try { final Reader in = new InputStreamReader ( is , STRING ) ; try { for ( ; ; ) { int rsz = in . read ( buffer , _NUM , buffer . length ) ; if ( rsz < _NUM ) break ; out . append ( buffer , _NUM , rsz ) ; } } finally { in . close ( ) ; } } catch ( IOException ignored ) { } return out . toString ( ) ; }
public boolean contains ( T item ) { return data . contains ( item ) ; }
public boolean contains ( T item ) { return data . contains ( item ) ; }
public static void checkNotEmpty ( Collection collection ) { if ( collection . isEmpty ( ) ) { throw new NullPointerException ( ) ; } }
public Bindings addOptComponent ( String property , Class clazz , JToggleButton c , boolean enabledByDefault ) { Binding b = new OptComponentBinding ( this , property , clazz , c , enabledByDefault ) ; if ( _optComponents . containsKey ( property ) ) { throw new BindingException ( Messages . getString ( STRING ) ) ; } _optComponents . put ( property , b ) ; return this ; }
public synchronized int fileExists ( JDBCSequentialFile file ) throws SQLException { connection . setAutoCommit ( _BOOL ) ; selectFileByFileName . setString ( _NUM , file . getFileName ( ) ) ; try ( ResultSet rs = selectFileByFileName . executeQuery ( ) ) { int id = rs . next ( ) ? rs . getInt ( _NUM ) : - _NUM ; connection . commit ( ) ; return id ; } catch ( Exception e ) { connection . rollback ( ) ; throw e ; } }
public HubLinkMapping ( String fileName , int numberOfHubs , Network network ) { this . numberOfHubs = numberOfHubs ; if ( fileName . contains ( STRING ) ) { readMappingTable ( fileName ) ; unMappedLinksAtZeroHub = _BOOL ; return ; } handleUnmappedLinksStart ( ) ; try { FileReader fr = new FileReader ( fileName ) ; BufferedReader br = new BufferedReader ( fr ) ; String line ; StringTokenizer tokenizer ; String token ; int linkId ; line = br . readLine ( ) ; while ( line != null ) { tokenizer = new StringTokenizer ( line ) ; for ( int i = _NUM ; i < this . numberOfHubs ; i ++ ) { token = tokenizer . nextToken ( ) ; linkId = ( int ) Double . parseDouble ( token ) ; linkHubMapping . put ( Integer . toString ( linkId ) , i ) ; } if ( tokenizer . hasMoreTokens ( ) ) { throw new RuntimeException ( STRING ) ; } line = br . readLine ( ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( STRING ) ; } linkHubMapping . remove ( STRING ) ; handleUnmappedLinksEnd ( network ) ; }
public HubLinkMapping ( String fileName , int numberOfHubs , Network network ) { this . numberOfHubs = numberOfHubs ; if ( fileName . contains ( STRING ) ) { readMappingTable ( fileName ) ; unMappedLinksAtZeroHub = _BOOL ; return ; } handleUnmappedLinksStart ( ) ; try { FileReader fr = new FileReader ( fileName ) ; BufferedReader br = new BufferedReader ( fr ) ; String line ; StringTokenizer tokenizer ; String token ; int linkId ; line = br . readLine ( ) ; while ( line != null ) { tokenizer = new StringTokenizer ( line ) ; for ( int i = _NUM ; i < this . numberOfHubs ; i ++ ) { token = tokenizer . nextToken ( ) ; linkId = ( int ) Double . parseDouble ( token ) ; linkHubMapping . put ( Integer . toString ( linkId ) , i ) ; } if ( tokenizer . hasMoreTokens ( ) ) { throw new RuntimeException ( STRING ) ; } line = br . readLine ( ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( STRING ) ; } linkHubMapping . remove ( STRING ) ; handleUnmappedLinksEnd ( network ) ; }
public HubLinkMapping ( String fileName , int numberOfHubs , Network network ) { this . numberOfHubs = numberOfHubs ; if ( fileName . contains ( STRING ) ) { readMappingTable ( fileName ) ; unMappedLinksAtZeroHub = _BOOL ; return ; } handleUnmappedLinksStart ( ) ; try { FileReader fr = new FileReader ( fileName ) ; BufferedReader br = new BufferedReader ( fr ) ; String line ; StringTokenizer tokenizer ; String token ; int linkId ; line = br . readLine ( ) ; while ( line != null ) { tokenizer = new StringTokenizer ( line ) ; for ( int i = _NUM ; i < this . numberOfHubs ; i ++ ) { token = tokenizer . nextToken ( ) ; linkId = ( int ) Double . parseDouble ( token ) ; linkHubMapping . put ( Integer . toString ( linkId ) , i ) ; } if ( tokenizer . hasMoreTokens ( ) ) { throw new RuntimeException ( STRING ) ; } line = br . readLine ( ) ; } } catch ( RuntimeException e ) { throw e ; } catch ( Exception e ) { throw new RuntimeException ( STRING ) ; } linkHubMapping . remove ( STRING ) ; handleUnmappedLinksEnd ( network ) ; }
void processUpdateQueueForTesting ( ) { while ( ! updates . isEmpty ( ) ) { IUpdate update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void processUpdateQueueForTesting ( ) { while ( ! updates . isEmpty ( ) ) { IUpdate update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void processUpdateQueueForTesting ( ) { while ( ! updates . isEmpty ( ) ) { IUpdate update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
void processUpdateQueueForTesting ( ) { while ( ! updates . isEmpty ( ) ) { IUpdate update = updates . poll ( ) ; if ( update != null ) update . dispatch ( ) ; } }
public DataSet ( ArrayList < Entry > yVals , int type ) { this . mType = type ; this . mYVals = yVals ; if ( yVals == null || yVals . size ( ) <= _NUM ) return ; calcMinMax ( ) ; calcYValueSum ( ) ; }
public boolean contains ( Song s ) { return mSongs . contains ( s ) ; }
public boolean contains ( Song s ) { return mSongs . contains ( s ) ; }
private void readObject ( ObjectInputStream stream ) throws IOException { try { decode ( stream ) ; } catch ( InvalidKeyException e ) { e . printStackTrace ( ) ; throw new IOException ( STRING + e . getMessage ( ) ) ; } }
private void convertOuterJoin ( final StringBuilder target , final CharSequence outerJoin ) throws FBSQLParseException { target . append ( outerJoin ) ; }
private void convertOuterJoin ( final StringBuilder target , final CharSequence outerJoin ) throws FBSQLParseException { target . append ( outerJoin ) ; }
private void convertOuterJoin ( final StringBuilder target , final CharSequence outerJoin ) throws FBSQLParseException { target . append ( outerJoin ) ; }
private void convertOuterJoin ( final StringBuilder target , final CharSequence outerJoin ) throws FBSQLParseException { target . append ( outerJoin ) ; }
public boolean clear ( T expect , boolean allowReset ) { sync . lock ( ) ; try { if ( expect != value ) { return _BOOL ; } ValueState prev = state ; clear ( allowReset ) ; return prev == ValueState . SET ; } finally { sync . unlock ( ) ; } }
public boolean clear ( T expect , boolean allowReset ) { sync . lock ( ) ; try { if ( expect != value ) { return _BOOL ; } ValueState prev = state ; clear ( allowReset ) ; return prev == ValueState . SET ; } finally { sync . unlock ( ) ; } }
public static < T > T median ( final Comparator < T > comparator , final T ... items ) { Validate . notEmpty ( items , STRING ) ; Validate . noNullElements ( items ) ; Validate . notNull ( comparator , STRING ) ; final TreeSet < T > sort = new TreeSet < T > ( comparator ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( STRING ) final T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - _NUM ) / _NUM ] ; return result ; }
public static < T > T median ( final Comparator < T > comparator , final T ... items ) { Validate . notEmpty ( items , STRING ) ; Validate . noNullElements ( items ) ; Validate . notNull ( comparator , STRING ) ; final TreeSet < T > sort = new TreeSet < T > ( comparator ) ; Collections . addAll ( sort , items ) ; @ SuppressWarnings ( STRING ) final T result = ( T ) sort . toArray ( ) [ ( sort . size ( ) - _NUM ) / _NUM ] ; return result ; }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
public void lazyKBestExtractOnHG ( HyperGraph hg , int topN , BufferedWriter out ) throws IOException { resetState ( ) ; if ( null == hg . goalNode ) return ; for ( int k = _NUM ; k <= topN ; k ++ ) { String hypStr = getKthHyp ( hg . goalNode , k ) ; if ( null == hypStr ) break ; out . write ( hypStr ) ; out . write ( STRING ) ; out . flush ( ) ; } }
private void addCharacters ( final Map < String , RPObject > characters ) { for ( Entry < String , RPObject > character : characters . entrySet ( ) ) { JButton button = createCharacterButton ( character . getKey ( ) , character . getValue ( ) ) ; characterPanel . add ( button ) ; } }
public void addMutedIp ( final String ip ) { addMutedIp ( ip , null ) ; }
public void addMutedIp ( final String ip ) { addMutedIp ( ip , null ) ; }
public DExportPrivateKeyPvk ( JFrame parent , String entryAlias , PrivateKey privateKey , PasswordQualityConfig passwordQualityConfig ) { super ( parent , Dialog . ModalityType . DOCUMENT_MODAL ) ; this . entryAlias = entryAlias ; this . privateKey = privateKey ; this . passwordQualityConfig = passwordQualityConfig ; initComponents ( ) ; }
public static void stopContext ( Context ctx ) { synchronized ( activeContexts ) { activeContexts . remove ( ctx ) ; if ( activeContexts . isEmpty ( ) ) { syncDeinitialize ( ) ; } else { if ( instance != null && getActivity ( ) != null ) { instance . deinitialize ( ) ; } } } }
public static void stopContext ( Context ctx ) { synchronized ( activeContexts ) { activeContexts . remove ( ctx ) ; if ( activeContexts . isEmpty ( ) ) { syncDeinitialize ( ) ; } else { if ( instance != null && getActivity ( ) != null ) { instance . deinitialize ( ) ; } } } }
public static void stopContext ( Context ctx ) { synchronized ( activeContexts ) { activeContexts . remove ( ctx ) ; if ( activeContexts . isEmpty ( ) ) { syncDeinitialize ( ) ; } else { if ( instance != null && getActivity ( ) != null ) { instance . deinitialize ( ) ; } } } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STRING , e ) ; } }
static void pauseThread ( long duration ) { try { Thread . sleep ( duration ) ; } catch ( Exception e ) { s_logger . warn ( STRING , e ) ; } }
public CViewSearcherDialog ( final Window owner , final IViewContainer viewContainer , final IAddress address ) { super ( owner , STRING , ModalityType . APPLICATION_MODAL ) ; Preconditions . checkNotNull ( viewContainer , STRING ) ; m_viewContainer = viewContainer ; createGui ( ) ; new CDialogEscaper ( this ) ; GuiHelper . centerChildToParent ( owner , this , _BOOL ) ; if ( address != null ) { m_offsetField . setText ( address . toHexString ( ) ) ; search ( address . toLong ( ) ) ; } }
public void removeIndex ( int n ) { if ( n >= size ) { throw new IndexOutOfBoundsException ( STRING ) ; } System . arraycopy ( values , n + _NUM , values , n , size - n - _NUM ) ; size -- ; }
public void removeIndex ( int n ) { if ( n >= size ) { throw new IndexOutOfBoundsException ( STRING ) ; } System . arraycopy ( values , n + _NUM , values , n , size - n - _NUM ) ; size -- ; }
private void init ( ) { mainPanel = new JPanel ( ) ; mainPanel . setLayout ( new BoxLayout ( mainPanel , BoxLayout . Y_AXIS ) ) ; mainPanel . add ( connectionPanel ) ; propertiesPanel = ConnectionSynapsePropertiesPanel . createSynapsePropertiesPanel ( this ) ; mainPanel . add ( propertiesPanel ) ; eirPanel = SynapsePolarityAndRandomizerPanel . createPolarityRatioPanel ( this ) ; mainPanel . add ( eirPanel ) ; fillFrame ( ) ; }
@ Override public Query rewrite ( IndexReader reader ) throws IOException { if ( disjuncts . length == _NUM ) { return disjuncts [ _NUM ] ; } boolean actuallyRewritten = _BOOL ; List < Query > rewrittenDisjuncts = new ArrayList < > ( ) ; for ( Query sub : disjuncts ) { Query rewrittenSub = sub . rewrite ( reader ) ; actuallyRewritten |= rewrittenSub != sub ; rewrittenDisjuncts . add ( rewrittenSub ) ; } if ( actuallyRewritten ) { return new DisjunctionMaxQuery ( rewrittenDisjuncts , tieBreakerMultiplier ) ; } return super . rewrite ( reader ) ; }
public void adjustTransformation ( double minXW , double minYW , double maxXW , double maxYW ) { double scaleX = _NUM ; double scaleY = _NUM ; if ( maxXW > minXW ) scaleX = ( getWidth ( ) - borderLeft - borderRight ) / ( maxXW - minXW ) ; if ( maxYW > minYW ) scaleY = ( getHeight ( ) - borderTop - borderBottom ) / ( maxYW - minYW ) ; offsetX = - minXW ; offsetY = - minYW ; scale = Math . min ( scaleX , scaleY ) ; }
public void adjustTransformation ( double minXW , double minYW , double maxXW , double maxYW ) { double scaleX = _NUM ; double scaleY = _NUM ; if ( maxXW > minXW ) scaleX = ( getWidth ( ) - borderLeft - borderRight ) / ( maxXW - minXW ) ; if ( maxYW > minYW ) scaleY = ( getHeight ( ) - borderTop - borderBottom ) / ( maxYW - minYW ) ; offsetX = - minXW ; offsetY = - minYW ; scale = Math . min ( scaleX , scaleY ) ; }
public void adjustTransformation ( double minXW , double minYW , double maxXW , double maxYW ) { double scaleX = _NUM ; double scaleY = _NUM ; if ( maxXW > minXW ) scaleX = ( getWidth ( ) - borderLeft - borderRight ) / ( maxXW - minXW ) ; if ( maxYW > minYW ) scaleY = ( getHeight ( ) - borderTop - borderBottom ) / ( maxYW - minYW ) ; offsetX = - minXW ; offsetY = - minYW ; scale = Math . min ( scaleX , scaleY ) ; }
public boolean hasVideoData ( Video v ) { Path source = getVideoPath ( v ) ; return Files . exists ( source ) ; }
public Random ( ) { this ( System . currentTimeMillis ( ) ) ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { StellarProcessor processor = new StellarProcessor ( ) ; Assert . assertTrue ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , StellarFunctions . FUNCTION_RESOLVER ( ) , context ) ; byte [ ] raw = SerDeUtils . toBytes ( ret ) ; Object actual = SerDeUtils . fromBytes ( raw , Object . class ) ; Assert . assertEquals ( ret , actual ) ; return ret ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { StellarProcessor processor = new StellarProcessor ( ) ; Assert . assertTrue ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , StellarFunctions . FUNCTION_RESOLVER ( ) , context ) ; byte [ ] raw = SerDeUtils . toBytes ( ret ) ; Object actual = SerDeUtils . fromBytes ( raw , Object . class ) ; Assert . assertEquals ( ret , actual ) ; return ret ; }
public static Object run ( String rule , Map < String , Object > variables , Context context ) { StellarProcessor processor = new StellarProcessor ( ) ; Assert . assertTrue ( rule + STRING , processor . validate ( rule , context ) ) ; Object ret = processor . parse ( rule , null , StellarFunctions . FUNCTION_RESOLVER ( ) , context ) ; byte [ ] raw = SerDeUtils . toBytes ( ret ) ; Object actual = SerDeUtils . fromBytes ( raw , Object . class ) ; Assert . assertEquals ( ret , actual ) ; return ret ; }
public boolean hasAvailableAddresses ( ) { if ( isPoolFull ( ) || getPoolAvailability ( ) == _NUM ) return _BOOL ; else return _BOOL ; }
public boolean hasAvailableAddresses ( ) { if ( isPoolFull ( ) || getPoolAvailability ( ) == _NUM ) return _BOOL ; else return _BOOL ; }
private static DeleteDisksResponse checkDeleteDisksResponse ( DeleteDisksResponse deleteDisksResponse ) throws RpcException { logger . info ( STRING , deleteDisksResponse ) ; switch ( deleteDisksResponse . getResult ( ) ) { case OK : break ; case SYSTEM_ERROR : throw new SystemErrorException ( deleteDisksResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STRING , deleteDisksResponse . getResult ( ) ) ) ; } return deleteDisksResponse ; }
private String [ ] splitTfvcCollectionUrl ( final String collectionUrl ) { final String [ ] result = new String [ _NUM ] ; if ( StringUtils . isEmpty ( collectionUrl ) ) { return result ; } final String trimmedUrl = UrlHelper . trimTrailingSeparators ( collectionUrl ) ; final int index = trimmedUrl . lastIndexOf ( UrlHelper . URL_SEPARATOR ) ; if ( index >= _NUM ) { result [ _NUM ] = trimmedUrl . substring ( _NUM , index + _NUM ) ; result [ _NUM ] = trimmedUrl . substring ( index + _NUM ) ; } else { result [ _NUM ] = collectionUrl ; result [ _NUM ] = StringUtils . EMPTY ; } return result ; }
public InputStream stream ( ) throws HttpRequestException { InputStream stream ; if ( code ( ) < HTTP_BAD_REQUEST ) try { stream = connection . getInputStream ( ) ; } catch ( IOException e ) { throw new HttpRequestException ( e ) ; } else { stream = connection . getErrorStream ( ) ; if ( stream == null ) try { stream = connection . getInputStream ( ) ; } catch ( IOException e ) { throw new HttpRequestException ( e ) ; } } if ( ! uncompress || ! ENCODING_GZIP . equals ( contentEncoding ( ) ) ) return stream ; else try { return new GZIPInputStream ( stream ) ; } catch ( IOException e ) { throw new HttpRequestException ( e ) ; } }
public void write ( char [ ] cbuf , int off , int len ) throws java . io . IOException { write ( new String ( cbuf , off , len ) ) ; }
public static TextWithMnemonic parseText ( final String textWithMnemonic ) { if ( textWithMnemonic == null ) { throw new IllegalArgumentException ( STRING ) ; } int index = - _NUM ; final StringBuffer plainText = new StringBuffer ( ) ; for ( int i = _NUM ; i < textWithMnemonic . length ( ) ; i ++ ) { char ch = textWithMnemonic . charAt ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= textWithMnemonic . length ( ) ) { break ; } ch = textWithMnemonic . charAt ( i ) ; if ( ch != STRING ) { index = plainText . length ( ) ; } } plainText . append ( ch ) ; } return new TextWithMnemonic ( plainText . toString ( ) , index ) ; }
public static TextWithMnemonic parseText ( final String textWithMnemonic ) { if ( textWithMnemonic == null ) { throw new IllegalArgumentException ( STRING ) ; } int index = - _NUM ; final StringBuffer plainText = new StringBuffer ( ) ; for ( int i = _NUM ; i < textWithMnemonic . length ( ) ; i ++ ) { char ch = textWithMnemonic . charAt ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= textWithMnemonic . length ( ) ) { break ; } ch = textWithMnemonic . charAt ( i ) ; if ( ch != STRING ) { index = plainText . length ( ) ; } } plainText . append ( ch ) ; } return new TextWithMnemonic ( plainText . toString ( ) , index ) ; }
public static TextWithMnemonic parseText ( final String textWithMnemonic ) { if ( textWithMnemonic == null ) { throw new IllegalArgumentException ( STRING ) ; } int index = - _NUM ; final StringBuffer plainText = new StringBuffer ( ) ; for ( int i = _NUM ; i < textWithMnemonic . length ( ) ; i ++ ) { char ch = textWithMnemonic . charAt ( i ) ; if ( ch == STRING ) { i ++ ; if ( i >= textWithMnemonic . length ( ) ) { break ; } ch = textWithMnemonic . charAt ( i ) ; if ( ch != STRING ) { index = plainText . length ( ) ; } } plainText . append ( ch ) ; } return new TextWithMnemonic ( plainText . toString ( ) , index ) ; }
private boolean isMimeFormat ( long format , String primaryType ) { String nat = getNativeForFormat ( format ) ; if ( nat == null ) { return _BOOL ; } try { DataFlavor df = new DataFlavor ( nat ) ; if ( primaryType . equals ( df . getPrimaryType ( ) ) ) { return _BOOL ; } } catch ( Exception e ) { } return _BOOL ; }
private boolean isMimeFormat ( long format , String primaryType ) { String nat = getNativeForFormat ( format ) ; if ( nat == null ) { return _BOOL ; } try { DataFlavor df = new DataFlavor ( nat ) ; if ( primaryType . equals ( df . getPrimaryType ( ) ) ) { return _BOOL ; } } catch ( Exception e ) { } return _BOOL ; }
private boolean isMimeFormat ( long format , String primaryType ) { String nat = getNativeForFormat ( format ) ; if ( nat == null ) { return _BOOL ; } try { DataFlavor df = new DataFlavor ( nat ) ; if ( primaryType . equals ( df . getPrimaryType ( ) ) ) { return _BOOL ; } } catch ( Exception e ) { } return _BOOL ; }
public byte receiveOneByte ( ) { Log . d ( TAG , STRING ) ; try { acquireLock ( ) ; mServerSocket . receive ( mReceivePacket ) ; Log . d ( TAG , STRING + ( _NUM + mReceivePacket . getData ( ) [ _NUM ] ) ) ; return mReceivePacket . getData ( ) [ _NUM ] ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return Byte . MIN_VALUE ; }
public void recruitPlayersFromStr ( String playersStr ) { String [ ] players = playersStr . split ( STRING ) ; String currLine = players [ _NUM ] ; int i = _NUM ; while ( ! currLine . equals ( STRING ) ) { recruitPlayerCSV ( currLine , _BOOL ) ; currLine = players [ ++ i ] ; } recruitWalkOns ( ) ; currLine = players [ ++ i ] ; while ( ! currLine . equals ( STRING ) ) { recruitPlayerCSV ( currLine , _BOOL ) ; currLine = players [ ++ i ] ; } }
static VerifierDeviceIdentity generate ( Random rng ) { long identity = rng . nextLong ( ) ; return new VerifierDeviceIdentity ( identity ) ; }
static VerifierDeviceIdentity generate ( Random rng ) { long identity = rng . nextLong ( ) ; return new VerifierDeviceIdentity ( identity ) ; }
public void placeItem ( ItemStack stack , BlockPos pos , World world , boolean centreItem ) { double offset = ( centreItem ) ? _NUM : _NUM ; EntityItem entityitem = new EntityItem ( world , ( double ) pos . getX ( ) + offset , ( double ) pos . getY ( ) + offset , ( double ) pos . getZ ( ) + offset , stack ) ; entityitem . motionX = _NUM ; entityitem . motionY = _NUM ; entityitem . motionZ = _NUM ; entityitem . setDefaultPickupDelay ( ) ; world . spawnEntityInWorld ( entityitem ) ; }
public void placeItem ( ItemStack stack , BlockPos pos , World world , boolean centreItem ) { double offset = ( centreItem ) ? _NUM : _NUM ; EntityItem entityitem = new EntityItem ( world , ( double ) pos . getX ( ) + offset , ( double ) pos . getY ( ) + offset , ( double ) pos . getZ ( ) + offset , stack ) ; entityitem . motionX = _NUM ; entityitem . motionY = _NUM ; entityitem . motionZ = _NUM ; entityitem . setDefaultPickupDelay ( ) ; world . spawnEntityInWorld ( entityitem ) ; }
public final void testGenerateSeedint01 ( ) { try { sr . generateSeed ( - _NUM ) ; fail ( STRING ) ; } catch ( NegativeArraySizeException e ) { } }
public final void testGenerateSeedint01 ( ) { try { sr . generateSeed ( - _NUM ) ; fail ( STRING ) ; } catch ( NegativeArraySizeException e ) { } }
private Shape decodeEdge ( int width , int height ) { path . reset ( ) ; path . moveTo ( width - _NUM , _NUM ) ; path . lineTo ( width - _NUM , height - _NUM ) ; path . lineTo ( width - _NUM , height - _NUM ) ; path . lineTo ( _NUM , height - _NUM ) ; return path ; }
public void applyCamera ( GL2 gl ) { gl . glMatrixMode ( GL2 . GL_PROJECTION ) ; gl . glLoadIdentity ( ) ; glu . gluPerspective ( _NUM , width / ( float ) height , _NUM , _NUM ) ; eye [ _NUM ] = ( float ) Math . sin ( theta ) * _NUM ; eye [ _NUM ] = _NUM ; eye [ _NUM ] = ( float ) Math . cos ( theta ) * _NUM ; glu . gluLookAt ( eye [ _NUM ] , eye [ _NUM ] , eye [ _NUM ] , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM ) ; gl . glMatrixMode ( GL2 . GL_MODELVIEW ) ; gl . glLoadIdentity ( ) ; gl . glViewport ( _NUM , _NUM , width , height ) ; }
private void updateUiByTrackColorMode ( String trackColorMode ) { boolean isFixedValue = trackColorMode . equals ( getString ( R . string . settings_map_track_color_mode_fixed_value ) ) ; boolean isDynamicValue = trackColorMode . equals ( getString ( R . string . settings_map_track_color_mode_dynamic_value ) ) ; slowPreference . setEnabled ( isFixedValue ) ; mediumPreference . setEnabled ( isFixedValue ) ; percentagePreference . setEnabled ( isDynamicValue ) ; }
public boolean isGroupExpanded ( int groupPosition ) { GroupMetadata groupMetadata ; for ( int i = mExpGroupMetadataList . size ( ) - _NUM ; i >= _NUM ; i -- ) { groupMetadata = mExpGroupMetadataList . get ( i ) ; if ( groupMetadata . gPos == groupPosition ) { return _BOOL ; } } return _BOOL ; }
private double [ ] incomingParamVector ( double [ ] incomingInst ) throws Exception { Instances miningSchemaI = m_miningSchema . getFieldsAsInstances ( ) ; double [ ] incomingPV = new double [ m_parameterList . size ( ) ] ; for ( int i = _NUM ; i < m_parameterList . size ( ) ; i ++ ) { incomingPV [ i ] = _NUM ; for ( int j = _NUM ; j < miningSchemaI . numAttributes ( ) ; j ++ ) { PPCell cellEntry = m_ppMatrix [ i ] [ j ] ; Predictor p = null ; if ( cellEntry != null ) { if ( ( p = getFactor ( cellEntry . m_predictorName ) ) != null ) { if ( ( int ) incomingInst [ p . m_miningSchemaIndex ] == ( int ) cellEntry . m_value ) { incomingPV [ i ] *= _NUM ; } else { incomingPV [ i ] *= _NUM ; } } else if ( ( p = getCovariate ( cellEntry . m_predictorName ) ) != null ) { incomingPV [ i ] *= Math . pow ( incomingInst [ p . m_miningSchemaIndex ] , cellEntry . m_value ) ; } else { throw new Exception ( STRING + cellEntry . m_predictorName + STRING ) ; } } } } return incomingPV ; }
private double [ ] incomingParamVector ( double [ ] incomingInst ) throws Exception { Instances miningSchemaI = m_miningSchema . getFieldsAsInstances ( ) ; double [ ] incomingPV = new double [ m_parameterList . size ( ) ] ; for ( int i = _NUM ; i < m_parameterList . size ( ) ; i ++ ) { incomingPV [ i ] = _NUM ; for ( int j = _NUM ; j < miningSchemaI . numAttributes ( ) ; j ++ ) { PPCell cellEntry = m_ppMatrix [ i ] [ j ] ; Predictor p = null ; if ( cellEntry != null ) { if ( ( p = getFactor ( cellEntry . m_predictorName ) ) != null ) { if ( ( int ) incomingInst [ p . m_miningSchemaIndex ] == ( int ) cellEntry . m_value ) { incomingPV [ i ] *= _NUM ; } else { incomingPV [ i ] *= _NUM ; } } else if ( ( p = getCovariate ( cellEntry . m_predictorName ) ) != null ) { incomingPV [ i ] *= Math . pow ( incomingInst [ p . m_miningSchemaIndex ] , cellEntry . m_value ) ; } else { throw new Exception ( STRING + cellEntry . m_predictorName + STRING ) ; } } } } return incomingPV ; }
private void createConsumers ( List < Object > consumersConfig ) { for ( Object objConsumer : consumersConfig ) { String className = CpeBuilderUtils . getClassNameFromConfig ( objConsumer ) ; Map < String , Object > params = CpeBuilderUtils . getParamsFromConfig ( objConsumer ) ; Optional < AnalysisEngineDescription > desc = createConsumer ( className , params , CONSUMER_DEFAULT_PACKAGE ) ; if ( desc . isPresent ( ) ) { String name = CpeBuilderUtils . getComponentName ( getConsumerNames ( ) , STRING + className ) ; addConsumer ( name , desc . get ( ) ) ; } } }
public boolean isValid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M_PI_2 && Math . abs ( lat . hi ( ) ) <= S2 . M_PI_2 && lng . isValid ( ) && lat . isEmpty ( ) == lng . isEmpty ( ) ) ; }
public boolean isValid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M_PI_2 && Math . abs ( lat . hi ( ) ) <= S2 . M_PI_2 && lng . isValid ( ) && lat . isEmpty ( ) == lng . isEmpty ( ) ) ; }
public boolean isValid ( ) { return ( Math . abs ( lat . lo ( ) ) <= S2 . M_PI_2 && Math . abs ( lat . hi ( ) ) <= S2 . M_PI_2 && lng . isValid ( ) && lat . isEmpty ( ) == lng . isEmpty ( ) ) ; }
@ Deprecated public MediaFile ( File f , MediaFileType type ) { this ( f . toPath ( ) , type ) ; }
public void addNameDeltaEventType ( String nameDeltaEventType ) { nameDeltaEventTypes . add ( nameDeltaEventType ) ; }
public void addNameDeltaEventType ( String nameDeltaEventType ) { nameDeltaEventTypes . add ( nameDeltaEventType ) ; }
public void log ( String event , String message ) { boolean eventActive = isEventActive ( event ) ; if ( ( this . logging && eventActive && ! writers . isEmpty ( ) ) ) { try { for ( Writer writer : writers . values ( ) ) { writer . write ( message ) ; writer . write ( STRING ) ; writer . flush ( ) ; } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
@ Override public void run ( ) { MultipleObjectsBundle data = generator . loadData ( ) ; if ( LOG . isVerbose ( ) ) { LOG . verbose ( STRING ) ; } try { if ( outputFile . exists ( ) && LOG . isVerbose ( ) ) { LOG . verbose ( STRING + outputFile + STRING + STRING ) ; } try ( OutputStreamWriter outStream = new FileWriter ( outputFile , _BOOL ) ) { writeClusters ( outStream , data ) ; } } catch ( IOException e ) { throw new AbortException ( STRING , e ) ; } if ( LOG . isVerbose ( ) ) { LOG . verbose ( STRING ) ; } }
@ Bean public BuildInformation buildInformation ( ) { BuildInformation buildInformation = new BuildInformation ( ) ; buildInformation . setBuildDate ( environment . getProperty ( STRING ) ) ; buildInformation . setBuildNumber ( environment . getProperty ( STRING ) ) ; buildInformation . setBuildOs ( environment . getProperty ( STRING ) ) ; buildInformation . setBuildUser ( environment . getProperty ( STRING ) ) ; LOGGER . info ( String . format ( STRING , buildInformation . getBuildNumber ( ) , buildInformation . getBuildDate ( ) , buildInformation . getBuildUser ( ) , buildInformation . getBuildOs ( ) ) ) ; LOGGER . info ( STRING + getSystemPropertyMap ( STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING , STRING ) ) ; return buildInformation ; }
private static String convertToMixed ( int addressLow , int addressHigh ) { if ( addressHigh == _NUM ) { if ( addressLow >= _NUM ) { return STRING + String . valueOf ( addressLow - _NUM ) + STRING + String . valueOf ( addressLow ) + STRING ; } else if ( addressLow >= _NUM ) { return STRING + String . valueOf ( addressLow - _NUM ) + STRING + String . valueOf ( addressLow ) + STRING ; } else if ( addressLow >= _NUM ) { return STRING + String . valueOf ( addressLow - _NUM ) + STRING + String . valueOf ( addressLow ) + STRING ; } else { return String . valueOf ( addressLow & _NUM ) ; } } else { return String . valueOf ( LOCO_ADR ( addressHigh , addressLow ) ) ; } }
public void write ( byte [ ] buffer , int offset , int length , boolean isEnd ) throws IOException { throw new UnsupportedOperationException ( String . valueOf ( this ) ) ; }
private List < VNXFileSystem > discoverAllFileSystems ( StorageSystem system ) throws VNXFileCollectionException , VNXException { List < VNXFileSystem > fileSystems = new ArrayList < VNXFileSystem > ( ) ; _logger . info ( STRING , system . getId ( ) ) ; try { List < VNXFileSystem > vnxFileSystems = getAllFileSystem ( system ) ; _logger . info ( STRING , vnxFileSystems . size ( ) ) ; if ( vnxFileSystems != null ) { for ( VNXFileSystem vnxfs : vnxFileSystems ) { FileShare fs = null ; URIQueryResultList results = new URIQueryResultList ( ) ; String fsNativeGuid = NativeGUIDGenerator . generateNativeGuid ( system , vnxfs . getFsId ( ) + STRING , NativeGUIDGenerator . FILESYSTEM ) ; if ( checkStorageFileSystemExistsInDB ( fsNativeGuid ) ) { continue ; } vnxfs . setFsNativeGuid ( fsNativeGuid ) ; fileSystems . add ( vnxfs ) ; } } _logger . info ( STRING , fileSystems . size ( ) ) ; } catch ( IOException e ) { _logger . error ( STRING , system . getId ( ) , e . getMessage ( ) ) ; VNXFileCollectionException vnxe = new VNXFileCollectionException ( STRING + system . getId ( ) ) ; vnxe . initCause ( e ) ; throw vnxe ; } _logger . info ( STRING , system . getId ( ) ) ; return fileSystems ; }
public void write ( byte [ ] b , int o , int len ) { while ( len > _NUM ) { int n = len <= availLen ? len : availLen ; System . arraycopy ( b , o , buf , offset , n ) ; incrementOffset ( n ) ; len -= n ; o += n ; } }
public void write ( byte [ ] b , int o , int len ) { while ( len > _NUM ) { int n = len <= availLen ? len : availLen ; System . arraycopy ( b , o , buf , offset , n ) ; incrementOffset ( n ) ; len -= n ; o += n ; } }
int selectServer ( int forceIndex ) { int index = forceIndex == - _NUM ? getLessSaturatedIndex ( ) : forceIndex ; serversCounters . incrementAndGet ( index ) ; return index ; }
int selectServer ( int forceIndex ) { int index = forceIndex == - _NUM ? getLessSaturatedIndex ( ) : forceIndex ; serversCounters . incrementAndGet ( index ) ; return index ; }
public static void deletePlayer ( PlayerAccountData accData ) { if ( accData . getDeletionDate ( ) != null ) { return ; } accData . setDeletionDate ( new Timestamp ( System . currentTimeMillis ( ) + _NUM * _NUM * _NUM ) ) ; storeDeletionTime ( accData ) ; }
public void lostOwnership ( Clipboard clipboard , Transferable contents ) { if ( ownsSelection ) { ownsSelection = _BOOL ; if ( component != null && ! component . hasFocus ( ) ) { setSelectionVisible ( _BOOL ) ; } } }
private void showFindReplaceDialog ( ) { JFrame frame = new JFrame ( ) ; FindReplaceDialog dialog = new FindReplaceDialog ( frame , this ) ; frame . setContentPane ( dialog ) ; frame . setTitle ( STRING ) ; frame . setVisible ( _BOOL ) ; frame . pack ( ) ; frame . setLocationRelativeTo ( null ) ; }
protected void switchState ( char testChar ) throws FBSQLParseException { if ( Character . isWhitespace ( testChar ) && ! isInState ( LITERAL_STATE ) ) { setState ( SPACE_STATE ) ; return ; } switch ( testChar ) { case STRING : if ( isInState ( NORMAL_STATE ) ) setState ( LITERAL_STATE ) ; else if ( isInState ( LITERAL_STATE ) ) setState ( NORMAL_STATE ) ; break ; case STRING : if ( ! isInState ( LITERAL_STATE ) && ! isInState ( BRACE_STATE ) ) setState ( COMMA_STATE ) ; break ; case STRING : case STRING : if ( ! isInState ( LITERAL_STATE ) ) setState ( BRACE_STATE ) ; break ; case STRING : case STRING : if ( ! isInState ( LITERAL_STATE ) ) setState ( CURLY_BRACE_STATE ) ; break ; default : if ( ! isInState ( LITERAL_STATE ) && ! isInState ( BRACE_STATE ) ) setState ( NORMAL_STATE ) ; } }
public static _Fields findByThriftId ( int fieldId ) { switch ( fieldId ) { case _NUM : return FULL_NAME ; case _NUM : return GENDER ; case _NUM : return LOCATION ; default : return null ; } }
public CreateStatement put ( CharSequence column , Object value ) { if ( ++ columnCount > _NUM ) { columns . append ( STRING ) ; values . append ( STRING ) ; } columns . append ( column ) ; append ( values , value ) ; return this ; }
public CreateStatement put ( CharSequence column , Object value ) { if ( ++ columnCount > _NUM ) { columns . append ( STRING ) ; values . append ( STRING ) ; } columns . append ( column ) ; append ( values , value ) ; return this ; }
@ Override public Node removeNamedItemNS ( String namespaceURI , String name ) throws DOMException { if ( isReadOnly ( ) ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . NO_MODIFICATION_ALLOWED_ERR , msg ) ; } int i = findNamePoint ( namespaceURI , name ) ; if ( i < _NUM ) { String msg = DOMMessageFormatter . formatMessage ( DOMMessageFormatter . DOM_DOMAIN , STRING , null ) ; throw new DOMException ( DOMException . NOT_FOUND_ERR , msg ) ; } NodeImpl n = ( NodeImpl ) nodes . get ( i ) ; nodes . remove ( i ) ; return n ; }
private void updateTransferredBytesAvg ( int newValue ) { int realCount = _NUM ; int sum = _NUM ; this . avgSamples [ this . nextSampleIndex ++ ] = newValue ; if ( this . nextSampleIndex >= BYTES_TRANSFERRED_AVG_SAMPLES ) { this . nextSampleIndex = _NUM ; } for ( int i = _NUM ; i < BYTES_TRANSFERRED_AVG_SAMPLES ; i ++ ) { if ( this . avgSamples [ i ] > _NUM ) { realCount ++ ; sum += this . avgSamples [ i ] ; } } if ( realCount > _NUM ) { this . avgTransferredBytes = sum / realCount ; } else { this . avgTransferredBytes = _NUM ; } }
public static void stopTimer ( String name ) { long stopTime = System . nanoTime ( ) ; Long startTime = openTimers . remove ( name ) ; if ( startTime == null ) { throw new IllegalArgumentException ( STRING ) ; } SummaryStatistics statistics = data . get ( name ) ; if ( statistics == null ) { statistics = new SummaryStatistics ( ) ; data . put ( name , statistics ) ; } statistics . addValue ( stopTime - startTime ) ; }
@ Override protected synchronized void read ( long offset , byte [ ] b ) throws IOException { if ( byteBuffer != null ) { byteBuffer . position ( ( int ) offset ) ; byteBuffer . get ( b ) ; } else { throw new IOException ( STRING + getPath ( ) + STRING ) ; } }
boolean addFuture ( GridDhtForceKeysFuture < ? , ? > fut ) { forceKeyFuts . put ( fut . futureId ( ) , fut ) ; if ( stopping ) { fut . onDone ( stopError ( ) ) ; return _BOOL ; } return _BOOL ; }
public synchronized void crash ( ) throws IOException { openFiles = new HashMap < > ( ) ; openFilesForWrite = new HashSet < > ( ) ; openFilesDeleted = new HashSet < > ( ) ; Map < Closeable , Exception > m = new IdentityHashMap < > ( openFileHandles ) ; for ( Closeable f : m . keySet ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corruptFiles ( unSyncedFiles ) ; crashed = _BOOL ; unSyncedFiles = new HashSet < > ( ) ; }
public synchronized void crash ( ) throws IOException { openFiles = new HashMap < > ( ) ; openFilesForWrite = new HashSet < > ( ) ; openFilesDeleted = new HashSet < > ( ) ; Map < Closeable , Exception > m = new IdentityHashMap < > ( openFileHandles ) ; for ( Closeable f : m . keySet ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corruptFiles ( unSyncedFiles ) ; crashed = _BOOL ; unSyncedFiles = new HashSet < > ( ) ; }
public synchronized void crash ( ) throws IOException { openFiles = new HashMap < > ( ) ; openFilesForWrite = new HashSet < > ( ) ; openFilesDeleted = new HashSet < > ( ) ; Map < Closeable , Exception > m = new IdentityHashMap < > ( openFileHandles ) ; for ( Closeable f : m . keySet ( ) ) { try { f . close ( ) ; } catch ( Exception ignored ) { } } corruptFiles ( unSyncedFiles ) ; crashed = _BOOL ; unSyncedFiles = new HashSet < > ( ) ; }
public int postFiles ( File [ ] files , int startIndexInArgs , OutputStream out , String type ) { reset ( ) ; int filesPosted = _NUM ; for ( File srcFile : files ) { if ( srcFile . isDirectory ( ) && srcFile . canRead ( ) ) { filesPosted += postDirectory ( srcFile , out , type ) ; } else if ( srcFile . isFile ( ) && srcFile . canRead ( ) ) { filesPosted += postFiles ( new File [ ] { srcFile } , out , type ) ; } else { File parent = srcFile . getParentFile ( ) ; if ( parent == null ) parent = new File ( STRING ) ; String fileGlob = srcFile . getName ( ) ; GlobFileFilter ff = new GlobFileFilter ( fileGlob , _BOOL ) ; File [ ] fileList = parent . listFiles ( ff ) ; if ( fileList == null || fileList . length == _NUM ) { warn ( STRING + srcFile ) ; continue ; } filesPosted += postFiles ( fileList , out , type ) ; } } return filesPosted ; }
public int postFiles ( File [ ] files , int startIndexInArgs , OutputStream out , String type ) { reset ( ) ; int filesPosted = _NUM ; for ( File srcFile : files ) { if ( srcFile . isDirectory ( ) && srcFile . canRead ( ) ) { filesPosted += postDirectory ( srcFile , out , type ) ; } else if ( srcFile . isFile ( ) && srcFile . canRead ( ) ) { filesPosted += postFiles ( new File [ ] { srcFile } , out , type ) ; } else { File parent = srcFile . getParentFile ( ) ; if ( parent == null ) parent = new File ( STRING ) ; String fileGlob = srcFile . getName ( ) ; GlobFileFilter ff = new GlobFileFilter ( fileGlob , _BOOL ) ; File [ ] fileList = parent . listFiles ( ff ) ; if ( fileList == null || fileList . length == _NUM ) { warn ( STRING + srcFile ) ; continue ; } filesPosted += postFiles ( fileList , out , type ) ; } } return filesPosted ; }
@ Override public String generateLabel ( XYDataset dataset , int series , int item ) { return generateLabelString ( dataset , series , item ) ; }
public boolean hasIncomingBatchInstances ( ) { if ( m_listenees . size ( ) == _NUM ) { return _BOOL ; } if ( m_listenees . containsKey ( STRING ) || m_listenees . containsKey ( STRING ) || m_listenees . containsKey ( STRING ) ) { return _BOOL ; } return _BOOL ; }
public boolean hasIncomingBatchInstances ( ) { if ( m_listenees . size ( ) == _NUM ) { return _BOOL ; } if ( m_listenees . containsKey ( STRING ) || m_listenees . containsKey ( STRING ) || m_listenees . containsKey ( STRING ) ) { return _BOOL ; } return _BOOL ; }
@ Override public boolean hasPermission ( U currentUser , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + currentUser ) ; decorate ( currentUser ) ; if ( permission . equals ( STRING ) ) return editable ; return _BOOL ; }
@ Override public boolean hasPermission ( U currentUser , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + currentUser ) ; decorate ( currentUser ) ; if ( permission . equals ( STRING ) ) return editable ; return _BOOL ; }
@ Override public boolean hasPermission ( U currentUser , String permission ) { log . debug ( STRING + permission + STRING + this + STRING + currentUser ) ; decorate ( currentUser ) ; if ( permission . equals ( STRING ) ) return editable ; return _BOOL ; }
private void findPrefixInChildren ( String prefix , ZooKeeper zookeeper , String dir ) throws KeeperException , InterruptedException { List < String > names = zookeeper . getChildren ( dir , _BOOL ) ; for ( String name : names ) { if ( name . startsWith ( prefix ) ) { id = name ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING + id ) ; } break ; } } if ( id == null ) { id = zookeeper . create ( dir + STRING + prefix , data , getAcl ( ) , EPHEMERAL_SEQUENTIAL ) ; if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING + id ) ; } } }
public void clear ( ) { mappings . clear ( ) ; }
@ Override public void before ( DerivationState state , int indent , int tailNodeIndex ) { HyperEdge edge = state . edge ; Rule rule = edge . getRule ( ) ; if ( rule == null ) { return ; } String lhs = Vocabulary . word ( rule . getLHS ( ) ) ; String unbracketedLHS = lhs . substring ( _NUM , lhs . length ( ) - _NUM ) ; Tree fragment = Tree . getFragmentFromYield ( rule . getEnglishWords ( ) ) ; if ( fragment == null ) { String subtree = String . format ( STRING , unbracketedLHS , state . parentNode . i , state . parentNode . j , quoteTerminals ( rule . getEnglishWords ( ) ) ) ; fragment = Tree . fromString ( subtree ) ; } merge ( fragment ) ; }
private void maybeThrowException ( ) throws E { if ( exception != null ) { throw exception ; } }
private boolean stringContainsSpecialCharacters ( String line ) { return line . indexOf ( quotechar ) != - _NUM || line . indexOf ( escapechar ) != - _NUM || line . indexOf ( separator ) != - _NUM || line . contains ( DEFAULT_LINE_END ) || line . contains ( STRING ) ; }
private boolean stringContainsSpecialCharacters ( String line ) { return line . indexOf ( quotechar ) != - _NUM || line . indexOf ( escapechar ) != - _NUM || line . indexOf ( separator ) != - _NUM || line . contains ( DEFAULT_LINE_END ) || line . contains ( STRING ) ; }
public Feature ( String line , Map cpStr2Int , Map lbStr2Int , Map fmap ) { StringTokenizer strTok = new StringTokenizer ( line , STRING ) ; int len = strTok . countTokens ( ) ; String strIdStr = strTok . nextToken ( ) ; int idx = Integer . parseInt ( strTok . nextToken ( ) ) ; float val = _NUM ; double wgt = Double . parseDouble ( strTok . nextToken ( ) ) ; StringTokenizer strIdTok = new StringTokenizer ( strIdStr , STRING ) ; String prefix = strIdTok . nextToken ( ) ; if ( prefix . compareToIgnoreCase ( STRING ) == _NUM ) { Integer yInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; Integer ypInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; if ( yInt != null && ypInt != null ) { eFeature1Init ( yInt . intValue ( ) , ypInt . intValue ( ) ) ; } } else if ( prefix . compareToIgnoreCase ( STRING ) == _NUM ) { Integer yInt = ( Integer ) lbStr2Int . get ( strIdTok . nextToken ( ) ) ; Integer cpInt = ( Integer ) cpStr2Int . get ( strIdTok . nextToken ( ) ) ; if ( yInt != null && cpInt != null ) { sFeature1Init ( yInt . intValue ( ) , cpInt . intValue ( ) ) ; } } this . idx = idx ; this . val = val ; this . wgt = wgt ; strId2IdxAdd ( fmap ) ; }
public static final String trimEnd ( String str ) { int position = str . length ( ) ; while ( ( position > _NUM ) && Character . isWhitespace ( str . charAt ( position - _NUM ) ) ) { position -- ; } return str . substring ( _NUM , position ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
@ SuppressWarnings ( { STRING , STRING } ) private static PipelineOp distinctTermScanJoin ( final PipelineOp left , final List < NV > anns , Predicate pred , final DatasetNode dataset , final Long cutoffLimitIsIgnored , final VarNode distinctTermScanVar , final Properties queryHints , final AST2BOpContext ctx ) { final IVariable distinctVar = distinctTermScanVar . getValueExpression ( ) ; anns . add ( new NV ( DistinctTermScanOp . Annotations . DISTINCT_VAR , distinctVar ) ) ; final Constant < IV > mockConst = new Constant < IV > ( TermId . mockIV ( VTE . URI ) ) ; final IPredicate mockPred = pred . asBound ( distinctVar , mockConst ) ; final SPOKeyOrder keyOrder = SPOKeyOrder . getKeyOrder ( mockPred , ctx . isQuads ( ) ? _NUM : _NUM ) ; pred = ( Predicate ) pred . setProperty ( IPredicate . Annotations . KEY_ORDER , keyOrder ) ; anns . add ( new NV ( PipelineJoin . Annotations . PREDICATE , pred ) ) ; return applyQueryHints ( new DistinctTermScanOp ( leftOrEmpty ( left ) , NV . asMap ( anns . toArray ( new NV [ anns . size ( ) ] ) ) ) , queryHints , ctx ) ; }
private void showPopupMenu ( final MouseEvent event ) { final ITagTreeNode selectedNode = ( ITagTreeNode ) TreeHelpers . getNodeAt ( this , event . getX ( ) , event . getY ( ) ) ; if ( selectedNode == null ) { final JPopupMenu popupMenu = new JPopupMenu ( ) ; popupMenu . add ( CActionProxy . proxy ( new CAddRootTagNodeAction ( m_parent , m_tagManager , m_rootNode . getTag ( ) ) ) ) ; popupMenu . show ( this , event . getX ( ) , event . getY ( ) ) ; } else { final JPopupMenu menu = selectedNode . getPopupMenu ( ) ; if ( menu != null ) { menu . show ( this , event . getX ( ) , event . getY ( ) ) ; } } }
private void burrowCave ( Point point , LayerDefinition layer ) { Queue < Point > branchPoints = new LinkedList < Point > ( ) ; HashSet < Point > visited = new HashSet < Point > ( ) ; branchPoints . add ( point ) ; List < Point > neighbours = getUnvisitedNeighbours ( point , visited ) ; do { visited . add ( point ) ; if ( neighbours . size ( ) > _NUM ) { Point next = Rand . rand ( neighbours ) ; branchPoints . add ( next ) ; int diffx = Integer . signum ( next . x - point . x ) ; int diffy = Integer . signum ( next . y - point . y ) ; for ( int i = _NUM ; i <= WALL_THICKNESS ; i ++ ) { setCollide ( layer , point . x + i * diffx , point . y + i * diffy , _BOOL ) ; } point = next ; } else { point = branchPoints . poll ( ) ; } neighbours = getUnvisitedNeighbours ( point , visited ) ; } while ( point != null ) ; }
public IntentBuilder addEmailBcc ( String address ) { if ( mBccAddresses == null ) { mBccAddresses = new ArrayList < String > ( ) ; } mBccAddresses . add ( address ) ; return this ; }
public IntentBuilder addEmailBcc ( String address ) { if ( mBccAddresses == null ) { mBccAddresses = new ArrayList < String > ( ) ; } mBccAddresses . add ( address ) ; return this ; }
public ServerCommit acquire ( OperationEntry entry , ServerSessionContext session , long timestamp ) { ServerCommit commit = pool . poll ( ) ; if ( commit == null ) { commit = new ServerCommit ( this , log ) ; } commit . reset ( entry , session , timestamp ) ; return commit ; }
private boolean assertStaticType ( Class < ? > cls , Name n ) { int local = n . index ( ) ; Class < ? > aclass = localClasses [ local ] ; if ( aclass != null && ( aclass == cls || cls . isAssignableFrom ( aclass ) ) ) { return _BOOL ; } else if ( aclass == null || aclass . isAssignableFrom ( cls ) ) { localClasses [ local ] = cls ; } return _BOOL ; }
public static void ensure32BitIe ( ) { File ie32 = new File ( IE32_LOCATION ) ; if ( findBrowser ( IE32_NAME ) == null && ie32 . exists ( ) ) { createBrowserDescriptor ( IE32_NAME , IE32_LOCATION ) ; } }
public static void ensure32BitIe ( ) { File ie32 = new File ( IE32_LOCATION ) ; if ( findBrowser ( IE32_NAME ) == null && ie32 . exists ( ) ) { createBrowserDescriptor ( IE32_NAME , IE32_LOCATION ) ; } }
public static void ensure32BitIe ( ) { File ie32 = new File ( IE32_LOCATION ) ; if ( findBrowser ( IE32_NAME ) == null && ie32 . exists ( ) ) { createBrowserDescriptor ( IE32_NAME , IE32_LOCATION ) ; } }
public static void ensure32BitIe ( ) { File ie32 = new File ( IE32_LOCATION ) ; if ( findBrowser ( IE32_NAME ) == null && ie32 . exists ( ) ) { createBrowserDescriptor ( IE32_NAME , IE32_LOCATION ) ; } }
@ Override public boolean isComponentEnabled ( ResolveInfo resolveInfo ) { if ( resolveInfo != null && resolveInfo . serviceInfo != null && ! TextUtils . isEmpty ( resolveInfo . serviceInfo . packageName ) ) { if ( mPermittedPackageNames == null || isSystemApp ( resolveInfo . serviceInfo . applicationInfo ) ) { return _BOOL ; } else { return mPermittedPackageNames . contains ( resolveInfo . serviceInfo . packageName ) ; } } return _BOOL ; }
@ Override public boolean isComponentEnabled ( ResolveInfo resolveInfo ) { if ( resolveInfo != null && resolveInfo . serviceInfo != null && ! TextUtils . isEmpty ( resolveInfo . serviceInfo . packageName ) ) { if ( mPermittedPackageNames == null || isSystemApp ( resolveInfo . serviceInfo . applicationInfo ) ) { return _BOOL ; } else { return mPermittedPackageNames . contains ( resolveInfo . serviceInfo . packageName ) ; } } return _BOOL ; }
@ Override public boolean isComponentEnabled ( ResolveInfo resolveInfo ) { if ( resolveInfo != null && resolveInfo . serviceInfo != null && ! TextUtils . isEmpty ( resolveInfo . serviceInfo . packageName ) ) { if ( mPermittedPackageNames == null || isSystemApp ( resolveInfo . serviceInfo . applicationInfo ) ) { return _BOOL ; } else { return mPermittedPackageNames . contains ( resolveInfo . serviceInfo . packageName ) ; } } return _BOOL ; }
@ Override public boolean isComponentEnabled ( ResolveInfo resolveInfo ) { if ( resolveInfo != null && resolveInfo . serviceInfo != null && ! TextUtils . isEmpty ( resolveInfo . serviceInfo . packageName ) ) { if ( mPermittedPackageNames == null || isSystemApp ( resolveInfo . serviceInfo . applicationInfo ) ) { return _BOOL ; } else { return mPermittedPackageNames . contains ( resolveInfo . serviceInfo . packageName ) ; } } return _BOOL ; }
@ Override public Generator < ILineSegment > construct ( String [ ] args ) { return new SlidingLadderGenerator ( Double . valueOf ( args [ _NUM ] ) ) ; }
public ParametricTextualExtensionRecognizer ( ArrayList exts ) { int size = exts . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { Object aux = exts . get ( i ) ; if ( aux instanceof String ) { String ext = ( String ) aux ; addExtension ( ext ) ; } } }
public ParametricTextualExtensionRecognizer ( ArrayList exts ) { int size = exts . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { Object aux = exts . get ( i ) ; if ( aux instanceof String ) { String ext = ( String ) aux ; addExtension ( ext ) ; } } }
public static SketchHex create ( String sketchName , String hexString ) throws HexParsingException { if ( sketchName . length ( ) > Constants . MAX_SKETCH_NAME_LENGTH ) { sketchName = sketchName . substring ( _NUM , Constants . MAX_SKETCH_NAME_LENGTH ) ; } List < Line > lines = parseHexStringToLines ( hexString ) ; byte [ ] bytes = convertLinesToBytes ( lines ) ; return new AutoParcel_SketchHex ( sketchName , bytes ) ; }
public static SketchHex create ( String sketchName , String hexString ) throws HexParsingException { if ( sketchName . length ( ) > Constants . MAX_SKETCH_NAME_LENGTH ) { sketchName = sketchName . substring ( _NUM , Constants . MAX_SKETCH_NAME_LENGTH ) ; } List < Line > lines = parseHexStringToLines ( hexString ) ; byte [ ] bytes = convertLinesToBytes ( lines ) ; return new AutoParcel_SketchHex ( sketchName , bytes ) ; }
private synchronized void close ( ) { if ( s != null ) { try { s . close ( ) ; } catch ( IOException ex ) { LOGGER . warning ( STRING + ex ) ; } } }
protected AnnotationQuery ( String scope , String metric , Map < String , String > tags , Long startTimestamp , Long endTimestamp ) { this ( ) ; requireArgument ( startTimestamp != null , STRING ) ; requireArgument ( scope != null , STRING ) ; requireArgument ( metric == null || ! metric . isEmpty ( ) , STRING ) ; _startTimestamp = startTimestamp ; _endTimestamp = endTimestamp ; _scope = scope ; _metric = metric ; if ( tags != null ) { setTags ( tags ) ; } }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > result = new Vector < Option > ( ) ; result . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; result . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return result . elements ( ) ; }
private void updateTypes ( @ Nonnull TurnoutOperation op ) { if ( ! initialized ) initialize ( ) ; LinkedList < TurnoutOperation > newTypes = new LinkedList < TurnoutOperation > ( ) ; Iterator < TurnoutOperation > iter = operationTypes . iterator ( ) ; boolean found = _BOOL ; while ( iter . hasNext ( ) ) { TurnoutOperation item = iter . next ( ) ; if ( item . getClass ( ) == op . getClass ( ) ) { newTypes . add ( op ) ; found = _BOOL ; log . debug ( STRING + item . getClass ( ) ) ; } else { newTypes . add ( item ) ; } } if ( ! found ) { newTypes . add ( op ) ; log . debug ( STRING + op . getClass ( ) ) ; } operationTypes = newTypes ; }
private void updateTypes ( @ Nonnull TurnoutOperation op ) { if ( ! initialized ) initialize ( ) ; LinkedList < TurnoutOperation > newTypes = new LinkedList < TurnoutOperation > ( ) ; Iterator < TurnoutOperation > iter = operationTypes . iterator ( ) ; boolean found = _BOOL ; while ( iter . hasNext ( ) ) { TurnoutOperation item = iter . next ( ) ; if ( item . getClass ( ) == op . getClass ( ) ) { newTypes . add ( op ) ; found = _BOOL ; log . debug ( STRING + item . getClass ( ) ) ; } else { newTypes . add ( item ) ; } } if ( ! found ) { newTypes . add ( op ) ; log . debug ( STRING + op . getClass ( ) ) ; } operationTypes = newTypes ; }
private void updateTypes ( @ Nonnull TurnoutOperation op ) { if ( ! initialized ) initialize ( ) ; LinkedList < TurnoutOperation > newTypes = new LinkedList < TurnoutOperation > ( ) ; Iterator < TurnoutOperation > iter = operationTypes . iterator ( ) ; boolean found = _BOOL ; while ( iter . hasNext ( ) ) { TurnoutOperation item = iter . next ( ) ; if ( item . getClass ( ) == op . getClass ( ) ) { newTypes . add ( op ) ; found = _BOOL ; log . debug ( STRING + item . getClass ( ) ) ; } else { newTypes . add ( item ) ; } } if ( ! found ) { newTypes . add ( op ) ; log . debug ( STRING + op . getClass ( ) ) ; } operationTypes = newTypes ; }
public static String humanReadableInt ( long number ) { long absNumber = Math . abs ( number ) ; double result = number ; String suffix = STRING ; if ( absNumber < _NUM ) { } else if ( absNumber < _NUM * _NUM ) { result = number / _NUM ; suffix = STRING ; } else if ( absNumber < _NUM * _NUM * _NUM ) { result = number / ( _NUM * _NUM ) ; suffix = STRING ; } else { result = number / ( _NUM * _NUM * _NUM ) ; suffix = STRING ; } return oneDecimal . format ( result ) + suffix ; }
public static String humanReadableInt ( long number ) { long absNumber = Math . abs ( number ) ; double result = number ; String suffix = STRING ; if ( absNumber < _NUM ) { } else if ( absNumber < _NUM * _NUM ) { result = number / _NUM ; suffix = STRING ; } else if ( absNumber < _NUM * _NUM * _NUM ) { result = number / ( _NUM * _NUM ) ; suffix = STRING ; } else { result = number / ( _NUM * _NUM * _NUM ) ; suffix = STRING ; } return oneDecimal . format ( result ) + suffix ; }
public void invokeHookEmit ( List < Object > values , String stream , Collection < Integer > outTasks ) { if ( taskHooks . size ( ) != _NUM ) { EmitInfo emitInfo = new EmitInfo ( values , stream , getThisTaskId ( ) , outTasks ) ; for ( ITaskHook taskHook : taskHooks ) { taskHook . emit ( emitInfo ) ; } } }
public void invokeHookEmit ( List < Object > values , String stream , Collection < Integer > outTasks ) { if ( taskHooks . size ( ) != _NUM ) { EmitInfo emitInfo = new EmitInfo ( values , stream , getThisTaskId ( ) , outTasks ) ; for ( ITaskHook taskHook : taskHooks ) { taskHook . emit ( emitInfo ) ; } } }
private Object queryCommandValue ( final String commandIdentifier ) { Check . notNull ( commandIdentifier , STRING ) ; final StringBuffer cmd = new StringBuffer ( ) ; cmd . append ( STRING ) ; cmd . append ( commandIdentifier ) ; cmd . append ( STRING ) ; return browser . evaluate ( cmd . toString ( ) ) ; }
public void invalidateVisualState ( ) { arguments . forEach ( null ) ; result . invalidateVisualState ( ) ; }
public static String loadLastColor ( Context context ) { try { SharedPreferences sharedPreferences = context . getSharedPreferences ( STRING , Context . MODE_PRIVATE ) ; String s = sharedPreferences . getString ( SP_KEY_LAST_COLOR , null ) ; Color . parseColor ( s ) ; return s ; } catch ( Exception e ) { e . printStackTrace ( ) ; return null ; } }
public CoreDescriptor ( CoreContainer container , String name , String instanceDir , Properties coreProps , SolrParams params ) { this . coreContainer = container ; originalCoreProperties . setProperty ( CORE_NAME , name ) ; originalCoreProperties . setProperty ( CORE_INSTDIR , instanceDir ) ; Properties containerProperties = container . getContainerProperties ( ) ; name = PropertiesUtil . substituteProperty ( checkPropertyIsNotEmpty ( name , CORE_NAME ) , containerProperties ) ; instanceDir = PropertiesUtil . substituteProperty ( checkPropertyIsNotEmpty ( instanceDir , CORE_INSTDIR ) , containerProperties ) ; coreProperties . putAll ( defaultProperties ) ; coreProperties . put ( CORE_NAME , name ) ; coreProperties . put ( CORE_INSTDIR , instanceDir ) ; coreProperties . put ( CORE_ABS_INSTDIR , convertToAbsolute ( instanceDir , container . getCoreRootDirectory ( ) ) ) ; for ( String propname : coreProps . stringPropertyNames ( ) ) { String propvalue = coreProps . getProperty ( propname ) ; if ( isUserDefinedProperty ( propname ) ) originalExtraProperties . put ( propname , propvalue ) ; else originalCoreProperties . put ( propname , propvalue ) ; if ( ! requiredProperties . contains ( propname ) ) coreProperties . setProperty ( propname , PropertiesUtil . substituteProperty ( propvalue , containerProperties ) ) ; } loadExtraProperties ( ) ; buildSubstitutableProperties ( ) ; if ( container . isZooKeeperAware ( ) ) { cloudDesc = new CloudDescriptor ( name , coreProperties , this ) ; if ( params != null ) { cloudDesc . setParams ( params ) ; } } else { cloudDesc = null ; } }
@ Override public void assertEquals ( String message , Object expectedObj , Object actualObj ) { ANOVAMatrix expected = ( ANOVAMatrix ) expectedObj ; ANOVAMatrix actual = ( ANOVAMatrix ) actualObj ; message = message + STRING + actual . getSource ( ) + STRING ; double [ ] [ ] expectedProbabilities = expected . getProbabilities ( ) ; double [ ] [ ] actualProbabilities = actual . getProbabilities ( ) ; for ( int i = _NUM ; i < expectedProbabilities . length ; i ++ ) { for ( int j = _NUM ; j < expectedProbabilities [ i ] . length ; j ++ ) { Assert . assertEquals ( message + STRING , expectedProbabilities [ i ] [ j ] , actualProbabilities [ i ] [ j ] , _NUM ) ; } } Assert . assertEquals ( message + STRING , expected . getSignificanceLevel ( ) , actual . getSignificanceLevel ( ) , _NUM ) ; }
private float [ ] calcBorderValues ( ) { float max = Integer . MIN_VALUE ; float min = Integer . MAX_VALUE ; for ( ChartSet set : chartView . data ) { for ( ChartEntry e : set . getEntries ( ) ) { if ( e . getValue ( ) >= max ) max = e . getValue ( ) ; if ( e . getValue ( ) <= min ) min = e . getValue ( ) ; } } return new float [ ] { min , max } ; }
public static void maxConnections ( final int maxConnections ) { setProperty ( STRING , Integer . toString ( maxConnections ) ) ; }
private InternalDistributedMember waitForNodeOrCreateBucket ( RetryTimeKeeper retryTime , EntryEventImpl event , Integer bucketId ) { InternalDistributedMember newNode ; if ( retryTime . overMaximum ( ) ) { PRHARedundancyProvider . timedOut ( this , null , null , STRING , retryTime . getRetryTime ( ) ) ; } retryTime . waitForBucketsRecovery ( ) ; newNode = getNodeForBucketWrite ( bucketId . intValue ( ) , retryTime ) ; if ( newNode == null ) { newNode = createBucket ( bucketId . intValue ( ) , getEntrySize ( event ) , retryTime ) ; } return newNode ; }
private InternalDistributedMember waitForNodeOrCreateBucket ( RetryTimeKeeper retryTime , EntryEventImpl event , Integer bucketId ) { InternalDistributedMember newNode ; if ( retryTime . overMaximum ( ) ) { PRHARedundancyProvider . timedOut ( this , null , null , STRING , retryTime . getRetryTime ( ) ) ; } retryTime . waitForBucketsRecovery ( ) ; newNode = getNodeForBucketWrite ( bucketId . intValue ( ) , retryTime ) ; if ( newNode == null ) { newNode = createBucket ( bucketId . intValue ( ) , getEntrySize ( event ) , retryTime ) ; } return newNode ; }
private InternalDistributedMember waitForNodeOrCreateBucket ( RetryTimeKeeper retryTime , EntryEventImpl event , Integer bucketId ) { InternalDistributedMember newNode ; if ( retryTime . overMaximum ( ) ) { PRHARedundancyProvider . timedOut ( this , null , null , STRING , retryTime . getRetryTime ( ) ) ; } retryTime . waitForBucketsRecovery ( ) ; newNode = getNodeForBucketWrite ( bucketId . intValue ( ) , retryTime ) ; if ( newNode == null ) { newNode = createBucket ( bucketId . intValue ( ) , getEntrySize ( event ) , retryTime ) ; } return newNode ; }
private InternalDistributedMember waitForNodeOrCreateBucket ( RetryTimeKeeper retryTime , EntryEventImpl event , Integer bucketId ) { InternalDistributedMember newNode ; if ( retryTime . overMaximum ( ) ) { PRHARedundancyProvider . timedOut ( this , null , null , STRING , retryTime . getRetryTime ( ) ) ; } retryTime . waitForBucketsRecovery ( ) ; newNode = getNodeForBucketWrite ( bucketId . intValue ( ) , retryTime ) ; if ( newNode == null ) { newNode = createBucket ( bucketId . intValue ( ) , getEntrySize ( event ) , retryTime ) ; } return newNode ; }
public CoapClient ( URI uri ) { this ( uri . toString ( ) ) ; }
public void doOpen ( ) { }
private void checkNotEqual ( UnknownFieldSet s1 , UnknownFieldSet s2 ) { String equalsError = String . format ( STRING , s1 , s2 ) ; assertFalse ( equalsError , s1 . equals ( s2 ) ) ; assertFalse ( equalsError , s2 . equals ( s1 ) ) ; assertFalse ( String . format ( STRING , s1 , s2 ) , s1 . hashCode ( ) == s2 . hashCode ( ) ) ; }
private void checkNotEqual ( UnknownFieldSet s1 , UnknownFieldSet s2 ) { String equalsError = String . format ( STRING , s1 , s2 ) ; assertFalse ( equalsError , s1 . equals ( s2 ) ) ; assertFalse ( equalsError , s2 . equals ( s1 ) ) ; assertFalse ( String . format ( STRING , s1 , s2 ) , s1 . hashCode ( ) == s2 . hashCode ( ) ) ; }
private void checkNotEqual ( UnknownFieldSet s1 , UnknownFieldSet s2 ) { String equalsError = String . format ( STRING , s1 , s2 ) ; assertFalse ( equalsError , s1 . equals ( s2 ) ) ; assertFalse ( equalsError , s2 . equals ( s1 ) ) ; assertFalse ( String . format ( STRING , s1 , s2 ) , s1 . hashCode ( ) == s2 . hashCode ( ) ) ; }
private boolean mayAccess ( Player player , Entity entity , RPAction action ) { if ( entity == null ) { return _BOOL ; } RPObject object = entity . getContainer ( ) ; if ( object == null ) { return _BOOL ; } RPSlot slot = entity . getContainerSlot ( ) ; if ( ! reorderableSlots . contains ( slot . getName ( ) ) ) { return _BOOL ; } if ( slot instanceof EntitySlot ) { if ( ! isReachableSlot ( player , slot ) ) { return _BOOL ; } } else if ( object != player ) { return _BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . getName ( ) + STRING + action ) ; return _BOOL ; } } slot = object . getContainerSlot ( ) ; if ( ( slot != null ) && isReachableSlot ( player , slot ) ) { return _BOOL ; } if ( object instanceof Corpse ) { return _BOOL ; } object = object . getContainer ( ) ; } while ( object != null ) ; return _BOOL ; }
private boolean mayAccess ( Player player , Entity entity , RPAction action ) { if ( entity == null ) { return _BOOL ; } RPObject object = entity . getContainer ( ) ; if ( object == null ) { return _BOOL ; } RPSlot slot = entity . getContainerSlot ( ) ; if ( ! reorderableSlots . contains ( slot . getName ( ) ) ) { return _BOOL ; } if ( slot instanceof EntitySlot ) { if ( ! isReachableSlot ( player , slot ) ) { return _BOOL ; } } else if ( object != player ) { return _BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . getName ( ) + STRING + action ) ; return _BOOL ; } } slot = object . getContainerSlot ( ) ; if ( ( slot != null ) && isReachableSlot ( player , slot ) ) { return _BOOL ; } if ( object instanceof Corpse ) { return _BOOL ; } object = object . getContainer ( ) ; } while ( object != null ) ; return _BOOL ; }
private boolean mayAccess ( Player player , Entity entity , RPAction action ) { if ( entity == null ) { return _BOOL ; } RPObject object = entity . getContainer ( ) ; if ( object == null ) { return _BOOL ; } RPSlot slot = entity . getContainerSlot ( ) ; if ( ! reorderableSlots . contains ( slot . getName ( ) ) ) { return _BOOL ; } if ( slot instanceof EntitySlot ) { if ( ! isReachableSlot ( player , slot ) ) { return _BOOL ; } } else if ( object != player ) { return _BOOL ; } do { if ( object instanceof Player ) { if ( object != player ) { logger . error ( STRING + player . getName ( ) + STRING + action ) ; return _BOOL ; } } slot = object . getContainerSlot ( ) ; if ( ( slot != null ) && isReachableSlot ( player , slot ) ) { return _BOOL ; } if ( object instanceof Corpse ) { return _BOOL ; } object = object . getContainer ( ) ; } while ( object != null ) ; return _BOOL ; }
public static void stop ( Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
public static void stop ( Thread thread ) { if ( thread != null ) { thread . interrupt ( ) ; } }
protected void onBeforeStart ( BundleContext ctx ) { }
protected void onBeforeStart ( BundleContext ctx ) { }
public CheckBoxList ( ) { this ( null ) ; }
public CheckBoxList ( ) { this ( null ) ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public MessageChannel createMessageChannel ( SIPRequest request , MessageProcessor mp , Hop nextHop ) throws IOException { Host targetHost = new Host ( ) ; targetHost . setHostname ( nextHop . getHost ( ) ) ; HostPort targetHostPort = new HostPort ( ) ; targetHostPort . setHost ( targetHost ) ; targetHostPort . setPort ( nextHop . getPort ( ) ) ; MessageChannel returnChannel = mp . createMessageChannel ( targetHostPort ) ; return returnChannel ; }
public static void resetFileStates ( List < FileState > fileStates ) { for ( Iterator < FileState > iter = fileStates . iterator ( ) ; iter . hasNext ( ) ; ) { FileState fileState = iter . next ( ) ; if ( fileState . getModification ( ) == deleted ) { iter . remove ( ) ; } else { fileState . setModification ( null ) ; fileState . setPreviousFileState ( null ) ; } } }
public static boolean isHotSpot ( ) { return jvmImplName . contains ( STRING ) ; }
public void runProgram ( ) { if ( ( runningThread == null ) && ! running ) { running = _BOOL ; runningThread = new Thread ( this ) ; runningThread . start ( ) ; } }
public void runProgram ( ) { if ( ( runningThread == null ) && ! running ) { running = _BOOL ; runningThread = new Thread ( this ) ; runningThread . start ( ) ; } }
public void runProgram ( ) { if ( ( runningThread == null ) && ! running ) { running = _BOOL ; runningThread = new Thread ( this ) ; runningThread . start ( ) ; } }
public void runProgram ( ) { if ( ( runningThread == null ) && ! running ) { running = _BOOL ; runningThread = new Thread ( this ) ; runningThread . start ( ) ; } }
public boolean equalsIgnoreSource ( Country country ) { return country != null && mCountryIso . equals ( country . getCountryIso ( ) ) ; }
public boolean equalsIgnoreSource ( Country country ) { return country != null && mCountryIso . equals ( country . getCountryIso ( ) ) ; }
public void write ( byte [ ] content ) throws IOException { out . write ( content ) ; }
public void subscriber ( Class < ? > api , @ Pin ServiceRefAmp serviceRef , Result < ? super Cancel > result ) { String path = api . getName ( ) ; String address = address ( path ) ; EventNodeAsset node = lookupPubSubNode ( address ) ; Cancel cancel = node . subscribeImpl ( serviceRef ) ; result . ok ( cancel ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
public void addListListener ( ActionListener a ) { listeners . add ( a ) ; }
static int exclusiveCount ( int c ) { return c & EXCLUSIVE_MASK ; }
static int exclusiveCount ( int c ) { return c & EXCLUSIVE_MASK ; }
static int exclusiveCount ( int c ) { return c & EXCLUSIVE_MASK ; }
public ZWaveMultiInstanceCommandClass ( ZWaveNode node , ZWaveController controller , ZWaveEndpoint endpoint ) { super ( node , controller , endpoint ) ; versionMax = MAX_SUPPORTED_VERSION ; }
private void prepareDataSet ( ) { dataSet1 = Arrays . asList ( new String [ ] { STRING , STRING } ) ; dataSet2 = Arrays . asList ( new String [ ] { STRING , STRING } ) ; dataSet3 = Arrays . asList ( new String [ ] { STRING , STRING } ) ; }
@ Override public void resetOptions ( ) { super . resetOptions ( ) ; setRetrieval ( NONE ) ; try { if ( m_DataBaseConnection != null && m_DataBaseConnection . isConnected ( ) ) { m_DataBaseConnection . disconnectFromDatabase ( ) ; } m_DataBaseConnection = newDatabaseConnection ( ) ; } catch ( Exception ex ) { printException ( ex ) ; } m_URL = m_DataBaseConnection . getDatabaseURL ( ) ; m_tableName = STRING ; m_Username = m_DataBaseConnection . getUsername ( ) ; m_Password = m_DataBaseConnection . getPassword ( ) ; m_count = _NUM ; m_id = _BOOL ; m_tabName = _BOOL ; }
private static String translateOSNameToFolderName ( String osName ) { if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else { return osName . replaceAll ( STRING , STRING ) ; } }
private static String translateOSNameToFolderName ( String osName ) { if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else if ( osName . contains ( STRING ) ) { return STRING ; } else { return osName . replaceAll ( STRING , STRING ) ; } }
public void appendItemToService ( int service , EcuDataItem newItem ) { HashMap < Integer , Vector < EcuDataItem > > currSvc = get ( service ) ; if ( currSvc == null ) { currSvc = new HashMap < Integer , Vector < EcuDataItem > > ( ) ; log . debug ( STRING + service + STRING + currSvc ) ; } Vector < EcuDataItem > currVec = currSvc . get ( newItem . pid ) ; if ( currVec == null ) { currVec = new Vector < EcuDataItem > ( ) ; log . debug ( STRING + newItem . pid + STRING + currVec ) ; } currVec . add ( newItem ) ; currSvc . put ( newItem . pid , currVec ) ; put ( service , currSvc ) ; log . debug ( STRING + service + STRING + String . format ( STRING , newItem . pid ) + STRING + currVec ) ; }
String prepareDataEntryFormForEntry ( String htmlCode , Collection < TrackedEntityDataValue > dataValues , I18n i18n , ProgramStage programStage , ProgramStageInstance programStageInstance , OrganisationUnit organisationUnit ) ;
String prepareDataEntryFormForEntry ( String htmlCode , Collection < TrackedEntityDataValue > dataValues , I18n i18n , ProgramStage programStage , ProgramStageInstance programStageInstance , OrganisationUnit organisationUnit ) ;
String prepareDataEntryFormForEntry ( String htmlCode , Collection < TrackedEntityDataValue > dataValues , I18n i18n , ProgramStage programStage , ProgramStageInstance programStageInstance , OrganisationUnit organisationUnit ) ;
@ Override public void afterPropertiesSet ( ) throws Exception { registeredProcess . add ( this ) ; }
@ Override public void afterPropertiesSet ( ) throws Exception { registeredProcess . add ( this ) ; }
public void testGetServletNamesForJspFileWithSingleServlet ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING + STRING + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; List < String > servletNames = WebXmlUtils . getServletNamesForJspFile ( webXml , STRING ) ; assertEquals ( _NUM , servletNames . size ( ) ) ; assertEquals ( STRING , servletNames . get ( _NUM ) ) ; }
public void testGetServletNamesForJspFileWithSingleServlet ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING + STRING + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; List < String > servletNames = WebXmlUtils . getServletNamesForJspFile ( webXml , STRING ) ; assertEquals ( _NUM , servletNames . size ( ) ) ; assertEquals ( STRING , servletNames . get ( _NUM ) ) ; }
public void testGetServletNamesForJspFileWithSingleServlet ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING + STRING + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; List < String > servletNames = WebXmlUtils . getServletNamesForJspFile ( webXml , STRING ) ; assertEquals ( _NUM , servletNames . size ( ) ) ; assertEquals ( STRING , servletNames . get ( _NUM ) ) ; }
public void testGetServletNamesForJspFileWithSingleServlet ( ) throws Exception { String xml = WEBAPP_TEST_HEADER + STRING + STRING + STRING + STRING + STRING ; WebXml webXml = WebXmlIo . parseWebXml ( new ByteArrayInputStream ( xml . getBytes ( STRING ) ) , getEntityResolver ( ) ) ; List < String > servletNames = WebXmlUtils . getServletNamesForJspFile ( webXml , STRING ) ; assertEquals ( _NUM , servletNames . size ( ) ) ; assertEquals ( STRING , servletNames . get ( _NUM ) ) ; }
public void addValue ( int count , String stringRepresentation ) { values . add ( new UniqueValue ( count , stringRepresentation ) ) ; }
public static Date parseXSDate ( String dateStr , TimeZone defaultTimeZone , CalendarFieldsToDateConverter calToDateConverter ) throws DateParseException { Matcher m = PATTERN_XS_DATE . matcher ( dateStr ) ; if ( ! m . matches ( ) ) { throw new DateParseException ( STRING + PATTERN_XS_DATE ) ; } return parseDate_parseMatcher ( m , defaultTimeZone , _BOOL , calToDateConverter ) ; }
public boolean isInterlaced ( ) { return interlaced ; }
public synchronized void end ( Component component ) { this . active = _BOOL ; this . offset = null ; this . beginPosition = null ; component . setCursor ( Cursor . getPredefinedCursor ( Cursor . DEFAULT_CURSOR ) ) ; }
public void storeSession ( UserSession session ) { sessions . add ( session ) ; }
public void testManyConnectionsUsingOneThread ( ) { try { int maxConnections = getConnectionNum ( ) ; openConnections ( maxConnections ) ; assertEquals ( STRING , maxConnections , vc . size ( ) ) ; } catch ( Exception e ) { fail ( STRING + e . toString ( ) ) ; } }
@ Override public StateConnection onCloseRead ( ) { ConnectionProtocol request = request ( ) ; if ( request != null ) { request . onCloseRead ( ) ; } _sequenceClose . set ( _sequenceRead . get ( ) ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { _isClosePending . set ( _BOOL ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { return StateConnection . CLOSE_READ_S ; } else { _isClosePending . set ( _BOOL ) ; return StateConnection . CLOSE ; } } else { return StateConnection . CLOSE ; } }
@ Override public StateConnection onCloseRead ( ) { ConnectionProtocol request = request ( ) ; if ( request != null ) { request . onCloseRead ( ) ; } _sequenceClose . set ( _sequenceRead . get ( ) ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { _isClosePending . set ( _BOOL ) ; if ( _sequenceFlush . get ( ) < _sequenceClose . get ( ) ) { return StateConnection . CLOSE_READ_S ; } else { _isClosePending . set ( _BOOL ) ; return StateConnection . CLOSE ; } } else { return StateConnection . CLOSE ; } }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
@ Override public Iterator < T > iterator ( ) { return buffer . descendingIterator ( ) ; }
public void received ( ByteBuffer buffer ) { hasReceivedData = _BOOL ; lastReceiveTime = System . currentTimeMillis ( ) ; }
public static TupleExpr process ( TupleExpr query , List < ExternalTupleSet > indexSet ) { boolean indexPlaced = _BOOL ; TupleExpr rtn = query . clone ( ) ; QueryNodeCount qnc = new QueryNodeCount ( ) ; rtn . visit ( qnc ) ; if ( qnc . getNodeCount ( ) / _NUM < indexSet . size ( ) ) { return null ; } organizeBSAs ( rtn ) ; if ( isTupleValid ( rtn ) ) { for ( ExternalTupleSet index : indexSet ) { if ( isTupleValid ( index . getTupleExpr ( ) ) ) { ExternalTupleSet eTup = ( ExternalTupleSet ) index . clone ( ) ; SPBubbleDownVisitor indexVistor = new SPBubbleDownVisitor ( eTup ) ; rtn . visit ( indexVistor ) ; FilterBubbleManager fbmv = new FilterBubbleManager ( eTup ) ; rtn . visit ( fbmv ) ; SubsetEqualsVisitor subIndexVis = new SubsetEqualsVisitor ( eTup , rtn ) ; rtn . visit ( subIndexVis ) ; indexPlaced = subIndexVis . indexPlaced ( ) ; if ( ! indexPlaced ) { break ; } } } if ( indexPlaced ) { return rtn ; } else { return null ; } } else { throw new IllegalArgumentException ( STRING ) ; } }
public static TupleExpr process ( TupleExpr query , List < ExternalTupleSet > indexSet ) { boolean indexPlaced = _BOOL ; TupleExpr rtn = query . clone ( ) ; QueryNodeCount qnc = new QueryNodeCount ( ) ; rtn . visit ( qnc ) ; if ( qnc . getNodeCount ( ) / _NUM < indexSet . size ( ) ) { return null ; } organizeBSAs ( rtn ) ; if ( isTupleValid ( rtn ) ) { for ( ExternalTupleSet index : indexSet ) { if ( isTupleValid ( index . getTupleExpr ( ) ) ) { ExternalTupleSet eTup = ( ExternalTupleSet ) index . clone ( ) ; SPBubbleDownVisitor indexVistor = new SPBubbleDownVisitor ( eTup ) ; rtn . visit ( indexVistor ) ; FilterBubbleManager fbmv = new FilterBubbleManager ( eTup ) ; rtn . visit ( fbmv ) ; SubsetEqualsVisitor subIndexVis = new SubsetEqualsVisitor ( eTup , rtn ) ; rtn . visit ( subIndexVis ) ; indexPlaced = subIndexVis . indexPlaced ( ) ; if ( ! indexPlaced ) { break ; } } } if ( indexPlaced ) { return rtn ; } else { return null ; } } else { throw new IllegalArgumentException ( STRING ) ; } }
@ Override public void saveResults ( ) { helper . writeScenesToJaif ( ) ; }
public static String gensalt ( final int log_rounds , final SecureRandom random ) { final StringBuffer rs = new StringBuffer ( ) ; final byte rnd [ ] = new byte [ BCRYPT_SALT_LEN ] ; random . nextBytes ( rnd ) ; rs . append ( STRING ) ; if ( log_rounds < _NUM ) { rs . append ( STRING ) ; } if ( log_rounds > _NUM ) { throw new IllegalArgumentException ( STRING ) ; } rs . append ( Integer . toString ( log_rounds ) ) ; rs . append ( STRING ) ; rs . append ( encode_base64 ( rnd , rnd . length ) ) ; return rs . toString ( ) ; }
public void replace ( ClassNode type , int n ) { remove ( n ) ; push ( type ) ; }
protected ReplacedElement lookupImageReplacedElement ( Element e ) { if ( imageComponents . size ( ) == _NUM ) { return null ; } ReplacedElement replacedElement = ( ReplacedElement ) imageComponents . get ( e ) ; return replacedElement ; }
byte dirTypeBackward ( ) { lastChar = text . charAt ( charIndex - _NUM ) ; if ( Character . isLowSurrogate ( lastChar ) ) { int codePoint = Character . codePointBefore ( text , charIndex ) ; charIndex -= Character . charCount ( codePoint ) ; return Character . getDirectionality ( codePoint ) ; } charIndex -- ; byte dirType = getCachedDirectionality ( lastChar ) ; if ( isHtml ) { if ( lastChar == STRING ) { dirType = skipTagBackward ( ) ; } else if ( lastChar == STRING ) { dirType = skipEntityBackward ( ) ; } } return dirType ; }
byte dirTypeBackward ( ) { lastChar = text . charAt ( charIndex - _NUM ) ; if ( Character . isLowSurrogate ( lastChar ) ) { int codePoint = Character . codePointBefore ( text , charIndex ) ; charIndex -= Character . charCount ( codePoint ) ; return Character . getDirectionality ( codePoint ) ; } charIndex -- ; byte dirType = getCachedDirectionality ( lastChar ) ; if ( isHtml ) { if ( lastChar == STRING ) { dirType = skipTagBackward ( ) ; } else if ( lastChar == STRING ) { dirType = skipEntityBackward ( ) ; } } return dirType ; }
public void validateItem ( final Element itemElement ) { hide ( ) ; }
public void addAllSearchables ( ArrayList < ? extends SearchResult > searchable ) { searchables . addAll ( searchable ) ; }
public static int [ ] shuffle ( int [ ] input ) { List < Integer > vals = new ArrayList < Integer > ( input . length ) ; for ( int i = _NUM ; i < input . length ; i ++ ) vals . add ( input [ i ] ) ; Collections . shuffle ( vals , SEEDED_RANDOM ) ; int [ ] copy = new int [ input . length ] ; for ( int i = _NUM ; i < input . length ; i ++ ) copy [ i ] = vals . get ( i ) ; return copy ; }
public OMGraphicList readCachedGraphics ( URL url ) throws java . io . IOException { if ( Debug . debugging ( STRING ) ) { Debug . output ( STRING ) ; } OMGraphicList omgraphics = new OMGraphicList ( ) ; if ( url != null ) { omgraphics . readGraphics ( url ) ; } return omgraphics ; }
@ SuppressWarnings ( STRING ) public static < K extends Throwable > void rewrapAndThrowIfInstance ( String newMessage , Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . isAssignableFrom ( t . getClass ( ) ) ) { K kt = ( K ) t ; K wrapped = Throwables . rewrap ( newMessage , kt ) ; throw wrapped ; } }
@ SuppressWarnings ( STRING ) public static < K extends Throwable > void rewrapAndThrowIfInstance ( String newMessage , Throwable t , Class < K > clazz ) throws K { if ( ( t != null ) && clazz . isAssignableFrom ( t . getClass ( ) ) ) { K kt = ( K ) t ; K wrapped = Throwables . rewrap ( newMessage , kt ) ; throw wrapped ; } }
private void writeStuffed ( int b ) throws IOException { out . write ( _NUM ) ; if ( b == _NUM ) { out . write ( _NUM ) ; } }
protected void updateHostTable ( ) { final ServiceScore [ ] serviceScores = serviceTableRef . get ( ) ; final IHostScoringRule scoringRule = scoringRuleRef . get ( ) ; if ( serviceScores == null || serviceScores . length == _NUM || scoringRule == null ) { hostTableRef . set ( null ) ; return ; } final Map < String , IHostMetrics > hostMetricsMap = getHostReportForKnownServices ( scoringRule , serviceScores ) ; if ( hostMetricsMap == null || hostMetricsMap . isEmpty ( ) ) { hostTableRef . set ( null ) ; return ; } if ( log . isTraceEnabled ( ) ) log . trace ( STRING + hostMetricsMap ) ; final HostTable newHostTable = normalizeHostScores ( scoringRule , hostMetricsMap ) ; if ( log . isTraceEnabled ( ) ) log . trace ( STRING + newHostTable ) ; hostTableRef . set ( newHostTable ) ; }
protected void updateHostTable ( ) { final ServiceScore [ ] serviceScores = serviceTableRef . get ( ) ; final IHostScoringRule scoringRule = scoringRuleRef . get ( ) ; if ( serviceScores == null || serviceScores . length == _NUM || scoringRule == null ) { hostTableRef . set ( null ) ; return ; } final Map < String , IHostMetrics > hostMetricsMap = getHostReportForKnownServices ( scoringRule , serviceScores ) ; if ( hostMetricsMap == null || hostMetricsMap . isEmpty ( ) ) { hostTableRef . set ( null ) ; return ; } if ( log . isTraceEnabled ( ) ) log . trace ( STRING + hostMetricsMap ) ; final HostTable newHostTable = normalizeHostScores ( scoringRule , hostMetricsMap ) ; if ( log . isTraceEnabled ( ) ) log . trace ( STRING + newHostTable ) ; hostTableRef . set ( newHostTable ) ; }
protected void updateHostTable ( ) { final ServiceScore [ ] serviceScores = serviceTableRef . get ( ) ; final IHostScoringRule scoringRule = scoringRuleRef . get ( ) ; if ( serviceScores == null || serviceScores . length == _NUM || scoringRule == null ) { hostTableRef . set ( null ) ; return ; } final Map < String , IHostMetrics > hostMetricsMap = getHostReportForKnownServices ( scoringRule , serviceScores ) ; if ( hostMetricsMap == null || hostMetricsMap . isEmpty ( ) ) { hostTableRef . set ( null ) ; return ; } if ( log . isTraceEnabled ( ) ) log . trace ( STRING + hostMetricsMap ) ; final HostTable newHostTable = normalizeHostScores ( scoringRule , hostMetricsMap ) ; if ( log . isTraceEnabled ( ) ) log . trace ( STRING + newHostTable ) ; hostTableRef . set ( newHostTable ) ; }
public void addRoot ( String name , File root ) { if ( TextUtils . isEmpty ( name ) ) { throw new IllegalArgumentException ( STRING ) ; } try { root = root . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STRING + root , e ) ; } mRoots . put ( name , root ) ; }
public void addRoot ( String name , File root ) { if ( TextUtils . isEmpty ( name ) ) { throw new IllegalArgumentException ( STRING ) ; } try { root = root . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STRING + root , e ) ; } mRoots . put ( name , root ) ; }
public void addRoot ( String name , File root ) { if ( TextUtils . isEmpty ( name ) ) { throw new IllegalArgumentException ( STRING ) ; } try { root = root . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STRING + root , e ) ; } mRoots . put ( name , root ) ; }
public void addRoot ( String name , File root ) { if ( TextUtils . isEmpty ( name ) ) { throw new IllegalArgumentException ( STRING ) ; } try { root = root . getCanonicalFile ( ) ; } catch ( IOException e ) { throw new IllegalArgumentException ( STRING + root , e ) ; } mRoots . put ( name , root ) ; }
public static char [ ] cloneCharArray ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == _NUM ) { return chars ; } char [ ] copy = new char [ len ] ; System . arraycopy ( chars , _NUM , copy , _NUM , len ) ; return copy ; }
public static char [ ] cloneCharArray ( char [ ] chars ) { if ( chars == null ) { return null ; } int len = chars . length ; if ( len == _NUM ) { return chars ; } char [ ] copy = new char [ len ] ; System . arraycopy ( chars , _NUM , copy , _NUM , len ) ; return copy ; }
void handleQuitButton ( ) { dir = null ; file = null ; target . hide ( ) ; }
@ Override public final int hashCode ( ) { long firsthash = Double . doubleToLongBits ( first ) ; firsthash = firsthash ^ ( firsthash > > _NUM ) ; long secondhash = Double . doubleToLongBits ( second ) ; secondhash = secondhash ^ ( secondhash > > _NUM ) ; return ( int ) ( firsthash * _NUM + secondhash ) ; }
@ Override public final int hashCode ( ) { long firsthash = Double . doubleToLongBits ( first ) ; firsthash = firsthash ^ ( firsthash > > _NUM ) ; long secondhash = Double . doubleToLongBits ( second ) ; secondhash = secondhash ^ ( secondhash > > _NUM ) ; return ( int ) ( firsthash * _NUM + secondhash ) ; }
@ Override public int read ( ) throws IOException { ensureOpen ( ) ; if ( next >= length ) return - _NUM ; return str . charAt ( next ++ ) ; }
public static byte [ ] createSignatureAlgorithmsExtension ( Vector supportedSignatureAlgorithms ) throws IOException { ByteArrayOutputStream buf = new ByteArrayOutputStream ( ) ; encodeSupportedSignatureAlgorithms ( supportedSignatureAlgorithms , _BOOL , buf ) ; return buf . toByteArray ( ) ; }
public static SpannableStringBuilder warpChooserTitle ( Activity context , String appName ) { @ SuppressLint ( STRING ) String title = String . format ( context . getString ( R . string . select_transfer_way_apk , appName ) ) ; ForegroundColorSpan fontSpanRed = new ForegroundColorSpan ( Utils . getColorWarp ( context , R . color . colorAccent ) ) ; int start = _NUM ; int end = start + appName . length ( ) + _NUM ; SpannableStringBuilder mSpannableBuilder = new SpannableStringBuilder ( title ) ; mSpannableBuilder . setSpan ( fontSpanRed , start , end , Spanned . SPAN_INCLUSIVE_INCLUSIVE ) ; return mSpannableBuilder ; }
public static SpannableStringBuilder warpChooserTitle ( Activity context , String appName ) { @ SuppressLint ( STRING ) String title = String . format ( context . getString ( R . string . select_transfer_way_apk , appName ) ) ; ForegroundColorSpan fontSpanRed = new ForegroundColorSpan ( Utils . getColorWarp ( context , R . color . colorAccent ) ) ; int start = _NUM ; int end = start + appName . length ( ) + _NUM ; SpannableStringBuilder mSpannableBuilder = new SpannableStringBuilder ( title ) ; mSpannableBuilder . setSpan ( fontSpanRed , start , end , Spanned . SPAN_INCLUSIVE_INCLUSIVE ) ; return mSpannableBuilder ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
public void componentAdded ( ContainerEvent e ) { Layer childLayer = ( Layer ) e . getChild ( ) ; addProjectionListener ( childLayer ) ; if ( ! removedLayers . removeElement ( childLayer ) ) { addedLayers . addElement ( childLayer ) ; } changeLayers ( e ) ; }
@ Nullable @ WorkerThread static File writeBitmapToDirectory ( @ NonNull Bitmap bitmap , @ NonNull File directory ) { if ( ! directory . mkdirs ( ) && ! directory . exists ( ) ) { Log . e ( TAG , STRING ) ; return null ; } return writeBitmapToFile ( bitmap , new File ( directory , createUniqueFilename ( BITMAP_PREFIX ) ) ) ; }
public byte [ ] encryptRaw ( byte [ ] baseKey , int usage , byte [ ] ivec , byte [ ] plaintext , int start , int len ) throws GeneralSecurityException , KrbCryptoException { if ( ! KeyUsage . isValid ( usage ) ) { throw new GeneralSecurityException ( STRING + usage ) ; } byte [ ] output = encryptCTS ( baseKey , usage , ivec , null , plaintext , start , len , _BOOL ) ; return output ; }
public static String [ ] split ( String string , char c ) { if ( countMatches ( string , c ) <= _NUM ) return new String [ ] { string } ; String s = string + c ; String [ ] sa = new String [ countMatches ( string , c ) + _NUM ] ; StringBuilder sb = new StringBuilder ( ) ; char [ ] ca = s . toCharArray ( ) ; int n = _NUM , x ; for ( x = _NUM ; x < ca . length ; x ++ ) { if ( ca [ x ] == c ) { sa [ n ] = sb . toString ( ) ; sb = new StringBuilder ( ) ; n ++ ; } else { sb . append ( ca [ x ] ) ; } } return sa ; }
synchronized void remove ( PgServerThread t ) { running . remove ( t ) ; }
public boolean initStream ( ReadStream readStream , ReadStream rawStream ) throws IOException { readStream . init ( _inStream ) ; return _BOOL ; }
public List < PojoField > cassandraUniqueFields ( ) { return casUniqueFields ; }
public List < PojoField > cassandraUniqueFields ( ) { return casUniqueFields ; }
public double secondsSinceStart ( ) { return ( timeSinceStart ( ) ) / _NUM ; }
private void buildNationalNumberForParsing ( String numberToParse , StringBuilder nationalNumber ) { int indexOfPhoneContext = numberToParse . indexOf ( RFC3966_PHONE_CONTEXT ) ; if ( indexOfPhoneContext > _NUM ) { int phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT . length ( ) ; if ( numberToParse . charAt ( phoneContextStart ) == PLUS_SIGN ) { int phoneContextEnd = numberToParse . indexOf ( STRING , phoneContextStart ) ; if ( phoneContextEnd > _NUM ) { nationalNumber . append ( numberToParse . substring ( phoneContextStart , phoneContextEnd ) ) ; } else { nationalNumber . append ( numberToParse . substring ( phoneContextStart ) ) ; } } int indexOfRfc3966Prefix = numberToParse . indexOf ( RFC3966_PREFIX ) ; int indexOfNationalNumber = ( indexOfRfc3966Prefix >= _NUM ) ? indexOfRfc3966Prefix + RFC3966_PREFIX . length ( ) : _NUM ; nationalNumber . append ( numberToParse . substring ( indexOfNationalNumber , indexOfPhoneContext ) ) ; } else { nationalNumber . append ( extractPossibleNumber ( numberToParse ) ) ; } int indexOfIsdn = nationalNumber . indexOf ( RFC3966_ISDN_SUBADDRESS ) ; if ( indexOfIsdn > _NUM ) { nationalNumber . delete ( indexOfIsdn , nationalNumber . length ( ) ) ; } }
private void buildNationalNumberForParsing ( String numberToParse , StringBuilder nationalNumber ) { int indexOfPhoneContext = numberToParse . indexOf ( RFC3966_PHONE_CONTEXT ) ; if ( indexOfPhoneContext > _NUM ) { int phoneContextStart = indexOfPhoneContext + RFC3966_PHONE_CONTEXT . length ( ) ; if ( numberToParse . charAt ( phoneContextStart ) == PLUS_SIGN ) { int phoneContextEnd = numberToParse . indexOf ( STRING , phoneContextStart ) ; if ( phoneContextEnd > _NUM ) { nationalNumber . append ( numberToParse . substring ( phoneContextStart , phoneContextEnd ) ) ; } else { nationalNumber . append ( numberToParse . substring ( phoneContextStart ) ) ; } } int indexOfRfc3966Prefix = numberToParse . indexOf ( RFC3966_PREFIX ) ; int indexOfNationalNumber = ( indexOfRfc3966Prefix >= _NUM ) ? indexOfRfc3966Prefix + RFC3966_PREFIX . length ( ) : _NUM ; nationalNumber . append ( numberToParse . substring ( indexOfNationalNumber , indexOfPhoneContext ) ) ; } else { nationalNumber . append ( extractPossibleNumber ( numberToParse ) ) ; } int indexOfIsdn = nationalNumber . indexOf ( RFC3966_ISDN_SUBADDRESS ) ; if ( indexOfIsdn > _NUM ) { nationalNumber . delete ( indexOfIsdn , nationalNumber . length ( ) ) ; } }
public int size ( ) { return inputs . size ( ) ; }
public final boolean canThrowExceptions ( ) { return ( flags & CAN_THROW_EXCEPTIONS ) != _NUM ; }
public static double angle ( NumberVector v1 , NumberVector v2 , NumberVector o ) { final int dim1 = v1 . getDimensionality ( ) , dim2 = v2 . getDimensionality ( ) , dimo = o . getDimensionality ( ) ; final int mindim = ( dim1 <= dim2 ) ? dim1 : dim2 ; double cross = _NUM , l1 = _NUM , l2 = _NUM ; for ( int k = _NUM ; k < mindim ; k ++ ) { final double ok = k < dimo ? o . doubleValue ( k ) : _NUM ; final double r1 = v1 . doubleValue ( k ) - ok ; final double r2 = v2 . doubleValue ( k ) - ok ; cross += r1 * r2 ; l1 += r1 * r1 ; l2 += r2 * r2 ; } for ( int k = mindim ; k < dim1 ; k ++ ) { final double ok = k < dimo ? o . doubleValue ( k ) : _NUM ; final double r1 = v1 . doubleValue ( k ) - ok ; l1 += r1 * r1 ; } for ( int k = mindim ; k < dim2 ; k ++ ) { final double ok = k < dimo ? o . doubleValue ( k ) : _NUM ; final double r2 = v2 . doubleValue ( k ) - ok ; l2 += r2 * r2 ; } final double a = ( cross == _NUM ) ? _NUM : ( l1 == _NUM || l2 == _NUM ) ? _NUM : Math . sqrt ( ( cross / l1 ) * ( cross / l2 ) ) ; return ( a < _NUM ) ? a : _NUM ; }
public static List < String > splitPath ( File file ) { List < String > output = new ArrayList < > ( ) ; File current = file ; while ( current != null ) { output . add ( current . getName ( ) ) ; current = current . getParentFile ( ) ; } Collections . reverse ( output ) ; return output ; }
public static List < String > splitPath ( File file ) { List < String > output = new ArrayList < > ( ) ; File current = file ; while ( current != null ) { output . add ( current . getName ( ) ) ; current = current . getParentFile ( ) ; } Collections . reverse ( output ) ; return output ; }
public void addHeader ( @ LayoutRes int layoutId ) { addHeader ( layoutId , null ) ; }
public void addHeader ( @ LayoutRes int layoutId ) { addHeader ( layoutId , null ) ; }
public void remove ( double value ) { if ( Double . isNaN ( value ) ) { return ; } int index = findInsertIndex ( value ) ; if ( index == - _NUM ) { throw new IllegalStateException ( STRING ) ; } Double valueAtIndex = values . get ( index ) ; if ( ( valueAtIndex != null ) && ( ! valueAtIndex . equals ( value ) ) ) { throw new IllegalStateException ( STRING ) ; } values . remove ( index ) ; }
public final int atAdPos ( final int pos ) { final int take_int = ( int ) Math . floor ( ( pos + _NUM ) / adfrequency ) ; Log . d ( STRING , take_int + STRING ) ; return take_int ; }
public void addAll ( T ... items ) { int start ; synchronized ( mLock ) { start = getItemCount ( ) ; Collections . addAll ( mObjects , items ) ; } if ( mNotifyOnChange ) notifyItemRangeInserted ( start , items . length ) ; }
public void addAll ( T ... items ) { int start ; synchronized ( mLock ) { start = getItemCount ( ) ; Collections . addAll ( mObjects , items ) ; } if ( mNotifyOnChange ) notifyItemRangeInserted ( start , items . length ) ; }
public ShellMinimumSizeEnforcer ( final Shell shell , final int minimumWidth , final int minimumHeight ) { this . shell = shell ; this . minimumWidth = minimumWidth ; this . minimumHeight = minimumHeight ; currentLocation = shell . getLocation ( ) ; if ( ( FORCE_LEGACY_BEHAVIOR || ! attemptSetMinimumSize ( ) ) && ! WindowSystem . isCurrentWindowSystem ( WindowSystem . X_WINDOW_SYSTEM ) ) { final MinSizeListener listener = new MinSizeListener ( ) ; shell . addControlListener ( listener ) ; } }
private boolean isPrettyPrintingEnabled ( ) { return flags . contains ( WriterFlags . PRETTY_PRINT ) && ! currentElement ( ) . unformattedChildren ; }
private boolean isPrettyPrintingEnabled ( ) { return flags . contains ( WriterFlags . PRETTY_PRINT ) && ! currentElement ( ) . unformattedChildren ; }
private boolean isPrettyPrintingEnabled ( ) { return flags . contains ( WriterFlags . PRETTY_PRINT ) && ! currentElement ( ) . unformattedChildren ; }
public void startDocumentEntity ( XMLInputSource xmlInputSource ) throws IOException , XNIException { startEntity ( XMLEntity , xmlInputSource , _BOOL , _BOOL ) ; }
public static Connection connectOrUpgrade ( String url , Properties info ) throws SQLException { if ( ! UPGRADE_CLASSES_PRESENT ) { return null ; } Properties i2 = new Properties ( ) ; i2 . putAll ( info ) ; Object o = info . get ( STRING ) ; if ( o instanceof char [ ] ) { i2 . put ( STRING , StringUtils . cloneCharArray ( ( char [ ] ) o ) ) ; } info = i2 ; ConnectionInfo ci = new ConnectionInfo ( url , info ) ; if ( ci . isRemote ( ) || ! ci . isPersistent ( ) ) { return null ; } String name = ci . getName ( ) ; if ( FileUtils . exists ( name + Constants . SUFFIX_PAGE_FILE ) ) { return null ; } if ( ! FileUtils . exists ( name + Constants . SUFFIX_OLD_DATABASE_FILE ) ) { return null ; } if ( ci . removeProperty ( STRING , _BOOL ) ) { return connectWithOldVersion ( url , info ) ; } synchronized ( DbUpgrade . class ) { upgrade ( ci , info ) ; return null ; } }
public static Connection connectOrUpgrade ( String url , Properties info ) throws SQLException { if ( ! UPGRADE_CLASSES_PRESENT ) { return null ; } Properties i2 = new Properties ( ) ; i2 . putAll ( info ) ; Object o = info . get ( STRING ) ; if ( o instanceof char [ ] ) { i2 . put ( STRING , StringUtils . cloneCharArray ( ( char [ ] ) o ) ) ; } info = i2 ; ConnectionInfo ci = new ConnectionInfo ( url , info ) ; if ( ci . isRemote ( ) || ! ci . isPersistent ( ) ) { return null ; } String name = ci . getName ( ) ; if ( FileUtils . exists ( name + Constants . SUFFIX_PAGE_FILE ) ) { return null ; } if ( ! FileUtils . exists ( name + Constants . SUFFIX_OLD_DATABASE_FILE ) ) { return null ; } if ( ci . removeProperty ( STRING , _BOOL ) ) { return connectWithOldVersion ( url , info ) ; } synchronized ( DbUpgrade . class ) { upgrade ( ci , info ) ; return null ; } }
protected GridClient startClient ( String addr , int port ) throws GridClientException { GridClientConfiguration cliCfg = new GridClientConfiguration ( ) ; cliCfg . setServers ( Collections . singleton ( addr + STRING + port ) ) ; cliCfg . setProtocol ( protocol ( ) ) ; return GridClientFactory . start ( cliCfg ) ; }
public int compare ( String o1 , String o2 ) { return o1 . compareToIgnoreCase ( o2 ) ; }
private DigicoreChain cleanChain ( DigicoreChain chain ) { return chain ; }
private DigicoreChain cleanChain ( DigicoreChain chain ) { return chain ; }
private DigicoreChain cleanChain ( DigicoreChain chain ) { return chain ; }
public static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { Assert . notNull ( clazz , STRING ) ; try { ClassLoader target = clazz . getClassLoader ( ) ; if ( target == null ) { return _BOOL ; } ClassLoader cur = classLoader ; if ( cur == target ) { return _BOOL ; } while ( cur != null ) { cur = cur . getParent ( ) ; if ( cur == target ) { return _BOOL ; } } return _BOOL ; } catch ( SecurityException ex ) { return _BOOL ; } }
public static boolean isCacheSafe ( Class < ? > clazz , ClassLoader classLoader ) { Assert . notNull ( clazz , STRING ) ; try { ClassLoader target = clazz . getClassLoader ( ) ; if ( target == null ) { return _BOOL ; } ClassLoader cur = classLoader ; if ( cur == target ) { return _BOOL ; } while ( cur != null ) { cur = cur . getParent ( ) ; if ( cur == target ) { return _BOOL ; } } return _BOOL ; } catch ( SecurityException ex ) { return _BOOL ; } }
public static void copy ( Resource in , OutputStream os , boolean closeOS ) throws IOException { InputStream is = null ; try { is = toBufferedInputStream ( in . getInputStream ( ) ) ; } catch ( IOException ioe ) { IOUtil . closeEL ( is ) ; throw ioe ; } copy ( is , os , _BOOL , closeOS ) ; }
public static void copy ( Resource in , OutputStream os , boolean closeOS ) throws IOException { InputStream is = null ; try { is = toBufferedInputStream ( in . getInputStream ( ) ) ; } catch ( IOException ioe ) { IOUtil . closeEL ( is ) ; throw ioe ; } copy ( is , os , _BOOL , closeOS ) ; }
public Instances resample ( Random random ) { Instances newData = new Instances ( this , numInstances ( ) ) ; while ( newData . numInstances ( ) < numInstances ( ) ) { newData . add ( instance ( random . nextInt ( numInstances ( ) ) ) ) ; } return newData ; }
public Instances resample ( Random random ) { Instances newData = new Instances ( this , numInstances ( ) ) ; while ( newData . numInstances ( ) < numInstances ( ) ) { newData . add ( instance ( random . nextInt ( numInstances ( ) ) ) ) ; } return newData ; }
public Instances resample ( Random random ) { Instances newData = new Instances ( this , numInstances ( ) ) ; while ( newData . numInstances ( ) < numInstances ( ) ) { newData . add ( instance ( random . nextInt ( numInstances ( ) ) ) ) ; } return newData ; }
protected abstract void storeBody ( DataOutputStream dos ) throws IOException ;
protected abstract void storeBody ( DataOutputStream dos ) throws IOException ;
public static void add ( Object spy ) { SPIES . add ( spy ) ; }
public void addCell ( groovy . swing . impl . TableLayoutCell tag ) { int gridx = _NUM ; for ( Iterator iter = cells . iterator ( ) ; iter . hasNext ( ) ; ) { groovy . swing . impl . TableLayoutCell cell = ( groovy . swing . impl . TableLayoutCell ) iter . next ( ) ; gridx += cell . getColspan ( ) ; } tag . getConstraints ( ) . gridx = gridx ; cells . add ( tag ) ; }
public void findAndInit ( Object someObj ) { if ( someObj instanceof MouseDelegator ) { Debug . message ( STRING , STRING ) ; setMouseDelegator ( ( MouseDelegator ) someObj ) ; } }
public void findAndInit ( Object someObj ) { if ( someObj instanceof MouseDelegator ) { Debug . message ( STRING , STRING ) ; setMouseDelegator ( ( MouseDelegator ) someObj ) ; } }
public void findAndInit ( Object someObj ) { if ( someObj instanceof MouseDelegator ) { Debug . message ( STRING , STRING ) ; setMouseDelegator ( ( MouseDelegator ) someObj ) ; } }
public static void addPathToClasspaths ( String path ) { extraPaths . addElement ( path ) ; }
public void doMouseClicked ( java . awt . event . MouseEvent e ) { if ( ! _editor . getFlag ( Editor . OPTION_CONTROLS , isControlling ( ) ) ) { return ; } if ( e . isMetaDown ( ) || e . isAltDown ( ) ) { return ; } if ( ( namedTurnoutWest == null ) || ( namedTurnoutEast == null ) ) { log . error ( STRING ) ; return ; } switch ( turnoutType ) { case DOUBLESLIP : doDoubleSlipMouseClick ( ) ; break ; case SINGLESLIP : doSingleSlipMouseClick ( ) ; break ; case THREEWAY : do3WayMouseClick ( ) ; break ; case SCISSOR : doScissorMouseClick ( ) ; break ; default : log . error ( STRING , turnoutType ) ; } }
public void doMouseClicked ( java . awt . event . MouseEvent e ) { if ( ! _editor . getFlag ( Editor . OPTION_CONTROLS , isControlling ( ) ) ) { return ; } if ( e . isMetaDown ( ) || e . isAltDown ( ) ) { return ; } if ( ( namedTurnoutWest == null ) || ( namedTurnoutEast == null ) ) { log . error ( STRING ) ; return ; } switch ( turnoutType ) { case DOUBLESLIP : doDoubleSlipMouseClick ( ) ; break ; case SINGLESLIP : doSingleSlipMouseClick ( ) ; break ; case THREEWAY : do3WayMouseClick ( ) ; break ; case SCISSOR : doScissorMouseClick ( ) ; break ; default : log . error ( STRING , turnoutType ) ; } }
public static char [ ] genOffsetBitmap ( int [ ] offsets ) { int lastOffset = offsets [ offsets . length - _NUM ] ; int numBlocks = ( lastOffset / BITMAP_BLOCK_SZ ) + _NUM ; int [ ] blockLengths = new int [ numBlocks ] ; Arrays . fill ( blockLengths , _NUM ) ; for ( int ix = _NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int blockForVal = val / BITMAP_BLOCK_SZ ; blockLengths [ blockForVal ] ++ ; } int totalSize = numBlocks ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { totalSize += blockLengths [ block ] ; } char [ ] encodedBlocks = new char [ totalSize ] ; int inputIx = _NUM ; int blockStartIx = _NUM ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { int blockSz = blockLengths [ block ] ; encodedBlocks [ blockStartIx ] = ( char ) blockSz ; for ( int i = _NUM ; i < blockSz ; i ++ ) { encodedBlocks [ blockStartIx + i + _NUM ] = ( char ) ( offsets [ inputIx + i ] % BITMAP_BLOCK_SZ ) ; } inputIx += blockSz ; blockStartIx += blockSz + _NUM ; } return encodedBlocks ; }
public static char [ ] genOffsetBitmap ( int [ ] offsets ) { int lastOffset = offsets [ offsets . length - _NUM ] ; int numBlocks = ( lastOffset / BITMAP_BLOCK_SZ ) + _NUM ; int [ ] blockLengths = new int [ numBlocks ] ; Arrays . fill ( blockLengths , _NUM ) ; for ( int ix = _NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int blockForVal = val / BITMAP_BLOCK_SZ ; blockLengths [ blockForVal ] ++ ; } int totalSize = numBlocks ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { totalSize += blockLengths [ block ] ; } char [ ] encodedBlocks = new char [ totalSize ] ; int inputIx = _NUM ; int blockStartIx = _NUM ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { int blockSz = blockLengths [ block ] ; encodedBlocks [ blockStartIx ] = ( char ) blockSz ; for ( int i = _NUM ; i < blockSz ; i ++ ) { encodedBlocks [ blockStartIx + i + _NUM ] = ( char ) ( offsets [ inputIx + i ] % BITMAP_BLOCK_SZ ) ; } inputIx += blockSz ; blockStartIx += blockSz + _NUM ; } return encodedBlocks ; }
public static char [ ] genOffsetBitmap ( int [ ] offsets ) { int lastOffset = offsets [ offsets . length - _NUM ] ; int numBlocks = ( lastOffset / BITMAP_BLOCK_SZ ) + _NUM ; int [ ] blockLengths = new int [ numBlocks ] ; Arrays . fill ( blockLengths , _NUM ) ; for ( int ix = _NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int blockForVal = val / BITMAP_BLOCK_SZ ; blockLengths [ blockForVal ] ++ ; } int totalSize = numBlocks ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { totalSize += blockLengths [ block ] ; } char [ ] encodedBlocks = new char [ totalSize ] ; int inputIx = _NUM ; int blockStartIx = _NUM ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { int blockSz = blockLengths [ block ] ; encodedBlocks [ blockStartIx ] = ( char ) blockSz ; for ( int i = _NUM ; i < blockSz ; i ++ ) { encodedBlocks [ blockStartIx + i + _NUM ] = ( char ) ( offsets [ inputIx + i ] % BITMAP_BLOCK_SZ ) ; } inputIx += blockSz ; blockStartIx += blockSz + _NUM ; } return encodedBlocks ; }
public static char [ ] genOffsetBitmap ( int [ ] offsets ) { int lastOffset = offsets [ offsets . length - _NUM ] ; int numBlocks = ( lastOffset / BITMAP_BLOCK_SZ ) + _NUM ; int [ ] blockLengths = new int [ numBlocks ] ; Arrays . fill ( blockLengths , _NUM ) ; for ( int ix = _NUM ; ix < offsets . length ; ix ++ ) { int val = offsets [ ix ] ; int blockForVal = val / BITMAP_BLOCK_SZ ; blockLengths [ blockForVal ] ++ ; } int totalSize = numBlocks ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { totalSize += blockLengths [ block ] ; } char [ ] encodedBlocks = new char [ totalSize ] ; int inputIx = _NUM ; int blockStartIx = _NUM ; for ( int block = _NUM ; block < numBlocks ; block ++ ) { int blockSz = blockLengths [ block ] ; encodedBlocks [ blockStartIx ] = ( char ) blockSz ; for ( int i = _NUM ; i < blockSz ; i ++ ) { encodedBlocks [ blockStartIx + i + _NUM ] = ( char ) ( offsets [ inputIx + i ] % BITMAP_BLOCK_SZ ) ; } inputIx += blockSz ; blockStartIx += blockSz + _NUM ; } return encodedBlocks ; }
public boolean writeAsKML ( Writer writer , boolean isDocument , KmlDocument kmlDocument ) { try { String objectType ; if ( this instanceof KmlFolder ) { if ( isDocument ) objectType = STRING ; else objectType = STRING ; } else if ( this instanceof KmlPlacemark ) objectType = STRING ; else if ( this instanceof KmlGroundOverlay ) objectType = STRING ; else return _BOOL ; writer . write ( STRING + objectType ) ; if ( mId != null ) writer . write ( STRING ) ; writer . write ( STRING ) ; if ( mStyle != null ) { writer . write ( STRING + mStyle + STRING ) ; } if ( mName != null ) { writer . write ( STRING + StringEscapeUtils . escapeXml10 ( mName ) + STRING ) ; } if ( mDescription != null ) { writer . write ( STRING + mDescription + STRING ) ; } if ( ! mVisibility ) { writer . write ( STRING ) ; } writeKMLSpecifics ( writer ) ; writeKMLExtendedData ( writer ) ; if ( isDocument ) { kmlDocument . writeKMLStyles ( writer ) ; } writer . write ( STRING + objectType + STRING ) ; return _BOOL ; } catch ( IOException e ) { e . printStackTrace ( ) ; return _BOOL ; } }
public boolean writeAsKML ( Writer writer , boolean isDocument , KmlDocument kmlDocument ) { try { String objectType ; if ( this instanceof KmlFolder ) { if ( isDocument ) objectType = STRING ; else objectType = STRING ; } else if ( this instanceof KmlPlacemark ) objectType = STRING ; else if ( this instanceof KmlGroundOverlay ) objectType = STRING ; else return _BOOL ; writer . write ( STRING + objectType ) ; if ( mId != null ) writer . write ( STRING ) ; writer . write ( STRING ) ; if ( mStyle != null ) { writer . write ( STRING + mStyle + STRING ) ; } if ( mName != null ) { writer . write ( STRING + StringEscapeUtils . escapeXml10 ( mName ) + STRING ) ; } if ( mDescription != null ) { writer . write ( STRING + mDescription + STRING ) ; } if ( ! mVisibility ) { writer . write ( STRING ) ; } writeKMLSpecifics ( writer ) ; writeKMLExtendedData ( writer ) ; if ( isDocument ) { kmlDocument . writeKMLStyles ( writer ) ; } writer . write ( STRING + objectType + STRING ) ; return _BOOL ; } catch ( IOException e ) { e . printStackTrace ( ) ; return _BOOL ; } }
public static boolean send ( XMPPConnection connection , Message msg ) { List < String > toList = getAllowedNotifiedAddresses ( connection ) ; toList = filterHangoutAddresses ( toList ) ; if ( toList . size ( ) > _NUM ) { try { Log . d ( STRING + toList . size ( ) + STRING ) ; MultipleRecipientManager . send ( connection , msg , toList , null , null ) ; } catch ( Exception e ) { Log . d ( STRING + e . getMessage ( ) ) ; for ( String notifiedAddress : toList ) { msg . setTo ( notifiedAddress ) ; try { connection . sendPacket ( msg ) ; } catch ( SmackException . NotConnectedException ex ) { Log . e ( STRING + ex . getMessage ( ) ) ; } } return _BOOL ; } } return _BOOL ; }
public void nextEntry ( ZipEntry ze ) throws IOException { LOG . fine ( STRING + currentPos ) ; byte [ ] intBuffer = new byte [ _NUM ] ; int bytesRead = fis . read ( intBuffer ) ; LOG . fine ( STRING + bytesRead ) ; if ( bytesRead == - _NUM ) { throw new IOException ( STRING + fis . available ( ) ) ; } int dataDescriptorLength = _NUM ; if ( Arrays . equals ( intBuffer , new byte [ ] { _NUM , _NUM , _NUM , _NUM } ) ) { dataDescriptorLength = _NUM + _NUM + _NUM ; fis . skip ( dataDescriptorLength ) ; fis . read ( intBuffer ) ; } if ( ! Arrays . equals ( intBuffer , new byte [ ] { _NUM , _NUM , _NUM , _NUM } ) ) { throw new IOException ( STRING + ByteArrayHelper . toString ( intBuffer ) ) ; } boolean hasDataDescriptor = ( ze . getMethod ( ) & _NUM ) > _NUM ; LOG . fine ( STRING + hasDataDescriptor ) ; this . compressedSize = ze . getCompressedSize ( ) ; fis . skip ( _NUM + _NUM + _NUM ) ; byte [ ] shortBuffer = new byte [ _NUM ] ; fis . read ( shortBuffer ) ; int fileNameLength = ByteArrayHelper . toInt ( shortBuffer ) ; fis . read ( shortBuffer ) ; int extraFieldLength = ByteArrayHelper . toInt ( shortBuffer ) ; startPos = _NUM + _NUM + fileNameLength + extraFieldLength + dataDescriptorLength ; currentPos = startPos ; endPos = startPos + this . compressedSize ; fis . skip ( fileNameLength + extraFieldLength ) ; }
public void close ( ) { closeResources ( ) ; valid = _BOOL ; LOGGER . info ( STRING + file . toAbsolutePath ( ) ) ; }
private void raiseErrorEvent ( int dialogTimeoutError ) { SIPDialogErrorEvent newErrorEvent ; Iterator < SIPDialogEventListener > listenerIterator ; SIPDialogEventListener nextListener ; newErrorEvent = new SIPDialogErrorEvent ( this , dialogTimeoutError ) ; synchronized ( eventListeners ) { listenerIterator = eventListeners . iterator ( ) ; while ( listenerIterator . hasNext ( ) ) { nextListener = ( SIPDialogEventListener ) listenerIterator . next ( ) ; nextListener . dialogErrorEvent ( newErrorEvent ) ; } } eventListeners . clear ( ) ; if ( dialogTimeoutError != SIPDialogErrorEvent . DIALOG_ACK_NOT_SENT_TIMEOUT && dialogTimeoutError != SIPDialogErrorEvent . DIALOG_ACK_NOT_RECEIVED_TIMEOUT && dialogTimeoutError != SIPDialogErrorEvent . DIALOG_REINVITE_TIMEOUT ) { delete ( ) ; } stopTimer ( ) ; }
public void autoArrange ( final ExecutionUnit process ) { List < ExecutionUnit > list = new ArrayList < > ( _NUM ) ; list . add ( _NUM , process ) ; autoArrange ( list ) ; }
private void initTable ( Database database ) throws SQLException { if ( database . findTungstenTable ( commitSeqnoTable . getSchema ( ) , commitSeqnoTable . getName ( ) ) == null ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + TABLE_NAME + STRING ) ; database . createTable ( commitSeqnoTable , _BOOL , tableType ) ; } }
private void initTable ( Database database ) throws SQLException { if ( database . findTungstenTable ( commitSeqnoTable . getSchema ( ) , commitSeqnoTable . getName ( ) ) == null ) { if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + TABLE_NAME + STRING ) ; database . createTable ( commitSeqnoTable , _BOOL , tableType ) ; } }
public BurpCertificate generateCertificate ( BurpCertificate issuer ) throws CertificateEncodingException , InvalidKeyException , IllegalStateException , NoSuchAlgorithmException , SignatureException , NoSuchProviderException , IOException , InvalidKeySpecException { if ( privateKey == null || publicKey == null ) { generateKeyPair ( ) ; } burpCertificate = new BurpCertificate ( generateX509Certificate ( issuer . getPrivateKey ( ) ) ) ; burpCertificate . setPrivateKey ( privateKey ) ; burpCertificate . setPublicKey ( publicKey ) ; burpCertificate . setSource ( STRING + issuer . getSubject ( ) ) ; return burpCertificate ; }
public BurpCertificate generateCertificate ( BurpCertificate issuer ) throws CertificateEncodingException , InvalidKeyException , IllegalStateException , NoSuchAlgorithmException , SignatureException , NoSuchProviderException , IOException , InvalidKeySpecException { if ( privateKey == null || publicKey == null ) { generateKeyPair ( ) ; } burpCertificate = new BurpCertificate ( generateX509Certificate ( issuer . getPrivateKey ( ) ) ) ; burpCertificate . setPrivateKey ( privateKey ) ; burpCertificate . setPublicKey ( publicKey ) ; burpCertificate . setSource ( STRING + issuer . getSubject ( ) ) ; return burpCertificate ; }
public BurpCertificate generateCertificate ( BurpCertificate issuer ) throws CertificateEncodingException , InvalidKeyException , IllegalStateException , NoSuchAlgorithmException , SignatureException , NoSuchProviderException , IOException , InvalidKeySpecException { if ( privateKey == null || publicKey == null ) { generateKeyPair ( ) ; } burpCertificate = new BurpCertificate ( generateX509Certificate ( issuer . getPrivateKey ( ) ) ) ; burpCertificate . setPrivateKey ( privateKey ) ; burpCertificate . setPublicKey ( publicKey ) ; burpCertificate . setSource ( STRING + issuer . getSubject ( ) ) ; return burpCertificate ; }
public static GDSServerVersion parseRawVersion ( String versionString ) throws GDSServerVersionException { Matcher matcher = VERSION_PATTERN . matcher ( versionString ) ; if ( ! matcher . matches ( ) ) { throw new GDSServerVersionException ( String . format ( STRING , versionString ) ) ; } return new GDSServerVersion ( versionString , matcher . group ( PLATFORM_IDX ) , matcher . group ( TYPE_IDX ) , matcher . group ( FULL_VERSION_IDX ) , Integer . parseInt ( matcher . group ( MAJOR_IDX ) ) , Integer . parseInt ( matcher . group ( MINOR_IDX ) ) , Integer . parseInt ( matcher . group ( VARIANT_IDX ) ) , Integer . parseInt ( matcher . group ( BUILD_IDX ) ) , matcher . group ( SERVER_NAME_IDX ) , matcher . group ( EXTENDED_INFO_IDX ) ) ; }
private void createContainerIfNecessary ( ) { if ( container . isFull ( ) ) { container = new TimerRawContainer ( ) ; data . add ( container ) ; } }
public Element generateSimpleElement ( final Document document , final Object pojo , final String ... attributes ) throws ParserConfigurationException , IllegalAccessException , InstantiationException { return generateSimpleElement ( document , pojo , Arrays . asList ( attributes ) ) ; }
private Type < ? > findInterface ( final Class < ? > theInterface ) { Type < ? > theInterfaceType = null ; LinkedList < Type < ? > > types = new LinkedList < Type < ? > > ( ) ; types . add ( this ) ; while ( theInterfaceType == null && ! types . isEmpty ( ) ) { Type < ? > currentType = types . removeFirst ( ) ; if ( theInterface . equals ( currentType . getRawType ( ) ) ) { theInterfaceType = currentType ; } else if ( ! currentType . equals ( TypeFactory . TYPE_OF_OBJECT ) ) { types . addAll ( Arrays . asList ( currentType . getInterfaces ( ) ) ) ; types . add ( currentType . getSuperType ( ) ) ; } } return theInterfaceType ; }
public static void applyActionRecursivelyOnEntities ( Entity root , Consumer < Entity > action ) { action . accept ( root ) ; NodeComponent nodeComponent = ComponentRetriever . get ( root , NodeComponent . class ) ; if ( nodeComponent != null && nodeComponent . children != null ) { for ( Entity targetEntity : nodeComponent . children ) { applyActionRecursivelyOnEntities ( targetEntity , action ) ; } } }
public static void moveFile ( File srcFile , File destFile ) throws IOException { if ( srcFile == null ) { throw new NullPointerException ( STRING ) ; } if ( destFile == null ) { throw new NullPointerException ( STRING ) ; } if ( ! srcFile . exists ( ) ) { throw new FileNotFoundException ( STRING + srcFile + STRING ) ; } if ( srcFile . isDirectory ( ) ) { throw new IOException ( STRING + srcFile + STRING ) ; } if ( destFile . exists ( ) ) { throw new FileExistsException ( STRING + destFile + STRING ) ; } if ( destFile . isDirectory ( ) ) { throw new IOException ( STRING + destFile + STRING ) ; } boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete ( ) ) { FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( STRING + srcFile + STRING + destFile + STRING ) ; } } }
public static void moveFile ( File srcFile , File destFile ) throws IOException { if ( srcFile == null ) { throw new NullPointerException ( STRING ) ; } if ( destFile == null ) { throw new NullPointerException ( STRING ) ; } if ( ! srcFile . exists ( ) ) { throw new FileNotFoundException ( STRING + srcFile + STRING ) ; } if ( srcFile . isDirectory ( ) ) { throw new IOException ( STRING + srcFile + STRING ) ; } if ( destFile . exists ( ) ) { throw new FileExistsException ( STRING + destFile + STRING ) ; } if ( destFile . isDirectory ( ) ) { throw new IOException ( STRING + destFile + STRING ) ; } boolean rename = srcFile . renameTo ( destFile ) ; if ( ! rename ) { copyFile ( srcFile , destFile ) ; if ( ! srcFile . delete ( ) ) { FileUtils . deleteQuietly ( destFile ) ; throw new IOException ( STRING + srcFile + STRING + destFile + STRING ) ; } } }
private void sendTcpRequest ( Socket socket , String request ) throws ApiException { try { LogUtils . LOGD ( TAG , STRING + request ) ; BufferedWriter writer = new BufferedWriter ( new OutputStreamWriter ( socket . getOutputStream ( ) ) ) ; writer . write ( request ) ; writer . flush ( ) ; } catch ( Exception e ) { LogUtils . LOGW ( TAG , STRING , e ) ; disconnect ( ) ; throw new ApiException ( ApiException . IO_EXCEPTION_WHILE_SENDING_REQUEST , e ) ; } }
public boolean elementAvailable ( String ns , String elemName ) throws javax . xml . transform . TransformerException { boolean isAvailable = _BOOL ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( extNS != null ) isAvailable = extNS . isElementAvailable ( elemName ) ; } return isAvailable ; }
public static Vec2D fromDegrees ( double angleInDegrees , double magnitude ) { double x = magnitude * Math . cos ( angleInDegrees * Math . PI / _NUM ) ; double y = magnitude * Math . sin ( angleInDegrees * Math . PI / _NUM ) ; return new Vec2D ( x , y ) ; }
public void handleException ( Exception e , int option ) { if ( ! getOptionIsSupported ( option ) ) { String message = e . getMessage ( ) ; if ( message != null && ( message . equals ( osDoesNotSupportOperationString ) || message . equals ( osDoesNotSupportOptionString ) || message . equals ( osDoesNotSupportOptionArgumentString ) ) ) { } else { fail ( STRING + e + STRING + getSocketOptionString ( option ) ) ; } } else { fail ( STRING + e . getMessage ( ) ) ; } }
protected String readAndSortFile ( String fileName ) throws Exception { return readAndSortFile ( fileName , null ) ; }
public void addAddress ( PeerAddress peerAddress ) { int newMax ; lock . lock ( ) ; try { addInactive ( peerAddress ) ; newMax = getMaxConnections ( ) + _NUM ; } finally { lock . unlock ( ) ; } setMaxConnections ( newMax ) ; }
public Builder withGlobalSuspendTimeout ( Duration globalSuspendTimeout ) { Assert . notNull ( globalSuspendTimeout , STRING ) ; this . globalSuspendTimeout = Assert . argNot ( globalSuspendTimeout , globalSuspendTimeout . isNegative ( ) || globalSuspendTimeout . isZero ( ) , STRING ) ; return this ; }
public Builder withGlobalSuspendTimeout ( Duration globalSuspendTimeout ) { Assert . notNull ( globalSuspendTimeout , STRING ) ; this . globalSuspendTimeout = Assert . argNot ( globalSuspendTimeout , globalSuspendTimeout . isNegative ( ) || globalSuspendTimeout . isZero ( ) , STRING ) ; return this ; }
public Builder withGlobalSuspendTimeout ( Duration globalSuspendTimeout ) { Assert . notNull ( globalSuspendTimeout , STRING ) ; this . globalSuspendTimeout = Assert . argNot ( globalSuspendTimeout , globalSuspendTimeout . isNegative ( ) || globalSuspendTimeout . isZero ( ) , STRING ) ; return this ; }
static URI withoutFragment ( final String fullUri ) { int hashmarkIdx = fullUri . indexOf ( STRING ) ; String rval ; if ( hashmarkIdx == - _NUM ) { rval = fullUri ; } else { rval = fullUri . substring ( _NUM , hashmarkIdx ) ; } try { return new URI ( rval ) ; } catch ( URISyntaxException e ) { throw new RuntimeException ( e ) ; } }
public static void flatten ( File dirToRemove ) throws IOException { final File parent = dirToRemove . getParentFile ( ) ; for ( File child : FileMisc . list ( dirToRemove ) ) { boolean createDestDir = _BOOL ; if ( child . isFile ( ) ) { FileUtils . moveFileToDirectory ( child , parent , createDestDir ) ; } else if ( child . isDirectory ( ) ) { FileUtils . moveDirectoryToDirectory ( child , parent , createDestDir ) ; } else { throw new IllegalArgumentException ( STRING + child ) ; } } FileMisc . forceDelete ( dirToRemove ) ; }
public static void flatten ( File dirToRemove ) throws IOException { final File parent = dirToRemove . getParentFile ( ) ; for ( File child : FileMisc . list ( dirToRemove ) ) { boolean createDestDir = _BOOL ; if ( child . isFile ( ) ) { FileUtils . moveFileToDirectory ( child , parent , createDestDir ) ; } else if ( child . isDirectory ( ) ) { FileUtils . moveDirectoryToDirectory ( child , parent , createDestDir ) ; } else { throw new IllegalArgumentException ( STRING + child ) ; } } FileMisc . forceDelete ( dirToRemove ) ; }
public static void flatten ( File dirToRemove ) throws IOException { final File parent = dirToRemove . getParentFile ( ) ; for ( File child : FileMisc . list ( dirToRemove ) ) { boolean createDestDir = _BOOL ; if ( child . isFile ( ) ) { FileUtils . moveFileToDirectory ( child , parent , createDestDir ) ; } else if ( child . isDirectory ( ) ) { FileUtils . moveDirectoryToDirectory ( child , parent , createDestDir ) ; } else { throw new IllegalArgumentException ( STRING + child ) ; } } FileMisc . forceDelete ( dirToRemove ) ; }
public static void flatten ( File dirToRemove ) throws IOException { final File parent = dirToRemove . getParentFile ( ) ; for ( File child : FileMisc . list ( dirToRemove ) ) { boolean createDestDir = _BOOL ; if ( child . isFile ( ) ) { FileUtils . moveFileToDirectory ( child , parent , createDestDir ) ; } else if ( child . isDirectory ( ) ) { FileUtils . moveDirectoryToDirectory ( child , parent , createDestDir ) ; } else { throw new IllegalArgumentException ( STRING + child ) ; } } FileMisc . forceDelete ( dirToRemove ) ; }
public static void flatten ( File dirToRemove ) throws IOException { final File parent = dirToRemove . getParentFile ( ) ; for ( File child : FileMisc . list ( dirToRemove ) ) { boolean createDestDir = _BOOL ; if ( child . isFile ( ) ) { FileUtils . moveFileToDirectory ( child , parent , createDestDir ) ; } else if ( child . isDirectory ( ) ) { FileUtils . moveDirectoryToDirectory ( child , parent , createDestDir ) ; } else { throw new IllegalArgumentException ( STRING + child ) ; } } FileMisc . forceDelete ( dirToRemove ) ; }
public boolean hasExtraFields ( PdxType other ) { for ( PdxField ft : this . fields ) { if ( ! ft . isDeleted ( ) && other . getPdxField ( ft . getFieldName ( ) ) == null ) { return _BOOL ; } } return _BOOL ; }
public boolean hasExtraFields ( PdxType other ) { for ( PdxField ft : this . fields ) { if ( ! ft . isDeleted ( ) && other . getPdxField ( ft . getFieldName ( ) ) == null ) { return _BOOL ; } } return _BOOL ; }
public static int mapToGridCell ( float lon , float lat ) { int xIndex = ( int ) Math . floor ( ( Math . abs ( LON_WEST ) - Math . abs ( lon ) ) / DELTA_LON ) ; int yIndex = ( int ) Math . floor ( ( LAT_NORTH - lat ) / DELTA_LAT ) ; return xIndex + ( yIndex * NUMBER_OF_GRID_X ) ; }
public static int mapToGridCell ( float lon , float lat ) { int xIndex = ( int ) Math . floor ( ( Math . abs ( LON_WEST ) - Math . abs ( lon ) ) / DELTA_LON ) ; int yIndex = ( int ) Math . floor ( ( LAT_NORTH - lat ) / DELTA_LAT ) ; return xIndex + ( yIndex * NUMBER_OF_GRID_X ) ; }
protected void insertEdgeEnd ( EdgeEnd e , Object obj ) { edgeMap . put ( e , obj ) ; edgeList = null ; }
protected void insertEdgeEnd ( EdgeEnd e , Object obj ) { edgeMap . put ( e , obj ) ; edgeList = null ; }
protected void insertEdgeEnd ( EdgeEnd e , Object obj ) { edgeMap . put ( e , obj ) ; edgeList = null ; }
protected void insertEdgeEnd ( EdgeEnd e , Object obj ) { edgeMap . put ( e , obj ) ; edgeList = null ; }
public GroupShardsIterator activePrimaryShardsGrouped ( String [ ] indices , boolean includeEmpty ) { ArrayList < ShardIterator > set = new ArrayList < > ( ) ; for ( String index : indices ) { IndexRoutingTable indexRoutingTable = index ( index ) ; if ( indexRoutingTable == null ) { throw new IndexNotFoundException ( index ) ; } for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { ShardRouting primary = indexShardRoutingTable . primaryShard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shardsIt ( ) ) ; } else if ( includeEmpty ) { set . add ( new PlainShardIterator ( primary . shardId ( ) , Collections . < ShardRouting > emptyList ( ) ) ) ; } } } return new GroupShardsIterator ( set ) ; }
public GroupShardsIterator activePrimaryShardsGrouped ( String [ ] indices , boolean includeEmpty ) { ArrayList < ShardIterator > set = new ArrayList < > ( ) ; for ( String index : indices ) { IndexRoutingTable indexRoutingTable = index ( index ) ; if ( indexRoutingTable == null ) { throw new IndexNotFoundException ( index ) ; } for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { ShardRouting primary = indexShardRoutingTable . primaryShard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shardsIt ( ) ) ; } else if ( includeEmpty ) { set . add ( new PlainShardIterator ( primary . shardId ( ) , Collections . < ShardRouting > emptyList ( ) ) ) ; } } } return new GroupShardsIterator ( set ) ; }
public GroupShardsIterator activePrimaryShardsGrouped ( String [ ] indices , boolean includeEmpty ) { ArrayList < ShardIterator > set = new ArrayList < > ( ) ; for ( String index : indices ) { IndexRoutingTable indexRoutingTable = index ( index ) ; if ( indexRoutingTable == null ) { throw new IndexNotFoundException ( index ) ; } for ( IndexShardRoutingTable indexShardRoutingTable : indexRoutingTable ) { ShardRouting primary = indexShardRoutingTable . primaryShard ( ) ; if ( primary . active ( ) ) { set . add ( primary . shardsIt ( ) ) ; } else if ( includeEmpty ) { set . add ( new PlainShardIterator ( primary . shardId ( ) , Collections . < ShardRouting > emptyList ( ) ) ) ; } } } return new GroupShardsIterator ( set ) ; }
public Truss popSpan ( ) { Span span = stack . removeLast ( ) ; builder . setSpan ( span . span , span . start , builder . length ( ) , SPAN_INCLUSIVE_EXCLUSIVE ) ; return this ; }
private int visitNodesRec ( Node v , EdgeMap < Integer > edgeWeights ) { int maxValue = _NUM ; for ( Edge e = v . getFirstOutEdge ( ) ; e != null ; e = v . getNextOutEdge ( e ) ) { if ( edgeWeights . get ( e ) == null ) { edgeWeights . set ( e , visitNodesRec ( e . getTarget ( ) , edgeWeights ) + ( Integer ) e . getInfo ( ) ) ; } maxValue = Math . max ( maxValue , edgeWeights . get ( e ) ) ; } return maxValue ; }
public synchronized void addIndex ( PageIndex index ) { metaObjects . put ( index . getId ( ) , index ) ; }
public void testMomentWithNoTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += STRING + STRING ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
public void testMomentWithNoTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += STRING + STRING ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
public void testMomentWithNoTypeErrorHandling ( ) { String xml = STRING ; xml += createStartMissionXml ( STRING , STRING ) ; xml += STRING + STRING ; xml += createNextMomentXml ( STRING ) ; xml += createLengthMinutesXml ( _NUM ) ; xml += createEndMomentXml ( ) ; xml += createEndMissionXml ( ) ; InputStream momentInputStream = new ByteArrayInputStream ( xml . getBytes ( ) ) ; mMission = new Mission ( mMissionData ) ; boolean didMissionParseFail = _BOOL ; try { mMission . readMoments ( momentInputStream ) ; } catch ( MissionParseException e ) { didMissionParseFail = _BOOL ; } Assert . assertEquals ( _BOOL , didMissionParseFail ) ; }
protected void releaseInternal ( ) { ContextTranslator . pts_1cfa_map = null ; ContextTranslator . objs_1cfa_map = null ; }
protected void releaseInternal ( ) { ContextTranslator . pts_1cfa_map = null ; ContextTranslator . objs_1cfa_map = null ; }
private QueryBuilderKraken parseUpdate ( ) { Token token ; UpdateQueryBuilder query = new UpdateQueryBuilder ( _tableManager , _sql ) ; String tableName = parseTableName ( ) ; query . setTableName ( tableName ) ; _query = query ; if ( ( token = scanToken ( ) ) != Token . SET ) { throw error ( L . l ( STRING , token ) ) ; } do { parseSetItem ( query ) ; } while ( ( token = scanToken ( ) ) == Token . COMMA ) ; _token = token ; ExprKraken whereExpr = null ; token = scanToken ( ) ; if ( token == Token . WHERE ) { whereExpr = parseExpr ( ) ; } else if ( token != null && token != Token . EOF ) { throw error ( STRING , token ) ; } ParamExpr [ ] params = _params . toArray ( new ParamExpr [ _params . size ( ) ] ) ; query . setParams ( params ) ; query . setWhereExpr ( whereExpr ) ; return query ; }
@ SuppressWarnings ( STRING ) public static < C > C parameterizeOrAbort ( Class < ? > c , Parameterization config ) { try { C ret = tryInstantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new AbortException ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . hasErrors ( ) ) { for ( ParameterException err : config . getErrors ( ) ) { LOG . warning ( err . toString ( ) ) ; } } if ( e instanceof AbortException ) { throw ( AbortException ) e ; } else { throw new AbortException ( STRING , e ) ; } } }
@ SuppressWarnings ( STRING ) public static < C > C parameterizeOrAbort ( Class < ? > c , Parameterization config ) { try { C ret = tryInstantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new AbortException ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . hasErrors ( ) ) { for ( ParameterException err : config . getErrors ( ) ) { LOG . warning ( err . toString ( ) ) ; } } if ( e instanceof AbortException ) { throw ( AbortException ) e ; } else { throw new AbortException ( STRING , e ) ; } } }
@ SuppressWarnings ( STRING ) public static < C > C parameterizeOrAbort ( Class < ? > c , Parameterization config ) { try { C ret = tryInstantiate ( ( Class < C > ) c , c , config ) ; if ( ret == null ) { throw new AbortException ( STRING ) ; } return ret ; } catch ( Exception e ) { if ( config . hasErrors ( ) ) { for ( ParameterException err : config . getErrors ( ) ) { LOG . warning ( err . toString ( ) ) ; } } if ( e instanceof AbortException ) { throw ( AbortException ) e ; } else { throw new AbortException ( STRING , e ) ; } } }
private static void expand3DigitNumber ( String numberString , WordRelation wordRelation , Item tokenItem ) { if ( numberString . charAt ( _NUM ) == STRING ) { expandNumberAt ( numberString , _NUM , wordRelation , tokenItem ) ; } else { String hundredDigit = digit2num [ numberString . charAt ( _NUM ) - STRING ] ; wordRelation . addWord ( tokenItem , hundredDigit ) ; wordRelation . addWord ( tokenItem , STRING ) ; expandNumberAt ( numberString , _NUM , wordRelation , tokenItem ) ; } }
public void test_writeRead ( ) { final IRawStore store = getStore ( ) ; try { final int len = _NUM ; final byte [ ] expected = new byte [ len ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr1 = store . write ( tmp ) ; assertEquals ( len , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; final ByteBuffer actual = store . read ( addr1 ) ; assertEquals ( expected , actual ) ; assertEquals ( _NUM , actual . position ( ) ) ; assertEquals ( expected . length , actual . limit ( ) ) ; } finally { store . destroy ( ) ; } }
public void test_writeRead ( ) { final IRawStore store = getStore ( ) ; try { final int len = _NUM ; final byte [ ] expected = new byte [ len ] ; r . nextBytes ( expected ) ; final ByteBuffer tmp = ByteBuffer . wrap ( expected ) ; final long addr1 = store . write ( tmp ) ; assertEquals ( len , tmp . position ( ) ) ; assertEquals ( tmp . position ( ) , tmp . limit ( ) ) ; final ByteBuffer actual = store . read ( addr1 ) ; assertEquals ( expected , actual ) ; assertEquals ( _NUM , actual . position ( ) ) ; assertEquals ( expected . length , actual . limit ( ) ) ; } finally { store . destroy ( ) ; } }
private void toStringWithChildren ( StringBuffer buffer , int indent ) { internalToString ( buffer , indent ) ; if ( fChildren != null ) { for ( Iterator < TextEdit > iterator = fChildren . iterator ( ) ; iterator . hasNext ( ) ; ) { TextEdit child = iterator . next ( ) ; buffer . append ( STRING ) ; child . toStringWithChildren ( buffer , indent + _NUM ) ; } } }
private void ensureCapacityHelper ( int minCapacity ) { int oldCapacity = elementData . length ; if ( minCapacity > oldCapacity ) { Object [ ] oldData = elementData ; int newCapacity = ( capacityIncrement > _NUM ) ? ( oldCapacity + capacityIncrement ) : ( oldCapacity * _NUM ) ; if ( newCapacity < minCapacity ) { newCapacity = minCapacity ; } elementData = new Object [ newCapacity ] ; System . arraycopy ( oldData , _NUM , elementData , _NUM , elementCount ) ; } }
private void ensureCapacityHelper ( int minCapacity ) { int oldCapacity = elementData . length ; if ( minCapacity > oldCapacity ) { Object [ ] oldData = elementData ; int newCapacity = ( capacityIncrement > _NUM ) ? ( oldCapacity + capacityIncrement ) : ( oldCapacity * _NUM ) ; if ( newCapacity < minCapacity ) { newCapacity = minCapacity ; } elementData = new Object [ newCapacity ] ; System . arraycopy ( oldData , _NUM , elementData , _NUM , elementCount ) ; } }
private void ensureCapacityHelper ( int minCapacity ) { int oldCapacity = elementData . length ; if ( minCapacity > oldCapacity ) { Object [ ] oldData = elementData ; int newCapacity = ( capacityIncrement > _NUM ) ? ( oldCapacity + capacityIncrement ) : ( oldCapacity * _NUM ) ; if ( newCapacity < minCapacity ) { newCapacity = minCapacity ; } elementData = new Object [ newCapacity ] ; System . arraycopy ( oldData , _NUM , elementData , _NUM , elementCount ) ; } }
public int execute ( String sql ) throws SQLException { if ( logger . isDebugEnabled ( ) ) logger . debug ( STRING + sql ) ; return statement . executeUpdate ( sql ) ; }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public void addObserver ( Observer observer ) { if ( observer == null ) { throw new NullPointerException ( ) ; } synchronized ( this ) { if ( ! observers . contains ( observer ) ) observers . add ( observer ) ; } }
public static String readLine ( Reader self ) throws IOException { if ( self instanceof BufferedReader ) { BufferedReader br = ( BufferedReader ) self ; return br . readLine ( ) ; } if ( self . markSupported ( ) ) { return readLineFromReaderWithMark ( self ) ; } return readLineFromReaderWithoutMark ( self ) ; }
public static boolean equals ( byte [ ] array1 , byte [ ] array2 ) { if ( array1 == array2 ) return _BOOL ; if ( array1 == null || array2 == null || array1 . length != array2 . length ) return _BOOL ; for ( int i = _NUM ; i < array1 . length ; i ++ ) { if ( array1 [ i ] != array2 [ i ] ) return _BOOL ; } return _BOOL ; }
public void log ( java . util . logging . Level level , CharSequence message ) { LogRecord rec = new ELKILogRecord ( level , message ) ; logger . log ( rec ) ; }
public void log ( java . util . logging . Level level , CharSequence message ) { LogRecord rec = new ELKILogRecord ( level , message ) ; logger . log ( rec ) ; }
public static void postfilter_mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > _NUM && m > _NUM ) { double [ ] postfilter_buff = new double [ m + _NUM ] ; mc2b ( mgc , postfilter_buff , m , alpha ) ; double e1 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] -= beta * alpha * mgc [ _NUM ] ; for ( int k = _NUM ; k < m ; k ++ ) postfilter_buff [ k ] *= ( _NUM + beta ) ; double e2 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] += Math . log ( e1 / e2 ) / _NUM ; b2mc ( postfilter_buff , mgc , m , alpha ) ; } }
public static void postfilter_mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > _NUM && m > _NUM ) { double [ ] postfilter_buff = new double [ m + _NUM ] ; mc2b ( mgc , postfilter_buff , m , alpha ) ; double e1 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] -= beta * alpha * mgc [ _NUM ] ; for ( int k = _NUM ; k < m ; k ++ ) postfilter_buff [ k ] *= ( _NUM + beta ) ; double e2 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] += Math . log ( e1 / e2 ) / _NUM ; b2mc ( postfilter_buff , mgc , m , alpha ) ; } }
public static void postfilter_mgc ( double mgc [ ] , int m , double alpha , double beta ) { if ( beta > _NUM && m > _NUM ) { double [ ] postfilter_buff = new double [ m + _NUM ] ; mc2b ( mgc , postfilter_buff , m , alpha ) ; double e1 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] -= beta * alpha * mgc [ _NUM ] ; for ( int k = _NUM ; k < m ; k ++ ) postfilter_buff [ k ] *= ( _NUM + beta ) ; double e2 = b2en ( postfilter_buff , m , alpha ) ; postfilter_buff [ _NUM ] += Math . log ( e1 / e2 ) / _NUM ; b2mc ( postfilter_buff , mgc , m , alpha ) ; } }
public void testToString ( ) { LinkedBlockingQueue q = populatedQueue ( SIZE ) ; String s = q . toString ( ) ; for ( int i = _NUM ; i < SIZE ; ++ i ) { assertTrue ( s . indexOf ( String . valueOf ( i ) ) >= _NUM ) ; } }
public void testToString ( ) { LinkedBlockingQueue q = populatedQueue ( SIZE ) ; String s = q . toString ( ) ; for ( int i = _NUM ; i < SIZE ; ++ i ) { assertTrue ( s . indexOf ( String . valueOf ( i ) ) >= _NUM ) ; } }
public static LDAPUrl valueOf ( final String url ) { return valueOf ( url , Schema . getDefaultSchema ( ) ) ; }
public BootPanel ( ) { initComponents ( ) ; }
public State ( PlotRenderingInfo info ) { super ( info ) ; }
public void process ( List < Object > appearAttrs , long occurTime ) { if ( expired ) { throw new IllegalStateException ( STRING ) ; } switch ( status ) { case not_sure : if ( occurTime < window . startTime ) { break ; } else if ( occurTime >= window . startTime && occurTime <= window . endTime ) { if ( expectAttrs . equals ( appearAttrs ) ) { status = OccurStatus . occured ; } break ; } else { status = OccurStatus . absent ; break ; } case occured : if ( occurTime > window . endTime ) { expired = _BOOL ; } break ; default : break ; } if ( status == OccurStatus . absent ) { expired = _BOOL ; } }
private boolean zzRefill ( ) throws java . io . IOException { if ( zzReader == null ) return _BOOL ; if ( zzStartRead > _NUM ) { System . arraycopy ( zzBuffer , zzStartRead , zzBuffer , _NUM , zzEndRead - zzStartRead ) ; zzEndRead -= zzStartRead ; zzCurrentPos -= zzStartRead ; zzMarkedPos -= zzStartRead ; zzPushbackPos -= zzStartRead ; zzStartRead = _NUM ; } if ( zzCurrentPos >= zzBuffer . length ) { char newBuffer [ ] = new char [ zzCurrentPos * _NUM ] ; System . arraycopy ( zzBuffer , _NUM , newBuffer , _NUM , zzBuffer . length ) ; zzBuffer = newBuffer ; } int numRead = zzReader . read ( zzBuffer , zzEndRead , zzBuffer . length - zzEndRead ) ; if ( numRead < _NUM ) { return _BOOL ; } else { zzEndRead += numRead ; return _BOOL ; } }
private static void verifyDigestsImplicitly ( InputStream in ) throws IOException { byte [ ] buffer = new byte [ BUF_SIZE ] ; while ( in . read ( buffer , _NUM , buffer . length ) != - _NUM ) { } }
public byte [ ] convertNv21toJpeg ( byte [ ] data_copy , int w , int h , int [ ] strides ) { Log . e ( TAG , STRING ) ; YuvImage yuvImage = new YuvImage ( data_copy , ImageFormat . NV21 , w , h , strides ) ; ByteArrayOutputStream postViewBytes = new ByteArrayOutputStream ( ) ; yuvImage . compressToJpeg ( new Rect ( _NUM , _NUM , w , h ) , _NUM , postViewBytes ) ; try { postViewBytes . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Log . e ( TAG , STRING ) ; return postViewBytes . toByteArray ( ) ; }
public byte [ ] convertNv21toJpeg ( byte [ ] data_copy , int w , int h , int [ ] strides ) { Log . e ( TAG , STRING ) ; YuvImage yuvImage = new YuvImage ( data_copy , ImageFormat . NV21 , w , h , strides ) ; ByteArrayOutputStream postViewBytes = new ByteArrayOutputStream ( ) ; yuvImage . compressToJpeg ( new Rect ( _NUM , _NUM , w , h ) , _NUM , postViewBytes ) ; try { postViewBytes . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } Log . e ( TAG , STRING ) ; return postViewBytes . toByteArray ( ) ; }
public BusMovement ( BusMovement proto ) { super ( proto ) ; this . controlSystem = proto . controlSystem ; this . id = nextID ++ ; controlSystem . registerBus ( this ) ; startMode = _BOOL ; }
protected String updateJavadoc ( String content ) throws Exception { String result ; int i ; result = content ; for ( i = _NUM ; i < m_StartTag . length ; i ++ ) { result = updateJavadoc ( result , i ) ; } return result ; }
protected String updateJavadoc ( String content ) throws Exception { String result ; int i ; result = content ; for ( i = _NUM ; i < m_StartTag . length ; i ++ ) { result = updateJavadoc ( result , i ) ; } return result ; }
public static String resolveRepoUrl ( String repoUrl ) { Repositories repositories = Repositories . get ( ) ; return resolveRepoUrl ( repositories , repoUrl ) ; }
public static String resolveRepoUrl ( String repoUrl ) { Repositories repositories = Repositories . get ( ) ; return resolveRepoUrl ( repositories , repoUrl ) ; }
public void incrementActiveRequests ( ) { if ( ! _statsOn ) { return ; } if ( _activeRequests . incrementAndGet ( ) >= HIGH_NUMBER_REQUESTS ) { _alertLog . warn ( MessageFormat . format ( STRING , _activeRequests , _reqRspPerMin . _avg ) ) ; } _reqsLstMin . incrementAndGet ( ) ; }
public void incrementActiveRequests ( ) { if ( ! _statsOn ) { return ; } if ( _activeRequests . incrementAndGet ( ) >= HIGH_NUMBER_REQUESTS ) { _alertLog . warn ( MessageFormat . format ( STRING , _activeRequests , _reqRspPerMin . _avg ) ) ; } _reqsLstMin . incrementAndGet ( ) ; }
public void incrementActiveRequests ( ) { if ( ! _statsOn ) { return ; } if ( _activeRequests . incrementAndGet ( ) >= HIGH_NUMBER_REQUESTS ) { _alertLog . warn ( MessageFormat . format ( STRING , _activeRequests , _reqRspPerMin . _avg ) ) ; } _reqsLstMin . incrementAndGet ( ) ; }
public void incrementActiveRequests ( ) { if ( ! _statsOn ) { return ; } if ( _activeRequests . incrementAndGet ( ) >= HIGH_NUMBER_REQUESTS ) { _alertLog . warn ( MessageFormat . format ( STRING , _activeRequests , _reqRspPerMin . _avg ) ) ; } _reqsLstMin . incrementAndGet ( ) ; }
public CharBuffer append ( float f ) { return append ( String . valueOf ( f ) ) ; }
public void release ( ) throws ReplicatorException , InterruptedException { connectionManager . releaseAll ( ) ; if ( ! readOnly ) writeLock . release ( ) ; stopLogSyncTask ( ) ; }
public void release ( ) throws ReplicatorException , InterruptedException { connectionManager . releaseAll ( ) ; if ( ! readOnly ) writeLock . release ( ) ; stopLogSyncTask ( ) ; }
public void release ( ) throws ReplicatorException , InterruptedException { connectionManager . releaseAll ( ) ; if ( ! readOnly ) writeLock . release ( ) ; stopLogSyncTask ( ) ; }
public static char readChar ( DataInputStream dis ) throws IOException { return ( char ) dis . readByte ( ) ; }
public final double doOperation ( ) throws OperatorFailedException { final int dim = parameter . getDimension ( ) ; final int dim1 = MathUtils . nextInt ( dim ) ; int dim2 = dim1 ; while ( dim1 == dim2 ) { dim2 = MathUtils . nextInt ( dim ) ; } double scalar1 = parameter . getParameterValue ( dim1 ) ; double scalar2 = parameter . getParameterValue ( dim2 ) ; final double d = MathUtils . nextDouble ( ) * delta * scalar1 ; scalar1 -= d ; if ( parameterWeights [ dim1 ] != parameterWeights [ dim2 ] ) { scalar2 += d * ( double ) parameterWeights [ dim1 ] / ( double ) parameterWeights [ dim2 ] ; } else { scalar2 += d ; } parameter . setParameterValue ( dim1 , scalar1 ) ; parameter . setParameterValue ( dim2 , scalar2 ) ; return Math . log ( scalar2 / ( scalar1 + d ) ) ; }
public final double doOperation ( ) throws OperatorFailedException { final int dim = parameter . getDimension ( ) ; final int dim1 = MathUtils . nextInt ( dim ) ; int dim2 = dim1 ; while ( dim1 == dim2 ) { dim2 = MathUtils . nextInt ( dim ) ; } double scalar1 = parameter . getParameterValue ( dim1 ) ; double scalar2 = parameter . getParameterValue ( dim2 ) ; final double d = MathUtils . nextDouble ( ) * delta * scalar1 ; scalar1 -= d ; if ( parameterWeights [ dim1 ] != parameterWeights [ dim2 ] ) { scalar2 += d * ( double ) parameterWeights [ dim1 ] / ( double ) parameterWeights [ dim2 ] ; } else { scalar2 += d ; } parameter . setParameterValue ( dim1 , scalar1 ) ; parameter . setParameterValue ( dim2 , scalar2 ) ; return Math . log ( scalar2 / ( scalar1 + d ) ) ; }
@ Override public void onFailure ( IMqttToken asyncActionToken , Throwable exception ) { exception . printStackTrace ( ) ; Log . e ( STRING , STRING + exception . getMessage ( ) ) ; onDisconnect ( _BOOL ) ; }
private native void notifyShowIDE ( ) ;
private void clearTagViewMap ( ) { TextView view ; for ( final Tag tag : mTagViewMap . keySet ( ) ) { view = mTagViewMap . get ( tag ) ; view . setTag ( null ) ; view . setOnClickListener ( null ) ; view . setSelected ( _BOOL ) ; mTextViewPool . add ( view ) ; } mTagViewMap . clear ( ) ; }
private void clearTagViewMap ( ) { TextView view ; for ( final Tag tag : mTagViewMap . keySet ( ) ) { view = mTagViewMap . get ( tag ) ; view . setTag ( null ) ; view . setOnClickListener ( null ) ; view . setSelected ( _BOOL ) ; mTextViewPool . add ( view ) ; } mTagViewMap . clear ( ) ; }
public static Class < ? > invocationHandlerReturnType ( Class < ? > type ) { if ( type == byte . class ) return Byte . class ; if ( type == char . class ) return Character . class ; if ( type == double . class ) return Double . class ; if ( type == float . class ) return Float . class ; if ( type == int . class ) return Integer . class ; if ( type == long . class ) return Long . class ; if ( type == short . class ) return Short . class ; if ( type == boolean . class ) return Boolean . class ; return type ; }
public void removed ( java . awt . Container cont ) { if ( dataHandlers != null ) { for ( LocationHandler dataHandler : dataHandlers ) { dataHandler . removed ( cont ) ; } } }
public void removed ( java . awt . Container cont ) { if ( dataHandlers != null ) { for ( LocationHandler dataHandler : dataHandlers ) { dataHandler . removed ( cont ) ; } } }
public void removed ( java . awt . Container cont ) { if ( dataHandlers != null ) { for ( LocationHandler dataHandler : dataHandlers ) { dataHandler . removed ( cont ) ; } } }
public void appendSimple ( Object ... data ) { if ( data . length != meta . size ( ) ) { throw new AbortException ( STRING ) ; } for ( int i = _NUM ; i < data . length ; i ++ ) { @ SuppressWarnings ( STRING ) final List < Object > col = ( List < Object > ) columns . get ( i ) ; col . add ( data [ i ] ) ; } }
public UriBuilder uriTemplate ( String uriTemplate ) { Matcher match = uriPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { scheme ( match . group ( _NUM ) ) ; String host = match . group ( _NUM ) ; if ( host != null ) { int at = host . indexOf ( STRING ) ; if ( at > - _NUM ) { String user = host . substring ( _NUM , at ) ; host = host . substring ( at + _NUM ) ; userInfo ( user ) ; } } host ( host ) ; if ( match . group ( _NUM ) != null ) port ( Integer . valueOf ( match . group ( _NUM ) ) ) ; if ( match . group ( _NUM ) != null ) path ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) replaceQuery ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) fragment ( match . group ( _NUM ) ) ; return this ; } match = sspPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { scheme ( match . group ( _NUM ) ) ; schemeSpecificPart ( match . group ( _NUM ) ) ; return this ; } match = pathPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { if ( match . group ( _NUM ) != null ) path ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) replaceQuery ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) fragment ( match . group ( _NUM ) ) ; return this ; } throw new RuntimeException ( STRING + uriTemplate ) ; }
public UriBuilder uriTemplate ( String uriTemplate ) { Matcher match = uriPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { scheme ( match . group ( _NUM ) ) ; String host = match . group ( _NUM ) ; if ( host != null ) { int at = host . indexOf ( STRING ) ; if ( at > - _NUM ) { String user = host . substring ( _NUM , at ) ; host = host . substring ( at + _NUM ) ; userInfo ( user ) ; } } host ( host ) ; if ( match . group ( _NUM ) != null ) port ( Integer . valueOf ( match . group ( _NUM ) ) ) ; if ( match . group ( _NUM ) != null ) path ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) replaceQuery ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) fragment ( match . group ( _NUM ) ) ; return this ; } match = sspPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { scheme ( match . group ( _NUM ) ) ; schemeSpecificPart ( match . group ( _NUM ) ) ; return this ; } match = pathPattern . matcher ( uriTemplate ) ; if ( match . matches ( ) ) { if ( match . group ( _NUM ) != null ) path ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) replaceQuery ( match . group ( _NUM ) ) ; if ( match . group ( _NUM ) != null ) fragment ( match . group ( _NUM ) ) ; return this ; } throw new RuntimeException ( STRING + uriTemplate ) ; }
public boolean equals ( Object obj ) { return ( this == obj || ( obj instanceof BasicMethodConstraints && Arrays . equals ( descs , ( ( BasicMethodConstraints ) obj ) . descs ) ) ) ; }
public TomcatManager ( URL url , String username , String password , String charset ) { this . url = url ; this . username = username ; this . password = password ; this . charset = charset ; try { md5 = MessageDigest . getInstance ( STRING ) ; } catch ( NoSuchAlgorithmException e ) { throw new CargoException ( STRING , e ) ; } }
public void removeSupportedOptions ( Set < String > unmatchedProcessorOptions ) { unmatchedProcessorOptions . removeAll ( supportedOptionNames ) ; }
public void print ( PrintWriter output , int w , int d ) { DecimalFormat format = new DecimalFormat ( ) ; format . setDecimalFormatSymbols ( new DecimalFormatSymbols ( Locale . US ) ) ; format . setMinimumIntegerDigits ( _NUM ) ; format . setMaximumFractionDigits ( d ) ; format . setMinimumFractionDigits ( d ) ; format . setGroupingUsed ( _BOOL ) ; print ( output , format , w + _NUM ) ; }
public InputBuilder < T > repeatAll ( int times ) { List < T > toAppend = new ArrayList < > ( ) ; for ( int i = _NUM ; i < times ; i ++ ) { toAppend . addAll ( input ) ; } input . addAll ( toAppend ) ; return this ; }
protected void redraw ( ) { while ( ! updateQueue . isEmpty ( ) ) { Visualization vis = updateQueue . pop ( ) ; vis . incrementalRedraw ( ) ; } }
public final char readChar ( ) throws java . io . IOException { return ( char ) readShort ( ) ; }
public final char readChar ( ) throws java . io . IOException { return ( char ) readShort ( ) ; }
public void deregisterAll ( Class < ? > category ) { SubRegistry reg = ( SubRegistry ) categoryMap . get ( category ) ; if ( reg == null ) { throw new IllegalArgumentException ( STRING ) ; } reg . clear ( ) ; }
private V doGet ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _NUM ) { @ SuppressWarnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < _NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V doGet ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _NUM ) { @ SuppressWarnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < _NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V doGet ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _NUM ) { @ SuppressWarnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < _NUM ) break outer ; b = n ; n = f ; } } return null ; }
private V doGet ( Object key ) { if ( key == null ) throw new NullPointerException ( ) ; Comparator < ? super K > cmp = comparator ; outer : for ( ; ; ) { for ( Node < K , V > b = findPredecessor ( key , cmp ) , n = b . next ; ; ) { Object v ; int c ; if ( n == null ) break outer ; Node < K , V > f = n . next ; if ( n != b . next ) break ; if ( ( v = n . value ) == null ) { n . helpDelete ( b , f ) ; break ; } if ( b . value == null || v == n ) break ; if ( ( c = cpr ( cmp , key , n . key ) ) == _NUM ) { @ SuppressWarnings ( STRING ) V vv = ( V ) v ; return vv ; } if ( c < _NUM ) break outer ; b = n ; n = f ; } } return null ; }
public Map < String , Integer > loadIdentifierIdPairs ( DBTransaction transaction ) throws SQLException { Map < String , Integer > map = new HashMap < String , Integer > ( ) ; String query = STRING ; ResultSet set = transaction . query ( query , new HashMap < String , Object > ( ) ) ; while ( set . next ( ) ) { String identifier = set . getString ( STRING ) ; Integer id = set . getInt ( STRING ) ; map . put ( identifier , id ) ; } return map ; }
@ SuppressWarnings ( STRING ) public String register ( String channel , String scope , Serializable user ) { switch ( Scope . of ( scope , user ) ) { case APPLICATION : return register ( null , channel , APPLICATION_SCOPE , sessionScope , getViewScope ( _BOOL ) ) ; case SESSION : return register ( user , channel , sessionScope , APPLICATION_SCOPE , getViewScope ( _BOOL ) ) ; case VIEW : return register ( user , channel , getViewScope ( _BOOL ) , APPLICATION_SCOPE , sessionScope ) ; default : throw new UnsupportedOperationException ( ) ; } }
@ SuppressWarnings ( STRING ) public String register ( String channel , String scope , Serializable user ) { switch ( Scope . of ( scope , user ) ) { case APPLICATION : return register ( null , channel , APPLICATION_SCOPE , sessionScope , getViewScope ( _BOOL ) ) ; case SESSION : return register ( user , channel , sessionScope , APPLICATION_SCOPE , getViewScope ( _BOOL ) ) ; case VIEW : return register ( user , channel , getViewScope ( _BOOL ) , APPLICATION_SCOPE , sessionScope ) ; default : throw new UnsupportedOperationException ( ) ; } }
public static void addClipboardListener ( final ClipboardListener l ) { listenerList . add ( l ) ; }
public static void addPackage ( String packagename ) { packages . add ( packagename ) ; }
public void readPrefs ( SharedPreferences settings , ActionFactory factory ) { boolean visible = _BOOL ; String actionId = settings . getString ( STRING + name + STRING , STRING ) ; mainAction = factory . getAction ( actionId ) ; if ( mainAction != null ) visible = _BOOL ; menuActions . clear ( ) ; for ( int i = _NUM ; i < maxMenuActions ; i ++ ) { actionId = settings . getString ( STRING + name + STRING + ( i + _NUM ) , STRING ) ; UIAction a = factory . getAction ( actionId ) ; if ( a != null ) visible = _BOOL ; menuActions . add ( a ) ; } if ( button != null ) button . setVisibility ( visible ? View . VISIBLE : View . GONE ) ; }
public boolean hasVaryAll ( ) { return varyFields . contains ( STRING ) ; }
public boolean hasVaryAll ( ) { return varyFields . contains ( STRING ) ; }
protected synchronized void establishStoreHome ( ) throws IOException { if ( m_storeDirOK ) { return ; } if ( ! m_storeHome . exists ( ) ) { if ( ! m_storeHome . mkdir ( ) ) { throw new IOException ( STRING + m_storeHome . toString ( ) ) ; } } if ( ! m_storeHome . isDirectory ( ) ) { throw new IOException ( STRING + m_storeHome + STRING ) ; } m_storeDirOK = _BOOL ; lockStore ( ) ; File [ ] contents = m_storeHome . listFiles ( ) ; for ( File f : contents ) { if ( f . isDirectory ( ) ) { Map < String , File > store = new LinkedHashMap < String , File > ( ) ; m_stores . put ( f . getName ( ) , store ) ; File [ ] storeEntries = f . listFiles ( ) ; for ( File se : storeEntries ) { store . put ( se . getName ( ) , se ) ; } } } unlockStore ( ) ; }
public static ByteString valueOfUtf8 ( final CharSequence s ) { if ( s . length ( ) == _NUM ) { return EMPTY ; } return wrap ( StaticUtils . getBytes ( s ) ) ; }
public static Image removeBgColor ( Image img , int offset ) { return null ; }
private boolean hasDividerBeforeFlexLine ( int flexLineIndex ) { if ( flexLineIndex < _NUM || flexLineIndex >= mFlexLines . size ( ) ) { return _BOOL ; } if ( allFlexLinesAreDummyBefore ( flexLineIndex ) ) { if ( isMainAxisDirectionHorizontal ( mFlexDirection ) ) { return ( mShowDividerHorizontal & SHOW_DIVIDER_BEGINNING ) != _NUM ; } else { return ( mShowDividerVertical & SHOW_DIVIDER_BEGINNING ) != _NUM ; } } else { if ( isMainAxisDirectionHorizontal ( mFlexDirection ) ) { return ( mShowDividerHorizontal & SHOW_DIVIDER_MIDDLE ) != _NUM ; } else { return ( mShowDividerVertical & SHOW_DIVIDER_MIDDLE ) != _NUM ; } } }
private boolean hasDividerBeforeFlexLine ( int flexLineIndex ) { if ( flexLineIndex < _NUM || flexLineIndex >= mFlexLines . size ( ) ) { return _BOOL ; } if ( allFlexLinesAreDummyBefore ( flexLineIndex ) ) { if ( isMainAxisDirectionHorizontal ( mFlexDirection ) ) { return ( mShowDividerHorizontal & SHOW_DIVIDER_BEGINNING ) != _NUM ; } else { return ( mShowDividerVertical & SHOW_DIVIDER_BEGINNING ) != _NUM ; } } else { if ( isMainAxisDirectionHorizontal ( mFlexDirection ) ) { return ( mShowDividerHorizontal & SHOW_DIVIDER_MIDDLE ) != _NUM ; } else { return ( mShowDividerVertical & SHOW_DIVIDER_MIDDLE ) != _NUM ; } } }
@ Override public int hashCode ( ) { return Arrays . hashCode ( ipaddress ) ; }
public String addDays ( Object odays , String format ) { int days = FunctionHandler . getInt ( odays ) ; Calendar now = Calendar . getInstance ( ) ; now . add ( Calendar . DAY_OF_YEAR , days ) ; DateFormat formatter = getFormatter ( format ) ; return formatter . format ( now . getTime ( ) ) ; }
public String addDays ( Object odays , String format ) { int days = FunctionHandler . getInt ( odays ) ; Calendar now = Calendar . getInstance ( ) ; now . add ( Calendar . DAY_OF_YEAR , days ) ; DateFormat formatter = getFormatter ( format ) ; return formatter . format ( now . getTime ( ) ) ; }
public ReceiveResultBehaviour ( ResultsAgent a , long lInterval , PrintStream pResultOutput ) { super ( a , lInterval ) ; myAgent = a ; Interval = lInterval ; pOut = pResultOutput ; }
public MapEntryInfoKey ( Object value , Object key ) { super ( value ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key ) { super ( value ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key ) { super ( value ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key ) { super ( value ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public MapEntryInfoKey ( Object value , Object key ) { super ( value ) ; _hashCode = _hashCode ^ key . hashCode ( ) ; _key = key ; }
public void addObscuredRecipient ( String playerName ) { obscuredRecipients . addElement ( playerName ) ; }
public void addObscuredRecipient ( String playerName ) { obscuredRecipients . addElement ( playerName ) ; }
public void addObscuredRecipient ( String playerName ) { obscuredRecipients . addElement ( playerName ) ; }
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < ja . length ( ) ; i += _NUM ) { if ( i > _NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . length ( ) > _NUM && ( s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( _NUM ) >= _NUM || s . charAt ( _NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = _NUM ; j < length ; j += _NUM ) { char c = s . charAt ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . toString ( ) ; }
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < ja . length ( ) ; i += _NUM ) { if ( i > _NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . length ( ) > _NUM && ( s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( _NUM ) >= _NUM || s . charAt ( _NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = _NUM ; j < length ; j += _NUM ) { char c = s . charAt ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . toString ( ) ; }
public static String rowToString ( JSONArray ja ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = _NUM ; i < ja . length ( ) ; i += _NUM ) { if ( i > _NUM ) { sb . append ( STRING ) ; } Object o = ja . opt ( i ) ; if ( o != null ) { String s = o . toString ( ) ; if ( s . length ( ) > _NUM && ( s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( STRING ) >= _NUM || s . indexOf ( _NUM ) >= _NUM || s . charAt ( _NUM ) == STRING ) ) { sb . append ( STRING ) ; int length = s . length ( ) ; for ( int j = _NUM ; j < length ; j += _NUM ) { char c = s . charAt ( j ) ; if ( c >= STRING && c != STRING ) { sb . append ( c ) ; } } sb . append ( STRING ) ; } else { sb . append ( s ) ; } } } sb . append ( STRING ) ; return sb . toString ( ) ; }
protected void fireProjectionStackEvent ( String command ) { if ( projListeners . isEmpty ( ) ) { return ; } ActionEvent event = new ActionEvent ( this , _NUM , command ) ; for ( ActionListener listener : projListeners ) { listener . actionPerformed ( event ) ; } }
public boolean offerLast ( E e ) { addLast ( e ) ; return _BOOL ; }
private static String readConfigProperty ( String relativePath , String propertyKey ) { String home = getRapidMinerHome ( ) ; if ( home == null ) { logWarn ( STRING + relativePath + STRING ) ; return null ; } File propertyFile = new File ( home , relativePath ) ; if ( propertyFile . canRead ( ) ) { Properties props = new Properties ( ) ; try ( InputStreamReader reader = new InputStreamReader ( new FileInputStream ( propertyFile ) , StandardCharsets . UTF_8 ) ) { props . load ( reader ) ; } catch ( IOException e ) { logWarn ( STRING + e . getLocalizedMessage ( ) ) ; } return props . getProperty ( propertyKey ) ; } else { logWarn ( STRING + propertyFile + STRING ) ; return null ; } }
private void drawXAxis ( Canvas canvas ) { int x = getScrollX ( ) + leftBorder ; int y = topBorder + effectiveHeight ; canvas . drawLine ( x , y , x + effectiveWidth , y , axisPaint ) ; String label = getXAxisLabel ( ) ; Rect rect = getRect ( axisPaint , label ) ; int yOffset = ( int ) rect . height ( ) / _NUM ; canvas . drawText ( label , x + effectiveWidth + spacer , y + yOffset , axisPaint ) ; double interval = getXAxisInterval ( ) ; ArrayList < Double > markerPositions = getXAxisMarkerPositions ( interval ) ; NumberFormat numberFormat = interval < _NUM ? X_FRACTION_FORMAT : X_NUMBER_FORMAT ; for ( int i = _NUM ; i < markerPositions . size ( ) ; i ++ ) { drawXAxisMarker ( canvas , markerPositions . get ( i ) , numberFormat , spacer + yOffset ) ; } }
public boolean equals ( Object object ) { if ( object == null || ! ( object instanceof SessionID ) ) { return _BOOL ; } SessionID another = ( SessionID ) object ; return encryptedString . equals ( another . encryptedString ) ; }
public RegressionEvoOptimization ( ExampleSet exampleSet , Kernel kernel , double c , double epsilon , int initType , int maxIterations , int generationsWithoutImprovement , int popSize , int selectionType , double tournamentFraction , boolean keepBest , int mutationType , double crossoverProb , boolean showConvergencePlot , boolean showPopulationPlot , RandomGenerator random , LoggingHandler logging , Operator executingOperator ) { super ( EvoSVM . createBoundArray ( _NUM , _NUM * exampleSet . size ( ) ) , EvoSVM . determineMax ( c , kernel , exampleSet , selectionType , _NUM * exampleSet . size ( ) ) , popSize , _NUM * exampleSet . size ( ) , initType , maxIterations , generationsWithoutImprovement , selectionType , tournamentFraction , keepBest , mutationType , Double . NaN , crossoverProb , showConvergencePlot , showPopulationPlot , random , logging , executingOperator ) ; this . exampleSet = exampleSet ; this . kernel = kernel ; this . ys = new double [ exampleSet . size ( ) ] ; Iterator < Example > reader = exampleSet . iterator ( ) ; int index = _NUM ; while ( reader . hasNext ( ) ) { Example example = reader . next ( ) ; ys [ index ++ ] = example . getLabel ( ) ; } this . optimizationFunction = new RegressionOptimizationFunction ( epsilon ) ; }
public EncoderTestSuiteBuilder valid ( String chars ) { for ( int i = _NUM , n = chars . length ( ) ; i < n ; ++ i ) { char ch = chars . charAt ( i ) ; _valid . set ( ch ) ; _invalid . clear ( ch ) ; _encoded . clear ( ch ) ; } return this ; }
@ Override public Promise < AuthStatus , AuthenticationException > secureResponse ( MessageInfoContext messageInfo , Subject subject ) { return newResultPromise ( SEND_SUCCESS ) ; }
@ Override public Promise < AuthStatus , AuthenticationException > secureResponse ( MessageInfoContext messageInfo , Subject subject ) { return newResultPromise ( SEND_SUCCESS ) ; }
@ Override public Promise < AuthStatus , AuthenticationException > secureResponse ( MessageInfoContext messageInfo , Subject subject ) { return newResultPromise ( SEND_SUCCESS ) ; }
protected void delay ( long delayMs , String desc ) { try { Thread . sleep ( delayMs ) ; } catch ( InterruptedException intExc ) { LOG . warn ( STRING + desc , intExc ) ; } }
protected void delay ( long delayMs , String desc ) { try { Thread . sleep ( delayMs ) ; } catch ( InterruptedException intExc ) { LOG . warn ( STRING + desc , intExc ) ; } }
protected void delay ( long delayMs , String desc ) { try { Thread . sleep ( delayMs ) ; } catch ( InterruptedException intExc ) { LOG . warn ( STRING + desc , intExc ) ; } }
static boolean continueEvaluationOnDenyDecision ( ) { return continueEvaluationOnDenyDecisionFlag ; }
static boolean continueEvaluationOnDenyDecision ( ) { return continueEvaluationOnDenyDecisionFlag ; }
public void sendChangeCollectionRequest ( final String variable , final List < String > childList , final String value ) { final StringBuilder requestJson = new StringBuilder ( ) ; requestJson . append ( STRING + variable + STRING ) ; for ( int i = _NUM ; i < childList . size ( ) ; i ++ ) { requestJson . append ( STRING + childList . get ( i ) + STRING ) ; } requestJson . append ( STRING + value + STRING ) ; sendEventToAgent ( requestJson . toString ( ) ) ; }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
private static Object runJUnit3Test ( Class scriptClass ) { try { Object testSuite = InvokerHelper . invokeConstructorOf ( STRING , new Object [ ] { scriptClass } ) ; return InvokerHelper . invokeStaticMethod ( STRING , STRING , new Object [ ] { testSuite } ) ; } catch ( ClassNotFoundException e ) { throw new GroovyRuntimeException ( STRING , e ) ; } }
< T > T onFindFirst ( Class < T > modelClass , boolean isEager ) { List < T > dataList = query ( modelClass , null , null , null , null , null , STRING , STRING , getForeignKeyAssociations ( modelClass . getName ( ) , isEager ) ) ; if ( dataList . size ( ) > _NUM ) { return dataList . get ( _NUM ) ; } return null ; }
static void dispose ( long pData ) { D3DRenderQueue rq = D3DRenderQueue . getInstance ( ) ; rq . lock ( ) ; try { RenderBuffer buf = rq . getBuffer ( ) ; rq . ensureCapacityAndAlignment ( _NUM , _NUM ) ; buf . putInt ( DISPOSE_SURFACE ) ; buf . putLong ( pData ) ; rq . flushNow ( ) ; } finally { rq . unlock ( ) ; } }
static void dispose ( long pData ) { D3DRenderQueue rq = D3DRenderQueue . getInstance ( ) ; rq . lock ( ) ; try { RenderBuffer buf = rq . getBuffer ( ) ; rq . ensureCapacityAndAlignment ( _NUM , _NUM ) ; buf . putInt ( DISPOSE_SURFACE ) ; buf . putLong ( pData ) ; rq . flushNow ( ) ; } finally { rq . unlock ( ) ; } }
static void dispose ( long pData ) { D3DRenderQueue rq = D3DRenderQueue . getInstance ( ) ; rq . lock ( ) ; try { RenderBuffer buf = rq . getBuffer ( ) ; rq . ensureCapacityAndAlignment ( _NUM , _NUM ) ; buf . putInt ( DISPOSE_SURFACE ) ; buf . putLong ( pData ) ; rq . flushNow ( ) ; } finally { rq . unlock ( ) ; } }
public SerbianNormalizationFilterFactory ( Map < String , String > args ) { super ( args ) ; this . haircut = get ( args , STRING , Arrays . asList ( STRING , STRING ) , STRING ) ; if ( ! args . isEmpty ( ) ) { throw new IllegalArgumentException ( STRING + args ) ; } }
public void add ( Comparator c ) { if ( c == null ) return ; if ( m_cmp . length == m_size ) { Comparator [ ] cmp = new Comparator [ m_size + INCREMENT ] ; System . arraycopy ( m_cmp , _NUM , cmp , _NUM , m_size ) ; m_cmp = cmp ; } m_cmp [ m_size ++ ] = c ; }
public List < IResource > chooseResources ( ) { if ( open ( ) == Window . OK ) { List < IResource > resources = new ArrayList < IResource > ( ) ; for ( Object obj : getResult ( ) ) { resources . add ( ( IResource ) obj ) ; } return resources ; } return null ; }
public List < IResource > chooseResources ( ) { if ( open ( ) == Window . OK ) { List < IResource > resources = new ArrayList < IResource > ( ) ; for ( Object obj : getResult ( ) ) { resources . add ( ( IResource ) obj ) ; } return resources ; } return null ; }
public static NativePage createNativePageForURL ( String url , NativePage candidatePage , Tab tab , TabModelSelector tabModelSelector , Activity activity ) { return createNativePageForURL ( url , candidatePage , tab , tabModelSelector , activity , tab . isIncognito ( ) ) ; }
private static Path renameToVanillaNetherOrEnd ( Path worldContainer , Path oldWorldPath , Path worldPath ) { final String newName = getVanillaNetherOrEndName ( oldWorldPath ) ; final Path newWorldPath = worldContainer . resolve ( newName ) ; if ( isValidBukkitNetherOrEnd ( worldContainer , oldWorldPath ) ) { if ( Files . notExists ( worldContainer . resolve ( newName ) ) ) { return newWorldPath ; } } return worldPath ; }
private static Path renameToVanillaNetherOrEnd ( Path worldContainer , Path oldWorldPath , Path worldPath ) { final String newName = getVanillaNetherOrEndName ( oldWorldPath ) ; final Path newWorldPath = worldContainer . resolve ( newName ) ; if ( isValidBukkitNetherOrEnd ( worldContainer , oldWorldPath ) ) { if ( Files . notExists ( worldContainer . resolve ( newName ) ) ) { return newWorldPath ; } } return worldPath ; }
private static Path renameToVanillaNetherOrEnd ( Path worldContainer , Path oldWorldPath , Path worldPath ) { final String newName = getVanillaNetherOrEndName ( oldWorldPath ) ; final Path newWorldPath = worldContainer . resolve ( newName ) ; if ( isValidBukkitNetherOrEnd ( worldContainer , oldWorldPath ) ) { if ( Files . notExists ( worldContainer . resolve ( newName ) ) ) { return newWorldPath ; } } return worldPath ; }
public void deleteStaticGroups ( Set groupDNs ) throws AMException , SSOException { Iterator iter = groupDNs . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupDN = ( String ) iter . next ( ) ; AMStaticGroup group = new AMStaticGroupImpl ( token , groupDN ) ; group . delete ( ) ; } }
public void deleteStaticGroups ( Set groupDNs ) throws AMException , SSOException { Iterator iter = groupDNs . iterator ( ) ; while ( iter . hasNext ( ) ) { String groupDN = ( String ) iter . next ( ) ; AMStaticGroup group = new AMStaticGroupImpl ( token , groupDN ) ; group . delete ( ) ; } }
protected void applyValue ( T value ) { bean . setValue ( property , value ) ; }
final void close ( ) { _isClose = _BOOL ; LockSupport . unpark ( this ) ; }
final void close ( ) { _isClose = _BOOL ; LockSupport . unpark ( this ) ; }
public DocumentAnalysisRequest addDocument ( SolrInputDocument doc ) { documents . add ( doc ) ; return this ; }
public static boolean writeLine ( String fileName , String value ) { BufferedWriter writer = null ; try { writer = new BufferedWriter ( new FileWriter ( fileName ) ) ; writer . write ( value ) ; } catch ( FileNotFoundException e ) { Log . w ( TAG , STRING + fileName + STRING , e ) ; return _BOOL ; } catch ( IOException e ) { Log . e ( TAG , STRING + fileName , e ) ; return _BOOL ; } finally { try { if ( writer != null ) { writer . close ( ) ; } } catch ( IOException e ) { } } return _BOOL ; }
public CActionDifferenceTraces ( final JFrame parent , final ITraceListProvider traceProvider , final TraceList trace1 , final TraceList trace2 ) { super ( String . format ( STRING , trace1 . getName ( ) , trace2 . getName ( ) ) ) ; m_parent = parent ; m_traceProvider = traceProvider ; m_trace1 = trace1 ; m_trace2 = trace2 ; }
long readDWord ( ) throws IOException { int b0 = m_in . read ( ) ; int b1 = m_in . read ( ) ; int b2 = m_in . read ( ) ; int b3 = m_in . read ( ) ; long value = ( ( b3 << _NUM ) & _NUM ) | ( ( b2 << _NUM ) & _NUM ) | ( ( b1 << _NUM ) & _NUM ) | ( b0 & _NUM ) ; return value ; }
long readDWord ( ) throws IOException { int b0 = m_in . read ( ) ; int b1 = m_in . read ( ) ; int b2 = m_in . read ( ) ; int b3 = m_in . read ( ) ; long value = ( ( b3 << _NUM ) & _NUM ) | ( ( b2 << _NUM ) & _NUM ) | ( ( b1 << _NUM ) & _NUM ) | ( b0 & _NUM ) ; return value ; }
long readDWord ( ) throws IOException { int b0 = m_in . read ( ) ; int b1 = m_in . read ( ) ; int b2 = m_in . read ( ) ; int b3 = m_in . read ( ) ; long value = ( ( b3 << _NUM ) & _NUM ) | ( ( b2 << _NUM ) & _NUM ) | ( ( b1 << _NUM ) & _NUM ) | ( b0 & _NUM ) ; return value ; }
public void addToWeightList ( double weight ) { weightList . add ( weight ) ; }
@ Override public boolean write ( byte [ ] data , int offset , int length ) throws IOException { if ( mSeqSize + length <= mLimit ) { mSeqData . write ( data , offset , length ) ; mSeqSize += length ; mChecksumSeq . update ( data , offset , length ) ; return _BOOL ; } return _BOOL ; }
private JScrollPane createDetailPanel ( String errorMessage ) { JTextArea textArea = new JTextArea ( errorMessage ) ; textArea . setLineWrap ( _BOOL ) ; textArea . setEditable ( _BOOL ) ; JScrollPane detailPane = new ExtendedJScrollPane ( textArea ) ; detailPane . setPreferredSize ( new Dimension ( getWidth ( ) , _NUM ) ) ; return detailPane ; }
private JScrollPane createDetailPanel ( String errorMessage ) { JTextArea textArea = new JTextArea ( errorMessage ) ; textArea . setLineWrap ( _BOOL ) ; textArea . setEditable ( _BOOL ) ; JScrollPane detailPane = new ExtendedJScrollPane ( textArea ) ; detailPane . setPreferredSize ( new Dimension ( getWidth ( ) , _NUM ) ) ; return detailPane ; }
private JScrollPane createDetailPanel ( String errorMessage ) { JTextArea textArea = new JTextArea ( errorMessage ) ; textArea . setLineWrap ( _BOOL ) ; textArea . setEditable ( _BOOL ) ; JScrollPane detailPane = new ExtendedJScrollPane ( textArea ) ; detailPane . setPreferredSize ( new Dimension ( getWidth ( ) , _NUM ) ) ; return detailPane ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void flush ( ) throws java . io . IOException { flushBuffer ( ) ; m_os . flush ( ) ; }
public void addCaretListener ( final ICaretListener listener ) { Preconditions . checkNotNull ( listener , STRING ) ; if ( ! m_listeners . contains ( listener ) ) { m_listeners . add ( listener ) ; } }
private static void closeSafe ( Closeable closeable ) { if ( closeable != null ) { try { closeable . close ( ) ; } catch ( IOException ignored ) { } } }
public void source ( File file ) { addArg ( STRING , file . getAbsolutePath ( ) ) ; }
private void drawOffsets ( final Graphics g ) { if ( isEnabled ( ) ) { g . setColor ( m_fontColorOffsets ) ; } else { g . setColor ( m_disabledColor != m_bgColorOffset ? m_disabledColor : Color . WHITE ) ; } final int x = ( - m_firstColumn * m_charWidth ) + _NUM ; final int bytesToDraw = getMaximumVisibleBytes ( ) ; final String formatString = m_addressMode == AddressMode . BIT32 ? STRING : STRING ; for ( int i = _NUM ; i < bytesToDraw ; i += m_bytesPerRow ) { final long address = m_baseAddress + ( m_firstRow * m_bytesPerRow ) + i ; final String offsetString = String . format ( formatString , address ) ; final int currentRow = i / m_bytesPerRow ; g . drawString ( offsetString , x , m_paddingTop + ( currentRow * m_rowHeight ) ) ; } }
private void drawOffsets ( final Graphics g ) { if ( isEnabled ( ) ) { g . setColor ( m_fontColorOffsets ) ; } else { g . setColor ( m_disabledColor != m_bgColorOffset ? m_disabledColor : Color . WHITE ) ; } final int x = ( - m_firstColumn * m_charWidth ) + _NUM ; final int bytesToDraw = getMaximumVisibleBytes ( ) ; final String formatString = m_addressMode == AddressMode . BIT32 ? STRING : STRING ; for ( int i = _NUM ; i < bytesToDraw ; i += m_bytesPerRow ) { final long address = m_baseAddress + ( m_firstRow * m_bytesPerRow ) + i ; final String offsetString = String . format ( formatString , address ) ; final int currentRow = i / m_bytesPerRow ; g . drawString ( offsetString , x , m_paddingTop + ( currentRow * m_rowHeight ) ) ; } }
public int evictStaleRefs ( ) { if ( timeout != _NUM ) { return evictStaleRefs ( timeout ) ; } return _NUM ; }
public int evictStaleRefs ( ) { if ( timeout != _NUM ) { return evictStaleRefs ( timeout ) ; } return _NUM ; }
public int evictStaleRefs ( ) { if ( timeout != _NUM ) { return evictStaleRefs ( timeout ) ; } return _NUM ; }
public static void createParentDirectories ( String path ) { File targetFile = new File ( path ) ; File parent = targetFile . getParentFile ( ) ; if ( ! parent . exists ( ) && ! parent . mkdirs ( ) ) { throw new IllegalStateException ( STRING + parent ) ; } }
public TopNMetric ( String metricName , SortDirection order ) { this ( metricName ) ; if ( order == SortDirection . ASC ) { this . type = TopNMetricType . INVERTED ; this . metricName = Optional . empty ( ) ; this . nested = Optional . of ( new TopNMetric ( metricName ) ) ; } }
public void addExitTime ( double time ) { if ( exitTimes == null ) { return ; } if ( time < _NUM ) { time = _NUM ; } exitTimes . add ( Double . valueOf ( time ) ) ; }
public void addExitTime ( double time ) { if ( exitTimes == null ) { return ; } if ( time < _NUM ) { time = _NUM ; } exitTimes . add ( Double . valueOf ( time ) ) ; }
public void addExitTime ( double time ) { if ( exitTimes == null ) { return ; } if ( time < _NUM ) { time = _NUM ; } exitTimes . add ( Double . valueOf ( time ) ) ; }
public static void writeFofn ( final File destination , final File ... files ) throws IOException { writeFofn ( destination , Arrays . asList ( files ) ) ; }
public static void writeFofn ( final File destination , final File ... files ) throws IOException { writeFofn ( destination , Arrays . asList ( files ) ) ; }
public static void writeFofn ( final File destination , final File ... files ) throws IOException { writeFofn ( destination , Arrays . asList ( files ) ) ; }
public static void writeFofn ( final File destination , final File ... files ) throws IOException { writeFofn ( destination , Arrays . asList ( files ) ) ; }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { final T o = iter . next ( ) ; if ( ! passesAllCriteria ( o ) ) { iter . remove ( ) ; } } } }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { final T o = iter . next ( ) ; if ( ! passesAllCriteria ( o ) ) { iter . remove ( ) ; } } } }
public void filter ( final Collection < T > collection ) { if ( collection != null ) { final Iterator < T > iter = collection . iterator ( ) ; while ( iter . hasNext ( ) ) { final T o = iter . next ( ) ; if ( ! passesAllCriteria ( o ) ) { iter . remove ( ) ; } } } }
public synchronized void write ( byte [ ] b , int off , int len ) throws IOException { ensureOpen ( ) ; if ( off < _NUM || len < _NUM || off > b . length - len ) { throw new IndexOutOfBoundsException ( ) ; } else if ( len == _NUM ) { return ; } if ( current == null ) { throw new ZipException ( STRING ) ; } ZipEntry entry = current . entry ; switch ( entry . method ) { case DEFLATED : super . write ( b , off , len ) ; break ; case STORED : written += len ; if ( written - locoff > entry . size ) { throw new ZipException ( STRING ) ; } out . write ( b , off , len ) ; break ; default : throw new ZipException ( STRING ) ; } crc . update ( b , off , len ) ; }
private void computeIFDOffset ( ) { long bytesPerRow = ( long ) Math . ceil ( ( sampleSize [ _NUM ] / _NUM ) * tileWidth * numBands ) ; long bytesPerTile = bytesPerRow * tileLength ; long lastTile = bytesPerTile ; if ( ! isTiled ) { long lastStripRows = length - ( tileLength * ( numTiles - _NUM ) ) ; lastTile = lastStripRows * bytesPerRow ; } long totalBytesOfData = bytesPerTile * ( numTiles - _NUM ) + lastTile ; firstIFDOffset = _NUM + totalBytesOfData ; if ( ( firstIFDOffset % _NUM ) != _NUM ) { firstIFDOffset ++ ; } }
public void runTest ( ) throws Throwable { Document doc ; NodeList emList ; Node emNode ; CharacterData emText ; Node nullChild ; doc = ( Document ) load ( STRING , _BOOL ) ; emList = doc . getElementsByTagName ( STRING ) ; emNode = emList . item ( _NUM ) ; emText = ( CharacterData ) emNode . getFirstChild ( ) ; nullChild = emText . getFirstChild ( ) ; assertNull ( STRING , nullChild ) ; }
private boolean hasIdleInvokers ( ) { for ( AsyncEventListenerInvoker invoker : this . scheduledInvokers ) { if ( invoker . isIdle ( ) ) { return _BOOL ; } } return _BOOL ; }
private boolean hasIdleInvokers ( ) { for ( AsyncEventListenerInvoker invoker : this . scheduledInvokers ) { if ( invoker . isIdle ( ) ) { return _BOOL ; } } return _BOOL ; }
private boolean hasIdleInvokers ( ) { for ( AsyncEventListenerInvoker invoker : this . scheduledInvokers ) { if ( invoker . isIdle ( ) ) { return _BOOL ; } } return _BOOL ; }
public static boolean validateBindAddress ( String bindAddress ) { if ( bindAddress == null || bindAddress . length ( ) == _NUM ) return _BOOL ; if ( InetAddressUtil . validateHost ( bindAddress ) == null ) return _BOOL ; return _BOOL ; }
@ SuppressWarnings ( STRING ) public DictionaryAdapter ( Context context , File dbPath , String dbName , String defaultTable ) { mContext = context ; mDbName = dbName ; mDefaultTable = defaultTable ; mDbPath = dbPath ; mDbFile = new File ( dbPath , mDbName ) ; if ( mDbFile . exists ( ) ) { open ( ) ; } }
public SphericalPolarCoordinates ( Vector3D v , double newRadius ) { radius = v . modulus ( ) ; theta = Math . acos ( v . getZ ( ) / radius ) ; phi = Math . atan ( v . getY ( ) / v . getX ( ) ) ; if ( v . getY ( ) < _NUM ) phi += Math . PI ; radius = newRadius ; }
private static String ensureUniqueId ( String id ) { Object exists = DOM . getElementById ( id ) ; int i = _NUM ; while ( exists != null ) { exists = DOM . getElementById ( id + STRING + ( ++ i ) ) ; } if ( i > _NUM ) { id = id + STRING + i ; } return id ; }
private static String ensureUniqueId ( String id ) { Object exists = DOM . getElementById ( id ) ; int i = _NUM ; while ( exists != null ) { exists = DOM . getElementById ( id + STRING + ( ++ i ) ) ; } if ( i > _NUM ) { id = id + STRING + i ; } return id ; }
private static String ensureUniqueId ( String id ) { Object exists = DOM . getElementById ( id ) ; int i = _NUM ; while ( exists != null ) { exists = DOM . getElementById ( id + STRING + ( ++ i ) ) ; } if ( i > _NUM ) { id = id + STRING + i ; } return id ; }
private int calculateSegmentSize ( int factor , int segmentSizeOld ) { DatabaseKelp db = _table . database ( ) ; long segmentFactor = _tableLength / db . getSegmentSizeMin ( ) ; long segmentFactorNew = segmentFactor / factor ; if ( segmentFactorNew > _NUM ) { int bit = _NUM - Long . numberOfLeadingZeros ( segmentFactorNew ) ; bit &= ~ _NUM ; long segmentFactorPower = ( _NUM << bit ) ; if ( segmentFactorPower < segmentFactorNew ) { segmentFactorNew = _NUM * segmentFactorPower ; } } long segmentSizeNew = segmentFactorNew * db . getSegmentSizeMin ( ) ; segmentSizeNew = Math . max ( db . getSegmentSizeMin ( ) , segmentSizeNew ) ; long segmentSizeBlob = _blobSizeMax * _NUM ; while ( segmentSizeNew < segmentSizeBlob ) { segmentSizeNew *= _NUM ; } segmentSizeNew = Math . min ( db . getSegmentSizeMax ( ) , segmentSizeNew ) ; return ( int ) Math . max ( segmentSizeNew , segmentSizeOld ) ; }
protected void initializePhase ( int w ) { Arrays . fill ( committedWorkers , _BOOL ) ; Arrays . fill ( parentWorkerByCommittedJob , - _NUM ) ; committedWorkers [ w ] = _BOOL ; for ( int j = _NUM ; j < dim ; j ++ ) { minSlackValueByJob [ j ] = costMatrix [ w ] [ j ] - labelByWorker [ w ] - labelByJob [ j ] ; minSlackWorkerByJob [ j ] = w ; } }
protected void initializePhase ( int w ) { Arrays . fill ( committedWorkers , _BOOL ) ; Arrays . fill ( parentWorkerByCommittedJob , - _NUM ) ; committedWorkers [ w ] = _BOOL ; for ( int j = _NUM ; j < dim ; j ++ ) { minSlackValueByJob [ j ] = costMatrix [ w ] [ j ] - labelByWorker [ w ] - labelByJob [ j ] ; minSlackWorkerByJob [ j ] = w ; } }
protected void initializePhase ( int w ) { Arrays . fill ( committedWorkers , _BOOL ) ; Arrays . fill ( parentWorkerByCommittedJob , - _NUM ) ; committedWorkers [ w ] = _BOOL ; for ( int j = _NUM ; j < dim ; j ++ ) { minSlackValueByJob [ j ] = costMatrix [ w ] [ j ] - labelByWorker [ w ] - labelByJob [ j ] ; minSlackWorkerByJob [ j ] = w ; } }
private void addPokemonToFavs ( PokeModel pokeModel , ArrayList < Integer > listOfFavPokemon ) { if ( pokeModel != null && listOfFavPokemon != null ) { int pokeNum = pokeModel . getPokedexNum ( ) ; if ( listOfFavPokemon . contains ( pokeNum ) ) { TypefaceUtils . displayToast ( mContext , getString ( R . string . redundant_fav_pokemon_msg ) , TypefaceUtils . TOAST_SHORT_DURATION ) ; } else { PokeCursorManager . insertPokemonInDb ( mContext , pokeNum , PokeDBContract . FavoritePokemonEntry . TABLE_NAME , PokeDBContract . FavoritePokemonEntry . COLUMN_NUMBER ) ; TypefaceUtils . displayToast ( mContext , getString ( R . string . add_pokemon_to_favs_msg ) , TypefaceUtils . TOAST_SHORT_DURATION ) ; } } }
public Response doPost ( String url ) { return doPost ( url , null ) ; }
public TemplateDruidQuery nest ( ) { LinkedHashSet < Aggregation > innerAggregations = new LinkedHashSet < > ( ) ; LinkedHashSet < Aggregation > outerAggregations = new LinkedHashSet < > ( ) ; for ( Aggregation agg : aggregations ) { Pair < Aggregation , Aggregation > split = agg . nest ( ) ; innerAggregations . add ( split . getRight ( ) ) ; outerAggregations . add ( split . getLeft ( ) ) ; } TemplateDruidQuery innerQuery ; if ( isNested ( ) ) { innerQuery = new TemplateDruidQuery ( innerAggregations , Collections . emptySet ( ) , nestedQuery , null ) ; } else { innerQuery = new TemplateDruidQuery ( innerAggregations , Collections . emptySet ( ) , null , null ) ; } return new TemplateDruidQuery ( outerAggregations , postAggregations , innerQuery , timeGrain ) ; }
public TemplateDruidQuery nest ( ) { LinkedHashSet < Aggregation > innerAggregations = new LinkedHashSet < > ( ) ; LinkedHashSet < Aggregation > outerAggregations = new LinkedHashSet < > ( ) ; for ( Aggregation agg : aggregations ) { Pair < Aggregation , Aggregation > split = agg . nest ( ) ; innerAggregations . add ( split . getRight ( ) ) ; outerAggregations . add ( split . getLeft ( ) ) ; } TemplateDruidQuery innerQuery ; if ( isNested ( ) ) { innerQuery = new TemplateDruidQuery ( innerAggregations , Collections . emptySet ( ) , nestedQuery , null ) ; } else { innerQuery = new TemplateDruidQuery ( innerAggregations , Collections . emptySet ( ) , null , null ) ; } return new TemplateDruidQuery ( outerAggregations , postAggregations , innerQuery , timeGrain ) ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
public LogMessage readLogBatch ( LogMessage startLog , List < LogMessage > logBatch ) throws IOException , CompressorException { long batchTime = startLog . getTime ( ) ; logBatch . add ( startLog ) ; LogMessage msg ; while ( ( msg = readNextMergedLogMessage ( ) ) != null ) { if ( msg . getTime ( ) == batchTime ) { logBatch . add ( msg ) ; } else { return msg ; } } return null ; }
protected void contributeTokenRequestParameters ( final QueryString bodyParameters ) { }
protected void contributeTokenRequestParameters ( final QueryString bodyParameters ) { }
private void dropProxy ( ProxyReg reg ) { synchronized ( caches ) { Iterator iter = caches . iterator ( ) ; while ( iter . hasNext ( ) ) { LookupCacheImpl cache = ( LookupCacheImpl ) iter . next ( ) ; cache . removeProxyReg ( reg ) ; } } }
public byte [ ] bytes ( ) throws HttpRequestException { final ByteArrayOutputStream output = byteStream ( ) ; try { copy ( buffer ( ) , output ) ; } catch ( IOException e ) { throw new HttpRequestException ( e ) ; } return output . toByteArray ( ) ; }
private QueueConnectionImpl createNewPrimary ( Set excludedServers ) { QueueConnectionImpl primary = null ; while ( primary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List servers = findQueueServers ( excludedServers , _NUM , _BOOL , printPrimaryNotFoundError , LocalizedStrings . QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE ) ; printPrimaryNotFoundError = _BOOL ; if ( servers == null || servers . isEmpty ( ) ) { break ; } Connection connection = null ; try { connection = factory . createClientToServerConnection ( ( ServerLocation ) servers . get ( _NUM ) , _BOOL ) ; } catch ( GemFireSecurityException e ) { throw e ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , servers . get ( _NUM ) ) ; } } if ( connection != null ) { primary = initializeQueueConnection ( connection , _BOOL , queueConnections . getFailedUpdater ( ) ) ; } excludedServers . addAll ( servers ) ; } if ( primary != null && sentClientReady && primary . sendClientReady ( ) ) { readyForEventsAfterFailover ( primary ) ; } return primary ; }
private QueueConnectionImpl createNewPrimary ( Set excludedServers ) { QueueConnectionImpl primary = null ; while ( primary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List servers = findQueueServers ( excludedServers , _NUM , _BOOL , printPrimaryNotFoundError , LocalizedStrings . QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE ) ; printPrimaryNotFoundError = _BOOL ; if ( servers == null || servers . isEmpty ( ) ) { break ; } Connection connection = null ; try { connection = factory . createClientToServerConnection ( ( ServerLocation ) servers . get ( _NUM ) , _BOOL ) ; } catch ( GemFireSecurityException e ) { throw e ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , servers . get ( _NUM ) ) ; } } if ( connection != null ) { primary = initializeQueueConnection ( connection , _BOOL , queueConnections . getFailedUpdater ( ) ) ; } excludedServers . addAll ( servers ) ; } if ( primary != null && sentClientReady && primary . sendClientReady ( ) ) { readyForEventsAfterFailover ( primary ) ; } return primary ; }
private QueueConnectionImpl createNewPrimary ( Set excludedServers ) { QueueConnectionImpl primary = null ; while ( primary == null && pool . getPoolOrCacheCancelInProgress ( ) == null ) { List servers = findQueueServers ( excludedServers , _NUM , _BOOL , printPrimaryNotFoundError , LocalizedStrings . QueueManagerImpl_COULD_NOT_FIND_SERVER_TO_CREATE_PRIMARY_CLIENT_QUEUE ) ; printPrimaryNotFoundError = _BOOL ; if ( servers == null || servers . isEmpty ( ) ) { break ; } Connection connection = null ; try { connection = factory . createClientToServerConnection ( ( ServerLocation ) servers . get ( _NUM ) , _BOOL ) ; } catch ( GemFireSecurityException e ) { throw e ; } catch ( Exception e ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( STRING , servers . get ( _NUM ) ) ; } } if ( connection != null ) { primary = initializeQueueConnection ( connection , _BOOL , queueConnections . getFailedUpdater ( ) ) ; } excludedServers . addAll ( servers ) ; } if ( primary != null && sentClientReady && primary . sendClientReady ( ) ) { readyForEventsAfterFailover ( primary ) ; } return primary ; }
public boolean isInside ( Point point ) { return bounds . contains ( point ) ; }
public boolean isInside ( Point point ) { return bounds . contains ( point ) ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; }
void unlink ( Node < E > p , Node < E > trail ) { p . item = null ; trail . next = p . next ; if ( last == p ) last = trail ; if ( count . getAndDecrement ( ) == capacity ) notFull . signal ( ) ; }
private Shape decodeMarkBorder ( int width , int height ) { double left = width / _NUM - _NUM ; double top = height / _NUM - _NUM ; path . reset ( ) ; path . moveTo ( left + _NUM , top + _NUM ) ; path . lineTo ( left + _NUM , top ) ; path . lineTo ( left + _NUM , top + _NUM ) ; path . closePath ( ) ; return path ; }
boolean alias ( String src , String target ) { if ( src == null ) return _BOOL ; PluginHolder < T > a = registry . get ( src ) ; if ( a == null ) return _BOOL ; PluginHolder < T > b = registry . get ( target ) ; if ( b != null ) return _BOOL ; registry . put ( target , a ) ; return _BOOL ; }
public int callInt ( String key ) { Double d = ( Double ) call ( key ) ; return d . intValue ( ) ; }
public int callInt ( String key ) { Double d = ( Double ) call ( key ) ; return d . intValue ( ) ; }
public int callInt ( String key ) { Double d = ( Double ) call ( key ) ; return d . intValue ( ) ; }
final void pruneExceptionalOut ( IR ir ) { int n = getNumberOfExceptionalOut ( ) ; if ( n > _NUM ) { ComputedBBEnum handlers = new ComputedBBEnum ( n ) ; Enumeration < Instruction > e = forwardRealInstrEnumerator ( ) ; while ( e . hasMoreElements ( ) ) { Instruction x = e . nextElement ( ) ; Enumeration < BasicBlock > bbs = getApplicableExceptionalOut ( x ) ; while ( bbs . hasMoreElements ( ) ) { BasicBlock bb = bbs . nextElement ( ) ; handlers . addPossiblyDuplicateElement ( bb ) ; } } deleteExceptionalOut ( ) ; for ( int i = _NUM ; handlers . hasMoreElements ( ) ; i ++ ) { ExceptionHandlerBasicBlock b = ( ExceptionHandlerBasicBlock ) handlers . nextElement ( ) ; insertOut ( b ) ; } } recomputeNormalOut ( ir ) ; }
protected void runDataBridgeAndCheckReturnValue ( DataBridgeApp dataBridgeApp , String [ ] args , Class < ? > noLoggingClass , DataBridgeApp . ReturnValue expectedReturnValue ) throws Exception { runDataBridgeAndCheckReturnValue ( dataBridgeApp , args , noLoggingClass , expectedReturnValue , null ) ; }
protected void runDataBridgeAndCheckReturnValue ( DataBridgeApp dataBridgeApp , String [ ] args , Class < ? > noLoggingClass , DataBridgeApp . ReturnValue expectedReturnValue ) throws Exception { runDataBridgeAndCheckReturnValue ( dataBridgeApp , args , noLoggingClass , expectedReturnValue , null ) ; }
public static String trimOrPad ( String str , int length , char padChar ) { String result ; if ( str == null ) { result = STRING ; } else { result = str ; } if ( result . length ( ) > length ) { return result . substring ( _NUM , length ) ; } while ( result . length ( ) < length ) { result += padChar ; } return result ; }
synchronized void add ( Object obj ) { if ( objList != null ) { objList . add ( obj ) ; } }
static private HashSet < String > initTwoPartTLDs ( ) { HashSet < String > set = new HashSet < String > ( _NUM ) ; for ( String multiPartTLD : multiPartTLDs ) { try { if ( multiPartTLD . matches ( STRING + tld2 + STRING ) ) { set . add ( multiPartTLD ) ; } } catch ( Exception ex ) { debugOut ( ex ) ; } } debugOut ( STRING + set . size ( ) ) ; return set ; }
private void removeEntryFromParent ( Entry entry , Entry parent , boolean doNotUpdateSiblings ) { final String entryId = entry . getId ( ) ; final String nextSiblingId = entry . getNextSiblingId ( ) ; final String previousSiblingId = entry . getPreviousSiblingId ( ) ; entry . setParentId ( null ) ; final String parentsFirstId = parent . getFirstChildId ( ) ; if ( parentsFirstId . equals ( entryId ) ) { parent . setFirstChildId ( nextSiblingId ) ; } final String parentsLastId = parent . getLastChildId ( ) ; if ( parentsLastId . equals ( entryId ) ) { parent . setLastChildId ( previousSiblingId ) ; } final Entry previousSibling = getEntryById ( previousSiblingId ) ; final Entry nextSibling = getEntryById ( nextSiblingId ) ; if ( ! doNotUpdateSiblings ) { if ( nextSibling != null ) { nextSibling . setPreviousSiblingId ( previousSiblingId ) ; } if ( previousSibling != null ) { previousSibling . setNextSiblingId ( nextSiblingId ) ; } } entry . setNextSiblingId ( null ) ; entry . setPreviousSiblingId ( null ) ; }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void close ( ) throws IOException { if ( writer != null ) { writer . close ( ) ; } else { cb = null ; closed = _BOOL ; } }
public void requestSecondsUntilPasswordExpirationWarning ( ) { operations . add ( PasswordPolicyStateOperationType . GET_SECONDS_UNTIL_PASSWORD_EXPIRATION_WARNING ) ; }
public static boolean isJavaBuiltinDataType ( Class clazz ) { if ( clazz == null ) { return _BOOL ; } Class clazzBoxed = getBoxedType ( clazz ) ; if ( isNumeric ( clazzBoxed ) ) { return _BOOL ; } if ( isBoolean ( clazzBoxed ) ) { return _BOOL ; } if ( clazzBoxed . equals ( String . class ) ) { return _BOOL ; } if ( ( clazzBoxed . equals ( char . class ) ) || ( clazzBoxed . equals ( Character . class ) ) ) { return _BOOL ; } if ( clazzBoxed . equals ( void . class ) ) { return _BOOL ; } return _BOOL ; }
public static String decode ( final String str , final String charsetName ) throws UnsupportedEncodingException { return decode ( new String ( str . getBytes ( charsetName ) , STRING ) ) ; }
private String toPathname ( final String ... pathElements ) { if ( pathElements != null ) { final StringBuilder buffer = new StringBuilder ( ) ; for ( String pathElement : pathElements ) { buffer . append ( File . separator ) ; buffer . append ( pathElement ) ; } return buffer . toString ( ) ; } return null ; }
@ Override public void close ( ) throws IOException { running . set ( _BOOL ) ; service . shutdown ( ) ; try { if ( ! service . awaitTermination ( SHUTDOWN_TIMEOUT , TimeUnit . SECONDS ) ) { LOG . error ( STRING + SHUTDOWN_TIMEOUT + STRING + TimeUnit . SECONDS + STRING + STRING ) ; } } catch ( InterruptedException e1 ) { LOG . warn ( STRING , e1 ) ; } }
@ Override public void close ( ) throws IOException { running . set ( _BOOL ) ; service . shutdown ( ) ; try { if ( ! service . awaitTermination ( SHUTDOWN_TIMEOUT , TimeUnit . SECONDS ) ) { LOG . error ( STRING + SHUTDOWN_TIMEOUT + STRING + TimeUnit . SECONDS + STRING + STRING ) ; } } catch ( InterruptedException e1 ) { LOG . warn ( STRING , e1 ) ; } }
public static boolean isNullConversion ( MethodType call , MethodType recv , boolean keepInterfaces ) { if ( call == recv ) return _BOOL ; int len = call . parameterCount ( ) ; if ( len != recv . parameterCount ( ) ) return _BOOL ; for ( int i = _NUM ; i < len ; i ++ ) if ( ! isNullConversion ( call . parameterType ( i ) , recv . parameterType ( i ) , keepInterfaces ) ) return _BOOL ; return isNullConversion ( recv . returnType ( ) , call . returnType ( ) , keepInterfaces ) ; }
public static boolean isNullConversion ( MethodType call , MethodType recv , boolean keepInterfaces ) { if ( call == recv ) return _BOOL ; int len = call . parameterCount ( ) ; if ( len != recv . parameterCount ( ) ) return _BOOL ; for ( int i = _NUM ; i < len ; i ++ ) if ( ! isNullConversion ( call . parameterType ( i ) , recv . parameterType ( i ) , keepInterfaces ) ) return _BOOL ; return isNullConversion ( recv . returnType ( ) , call . returnType ( ) , keepInterfaces ) ; }
@ Override protected void onLayout ( boolean changed , int l , int t , int r , int b ) { super . onLayout ( changed , l , t , r , b ) ; mInLayout = _BOOL ; layout ( _NUM , _BOOL ) ; mInLayout = _BOOL ; }
public Vector < RtcpSdesPacket > makereports ( ) { Vector < RtcpSdesPacket > packets = new Vector < RtcpSdesPacket > ( ) ; RtcpSdesPacket rtcpsdespacket = new RtcpSdesPacket ( new RtcpSdesBlock [ _NUM ] ) ; rtcpsdespacket . sdes [ _NUM ] = new RtcpSdesBlock ( ) ; rtcpsdespacket . sdes [ _NUM ] . ssrc = rtcpSession . SSRC ; Vector < RtcpSdesItem > vector = new Vector < RtcpSdesItem > ( ) ; vector . addElement ( new RtcpSdesItem ( _NUM , RtpSource . CNAME ) ) ; rtcpsdespacket . sdes [ _NUM ] . items = new RtcpSdesItem [ vector . size ( ) ] ; vector . copyInto ( rtcpsdespacket . sdes [ _NUM ] . items ) ; packets . addElement ( rtcpsdespacket ) ; return packets ; }
private double [ ] projectSparse ( SparseNumberVector in , double [ ] ret ) { Arrays . fill ( ret , _NUM ) ; for ( int iter = in . iter ( ) ; in . iterValid ( iter ) ; iter = in . iterAdvance ( iter ) ) { final int i = in . iterDim ( iter ) ; final double val = in . iterDoubleValue ( iter ) ; for ( int o = _NUM ; o < ret . length ; o ++ ) { ret [ o ] += val * matrix [ o ] [ i ] ; } } return ret ; }
public static void notifyRunningInstance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; InetSocketAddress address = new InetSocketAddress ( InetAddress . getLoopbackAddress ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , _NUM ) ; try ( PrintWriter output = new PrintWriter ( new OutputStreamWriter ( connection . getOutputStream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IOException ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notifyRunningInstance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; InetSocketAddress address = new InetSocketAddress ( InetAddress . getLoopbackAddress ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , _NUM ) ; try ( PrintWriter output = new PrintWriter ( new OutputStreamWriter ( connection . getOutputStream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IOException ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notifyRunningInstance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; InetSocketAddress address = new InetSocketAddress ( InetAddress . getLoopbackAddress ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , _NUM ) ; try ( PrintWriter output = new PrintWriter ( new OutputStreamWriter ( connection . getOutputStream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IOException ex ) { LOGGER . warning ( STRING + ex ) ; } }
public static void notifyRunningInstance ( int port , String message ) { try { LOGGER . info ( STRING + message ) ; InetSocketAddress address = new InetSocketAddress ( InetAddress . getLoopbackAddress ( ) , port ) ; Socket connection = new Socket ( ) ; connection . connect ( address , _NUM ) ; try ( PrintWriter output = new PrintWriter ( new OutputStreamWriter ( connection . getOutputStream ( ) , STRING ) ) ) { output . print ( message ) ; } } catch ( IOException ex ) { LOGGER . warning ( STRING + ex ) ; } }
void populateRegionSubRegions ( RegionSubRegionSnapshot parentSnapShot , Set regions , GemFireCacheImpl cache ) { if ( cancelled ) return ; Region subRegion = null ; RegionSubRegionSnapshot subRegionSnapShot = null ; for ( Iterator iter = regions . iterator ( ) ; iter . hasNext ( ) ; ) { subRegion = ( Region ) iter . next ( ) ; try { subRegionSnapShot = new RegionSubRegionSnapshot ( subRegion ) ; parentSnapShot . addSubRegion ( subRegionSnapShot ) ; Set subRegions = subRegion . subregions ( _BOOL ) ; populateRegionSubRegions ( subRegionSnapShot , subRegions , cache ) ; } catch ( Exception e ) { logger . debug ( STRING , subRegion . getFullPath ( ) , e ) ; } } }
public static void writeBytesToStream ( byte [ ] bytes , OutputStream outputStream ) throws IOException { BufferedOutputStream bos = new BufferedOutputStream ( outputStream ) ; try { bos . write ( bytes ) ; } finally { bos . close ( ) ; } }
public void parseHierarchy ( String hCode , Properties props , SymbolPart parent ) { List codePositionList = null ; if ( nextPosition != null ) { codePositionList = nextPosition . getPositionChoices ( ) ; } if ( codePositionList == null || codePositionList . isEmpty ( ) ) { Debug . output ( prettyName + STRING ) ; return ; } List parentList = null ; for ( Iterator it = codePositionList . iterator ( ) ; it . hasNext ( ) ; ) { CodePosition cp = ( CodePosition ) it . next ( ) ; String newHCode = hCode + STRING + cp . getHierarchyNumber ( ) ; if ( DEBUG ) { Debug . output ( STRING + newHCode + STRING + cp . getPrettyName ( ) ) ; } String entry = props . getProperty ( newHCode ) ; if ( entry != null ) { SymbolPart sp = new SymbolPart ( cp , entry , props , parent ) ; if ( parentList == null ) { parentList = parent . getSubs ( ) ; if ( parentList == null ) { parentList = new ArrayList ( ) ; parent . setSubs ( parentList ) ; } } if ( DEBUG ) { Debug . output ( STRING + sp . getPrettyName ( ) + STRING + parent . getPrettyName ( ) ) ; } parentList . add ( sp ) ; if ( DEBUG ) { Debug . output ( STRING + cp . getPrettyName ( ) + STRING + sp . getPrettyName ( ) ) ; } cp . parseHierarchy ( newHCode , props , sp ) ; } else { if ( DEBUG ) { Debug . output ( STRING + newHCode ) ; } } } }
public UtilizationModelPlanetLabInMemory ( String inputPath , double schedulingInterval ) throws NumberFormatException , IOException { data = new double [ _NUM ] ; setSchedulingInterval ( schedulingInterval ) ; BufferedReader input = new BufferedReader ( new FileReader ( inputPath ) ) ; int n = data . length ; for ( int i = _NUM ; i < n - _NUM ; i ++ ) { data [ i ] = Integer . valueOf ( input . readLine ( ) ) / _NUM ; } data [ n - _NUM ] = data [ n - _NUM ] ; input . close ( ) ; }
public static ByteBuffer readFully ( FileChannel channel , long fileOffset , int bytesToRead ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( bytesToRead ) ; int totalBytesRead = _NUM ; while ( totalBytesRead < bytesToRead ) { int bytesRead = channel . read ( buffer , fileOffset + totalBytesRead ) ; if ( bytesRead < _NUM ) { throw new EOFException ( STRING + bytesToRead + STRING + totalBytesRead + STRING ) ; } totalBytesRead += bytesRead ; } buffer . flip ( ) ; return buffer ; }
public static ByteBuffer readFully ( FileChannel channel , long fileOffset , int bytesToRead ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( bytesToRead ) ; int totalBytesRead = _NUM ; while ( totalBytesRead < bytesToRead ) { int bytesRead = channel . read ( buffer , fileOffset + totalBytesRead ) ; if ( bytesRead < _NUM ) { throw new EOFException ( STRING + bytesToRead + STRING + totalBytesRead + STRING ) ; } totalBytesRead += bytesRead ; } buffer . flip ( ) ; return buffer ; }
public static ByteBuffer readFully ( FileChannel channel , long fileOffset , int bytesToRead ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( bytesToRead ) ; int totalBytesRead = _NUM ; while ( totalBytesRead < bytesToRead ) { int bytesRead = channel . read ( buffer , fileOffset + totalBytesRead ) ; if ( bytesRead < _NUM ) { throw new EOFException ( STRING + bytesToRead + STRING + totalBytesRead + STRING ) ; } totalBytesRead += bytesRead ; } buffer . flip ( ) ; return buffer ; }
public static ByteBuffer readFully ( FileChannel channel , long fileOffset , int bytesToRead ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( bytesToRead ) ; int totalBytesRead = _NUM ; while ( totalBytesRead < bytesToRead ) { int bytesRead = channel . read ( buffer , fileOffset + totalBytesRead ) ; if ( bytesRead < _NUM ) { throw new EOFException ( STRING + bytesToRead + STRING + totalBytesRead + STRING ) ; } totalBytesRead += bytesRead ; } buffer . flip ( ) ; return buffer ; }
public static ByteBuffer readFully ( FileChannel channel , long fileOffset , int bytesToRead ) throws IOException { ByteBuffer buffer = ByteBuffer . allocate ( bytesToRead ) ; int totalBytesRead = _NUM ; while ( totalBytesRead < bytesToRead ) { int bytesRead = channel . read ( buffer , fileOffset + totalBytesRead ) ; if ( bytesRead < _NUM ) { throw new EOFException ( STRING + bytesToRead + STRING + totalBytesRead + STRING ) ; } totalBytesRead += bytesRead ; } buffer . flip ( ) ; return buffer ; }
public void addTileset ( final TileSetDefinition set ) { tilesets . add ( set ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
public static String escape ( String string ) { char c ; String s = string . trim ( ) ; int length = s . length ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i += _NUM ) { c = s . charAt ( i ) ; if ( c < STRING || c == STRING || c == STRING || c == STRING || c == STRING ) { sb . append ( STRING ) ; sb . append ( Character . forDigit ( ( char ) ( ( c > > > _NUM ) & _NUM ) , _NUM ) ) ; sb . append ( Character . forDigit ( ( char ) ( c & _NUM ) , _NUM ) ) ; } else { sb . append ( c ) ; } } return sb . toString ( ) ; }
private final void _writeString ( char [ ] text , int offset , int len ) throws IOException , JsonGenerationException { if ( _characterEscapes != null ) { _writeStringCustom ( text , offset , len ) ; return ; } if ( _maximumNonEscapedChar != _NUM ) { _writeStringASCII ( text , offset , len , _maximumNonEscapedChar ) ; return ; } len += offset ; final int [ ] escCodes = _outputEscapes ; final int escLen = escCodes . length ; while ( offset < len ) { int start = offset ; while ( _BOOL ) { char c = text [ offset ] ; if ( c < escLen && escCodes [ c ] != _NUM ) { break ; } if ( ++ offset >= len ) { break ; } } int newAmount = offset - start ; if ( newAmount < SHORT_WRITE ) { if ( ( _outputTail + newAmount ) > _outputEnd ) { _flushBuffer ( ) ; } if ( newAmount > _NUM ) { System . arraycopy ( text , start , _outputBuffer , _outputTail , newAmount ) ; _outputTail += newAmount ; } } else { _flushBuffer ( ) ; _writer . write ( text , start , newAmount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; _appendCharacterEscape ( c , escCodes [ c ] ) ; } }
private final void _writeString ( char [ ] text , int offset , int len ) throws IOException , JsonGenerationException { if ( _characterEscapes != null ) { _writeStringCustom ( text , offset , len ) ; return ; } if ( _maximumNonEscapedChar != _NUM ) { _writeStringASCII ( text , offset , len , _maximumNonEscapedChar ) ; return ; } len += offset ; final int [ ] escCodes = _outputEscapes ; final int escLen = escCodes . length ; while ( offset < len ) { int start = offset ; while ( _BOOL ) { char c = text [ offset ] ; if ( c < escLen && escCodes [ c ] != _NUM ) { break ; } if ( ++ offset >= len ) { break ; } } int newAmount = offset - start ; if ( newAmount < SHORT_WRITE ) { if ( ( _outputTail + newAmount ) > _outputEnd ) { _flushBuffer ( ) ; } if ( newAmount > _NUM ) { System . arraycopy ( text , start , _outputBuffer , _outputTail , newAmount ) ; _outputTail += newAmount ; } } else { _flushBuffer ( ) ; _writer . write ( text , start , newAmount ) ; } if ( offset >= len ) { break ; } char c = text [ offset ++ ] ; _appendCharacterEscape ( c , escCodes [ c ] ) ; } }
public void sendMessage ( SIPMessage sipMessage , InetAddress receiverAddress , int receiverPort ) throws IOException { long time = System . currentTimeMillis ( ) ; sendMessage ( sipMessage , receiverAddress , receiverPort , sipMessage instanceof SIPRequest ) ; logMessage ( sipMessage , receiverAddress , receiverPort , time ) ; }
public static void writeFileList ( XMLOutput xmlOutput , String tagName , Iterable < File > listValues ) throws IOException { if ( listValues != null ) { writeFileList ( xmlOutput , tagName , listValues . iterator ( ) ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return _BOOL ; if ( o1 == null || o2 == null ) return _BOOL ; Class c = o1 . getClass ( ) ; if ( c != o2 . getClass ( ) ) return _BOOL ; if ( c . isArray ( ) ) { int length = Array . getLength ( o1 ) ; int length2 = Array . getLength ( o2 ) ; if ( length != length2 ) return _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return _BOOL ; } return _BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return _BOOL ; if ( o1 == null || o2 == null ) return _BOOL ; Class c = o1 . getClass ( ) ; if ( c != o2 . getClass ( ) ) return _BOOL ; if ( c . isArray ( ) ) { int length = Array . getLength ( o1 ) ; int length2 = Array . getLength ( o2 ) ; if ( length != length2 ) return _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return _BOOL ; } return _BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return _BOOL ; if ( o1 == null || o2 == null ) return _BOOL ; Class c = o1 . getClass ( ) ; if ( c != o2 . getClass ( ) ) return _BOOL ; if ( c . isArray ( ) ) { int length = Array . getLength ( o1 ) ; int length2 = Array . getLength ( o2 ) ; if ( length != length2 ) return _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return _BOOL ; } return _BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return _BOOL ; if ( o1 == null || o2 == null ) return _BOOL ; Class c = o1 . getClass ( ) ; if ( c != o2 . getClass ( ) ) return _BOOL ; if ( c . isArray ( ) ) { int length = Array . getLength ( o1 ) ; int length2 = Array . getLength ( o2 ) ; if ( length != length2 ) return _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return _BOOL ; } return _BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static boolean equals ( Object o1 , Object o2 ) { if ( o1 == o2 ) return _BOOL ; if ( o1 == null || o2 == null ) return _BOOL ; Class c = o1 . getClass ( ) ; if ( c != o2 . getClass ( ) ) return _BOOL ; if ( c . isArray ( ) ) { int length = Array . getLength ( o1 ) ; int length2 = Array . getLength ( o2 ) ; if ( length != length2 ) return _BOOL ; for ( int i = _NUM ; i < length ; i ++ ) { Object c1 = Array . get ( o1 , i ) ; Object c2 = Array . get ( o2 , i ) ; if ( ! equals ( c1 , c2 ) ) return _BOOL ; } return _BOOL ; } else { return o1 . equals ( o2 ) ; } }
public static byte [ ] hexStringToBytes ( final String hexString ) { return DatatypeConverter . parseHexBinary ( hexString ) ; }
public static byte [ ] hexStringToBytes ( final String hexString ) { return DatatypeConverter . parseHexBinary ( hexString ) ; }
public static byte [ ] hexStringToBytes ( final String hexString ) { return DatatypeConverter . parseHexBinary ( hexString ) ; }
protected void writeHeader ( RandomAccessFile file , int size ) throws IOException { String str ; int offset = _NUM ; byte [ ] buffer = new byte [ _NUM ] ; str = Integer . toString ( getSize ( ) ) ; for ( int i = _NUM ; i < ( _NUM - str . length ( ) ) ; i ++ ) { buffer [ i ] = ( byte ) STRING ; } offset += ( _NUM - str . length ( ) ) ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) { buffer [ i + offset ] = ( byte ) str . charAt ( i ) ; } file . write ( buffer ) ; }
public boolean addAll ( Collection coll , boolean allowRepeated ) { boolean isChanged = _BOOL ; for ( Iterator i = coll . iterator ( ) ; i . hasNext ( ) ; ) { add ( ( Coordinate ) i . next ( ) , allowRepeated ) ; isChanged = _BOOL ; } return isChanged ; }
protected AsyncHttpRequest newAsyncHttpRequest ( DefaultHttpClient client , HttpContext httpContext , HttpUriRequest uriRequest , String contentType , ResponseHandlerInterface responseHandler , Context context ) { return new AsyncHttpRequest ( client , httpContext , uriRequest , responseHandler ) ; }
@ Override public ArrayList < String > list ( String path ) { ArrayList < String > fileNameList = new ArrayList < String > ( ) ; DropboxAPI . Entry files = null ; try { files = mDBApi . metadata ( path , _NUM , null , _BOOL , null ) ; for ( Entry e : files . contents ) { fileNameList . add ( e . fileName ( ) ) ; } } catch ( DropboxException e ) { e . printStackTrace ( ) ; } return fileNameList ; }
public void orWith ( OrCondition other ) { children . addAll ( other . getAndTerms ( ) ) ; }
public void orWith ( OrCondition other ) { children . addAll ( other . getAndTerms ( ) ) ; }
public void orWith ( OrCondition other ) { children . addAll ( other . getAndTerms ( ) ) ; }
public void orWith ( OrCondition other ) { children . addAll ( other . getAndTerms ( ) ) ; }
protected void addBeanConnectionRelation ( MetaBean meta , String connection ) { Vector < String > relations ; Object key ; relations = getBeanConnectionRelation ( meta ) ; relations . add ( connection ) ; if ( meta == null ) { key = REGULAR_CONNECTION ; } else { key = meta ; } m_BeanConnectionRelation . put ( key , relations ) ; }
public void put ( E e ) { offer ( e ) ; }
public void put ( E e ) { offer ( e ) ; }
public RMRealmModelImpl ( HttpServletRequest req , Map map ) { super ( req , map ) ; }
public RMRealmModelImpl ( HttpServletRequest req , Map map ) { super ( req , map ) ; }
public RMRealmModelImpl ( HttpServletRequest req , Map map ) { super ( req , map ) ; }
void pushBaseIndentifier ( String baseID ) { if ( null != baseID ) { int posOfHash = baseID . indexOf ( STRING ) ; if ( posOfHash > - _NUM ) { m_fragmentIDString = baseID . substring ( posOfHash + _NUM ) ; m_shouldProcess = _BOOL ; } else m_shouldProcess = _BOOL ; } else m_shouldProcess = _BOOL ; m_baseIdentifiers . push ( baseID ) ; }
void pushBaseIndentifier ( String baseID ) { if ( null != baseID ) { int posOfHash = baseID . indexOf ( STRING ) ; if ( posOfHash > - _NUM ) { m_fragmentIDString = baseID . substring ( posOfHash + _NUM ) ; m_shouldProcess = _BOOL ; } else m_shouldProcess = _BOOL ; } else m_shouldProcess = _BOOL ; m_baseIdentifiers . push ( baseID ) ; }
private void fillInsideDraw ( Graphics g , int x , int y , int w , int h ) { g . setColor ( Color . BLACK ) ; g . drawRect ( x , y , w , h ) ; g . setColor ( Color . LIGHT_GRAY ) ; g . fillRect ( x + _NUM , y + _NUM , w - _NUM , h - _NUM ) ; }
private void fillInsideDraw ( Graphics g , int x , int y , int w , int h ) { g . setColor ( Color . BLACK ) ; g . drawRect ( x , y , w , h ) ; g . setColor ( Color . LIGHT_GRAY ) ; g . fillRect ( x + _NUM , y + _NUM , w - _NUM , h - _NUM ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
private void updateThumbnailMatrix ( ) { if ( mThumbnail == null ) return ; if ( mImageMatrix == null ) mImageMatrix = new Matrix ( ) ; float widthScale = ( float ) getMeasuredWidth ( ) / mThumbnail . getWidth ( ) ; float heightScale = ( float ) getMeasuredHeight ( ) / mThumbnail . getHeight ( ) ; float scale = Math . max ( widthScale , heightScale ) ; mImageMatrix . setScale ( scale , scale ) ; setImageMatrix ( mImageMatrix ) ; }
public void addSprite ( OdorWorldEntity sprite ) { sprites . add ( sprite ) ; }
@ Override public ServerHeartbeat serverDyn ( String address , int port , boolean isSSL , String clusterId , String displayName ) { Objects . requireNonNull ( address ) ; Objects . requireNonNull ( clusterId ) ; ClusterHeartbeat cluster = createCluster ( clusterId ) ; ServerHeartbeat server = cluster . createServer ( address , port , isSSL ) ; if ( displayName != null ) { server . setDisplayName ( displayName ) ; } cluster . addDynamicServer ( server ) ; return server ; }
@ OnClick ( R . id . info_icon_button ) public void onInfoClick ( View view ) { Offer selectedOffer ; int position = getAdapterPosition ( ) ; int cardPosition = getCardPosition ( position ) ; selectedOffer = offers . get ( cardPosition ) ; goToInfo ( selectedOffer , view . getContext ( ) ) ; }
@ OnClick ( R . id . info_icon_button ) public void onInfoClick ( View view ) { Offer selectedOffer ; int position = getAdapterPosition ( ) ; int cardPosition = getCardPosition ( position ) ; selectedOffer = offers . get ( cardPosition ) ; goToInfo ( selectedOffer , view . getContext ( ) ) ; }
@ OnClick ( R . id . info_icon_button ) public void onInfoClick ( View view ) { Offer selectedOffer ; int position = getAdapterPosition ( ) ; int cardPosition = getCardPosition ( position ) ; selectedOffer = offers . get ( cardPosition ) ; goToInfo ( selectedOffer , view . getContext ( ) ) ; }
@ OnClick ( R . id . info_icon_button ) public void onInfoClick ( View view ) { Offer selectedOffer ; int position = getAdapterPosition ( ) ; int cardPosition = getCardPosition ( position ) ; selectedOffer = offers . get ( cardPosition ) ; goToInfo ( selectedOffer , view . getContext ( ) ) ; }
public static String geServerBaseURL ( HttpServletRequest request ) { String uri = request . getRequestURI ( ) ; int index = uri . indexOf ( STRING , _NUM ) ; if ( index != - _NUM ) { uri = uri . substring ( _NUM , index ) ; } return request . getScheme ( ) + STRING + request . getServerName ( ) + STRING + request . getServerPort ( ) + uri ; }
private void addAction ( String label , int id , int type ) { CardAction cardAction = new CardAction ( ) ; cardAction . label = label ; cardAction . id = id ; cardAction . type = type ; mCardActions . add ( cardAction ) ; }
private void handleChannelInfoResult ( RequestType type , String url , String result , int responseCode , String stream ) { if ( result == null || responseCode != _NUM ) { handleChannelInfoResultError ( stream , type , responseCode ) ; return ; } ChannelInfo info = parseChannelInfo ( result ) ; if ( info == null ) { LOGGER . warning ( STRING + result ) ; handleChannelInfoResultError ( stream , type , responseCode ) ; return ; } if ( type == RequestType . CHANNEL_PUT ) { resultListener . putChannelInfoResult ( RequestResult . SUCCESS ) ; } resultListener . receivedChannelInfo ( stream , info , RequestResult . SUCCESS ) ; cachedChannelInfo . put ( stream , info ) ; userIDs . channelInfoReceived ( info ) ; }
public double normalDistance ( final double x , final double y , final double z ) { return Math . sqrt ( normalDistanceSquared ( x , y , z ) ) ; }
public mxICellOverlay removeCellOverlay ( Object cell , mxICellOverlay overlay ) { if ( overlay == null ) { removeCellOverlays ( cell ) ; } else { mxICellOverlay [ ] arr = getCellOverlays ( cell ) ; if ( arr != null ) { List < mxICellOverlay > list = Arrays . asList ( arr ) ; if ( list . remove ( overlay ) ) { removeCellOverlayComponent ( overlay , cell ) ; } arr = ( mxICellOverlay [ ] ) list . toArray ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
public mxICellOverlay removeCellOverlay ( Object cell , mxICellOverlay overlay ) { if ( overlay == null ) { removeCellOverlays ( cell ) ; } else { mxICellOverlay [ ] arr = getCellOverlays ( cell ) ; if ( arr != null ) { List < mxICellOverlay > list = Arrays . asList ( arr ) ; if ( list . remove ( overlay ) ) { removeCellOverlayComponent ( overlay , cell ) ; } arr = ( mxICellOverlay [ ] ) list . toArray ( ) ; overlays . put ( cell , arr ) ; } } return overlay ; }
@ Override public DOMImplementation item ( int index ) { final int length = getLength ( ) ; if ( index >= _NUM && index < length ) { return ( DOMImplementation ) fImplementations . get ( index ) ; } return null ; }
@ Override public DOMImplementation item ( int index ) { final int length = getLength ( ) ; if ( index >= _NUM && index < length ) { return ( DOMImplementation ) fImplementations . get ( index ) ; } return null ; }
private void removeKeys ( Hashtable themeRes , String uiid ) { if ( uiid == null || uiid . length ( ) == _NUM ) { for ( Object k : themeRes . keySet ( ) ) { String key = ( String ) k ; if ( key . indexOf ( STRING ) > - _NUM || key . indexOf ( STRING ) > - _NUM || key . indexOf ( STRING ) > - _NUM ) { continue ; } themeRes . remove ( key ) ; removeKeys ( themeRes , uiid ) ; return ; } return ; } for ( Object k : themeRes . keySet ( ) ) { String key = ( String ) k ; if ( key . startsWith ( uiid ) ) { if ( prefix . length ( ) == _NUM && key . indexOf ( STRING ) > _NUM ) { continue ; } themeRes . remove ( key ) ; removeKeys ( themeRes , uiid ) ; return ; } } }
private void removeKeys ( Hashtable themeRes , String uiid ) { if ( uiid == null || uiid . length ( ) == _NUM ) { for ( Object k : themeRes . keySet ( ) ) { String key = ( String ) k ; if ( key . indexOf ( STRING ) > - _NUM || key . indexOf ( STRING ) > - _NUM || key . indexOf ( STRING ) > - _NUM ) { continue ; } themeRes . remove ( key ) ; removeKeys ( themeRes , uiid ) ; return ; } return ; } for ( Object k : themeRes . keySet ( ) ) { String key = ( String ) k ; if ( key . startsWith ( uiid ) ) { if ( prefix . length ( ) == _NUM && key . indexOf ( STRING ) > _NUM ) { continue ; } themeRes . remove ( key ) ; removeKeys ( themeRes , uiid ) ; return ; } } }
public void addSetter ( int i ) { for ( ScatterPlotSetter setter : setterList ) { if ( setter . getIndex ( ) == i ) { return ; } } setterList . add ( new ScatterPlotSetter ( i ) ) ; }
public void remove ( final int index ) { checkWidget ( ) ; if ( index < _NUM || index >= items . size ( ) ) { SWT . error ( SWT . ERROR_INVALID_ARGUMENT ) ; } items . remove ( index ) ; redrawTables ( ) ; }
public static KeyStore loadKeyStore ( String type , File file , char [ ] password ) throws Exception { KeyStore keyStore = KeyStore . getInstance ( type ) ; try ( FileInputStream fis = new FileInputStream ( file ) ) { keyStore . load ( fis , password ) ; } return keyStore ; }
protected void garbageCollect ( VisualTable labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; if ( ! item . isStartVisible ( ) && ! item . isEndVisible ( ) ) { labels . removeTuple ( item ) ; } } }
protected void garbageCollect ( VisualTable labels ) { Iterator iter = labels . tuples ( ) ; while ( iter . hasNext ( ) ) { VisualItem item = ( VisualItem ) iter . next ( ) ; if ( ! item . isStartVisible ( ) && ! item . isEndVisible ( ) ) { labels . removeTuple ( item ) ; } } }
@ Override protected void update ( ) { m_ButtonStart . setEnabled ( hasData ( ) ) ; m_ButtonStop . setEnabled ( isRunning ( ) ) ; }
public static final TimeoutToken addTimeoutHandler ( long runTime , Runnable handler ) { TimeoutToken token = new TimeoutToken ( runTime , handler ) ; synchronized ( todolist ) { todolist . add ( token ) ; Collections . sort ( todolist ) ; if ( timeoutThread != null ) timeoutThread . interrupt ( ) ; else { timeoutThread = new TimeoutThread ( ) ; timeoutThread . setDaemon ( _BOOL ) ; timeoutThread . start ( ) ; } } return token ; }
public static WKTGeometry createEmpty ( WKTType wktType ) { WKTGeometry wktGeometry = new WKTGeometry ( ) ; wktGeometry . setGeometryType ( wktType ) ; return wktGeometry ; }
public static Object executeScript ( String filePath , String functionName , Map < String , Object > context ) { return executeScript ( filePath , functionName , context , new Object [ ] { context } ) ; }
public static Object executeScript ( String filePath , String functionName , Map < String , Object > context ) { return executeScript ( filePath , functionName , context , new Object [ ] { context } ) ; }
public static Object executeScript ( String filePath , String functionName , Map < String , Object > context ) { return executeScript ( filePath , functionName , context , new Object [ ] { context } ) ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public DataTypeParser register ( int jdbcType , String grammar ) { Objects . requireNonNull ( grammar , STRING ) ; DataTypePattern pattern = parser . parse ( jdbcType , grammar ) ; pattern . forEachFirstToken ( null ) ; return this ; }
public boolean removeEntry ( T e ) { if ( e == null ) return _BOOL ; boolean removed = mYVals . remove ( e ) ; if ( removed ) { float val = e . getVal ( ) ; mYValueSum -= val ; calcMinMax ( mLastStart , mLastEnd ) ; } return removed ; }
public boolean removeEntry ( T e ) { if ( e == null ) return _BOOL ; boolean removed = mYVals . remove ( e ) ; if ( removed ) { float val = e . getVal ( ) ; mYValueSum -= val ; calcMinMax ( mLastStart , mLastEnd ) ; } return removed ; }
public synchronized void addTemplate ( DockerSlaveTemplate t ) { templates . add ( t ) ; }
public static String transformFilename ( String fileName ) { if ( ! fileName . endsWith ( STRING ) ) { fileName = fileName + STRING ; } return fileName ; }
public static String transformFilename ( String fileName ) { if ( ! fileName . endsWith ( STRING ) ) { fileName = fileName + STRING ; } return fileName ; }
public static String transformFilename ( String fileName ) { if ( ! fileName . endsWith ( STRING ) ) { fileName = fileName + STRING ; } return fileName ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public int nextInt ( ) { throw new UnsupportedOperationException ( STRING ) ; }
public void finish ( boolean restoreBuiltinClasses ) { DocCommentGenerator g = new TopLevelGenerator ( ) ; g . generate ( tab ) ; xml = g . toString ( ) ; g = null ; if ( restoreBuiltinClasses && xml != null ) { xml = xml . replaceAll ( STRING , STRING ) ; xml = xml . replaceAll ( STRING , STRING ) ; xml = xml . replaceAll ( STRING , STRING ) ; } }
public void finish ( boolean restoreBuiltinClasses ) { DocCommentGenerator g = new TopLevelGenerator ( ) ; g . generate ( tab ) ; xml = g . toString ( ) ; g = null ; if ( restoreBuiltinClasses && xml != null ) { xml = xml . replaceAll ( STRING , STRING ) ; xml = xml . replaceAll ( STRING , STRING ) ; xml = xml . replaceAll ( STRING , STRING ) ; } }
private void drawTextElements ( Canvas canvas , float textSize , Typeface typeface , ColorStateList textColor , String [ ] texts , float [ ] textX , float [ ] textY , Paint paint , int alpha , boolean showActivated , int activatedDegrees , boolean activatedOnly ) { paint . setTextSize ( textSize ) ; paint . setTypeface ( typeface ) ; final float activatedIndex = activatedDegrees / ( _NUM / NUM_POSITIONS ) ; final int activatedFloor = ( int ) activatedIndex ; final int activatedCeil = ( ( int ) Math . ceil ( activatedIndex ) ) % NUM_POSITIONS ; for ( int i = _NUM ; i < _NUM ; i ++ ) { final boolean activated = ( activatedFloor == i || activatedCeil == i ) ; if ( activatedOnly && ! activated ) { continue ; } final int [ ] stateMask = new int [ ] { android . R . attr . state_enabled , ( showActivated && activated ? android . R . attr . state_selected : _NUM ) } ; final int color = textColor . getColorForState ( stateMask , _NUM ) ; paint . setColor ( color ) ; paint . setAlpha ( getMultipliedAlpha ( color , alpha ) ) ; canvas . drawText ( texts [ i ] , textX [ i ] , textY [ i ] , paint ) ; } }
private void drawTextElements ( Canvas canvas , float textSize , Typeface typeface , ColorStateList textColor , String [ ] texts , float [ ] textX , float [ ] textY , Paint paint , int alpha , boolean showActivated , int activatedDegrees , boolean activatedOnly ) { paint . setTextSize ( textSize ) ; paint . setTypeface ( typeface ) ; final float activatedIndex = activatedDegrees / ( _NUM / NUM_POSITIONS ) ; final int activatedFloor = ( int ) activatedIndex ; final int activatedCeil = ( ( int ) Math . ceil ( activatedIndex ) ) % NUM_POSITIONS ; for ( int i = _NUM ; i < _NUM ; i ++ ) { final boolean activated = ( activatedFloor == i || activatedCeil == i ) ; if ( activatedOnly && ! activated ) { continue ; } final int [ ] stateMask = new int [ ] { android . R . attr . state_enabled , ( showActivated && activated ? android . R . attr . state_selected : _NUM ) } ; final int color = textColor . getColorForState ( stateMask , _NUM ) ; paint . setColor ( color ) ; paint . setAlpha ( getMultipliedAlpha ( color , alpha ) ) ; canvas . drawText ( texts [ i ] , textX [ i ] , textY [ i ] , paint ) ; } }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
public void testBenchmark ( ) throws Exception { runTest ( STRING , STRING ) ; runTest ( STRING , STRING ) ; }
private void updateLessThanGwt25 ( List < String > programArgs , int indexDisabled , int indexEnabled ) { if ( indexDisabled > - _NUM ) { programArgs . remove ( indexDisabled ) ; } if ( indexEnabled > - _NUM ) { programArgs . remove ( indexEnabled ) ; } }
public static Uri addMessageToUri ( ContentResolver resolver , Uri uri , String address , String body , String subject , Long date , boolean read , boolean deliveryReport ) { return addMessageToUri ( resolver , uri , address , body , subject , date , read , deliveryReport , - _NUM ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
public void paint ( Graphics g ) { g = g . create ( ) ; setRenderingHints ( g ) ; setCompositeOnGraphics ( ( Graphics2D ) g ) ; super . paint ( g ) ; }
private ActionButton createToolbarButton ( Action action ) { return new ActionButton ( action , actionManager , presentationFactory . getPresentation ( action ) , managerProvider . get ( ) , toolbarResources ) ; }
public Namespace ( PrincipalUser creator , String qualifier , PrincipalUser owner , Set < PrincipalUser > users ) { super ( creator ) ; setQualifier ( qualifier ) ; setOwner ( owner ) ; if ( users != null && ! users . isEmpty ( ) ) { setUsers ( users ) ; } addUser ( owner ) ; }
public void disableScheduleRenewal ( ) { currentLease . set ( null ) ; Set < Lease > leases = new HashSet < > ( schedules . keySet ( ) ) ; for ( Lease lease : leases ) { cancelSchedule ( lease ) ; schedules . remove ( lease ) ; } }
public void updateUserInfo ( Bundle userInfo ) { mUserInfo = userInfo ; loadChatMessages ( ) ; }
private static List < List < ? > > executeH2Query ( String sql , Object [ ] args ) throws SQLException { List < List < ? > > res = new ArrayList < > ( ) ; ResultSet rs = null ; try ( PreparedStatement st = conn . prepareStatement ( sql ) ) { for ( int idx = _NUM ; idx < args . length ; idx ++ ) st . setObject ( idx + _NUM , args [ idx ] ) ; rs = st . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; int colCnt = meta . getColumnCount ( ) ; while ( rs . next ( ) ) { List < Object > row = new ArrayList < > ( colCnt ) ; for ( int i = _NUM ; i <= colCnt ; i ++ ) row . add ( rs . getObject ( i ) ) ; res . add ( row ) ; } } finally { U . closeQuiet ( rs ) ; } return res ; }
private static List < List < ? > > executeH2Query ( String sql , Object [ ] args ) throws SQLException { List < List < ? > > res = new ArrayList < > ( ) ; ResultSet rs = null ; try ( PreparedStatement st = conn . prepareStatement ( sql ) ) { for ( int idx = _NUM ; idx < args . length ; idx ++ ) st . setObject ( idx + _NUM , args [ idx ] ) ; rs = st . executeQuery ( ) ; ResultSetMetaData meta = rs . getMetaData ( ) ; int colCnt = meta . getColumnCount ( ) ; while ( rs . next ( ) ) { List < Object > row = new ArrayList < > ( colCnt ) ; for ( int i = _NUM ; i <= colCnt ; i ++ ) row . add ( rs . getObject ( i ) ) ; res . add ( row ) ; } } finally { U . closeQuiet ( rs ) ; } return res ; }
public void addAll ( Collection < Individual > newIndividuals ) { individuals . addAll ( newIndividuals ) ; }
public String generateExportChangePathParams ( Workflow workflow , String wfGroupId , String waitFor , URI storageURI , URI exportGroupURI , URI volumeURI ) throws ControllerException { DiscoveredSystemObject storageSystem = getStorageSystem ( _dbClient , storageURI ) ; BlockObject volume = BlockObject . fetch ( _dbClient , volumeURI ) ; Workflow . Method method = ExportWorkflowEntryPoints . exportGroupChangePathParamsMethod ( storageURI , exportGroupURI , volumeURI ) ; return newWorkflowStep ( workflow , wfGroupId , String . format ( STRING , storageSystem . getNativeGuid ( ) , storageURI , volume . getLabel ( ) , volumeURI ) , storageSystem , method , null , waitFor ) ; }
protected void updateIdleExpireTime ( long now ) { _threadIdleExpireTime . set ( now + _idleTimeout ) ; }
@ Nullable public V removeLast ( ) { return vals . isEmpty ( ) ? null : vals . removeLast ( ) ; }
public Curve makeCurve ( int color ) { Curve c = new Curve ( color ) ; curves . add ( c ) ; return c ; }
private Set < Entity > analyseRequiredUpdates ( AuditInformation audit , OperationGroup updateGroup ) { Set < Entity > updateRequired = new HashSet < > ( ) ; Set < Entity > updateNotRequired = new HashSet < > ( ) ; for ( Entity entity : updateGroup . getEntities ( ) ) { analyseEntityRequiresUpdate ( audit , entity , updateRequired , updateNotRequired ) ; } return updateRequired ; }
private Set < Entity > analyseRequiredUpdates ( AuditInformation audit , OperationGroup updateGroup ) { Set < Entity > updateRequired = new HashSet < > ( ) ; Set < Entity > updateNotRequired = new HashSet < > ( ) ; for ( Entity entity : updateGroup . getEntities ( ) ) { analyseEntityRequiresUpdate ( audit , entity , updateRequired , updateNotRequired ) ; } return updateRequired ; }
private Set < Entity > analyseRequiredUpdates ( AuditInformation audit , OperationGroup updateGroup ) { Set < Entity > updateRequired = new HashSet < > ( ) ; Set < Entity > updateNotRequired = new HashSet < > ( ) ; for ( Entity entity : updateGroup . getEntities ( ) ) { analyseEntityRequiresUpdate ( audit , entity , updateRequired , updateNotRequired ) ; } return updateRequired ; }
public TDoubleDoubleHashMap absoluteDistributionLog10 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin_idx = Math . ceil ( Math . log10 ( values . get ( i ) / descretization ) ) ; bin_idx = Math . max ( bin_idx , _NUM ) ; double binWidth = Math . pow ( _NUM , bin_idx ) - Math . pow ( _NUM , bin_idx - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin_idx ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
public TDoubleDoubleHashMap absoluteDistributionLog10 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin_idx = Math . ceil ( Math . log10 ( values . get ( i ) / descretization ) ) ; bin_idx = Math . max ( bin_idx , _NUM ) ; double binWidth = Math . pow ( _NUM , bin_idx ) - Math . pow ( _NUM , bin_idx - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin_idx ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
public TDoubleDoubleHashMap absoluteDistributionLog10 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin_idx = Math . ceil ( Math . log10 ( values . get ( i ) / descretization ) ) ; bin_idx = Math . max ( bin_idx , _NUM ) ; double binWidth = Math . pow ( _NUM , bin_idx ) - Math . pow ( _NUM , bin_idx - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin_idx ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
public TDoubleDoubleHashMap absoluteDistributionLog10 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin_idx = Math . ceil ( Math . log10 ( values . get ( i ) / descretization ) ) ; bin_idx = Math . max ( bin_idx , _NUM ) ; double binWidth = Math . pow ( _NUM , bin_idx ) - Math . pow ( _NUM , bin_idx - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin_idx ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
private String generateFittingText ( Method method , Rectangle2D rect , FontMetrics fontMetrics ) { if ( rect . getWidth ( ) < fontMetrics . stringWidth ( STRING ) ) { return STRING ; } String fullyQualified = method . getNameSpace ( ) + STRING + method . getName ( ) ; if ( fontMetrics . stringWidth ( fullyQualified ) < rect . getWidth ( ) ) { return fullyQualified ; } String abbrevPackage = getShortPackageName ( method . getNameSpace ( ) ) + STRING + method . getName ( ) ; if ( fontMetrics . stringWidth ( abbrevPackage ) < rect . getWidth ( ) ) { return abbrevPackage ; } if ( fontMetrics . stringWidth ( method . getName ( ) ) < rect . getWidth ( ) ) { return method . getName ( ) ; } return STRING ; }
private void startBackgroundTimer ( ) { if ( mBackgroundTimer != null ) { mBackgroundTimer . cancel ( ) ; } mBackgroundTimer = new Timer ( ) ; mBackgroundTimer . schedule ( new UpdateBackgroundTask ( ) , BACKGROUND_UPDATE_DELAY ) ; }
public static byte [ ] subArray ( byte [ ] input , int start , int end ) { byte [ ] result = new byte [ end - start ] ; System . arraycopy ( input , start , result , _NUM , end - start ) ; return result ; }
public synchronized void deleteLeastUsedConnection ( ) { final HttpConnection connection = ( HttpConnection ) freeConnections . removeFirst ( ) ; if ( connection != null ) { deleteConnection ( connection ) ; } else if ( LOG . isDebugEnabled ( ) ) { LOG . debug ( STRING ) ; } }
protected void addActionExceptionWarning ( Exception e ) { String msg = e . getMessage ( ) ; if ( msg != null ) { warnings . add ( msg ) ; } }
@ ApiOperation ( value = STRING ) @ RequestMapping ( value = STRING , method = RequestMethod . POST ) @ ResponseStatus ( HttpStatus . NO_CONTENT ) @ ResponseBody public final void postRequestInitialLoad ( @ PathVariable ( STRING ) String engineName , @ RequestParam ( value = STRING ) String nodeId ) { ISymmetricEngine engine = getSymmetricEngine ( engineName ) ; INodeService nodeService = engine . getNodeService ( ) ; nodeService . setInitialLoadEnabled ( nodeId , _BOOL , _BOOL , - _NUM , STRING ) ; }
@ ApiOperation ( value = STRING ) @ RequestMapping ( value = STRING , method = RequestMethod . POST ) @ ResponseStatus ( HttpStatus . NO_CONTENT ) @ ResponseBody public final void postRequestInitialLoad ( @ PathVariable ( STRING ) String engineName , @ RequestParam ( value = STRING ) String nodeId ) { ISymmetricEngine engine = getSymmetricEngine ( engineName ) ; INodeService nodeService = engine . getNodeService ( ) ; nodeService . setInitialLoadEnabled ( nodeId , _BOOL , _BOOL , - _NUM , STRING ) ; }
@ ApiOperation ( value = STRING ) @ RequestMapping ( value = STRING , method = RequestMethod . POST ) @ ResponseStatus ( HttpStatus . NO_CONTENT ) @ ResponseBody public final void postRequestInitialLoad ( @ PathVariable ( STRING ) String engineName , @ RequestParam ( value = STRING ) String nodeId ) { ISymmetricEngine engine = getSymmetricEngine ( engineName ) ; INodeService nodeService = engine . getNodeService ( ) ; nodeService . setInitialLoadEnabled ( nodeId , _BOOL , _BOOL , - _NUM , STRING ) ; }
@ ApiOperation ( value = STRING ) @ RequestMapping ( value = STRING , method = RequestMethod . POST ) @ ResponseStatus ( HttpStatus . NO_CONTENT ) @ ResponseBody public final void postRequestInitialLoad ( @ PathVariable ( STRING ) String engineName , @ RequestParam ( value = STRING ) String nodeId ) { ISymmetricEngine engine = getSymmetricEngine ( engineName ) ; INodeService nodeService = engine . getNodeService ( ) ; nodeService . setInitialLoadEnabled ( nodeId , _BOOL , _BOOL , - _NUM , STRING ) ; }
public DisjunctionMaxWeight ( IndexSearcher searcher , boolean needsScores , float boost ) throws IOException { super ( DisjunctionMaxQuery . this ) ; for ( Query disjunctQuery : disjuncts ) { weights . add ( searcher . createWeight ( disjunctQuery , needsScores , boost ) ) ; } this . needsScores = needsScores ; }
public void unregisterMBean ( ObjectName objectName ) { try { if ( ! isRegistered ( objectName ) ) { return ; } mbeanServer . unregisterMBean ( objectName ) ; if ( localGemFireMBean . get ( objectName ) != null ) { localGemFireMBean . remove ( objectName ) ; } } catch ( NullPointerException e ) { throw new ManagementException ( e ) ; } catch ( InstanceNotFoundException e ) { throw new ManagementException ( e ) ; } catch ( MBeanRegistrationException e ) { throw new ManagementException ( e ) ; } }
public void write ( DataOutput dos ) throws IOException { int length = ( points . length / _NUM ) * _NUM ; dos . writeInt ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) { dos . writeFloat ( points [ i ] ) ; } }
public void write ( DataOutput dos ) throws IOException { int length = ( points . length / _NUM ) * _NUM ; dos . writeInt ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) { dos . writeFloat ( points [ i ] ) ; } }
public static Connection ensureTableExists ( final Table table ) throws SQLException { establishConnection ( ) ; try ( final Statement stmt = connection . createStatement ( ) ) { stmt . execute ( table . getCreationStatement ( ) ) ; return connection ; } }
public static Connection ensureTableExists ( final Table table ) throws SQLException { establishConnection ( ) ; try ( final Statement stmt = connection . createStatement ( ) ) { stmt . execute ( table . getCreationStatement ( ) ) ; return connection ; } }
public static Connection ensureTableExists ( final Table table ) throws SQLException { establishConnection ( ) ; try ( final Statement stmt = connection . createStatement ( ) ) { stmt . execute ( table . getCreationStatement ( ) ) ; return connection ; } }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . writeObject ( toString ( ) ) ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . writeObject ( toString ( ) ) ; }
private void writeObject ( java . io . ObjectOutputStream s ) throws java . io . IOException { s . writeObject ( toString ( ) ) ; }
public void forgetFfmpegPath ( ) { settings . put ( SETTINGS_FFMPEG_PATH , FFMPEG_PATH_UNSET ) ; }
public Builder withThreads ( int threads ) { properties . setProperty ( NettyOptions . THREADS , String . valueOf ( Assert . argNot ( threads , threads <= _NUM , STRING ) ) ) ; return this ; }
private void closeJar ( String path ) { if ( jarfiles . containsKey ( path ) ) { JarHolder theJar = ( JarHolder ) jarfiles . get ( path ) ; theJar . close ( ) ; } }
public static long copy ( InputStream input , OutputStream output , byte [ ] buffer ) throws IOException { long count = _NUM ; int n = _NUM ; while ( - _NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , _NUM , n ) ; count += n ; } return count ; }
public static long copy ( InputStream input , OutputStream output , byte [ ] buffer ) throws IOException { long count = _NUM ; int n = _NUM ; while ( - _NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , _NUM , n ) ; count += n ; } return count ; }
public static long copy ( InputStream input , OutputStream output , byte [ ] buffer ) throws IOException { long count = _NUM ; int n = _NUM ; while ( - _NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , _NUM , n ) ; count += n ; } return count ; }
public static long copy ( InputStream input , OutputStream output , byte [ ] buffer ) throws IOException { long count = _NUM ; int n = _NUM ; while ( - _NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , _NUM , n ) ; count += n ; } return count ; }
public static long copy ( InputStream input , OutputStream output , byte [ ] buffer ) throws IOException { long count = _NUM ; int n = _NUM ; while ( - _NUM != ( n = input . read ( buffer ) ) ) { output . write ( buffer , _NUM , n ) ; count += n ; } return count ; }
private void configureOutputStream ( ) { String filename = generateFilename ( ) ; File file = null ; try { file = acquireUniqueFile ( filename ) ; if ( isDebuggable ( Level . CONFIG ) ) { LogHelper . println ( STRING , Level . CONFIG , STRING + file . getAbsolutePath ( ) ) ; } FileOutputStream fout = new FileOutputStream ( file , append ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout ) ; MeteredStream meteredStream = new MeteredStream ( bout , ( int ) file . length ( ) ) ; setOutputStream ( meteredStream ) ; sizeRollingPolicy . setMeteredStream ( meteredStream ) ; timeRollingPolicy . setTimestamp ( ) ; backupPolicy . track ( file ) ; if ( monitorCreatedFiles ) { filesCreated . add ( _NUM , file ) ; } } catch ( IOException ioe ) { String filepath = file != null ? file . getAbsolutePath ( ) : filename ; reportError ( STRING + filepath , ioe , ErrorManager . OPEN_FAILURE ) ; corruptedOutputStream = _BOOL ; } }
private void configureOutputStream ( ) { String filename = generateFilename ( ) ; File file = null ; try { file = acquireUniqueFile ( filename ) ; if ( isDebuggable ( Level . CONFIG ) ) { LogHelper . println ( STRING , Level . CONFIG , STRING + file . getAbsolutePath ( ) ) ; } FileOutputStream fout = new FileOutputStream ( file , append ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout ) ; MeteredStream meteredStream = new MeteredStream ( bout , ( int ) file . length ( ) ) ; setOutputStream ( meteredStream ) ; sizeRollingPolicy . setMeteredStream ( meteredStream ) ; timeRollingPolicy . setTimestamp ( ) ; backupPolicy . track ( file ) ; if ( monitorCreatedFiles ) { filesCreated . add ( _NUM , file ) ; } } catch ( IOException ioe ) { String filepath = file != null ? file . getAbsolutePath ( ) : filename ; reportError ( STRING + filepath , ioe , ErrorManager . OPEN_FAILURE ) ; corruptedOutputStream = _BOOL ; } }
private void configureOutputStream ( ) { String filename = generateFilename ( ) ; File file = null ; try { file = acquireUniqueFile ( filename ) ; if ( isDebuggable ( Level . CONFIG ) ) { LogHelper . println ( STRING , Level . CONFIG , STRING + file . getAbsolutePath ( ) ) ; } FileOutputStream fout = new FileOutputStream ( file , append ) ; BufferedOutputStream bout = new BufferedOutputStream ( fout ) ; MeteredStream meteredStream = new MeteredStream ( bout , ( int ) file . length ( ) ) ; setOutputStream ( meteredStream ) ; sizeRollingPolicy . setMeteredStream ( meteredStream ) ; timeRollingPolicy . setTimestamp ( ) ; backupPolicy . track ( file ) ; if ( monitorCreatedFiles ) { filesCreated . add ( _NUM , file ) ; } } catch ( IOException ioe ) { String filepath = file != null ? file . getAbsolutePath ( ) : filename ; reportError ( STRING + filepath , ioe , ErrorManager . OPEN_FAILURE ) ; corruptedOutputStream = _BOOL ; } }
private static Path2D createLeftTabShape ( int x , int y , int w , int h , double rLeft , boolean addSide ) { Path2D path = new Path2D . Double ( ) ; path . append ( new Line2D . Double ( x + w , y + h , x + rLeft , y + h ) , _BOOL ) ; QuadCurve2D curve = new QuadCurve2D . Double ( x + rLeft , y + h , x , y + h , x , y + h - rLeft ) ; path . append ( curve , _BOOL ) ; path . append ( new Line2D . Double ( x , y + h - rLeft , x , y + rLeft ) , _BOOL ) ; curve = new QuadCurve2D . Double ( x , y + rLeft , x , y , x + rLeft , y ) ; path . append ( curve , _BOOL ) ; path . append ( new Line2D . Double ( x + rLeft , y , x + w , y ) , _BOOL ) ; if ( addSide ) { path . append ( new Line2D . Double ( x + w , y , x + w , y + h - _NUM ) , _BOOL ) ; } return path ; }
public ArrayList < WalletTableData > createWalletTableData ( final BitcoinController bitcoinController , String walletFilename ) { ArrayList < WalletTableData > walletData = new ArrayList < WalletTableData > ( ) ; if ( walletFilename == null ) { return walletData ; } WalletData perWalletModelData = null ; if ( perWalletModelDataList != null ) { for ( WalletData loopPerWalletModelData : perWalletModelDataList ) { if ( walletFilename . equals ( loopPerWalletModelData . getWalletFilename ( ) ) ) { perWalletModelData = loopPerWalletModelData ; break ; } } } return createWalletTableData ( bitcoinController , perWalletModelData ) ; }
public ArrayList < WalletTableData > createWalletTableData ( final BitcoinController bitcoinController , String walletFilename ) { ArrayList < WalletTableData > walletData = new ArrayList < WalletTableData > ( ) ; if ( walletFilename == null ) { return walletData ; } WalletData perWalletModelData = null ; if ( perWalletModelDataList != null ) { for ( WalletData loopPerWalletModelData : perWalletModelDataList ) { if ( walletFilename . equals ( loopPerWalletModelData . getWalletFilename ( ) ) ) { perWalletModelData = loopPerWalletModelData ; break ; } } } return createWalletTableData ( bitcoinController , perWalletModelData ) ; }
public ArrayList < WalletTableData > createWalletTableData ( final BitcoinController bitcoinController , String walletFilename ) { ArrayList < WalletTableData > walletData = new ArrayList < WalletTableData > ( ) ; if ( walletFilename == null ) { return walletData ; } WalletData perWalletModelData = null ; if ( perWalletModelDataList != null ) { for ( WalletData loopPerWalletModelData : perWalletModelDataList ) { if ( walletFilename . equals ( loopPerWalletModelData . getWalletFilename ( ) ) ) { perWalletModelData = loopPerWalletModelData ; break ; } } } return createWalletTableData ( bitcoinController , perWalletModelData ) ; }
@ Deprecated public static < T > T executeWithBackOff ( AbstractGoogleClientRequest < T > client , String error , Object ... errorArgs ) throws IOException , InterruptedException { return executeWithBackOff ( client , String . format ( error , errorArgs ) ) ; }
public void deleteEntities ( String name , String protocol , String realm ) throws AMConsoleException { if ( protocol . equals ( IDFF ) ) { deleteIDFFEntity ( name , realm ) ; } else if ( protocol . equals ( WSFED ) ) { deleteWSFedEntity ( name , realm ) ; } else { deleteSAMLv2Entity ( name , realm ) ; } }
public StrBuilder insert ( int index , Object obj ) { if ( obj == null ) { return insert ( index , nullText ) ; } return insert ( index , obj . toString ( ) ) ; }
public SIPServerTransaction createServerTransaction ( MessageChannel encapsulatedMessageChannel ) { if ( unlimitedServerTransactionTableSize ) { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } else { float threshold = ( ( float ) ( serverTransactionTable . size ( ) - serverTransactionTableLowaterMark ) ) / ( ( float ) ( serverTransactionTableHighwaterMark - serverTransactionTableLowaterMark ) ) ; boolean decision = Math . random ( ) > _NUM - threshold ; if ( decision ) { return null ; } else { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } } }
public SIPServerTransaction createServerTransaction ( MessageChannel encapsulatedMessageChannel ) { if ( unlimitedServerTransactionTableSize ) { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } else { float threshold = ( ( float ) ( serverTransactionTable . size ( ) - serverTransactionTableLowaterMark ) ) / ( ( float ) ( serverTransactionTableHighwaterMark - serverTransactionTableLowaterMark ) ) ; boolean decision = Math . random ( ) > _NUM - threshold ; if ( decision ) { return null ; } else { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } } }
public SIPServerTransaction createServerTransaction ( MessageChannel encapsulatedMessageChannel ) { if ( unlimitedServerTransactionTableSize ) { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } else { float threshold = ( ( float ) ( serverTransactionTable . size ( ) - serverTransactionTableLowaterMark ) ) / ( ( float ) ( serverTransactionTableHighwaterMark - serverTransactionTableLowaterMark ) ) ; boolean decision = Math . random ( ) > _NUM - threshold ; if ( decision ) { return null ; } else { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } } }
public SIPServerTransaction createServerTransaction ( MessageChannel encapsulatedMessageChannel ) { if ( unlimitedServerTransactionTableSize ) { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } else { float threshold = ( ( float ) ( serverTransactionTable . size ( ) - serverTransactionTableLowaterMark ) ) / ( ( float ) ( serverTransactionTableHighwaterMark - serverTransactionTableLowaterMark ) ) ; boolean decision = Math . random ( ) > _NUM - threshold ; if ( decision ) { return null ; } else { return new SIPServerTransaction ( this , encapsulatedMessageChannel ) ; } } }
public void addLatLine ( double lat , double minLon , double maxLon ) { String name = STRING + nextShape ; nextShape ++ ; b . append ( STRING + name + STRING ) ; double lon ; int steps = getStepCount ( lat , minLon , lat , maxLon ) ; for ( lon = minLon ; lon <= maxLon ; lon += ( maxLon - minLon ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING + lat + STRING + maxLon + STRING ) ; lon -= ( maxLon - minLon ) / steps ; for ( ; lon >= minLon ; lon -= ( maxLon - minLon ) / steps ) { b . append ( STRING + lat + STRING + lon + STRING ) ; } b . append ( STRING ) ; b . append ( STRING + name + STRING ) ; }
public void add ( T object ) { if ( mEventDelegate != null ) mEventDelegate . addData ( object == null ? _NUM : _NUM ) ; if ( object != null ) { synchronized ( mLock ) { mObjects . add ( object ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public void add ( T object ) { if ( mEventDelegate != null ) mEventDelegate . addData ( object == null ? _NUM : _NUM ) ; if ( object != null ) { synchronized ( mLock ) { mObjects . add ( object ) ; } } if ( mNotifyOnChange ) notifyDataSetChanged ( ) ; }
public double [ ] [ ] extractMainSetJacobian ( final ODEState state ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] [ ] dYdY0 = new double [ jode . getDimension ( ) ] [ jode . getDimension ( ) ] ; int j = _NUM ; for ( int i = _NUM ; i < jode . getDimension ( ) ; i ++ ) { System . arraycopy ( p , j , dYdY0 [ i ] , _NUM , jode . getDimension ( ) ) ; j += jode . getDimension ( ) ; } return dYdY0 ; }
public double [ ] [ ] extractMainSetJacobian ( final ODEState state ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] [ ] dYdY0 = new double [ jode . getDimension ( ) ] [ jode . getDimension ( ) ] ; int j = _NUM ; for ( int i = _NUM ; i < jode . getDimension ( ) ; i ++ ) { System . arraycopy ( p , j , dYdY0 [ i ] , _NUM , jode . getDimension ( ) ) ; j += jode . getDimension ( ) ; } return dYdY0 ; }
public void loadFromFile ( String sFileName ) throws FileNotFoundException , IOException { FileReader frFile = new FileReader ( sFileName ) ; String sText = STRING ; int c = frFile . read ( ) ; while ( c != - _NUM ) { sText += c ; c = frFile . read ( ) ; } addText ( sText ) ; frFile . close ( ) ; }
public void loadFromFile ( String sFileName ) throws FileNotFoundException , IOException { FileReader frFile = new FileReader ( sFileName ) ; String sText = STRING ; int c = frFile . read ( ) ; while ( c != - _NUM ) { sText += c ; c = frFile . read ( ) ; } addText ( sText ) ; frFile . close ( ) ; }
public LDIFChangeRecordWriter ( final List < String > ldifLines ) { super ( ldifLines ) ; }
public LDIFChangeRecordWriter ( final List < String > ldifLines ) { super ( ldifLines ) ; }
private static ReserveResponse checkReserveResponse ( ReserveResponse reserveResponse ) throws RpcException { logger . info ( STRING , reserveResponse ) ; switch ( reserveResponse . getResult ( ) ) { case OK : break ; case STALE_GENERATION : logger . warn ( STRING , reserveResponse . getError ( ) ) ; throw new StaleGenerationException ( reserveResponse . getError ( ) ) ; case SYSTEM_ERROR : logger . warn ( STRING , reserveResponse . getError ( ) ) ; throw new SystemErrorException ( reserveResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STRING , reserveResponse . getResult ( ) ) ) ; } return reserveResponse ; }
public static boolean openUrlPrompt ( Component parent , String url , boolean forcePrompt ) { if ( url == null ) { return _BOOL ; } List < String > list = new ArrayList < > ( ) ; list . add ( url ) ; return openUrlsPrompt ( parent , list , forcePrompt ) ; }
public static boolean openUrlPrompt ( Component parent , String url , boolean forcePrompt ) { if ( url == null ) { return _BOOL ; } List < String > list = new ArrayList < > ( ) ; list . add ( url ) ; return openUrlsPrompt ( parent , list , forcePrompt ) ; }
public void logFine ( String message ) { logger . fine ( logPrefix + message ) ; }
public void logFine ( String message ) { logger . fine ( logPrefix + message ) ; }
public void logFine ( String message ) { logger . fine ( logPrefix + message ) ; }
private static char [ ] subscriptForDigit ( int digit ) { return Character . toChars ( _NUM + digit ) ; }
public static String deleteFromCart ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; LocalDispatcher dispatcher = ( LocalDispatcher ) request . getAttribute ( STRING ) ; ShoppingCartHelper cartHelper = new ShoppingCartHelper ( null , dispatcher , cart ) ; String controlDirective ; Map < String , Object > result ; Map < String , Object > paramMap = UtilHttp . getParameterMap ( request ) ; result = cartHelper . deleteFromCart ( paramMap ) ; controlDirective = processResult ( result , request ) ; if ( controlDirective . equals ( ERROR ) ) { return STRING ; } else { return STRING ; } }
public HeaderSection ( DexFile file ) { super ( null , file , _NUM ) ; HeaderItem item = new HeaderItem ( ) ; item . setIndex ( _NUM ) ; this . list = Collections . singletonList ( item ) ; }
public synchronized void rotateAbs ( final Point2D p , double theta ) { double zx = p . getX ( ) , zy = p . getY ( ) ; damageReport ( ) ; m_transform . translate ( zx , zy ) ; m_transform . rotate ( theta ) ; m_transform . translate ( - zx , - zy ) ; try { m_itransform = m_transform . createInverse ( ) ; } catch ( Exception e ) { } }
public synchronized void rotateAbs ( final Point2D p , double theta ) { double zx = p . getX ( ) , zy = p . getY ( ) ; damageReport ( ) ; m_transform . translate ( zx , zy ) ; m_transform . rotate ( theta ) ; m_transform . translate ( - zx , - zy ) ; try { m_itransform = m_transform . createInverse ( ) ; } catch ( Exception e ) { } }
public synchronized void rotateAbs ( final Point2D p , double theta ) { double zx = p . getX ( ) , zy = p . getY ( ) ; damageReport ( ) ; m_transform . translate ( zx , zy ) ; m_transform . rotate ( theta ) ; m_transform . translate ( - zx , - zy ) ; try { m_itransform = m_transform . createInverse ( ) ; } catch ( Exception e ) { } }
public BufferedHeader ( final CharArrayBuffer buffer ) throws ParseException { super ( ) ; if ( buffer == null ) { throw new IllegalArgumentException ( STRING ) ; } int colon = buffer . indexOf ( STRING ) ; if ( colon == - _NUM ) { throw new ParseException ( STRING + buffer . toString ( ) ) ; } String s = buffer . substringTrimmed ( _NUM , colon ) ; if ( s . length ( ) == _NUM ) { throw new ParseException ( STRING + buffer . toString ( ) ) ; } this . buffer = buffer ; this . name = s ; this . valuePos = colon + _NUM ; }
public BufferedHeader ( final CharArrayBuffer buffer ) throws ParseException { super ( ) ; if ( buffer == null ) { throw new IllegalArgumentException ( STRING ) ; } int colon = buffer . indexOf ( STRING ) ; if ( colon == - _NUM ) { throw new ParseException ( STRING + buffer . toString ( ) ) ; } String s = buffer . substringTrimmed ( _NUM , colon ) ; if ( s . length ( ) == _NUM ) { throw new ParseException ( STRING + buffer . toString ( ) ) ; } this . buffer = buffer ; this . name = s ; this . valuePos = colon + _NUM ; }
public static boolean isDirectlyGettingPowered ( World world , Coord4D coord ) { for ( ForgeDirection side : ForgeDirection . VALID_DIRECTIONS ) { Coord4D sideCoord = coord . getFromSide ( side ) ; if ( sideCoord . exists ( world ) ) { if ( world . isBlockProvidingPowerTo ( coord . xCoord , coord . yCoord , coord . zCoord , side . ordinal ( ) ) > _NUM ) { return _BOOL ; } } } return _BOOL ; }
public static boolean isDirectlyGettingPowered ( World world , Coord4D coord ) { for ( ForgeDirection side : ForgeDirection . VALID_DIRECTIONS ) { Coord4D sideCoord = coord . getFromSide ( side ) ; if ( sideCoord . exists ( world ) ) { if ( world . isBlockProvidingPowerTo ( coord . xCoord , coord . yCoord , coord . zCoord , side . ordinal ( ) ) > _NUM ) { return _BOOL ; } } } return _BOOL ; }
public static boolean isDirectlyGettingPowered ( World world , Coord4D coord ) { for ( ForgeDirection side : ForgeDirection . VALID_DIRECTIONS ) { Coord4D sideCoord = coord . getFromSide ( side ) ; if ( sideCoord . exists ( world ) ) { if ( world . isBlockProvidingPowerTo ( coord . xCoord , coord . yCoord , coord . zCoord , side . ordinal ( ) ) > _NUM ) { return _BOOL ; } } } return _BOOL ; }
public DistributedLogMultiStreamWriter build ( ) { Preconditions . checkArgument ( ( null != _streams && ! _streams . isEmpty ( ) ) , STRING ) ; Preconditions . checkNotNull ( _client , STRING ) ; Preconditions . checkNotNull ( _codec , STRING ) ; Preconditions . checkArgument ( _firstSpeculativeTimeoutMs > _NUM && _firstSpeculativeTimeoutMs <= _maxSpeculativeTimeoutMs && _speculativeBackoffMultiplier > _NUM && _maxSpeculativeTimeoutMs < _requestTimeoutMs , STRING ) ; return new DistributedLogMultiStreamWriter ( _streams , _client , Math . min ( _bufferSize , MAX_LOGRECORDSET_SIZE ) , _flushIntervalMicros , _requestTimeoutMs , _firstSpeculativeTimeoutMs , _maxSpeculativeTimeoutMs , _speculativeBackoffMultiplier , _codec , _ticker , _executorService ) ; }
public void dequeue ( AnthURL url ) { readyUrls . remove ( url ) ; if ( valueFunction . getNecessities ( HostValueUpdateNecessity . ON_QUEUE_CHANGE ) ) { scoreUpdateNeeded = _BOOL ; } }
private String antProjectToArtifactName ( String origModule ) { String module = origModule ; if ( ! origModule . startsWith ( STRING ) ) { module = STRING + module ; } return module ; }
private String antProjectToArtifactName ( String origModule ) { String module = origModule ; if ( ! origModule . startsWith ( STRING ) ) { module = STRING + module ; } return module ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void columnRemoved ( TableColumnModelEvent e ) { LimeTableColumn ltc ; TableColumnModel tcm = table . getColumnModel ( ) ; for ( int i = _NUM ; i < tcm . getColumnCount ( ) ; i ++ ) { ltc = ( LimeTableColumn ) tcm . getColumn ( i ) ; setOrder ( ltc , i ) ; } LimeTableColumn removedColumn = table . getLastRemovedColumn ( ) ; ltc = removedColumn ; setVisibility ( ltc , _BOOL ) ; int order = getOrder ( ltc ) ; for ( Iterator < LimeTableColumn > i = table . getHiddenColumns ( ) ; i . hasNext ( ) ; ) { ltc = i . next ( ) ; int current = getOrder ( ltc ) ; if ( current > order ) setOrder ( ltc , current - _NUM ) ; } if ( listener != null ) listener . columnRemoved ( removedColumn , table ) ; save ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
public void addNotify ( ) { super . addNotify ( ) ; if ( textArea != null ) { l . install ( textArea ) ; } updateCellWidths ( ) ; updateCellHeights ( ) ; }
JCERSAPrivateCrtKey ( RSAPrivateCrtKeySpec spec ) { this . modulus = spec . getModulus ( ) ; this . publicExponent = spec . getPublicExponent ( ) ; this . privateExponent = spec . getPrivateExponent ( ) ; this . primeP = spec . getPrimeP ( ) ; this . primeQ = spec . getPrimeQ ( ) ; this . primeExponentP = spec . getPrimeExponentP ( ) ; this . primeExponentQ = spec . getPrimeExponentQ ( ) ; this . crtCoefficient = spec . getCrtCoefficient ( ) ; }
abstract void toXML ( StringBuilder xml , int level ) ;
public void actionPerformed ( ActionEvent e ) { ControlPanelPropertyEditor editor = new ControlPanelPropertyEditor ( this ) ; editor . setVisible ( _BOOL ) ; }
static String toC ( String identifier ) { return identifier . replace ( STRING , STRING ) ; }
public long sigignore ( ) { return Long . parseLong ( fields [ _NUM ] ) ; }
public long sigignore ( ) { return Long . parseLong ( fields [ _NUM ] ) ; }
public long sigignore ( ) { return Long . parseLong ( fields [ _NUM ] ) ; }
public long sigignore ( ) { return Long . parseLong ( fields [ _NUM ] ) ; }
public PacProxySelector ( String pacUrl ) { if ( pacUrl == null ) { throw new NullPointerException ( ) ; } this . pacUrl = pacUrl ; }
@ Override public MemBufferHolder < SysMemAllocator > createBuffer ( long size , boolean autoreclaim ) { MemBufferHolder < SysMemAllocator > ret = null ; ByteBuffer bb = null ; if ( currentMemory . get ( ) + size > maxStoreCapacity ) { if ( m_activegc ) { forceGC ( ) ; } } if ( currentMemory . get ( ) + size <= maxStoreCapacity ) { bb = ByteBuffer . allocateDirect ( ( int ) size ) ; } if ( null != bb ) { ret = new MemBufferHolder < SysMemAllocator > ( this , bb ) ; ret . setCollector ( m_bufcollector ) ; if ( autoreclaim ) { m_bufcollector . register ( ret ) ; } currentMemory . getAndAdd ( size ) ; } return ret ; }
public void inherit ( ) { addClassPath ( System . getProperty ( STRING ) ) ; }
public void inherit ( ) { addClassPath ( System . getProperty ( STRING ) ) ; }
public Composer alpha ( long animDuration , float alpha , Ease ease ) { AnimParameter beforeParam = mTweenParameterList . size ( ) > _NUM ? mTweenParameterList . get ( mTweenParameterList . size ( ) - _NUM ) : mInitialParam ; mTweenParameterList . add ( new TweenParameter ( beforeParam . x , beforeParam . y , Util . convertAlphaFloatToInt ( alpha ) , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , animDuration , ease ) ) ; return this ; }
public Composer alpha ( long animDuration , float alpha , Ease ease ) { AnimParameter beforeParam = mTweenParameterList . size ( ) > _NUM ? mTweenParameterList . get ( mTweenParameterList . size ( ) - _NUM ) : mInitialParam ; mTweenParameterList . add ( new TweenParameter ( beforeParam . x , beforeParam . y , Util . convertAlphaFloatToInt ( alpha ) , beforeParam . scaleX , beforeParam . scaleY , beforeParam . rotation , animDuration , ease ) ) ; return this ; }
public void writeStringNoCompression ( String str ) throws IOException { if ( str == null ) { writeInt ( _NUM ) ; } else { writeInt ( str . length ( ) ) ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . charAt ( i ) ) ; position += str . length ( ) ; } }
public void writeStringNoCompression ( String str ) throws IOException { if ( str == null ) { writeInt ( _NUM ) ; } else { writeInt ( str . length ( ) ) ; for ( int i = _NUM ; i < str . length ( ) ; i ++ ) outs . write ( ( byte ) str . charAt ( i ) ) ; position += str . length ( ) ; } }
public < R > FutureW < R > flatMapCf ( final Function < ? super T , ? extends CompletionStage < ? extends R > > mapper ) { return FutureW . < R > of ( future . < R > thenCompose ( null ) ) ; }
public < R > FutureW < R > flatMapCf ( final Function < ? super T , ? extends CompletionStage < ? extends R > > mapper ) { return FutureW . < R > of ( future . < R > thenCompose ( null ) ) ; }
public static String capitalizeFirstOnly ( String s ) { if ( s == null ) return null ; if ( s . length ( ) == _NUM ) return s ; StringBuffer sbuf = new StringBuffer ( ) ; char c = s . charAt ( _NUM ) ; sbuf . append ( Character . toUpperCase ( c ) ) ; boolean space = Character . isWhitespace ( c ) ; for ( int i = _NUM ; i < s . length ( ) ; ++ i ) { c = s . charAt ( i ) ; if ( Character . isWhitespace ( c ) ) { space = _BOOL ; } else if ( space ) { c = Character . toUpperCase ( c ) ; space = _BOOL ; } else { c = Character . toLowerCase ( c ) ; } sbuf . append ( c ) ; } return sbuf . toString ( ) ; }
public static Resource decodeContext ( String encodedValue , ValueFactory valueFactory ) { if ( encodedValue == null ) { return null ; } else if ( NULL_PARAM_VALUE . equals ( encodedValue ) ) { return null ; } else { return decodeResource ( encodedValue , valueFactory ) ; } }
@ SuppressWarnings ( STRING ) public final void selectAll ( ) { for ( int i = _NUM ; i < realmResults . size ( ) ; i ++ ) selectedPositions . add ( i ) ; notifyDataSetChanged ( ) ; }
private Map < String , String > buildShortNameToFullNameMap ( Set < String > classSet ) { Map < String , String > result = new HashMap < String , String > ( ) ; for ( String className : classSet ) { String shortClassName = getShortClassName ( className ) ; result . put ( shortClassName , className ) ; } return result ; }
public List toList ( ) { Object [ ] copiedElements = new Object [ numElements ] ; System . arraycopy ( elements , _NUM , copiedElements , _NUM , numElements ) ; return Arrays . asList ( copiedElements ) ; }
public List toList ( ) { Object [ ] copiedElements = new Object [ numElements ] ; System . arraycopy ( elements , _NUM , copiedElements , _NUM , numElements ) ; return Arrays . asList ( copiedElements ) ; }
public static long calculateChunkedContentLength ( long originalLength , long chunkSize ) { if ( originalLength <= _NUM ) { throw new IllegalArgumentException ( STRING ) ; } long maxSizeChunks = originalLength / chunkSize ; long remainingBytes = originalLength % chunkSize ; return maxSizeChunks * calculateChunkHeaderLength ( chunkSize ) + ( remainingBytes > _NUM ? calculateChunkHeaderLength ( remainingBytes ) : _NUM ) + calculateChunkHeaderLength ( _NUM ) ; }
public static long calculateChunkedContentLength ( long originalLength , long chunkSize ) { if ( originalLength <= _NUM ) { throw new IllegalArgumentException ( STRING ) ; } long maxSizeChunks = originalLength / chunkSize ; long remainingBytes = originalLength % chunkSize ; return maxSizeChunks * calculateChunkHeaderLength ( chunkSize ) + ( remainingBytes > _NUM ? calculateChunkHeaderLength ( remainingBytes ) : _NUM ) + calculateChunkHeaderLength ( _NUM ) ; }
private static URI url ( String path ) { return URI . create ( STRING + path ) ; }
private static URI url ( String path ) { return URI . create ( STRING + path ) ; }
public static void copy ( File fromFile , File toFile , int bufSize ) throws IOException { FileInputStream fis = new FileInputStream ( fromFile ) ; FileOutputStream fos = new FileOutputStream ( toFile ) ; if ( bufSize <= _NUM ) { bufSize = _NUM ; } byte [ ] bytes = new byte [ bufSize ] ; int numRead ; while ( ( numRead = fis . read ( bytes ) ) > _NUM ) { fos . write ( bytes , _NUM , numRead ) ; } fis . close ( ) ; fos . close ( ) ; }
void verifyExceptionCaptured ( Class < ? extends Throwable > expectedExceptionClass ) { assertTrue ( STRING , exceptionEventCapture . hasCaptured ( ) ) ; Throwable caughtEx = exceptionEventCapture . getValue ( ) ; assertEquals ( expectedExceptionClass , caughtEx . getClass ( ) ) ; exceptionEventCapture . reset ( ) ; }
void verifyExceptionCaptured ( Class < ? extends Throwable > expectedExceptionClass ) { assertTrue ( STRING , exceptionEventCapture . hasCaptured ( ) ) ; Throwable caughtEx = exceptionEventCapture . getValue ( ) ; assertEquals ( expectedExceptionClass , caughtEx . getClass ( ) ) ; exceptionEventCapture . reset ( ) ; }
void verifyExceptionCaptured ( Class < ? extends Throwable > expectedExceptionClass ) { assertTrue ( STRING , exceptionEventCapture . hasCaptured ( ) ) ; Throwable caughtEx = exceptionEventCapture . getValue ( ) ; assertEquals ( expectedExceptionClass , caughtEx . getClass ( ) ) ; exceptionEventCapture . reset ( ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addAll ( Collections . list ( super . listOptions ( ) ) ) ; return newVector . elements ( ) ; }
public void notifyTargetActivityChanged ( TargetActivity targetActivity ) { int in = targetActivities . indexOf ( targetActivity ) ; if ( in != - _NUM ) { notifyItemChanged ( in + _NUM ) ; } }
private boolean needIndexConsistency ( ) { return _index != null && _index . needConsistency ( ) ; }
public static void deleteExisitingRows ( String table , String filter , Connection connection ) { table = table . replace ( STRING , STRING ) ; filter = filter . replace ( STRING , STRING ) ; StringBuilder deleteRowsQuery = new StringBuilder ( ) ; deleteRowsQuery . append ( STRING ) ; deleteRowsQuery . append ( table ) ; deleteRowsQuery . append ( STRING ) ; deleteRowsQuery . append ( filter ) ; deleteRowsQuery . append ( STRING ) ; LOG . info ( STRING ) ; LOG . info ( deleteRowsQuery ) ; executeStatementIfExists ( deleteRowsQuery . toString ( ) , connection ) ; }
void rollback ( List < Type > saved_undet ) { Assert . check ( saved_undet != null && saved_undet . length ( ) == undetvars . length ( ) ) ; for ( Type t : undetvars ) { UndetVar uv = ( UndetVar ) t ; UndetVar uv_saved = ( UndetVar ) saved_undet . head ; for ( InferenceBound ib : InferenceBound . values ( ) ) { uv . setBounds ( ib , uv_saved . getBounds ( ib ) ) ; } uv . inst = uv_saved . inst ; saved_undet = saved_undet . tail ; } }
void rollback ( List < Type > saved_undet ) { Assert . check ( saved_undet != null && saved_undet . length ( ) == undetvars . length ( ) ) ; for ( Type t : undetvars ) { UndetVar uv = ( UndetVar ) t ; UndetVar uv_saved = ( UndetVar ) saved_undet . head ; for ( InferenceBound ib : InferenceBound . values ( ) ) { uv . setBounds ( ib , uv_saved . getBounds ( ib ) ) ; } uv . inst = uv_saved . inst ; saved_undet = saved_undet . tail ; } }
private Method findAnyMethodMatch ( Class < ? > clz , String name , Class < ? > [ ] classes ) { try { Method m = clz . getDeclaredMethod ( name , classes ) ; if ( m != null ) { return m ; } } catch ( NoSuchMethodException ignored ) { } Class < ? > sup = clz . getSuperclass ( ) ; if ( sup != null ) { Method m = findAnyMethodMatch ( sup , name , classes ) ; if ( m != null ) { return m ; } } Class < ? > [ ] itfs = clz . getInterfaces ( ) ; if ( itfs != null && itfs . length > _NUM ) { for ( Class < ? > itf : itfs ) { Method m = findAnyMethodMatch ( itf , name , classes ) ; if ( m != null ) { return m ; } } } return null ; }
private Method findAnyMethodMatch ( Class < ? > clz , String name , Class < ? > [ ] classes ) { try { Method m = clz . getDeclaredMethod ( name , classes ) ; if ( m != null ) { return m ; } } catch ( NoSuchMethodException ignored ) { } Class < ? > sup = clz . getSuperclass ( ) ; if ( sup != null ) { Method m = findAnyMethodMatch ( sup , name , classes ) ; if ( m != null ) { return m ; } } Class < ? > [ ] itfs = clz . getInterfaces ( ) ; if ( itfs != null && itfs . length > _NUM ) { for ( Class < ? > itf : itfs ) { Method m = findAnyMethodMatch ( itf , name , classes ) ; if ( m != null ) { return m ; } } } return null ; }
public void stop ( ) { isAlive = _BOOL ; statsSnapShot . stop ( ) ; holdingBuffer . clear ( ) ; IOUtils . closeQuietly ( this ) ; }
public void performRankingUpdate ( Map < Integer , Integer > legionRanking ) { log . info ( STRING ) ; long startTime = System . currentTimeMillis ( ) ; Iterator < Legion > legionsIterator = allCachedLegions . iterator ( ) ; int legionsUpdated = _NUM ; this . legionRanking = legionRanking ; while ( legionsIterator . hasNext ( ) ) { Legion legion = legionsIterator . next ( ) ; if ( legionRanking . containsKey ( legion . getLegionId ( ) ) ) { legion . setLegionRank ( legionRanking . get ( legion . getLegionId ( ) ) ) ; PacketSendUtility . broadcastPacketToLegion ( legion , new SM_LEGION_EDIT ( _NUM , legion ) ) ; } legionsUpdated ++ ; } long workTime = System . currentTimeMillis ( ) - startTime ; log . info ( STRING + workTime + STRING + legionsUpdated ) ; }
private static void removeTable ( Connection conn , String name ) throws SQLException { name = name . replace ( STRING , STRING ) ; Statement stat = conn . createStatement ( ) ; stat . execute ( STRING + name ) ; DBUtil . commitEL ( conn ) ; }
private void updateModel ( Image imageToUpdate ) { Log . v ( TAG , STRING + imageToUpdate ) ; for ( Image image : mImagesList ) { if ( image . equals ( imageToUpdate ) ) { Log . v ( TAG , STRING + imageToUpdate ) ; image . setVisibility ( imageToUpdate . isVisible ( ) ) ; break ; } } int index = mImagesList . indexOf ( imageToUpdate ) ; Log . v ( TAG , STRING + index ) ; mAdapter . notifyItemChanged ( index ) ; Rect dirty = new Rect ( ) ; View viewAtPosition = mLayoutManager . findViewByPosition ( index ) ; viewAtPosition . getDrawingRect ( dirty ) ; mRecyclerView . invalidate ( dirty ) ; }
@ InitBinder public void initBinder ( WebDataBinder webDataBinder ) { SimpleDateFormat dateFormat = new SimpleDateFormat ( DATE_FORMAT ) ; dateFormat . setLenient ( _BOOL ) ; webDataBinder . registerCustomEditor ( Date . class , new CustomDateEditor ( dateFormat , _BOOL ) ) ; }
public static void cleanupTenant ( ) throws Exception { CasIdmClient idmClient = new CasIdmClient ( getIdmHostName ( ) ) ; int i = _NUM ; String tenantName = ServerConfig . getTenant ( i ) ; while ( tenantName != null ) { IdmDataRemover . addTenant ( tenantName ) ; i ++ ; tenantName = ServerConfig . getTenant ( i ) ; } try { IdmDataRemover . removeData ( idmClient ) ; } catch ( Exception e ) { logger . debug ( STRING + e . toString ( ) ) ; } }
public static CTraceOptionsDialog show ( final JFrame parent ) { final CTraceOptionsDialog dlg = new CTraceOptionsDialog ( parent ) ; GuiHelper . centerChildToParent ( parent , dlg , _BOOL ) ; dlg . setVisible ( _BOOL ) ; return dlg ; }
private static String [ ] makeColumnNames ( ColumnType types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = _NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] makeColumnNames ( ColumnType types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = _NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] makeColumnNames ( ColumnType types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = _NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
private static String [ ] makeColumnNames ( ColumnType types [ ] ) { String [ ] header = new String [ types . length ] ; for ( int i = _NUM ; i < types . length ; i ++ ) { header [ i ] = STRING + i ; } return header ; }
public void caretUpdate ( CaretEvent e ) { timer . restart ( ) ; }
private Bitmap createPhotoThumbnail ( final String aImageUrl ) { Bitmap bitmapRetValue = null ; if ( null != aImageUrl ) { Uri imageUri = Uri . fromFile ( new File ( aImageUrl ) ) ; int rotationAngle = ImageUtils . getRotationAngleForBitmap ( VectorMediasPickerActivity . this , imageUri ) ; try { final String filename = imageUri . getPath ( ) ; FileInputStream imageStream = new FileInputStream ( new File ( filename ) ) ; bitmapRetValue = createPhotoThumbnail ( imageStream , rotationAngle ) ; imageStream . close ( ) ; System . gc ( ) ; } catch ( OutOfMemoryError e ) { Log . e ( LOG_TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } } return bitmapRetValue ; }
private Bitmap createPhotoThumbnail ( final String aImageUrl ) { Bitmap bitmapRetValue = null ; if ( null != aImageUrl ) { Uri imageUri = Uri . fromFile ( new File ( aImageUrl ) ) ; int rotationAngle = ImageUtils . getRotationAngleForBitmap ( VectorMediasPickerActivity . this , imageUri ) ; try { final String filename = imageUri . getPath ( ) ; FileInputStream imageStream = new FileInputStream ( new File ( filename ) ) ; bitmapRetValue = createPhotoThumbnail ( imageStream , rotationAngle ) ; imageStream . close ( ) ; System . gc ( ) ; } catch ( OutOfMemoryError e ) { Log . e ( LOG_TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } } return bitmapRetValue ; }
private Bitmap createPhotoThumbnail ( final String aImageUrl ) { Bitmap bitmapRetValue = null ; if ( null != aImageUrl ) { Uri imageUri = Uri . fromFile ( new File ( aImageUrl ) ) ; int rotationAngle = ImageUtils . getRotationAngleForBitmap ( VectorMediasPickerActivity . this , imageUri ) ; try { final String filename = imageUri . getPath ( ) ; FileInputStream imageStream = new FileInputStream ( new File ( filename ) ) ; bitmapRetValue = createPhotoThumbnail ( imageStream , rotationAngle ) ; imageStream . close ( ) ; System . gc ( ) ; } catch ( OutOfMemoryError e ) { Log . e ( LOG_TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } } return bitmapRetValue ; }
private Bitmap createPhotoThumbnail ( final String aImageUrl ) { Bitmap bitmapRetValue = null ; if ( null != aImageUrl ) { Uri imageUri = Uri . fromFile ( new File ( aImageUrl ) ) ; int rotationAngle = ImageUtils . getRotationAngleForBitmap ( VectorMediasPickerActivity . this , imageUri ) ; try { final String filename = imageUri . getPath ( ) ; FileInputStream imageStream = new FileInputStream ( new File ( filename ) ) ; bitmapRetValue = createPhotoThumbnail ( imageStream , rotationAngle ) ; imageStream . close ( ) ; System . gc ( ) ; } catch ( OutOfMemoryError e ) { Log . e ( LOG_TAG , STRING ) ; } catch ( Exception e ) { Log . e ( LOG_TAG , STRING + e . getMessage ( ) ) ; } } return bitmapRetValue ; }
public static String tryGetCanonicalPathElseGetAbsolutePath ( final File file ) { try { return file . getCanonicalPath ( ) ; } catch ( IOException e ) { return file . getAbsolutePath ( ) ; } }
public static String tryGetCanonicalPathElseGetAbsolutePath ( final File file ) { try { return file . getCanonicalPath ( ) ; } catch ( IOException e ) { return file . getAbsolutePath ( ) ; } }
public boolean isEmpty ( ) { return fields . size ( ) <= _NUM ; }
public boolean isEmpty ( ) { return fields . size ( ) <= _NUM ; }
public boolean isEmpty ( ) { return fields . size ( ) <= _NUM ; }
public boolean isEmpty ( ) { return fields . size ( ) <= _NUM ; }
public boolean isEmpty ( ) { return fields . size ( ) <= _NUM ; }
@ Override public void handleKey ( int virtualKeyCode , int transitionState , char keyChar ) { switchControlKeys ( virtualKeyCode , transitionState ) ; inputBuffer . add ( new GlobalKeyEvent ( this , virtualKeyCode , transitionState , keyChar , menuPressed , shiftPressed , controlPressed , extendedKey ) ) ; }
@ Override public void handleKey ( int virtualKeyCode , int transitionState , char keyChar ) { switchControlKeys ( virtualKeyCode , transitionState ) ; inputBuffer . add ( new GlobalKeyEvent ( this , virtualKeyCode , transitionState , keyChar , menuPressed , shiftPressed , controlPressed , extendedKey ) ) ; }
static public String handle ( String request ) { StringBuilder response = new StringBuilder ( ) ; JSONTokener tokener = new JSONTokener ( request ) ; try { Object token = tokener . nextValue ( ) ; response . append ( STRING ) ; if ( token instanceof JSONArray ) { JSONArray array = ( JSONArray ) token ; for ( int i = _NUM ; i < array . length ( ) ; i ++ ) { JSONObject object = ( JSONObject ) array . get ( i ) ; response . append ( STRING + object . getString ( STRING ) + STRING ) ; exec ( object , response ) ; if ( i != array . length ( ) - _NUM ) response . append ( STRING ) ; } } else if ( token instanceof JSONObject ) { JSONObject object = ( JSONObject ) token ; response . append ( STRING + object . getString ( STRING ) + STRING ) ; exec ( object , response ) ; } response . append ( STRING ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + request ) ; e . printStackTrace ( ) ; return STRING ; } Log . d ( TAG , STRING + request ) ; Log . d ( TAG , STRING + response . toString ( ) ) ; return response . toString ( ) ; }
static public String handle ( String request ) { StringBuilder response = new StringBuilder ( ) ; JSONTokener tokener = new JSONTokener ( request ) ; try { Object token = tokener . nextValue ( ) ; response . append ( STRING ) ; if ( token instanceof JSONArray ) { JSONArray array = ( JSONArray ) token ; for ( int i = _NUM ; i < array . length ( ) ; i ++ ) { JSONObject object = ( JSONObject ) array . get ( i ) ; response . append ( STRING + object . getString ( STRING ) + STRING ) ; exec ( object , response ) ; if ( i != array . length ( ) - _NUM ) response . append ( STRING ) ; } } else if ( token instanceof JSONObject ) { JSONObject object = ( JSONObject ) token ; response . append ( STRING + object . getString ( STRING ) + STRING ) ; exec ( object , response ) ; } response . append ( STRING ) ; } catch ( Exception e ) { Log . e ( TAG , STRING + request ) ; e . printStackTrace ( ) ; return STRING ; } Log . d ( TAG , STRING + request ) ; Log . d ( TAG , STRING + response . toString ( ) ) ; return response . toString ( ) ; }
public void stubFromMethod ( Element elt ) { if ( ! ( elt . getKind ( ) == ElementKind . CONSTRUCTOR || elt . getKind ( ) == ElementKind . METHOD ) ) { return ; } String newPackage = ElementUtils . getVerboseName ( ElementUtils . enclosingPackage ( elt ) ) ; if ( ! newPackage . equals ( STRING ) ) { currentPackage = newPackage ; currentIndention = STRING ; indent ( ) ; } ExecutableElement method = ( ExecutableElement ) elt ; printMethodDecl ( method ) ; }
public final boolean equals ( Object obj ) { return super . equals ( obj ) ; }
private static final void run ( Runnable runnable ) { runnable . run ( ) ; }
private List < Activity > findBestInsertion ( List < Activity > partialRoute , boolean allowAsMajor ) { int startIndex = _NUM ; int endIndex = partialRoute . size ( ) - _NUM ; if ( allowAsMajor ) { startIndex = _NUM ; endIndex = partialRoute . size ( ) ; } List < Activity > newList = partialRoute ; double best = Double . POSITIVE_INFINITY ; List < Activity > bestList = null ; for ( int i = startIndex ; i <= endIndex ; i ++ ) { List < Activity > tmpList = new ArrayList < > ( newList ) ; Activity tmpActivity = getRelocationActivity ( ) ; tmpList . add ( i , tmpActivity ) ; double tmp = evaluateList ( tmpList ) ; if ( tmp < best ) { if ( i == _NUM ) { tmpActivity . setType ( STRING ) ; tmpActivity . setEndTime ( Time . parseTime ( STRING ) ) ; } else if ( i == partialRoute . size ( ) ) { tmpActivity . setType ( STRING ) ; } else { tmpActivity . setType ( STRING ) ; tmpActivity . setMaximumDuration ( Time . parseTime ( STRING ) ) ; } best = tmp ; bestList = tmpList ; } } return bestList ; }
public DSubjectKeyIdentifier ( JDialog parent , byte [ ] value , PublicKey subjectPublicKey ) throws IOException { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; this . subjectPublicKey = subjectPublicKey ; initComponents ( ) ; prepopulateWithValue ( value ) ; }
private void startReplicationService ( TungstenProperties replProps ) throws ReplicatorException { String serviceName = replProps . getString ( ReplicatorConf . SERVICE_NAME ) ; String serviceType = replProps . getString ( ReplicatorConf . SERVICE_TYPE ) ; boolean isDetached = replProps . getBoolean ( ReplicatorConf . DETACHED ) ; OpenReplicatorManagerMBean orm = null ; try { if ( isDetached ) { throw new ReplicatorException ( STRING ) ; } else { orm = createInternalService ( serviceName ) ; } replicators . put ( serviceName , orm ) ; orm . start ( replProps . getBoolean ( ReplicatorConf . FORCE_OFFLINE ) ) ; int listenPort = orm . getMasterListenPort ( ) ; if ( listenPort > masterListenPortMax ) masterListenPortMax = listenPort ; logger . info ( String . format ( STRING , ( isDetached ? STRING : STRING ) , serviceType , serviceName ) ) ; } catch ( Exception e ) { logger . error ( String . format ( STRING , serviceName ) , e ) ; } }
public static Source fromURL ( URL url , Charset cs ) throws IOException { URI uri ; try { uri = url . toURI ( ) ; } catch ( URISyntaxException e ) { throw new IOException ( STRING , e ) ; } try ( InputStream is = url . openStream ( ) ) { return fromStream ( is , uri , cs ) ; } }
private BufferedImageHelper ( ) { }
public ArrayAccessTree buildArrayAccess ( ExpressionTree array , ExpressionTree index ) { ArrayType arrayType = ( ArrayType ) InternalUtils . typeOf ( array ) ; JCTree . JCArrayAccess access = maker . Indexed ( ( JCTree . JCExpression ) array , ( JCTree . JCExpression ) index ) ; access . setType ( ( Type ) arrayType . getComponentType ( ) ) ; return access ; }
public ArrayAccessTree buildArrayAccess ( ExpressionTree array , ExpressionTree index ) { ArrayType arrayType = ( ArrayType ) InternalUtils . typeOf ( array ) ; JCTree . JCArrayAccess access = maker . Indexed ( ( JCTree . JCExpression ) array , ( JCTree . JCExpression ) index ) ; access . setType ( ( Type ) arrayType . getComponentType ( ) ) ; return access ; }
public void doInitiatorAliasSet ( StorageSystem storage , Initiator initiator , String initiatorAlias ) throws Exception { try { checkIfProviderSupportsAliasOperations ( storage ) ; CIMObjectPath hwManagementIDSvcPath = _cimPath . getStorageHardwareIDManagementService ( storage ) ; CIMObjectPath shidPath = getSHIDPathForAliasOperation ( storage , hwManagementIDSvcPath , initiator ) ; CIMArgument [ ] inArgs = _helper . getEMCInitiatorAliasSetArgs ( shidPath , initiatorAlias ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . invokeMethod ( storage , hwManagementIDSvcPath , SmisConstants . INITIATOR_ALIAS_SET , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; throw e ; } }
public void doInitiatorAliasSet ( StorageSystem storage , Initiator initiator , String initiatorAlias ) throws Exception { try { checkIfProviderSupportsAliasOperations ( storage ) ; CIMObjectPath hwManagementIDSvcPath = _cimPath . getStorageHardwareIDManagementService ( storage ) ; CIMObjectPath shidPath = getSHIDPathForAliasOperation ( storage , hwManagementIDSvcPath , initiator ) ; CIMArgument [ ] inArgs = _helper . getEMCInitiatorAliasSetArgs ( shidPath , initiatorAlias ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . invokeMethod ( storage , hwManagementIDSvcPath , SmisConstants . INITIATOR_ALIAS_SET , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; throw e ; } }
public void doInitiatorAliasSet ( StorageSystem storage , Initiator initiator , String initiatorAlias ) throws Exception { try { checkIfProviderSupportsAliasOperations ( storage ) ; CIMObjectPath hwManagementIDSvcPath = _cimPath . getStorageHardwareIDManagementService ( storage ) ; CIMObjectPath shidPath = getSHIDPathForAliasOperation ( storage , hwManagementIDSvcPath , initiator ) ; CIMArgument [ ] inArgs = _helper . getEMCInitiatorAliasSetArgs ( shidPath , initiatorAlias ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . invokeMethod ( storage , hwManagementIDSvcPath , SmisConstants . INITIATOR_ALIAS_SET , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; throw e ; } }
public void doInitiatorAliasSet ( StorageSystem storage , Initiator initiator , String initiatorAlias ) throws Exception { try { checkIfProviderSupportsAliasOperations ( storage ) ; CIMObjectPath hwManagementIDSvcPath = _cimPath . getStorageHardwareIDManagementService ( storage ) ; CIMObjectPath shidPath = getSHIDPathForAliasOperation ( storage , hwManagementIDSvcPath , initiator ) ; CIMArgument [ ] inArgs = _helper . getEMCInitiatorAliasSetArgs ( shidPath , initiatorAlias ) ; CIMArgument [ ] outArgs = new CIMArgument [ _NUM ] ; _helper . invokeMethod ( storage , hwManagementIDSvcPath , SmisConstants . INITIATOR_ALIAS_SET , inArgs , outArgs ) ; } catch ( WBEMException e ) { _log . error ( STRING , e ) ; throw e ; } catch ( Exception e ) { _log . error ( STRING , e ) ; throw e ; } }
void parseFinish ( ) { mChildren = mCurrentGroup . getChildren ( ) ; }
public void deleteAttributes ( int [ ] columnIndices ) { int i ; Arrays . sort ( columnIndices ) ; addUndoPoint ( ) ; m_IgnoreChanges = _BOOL ; for ( i = columnIndices . length - _NUM ; i >= _NUM ; i -- ) { deleteAttributeAt ( columnIndices [ i ] , _BOOL ) ; } m_IgnoreChanges = _BOOL ; notifyListener ( new TableModelEvent ( this , TableModelEvent . HEADER_ROW ) ) ; }
void addChild ( EnvironmentLogger child ) { _children . add ( new WeakReference < EnvironmentLogger > ( child ) ) ; updateChildren ( ) ; }
void addChild ( EnvironmentLogger child ) { _children . add ( new WeakReference < EnvironmentLogger > ( child ) ) ; updateChildren ( ) ; }
public JPopupMenu createPopupMenu ( ) { return createPopupMenu ( getAllSelectedLines ( ) ) ; }
private static int buildRequestCode ( long threadId , int action ) { action ++ ; return ( int ) ( action * _NUM + threadId ) ; }
private static int buildRequestCode ( long threadId , int action ) { action ++ ; return ( int ) ( action * _NUM + threadId ) ; }
public void clearSelection ( ) { m_selectedItems . clear ( ) ; }
public void clearSelection ( ) { m_selectedItems . clear ( ) ; }
private String createConnectionName ( ) { StringBuilder nameBuffer = new StringBuilder ( ) ; nameBuffer . append ( getConnectionType ( ) ) ; nameBuffer . append ( STRING ) ; nameBuffer . append ( _host ) ; nameBuffer . append ( STRING ) ; nameBuffer . append ( _port ) ; return nameBuffer . toString ( ) ; }
private static double computeKLD ( double [ ] px , double [ ] py ) { double result = _NUM ; for ( int i = _NUM ; i < px . length ; i ++ ) { double xi = Math . max ( px [ i ] , _NUM ) ; double yi = Math . max ( py [ i ] , _NUM ) ; result += xi * Math . log ( xi / yi ) ; } return result ; }
@ Override public final int readByte ( ) { int temp ; try { temp = raf . read ( ) ; if ( temp == - _NUM ) { throw new RuntimeException ( STRING ) ; } read ++ ; return temp ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String toString ( JSONObject jo ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . getString ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . optBoolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public static String toString ( JSONObject jo ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . getString ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . optBoolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public static String toString ( JSONObject jo ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . getString ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . optBoolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public static String toString ( JSONObject jo ) throws JSONException { StringBuilder sb = new StringBuilder ( ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( jo . getString ( STRING ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . has ( STRING ) ) { sb . append ( STRING ) ; sb . append ( escape ( jo . getString ( STRING ) ) ) ; } if ( jo . optBoolean ( STRING ) ) { sb . append ( STRING ) ; } return sb . toString ( ) ; }
public void close ( ) { flush ( ) ; try { out . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }
public void close ( ) { flush ( ) ; try { out . close ( ) ; } catch ( IOException e ) { throw new IllegalStateException ( e ) ; } }
public void add ( File file , String pathForEntry , String password ) throws IOException , UnsupportedEncodingException { FileInputStream fis = new FileInputStream ( file ) ; try { add ( pathForEntry , fis , password ) ; } finally { fis . close ( ) ; } }
public void add ( File file , String pathForEntry , String password ) throws IOException , UnsupportedEncodingException { FileInputStream fis = new FileInputStream ( file ) ; try { add ( pathForEntry , fis , password ) ; } finally { fis . close ( ) ; } }
public static String createTestPtStationCSVFile ( File file ) { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; return file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public static String createTestPtStationCSVFile ( File file ) { try ( BufferedWriter bw = new BufferedWriter ( new FileWriter ( file ) ) ) { bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; bw . write ( STRING ) ; bw . newLine ( ) ; return file . getCanonicalPath ( ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } }
public PowerModelSqrt ( double maxPower , double staticPowerPercent ) { setMaxPower ( maxPower ) ; setStaticPower ( staticPowerPercent * maxPower ) ; setConstant ( ( maxPower - getStaticPower ( ) ) / Math . sqrt ( _NUM ) ) ; }
public void add ( RegistrationHandle handle ) { handles . add ( handle ) ; }
public void add ( RegistrationHandle handle ) { handles . add ( handle ) ; }
public void addGossipMember ( GossipMember member ) { gossipMembers . add ( member ) ; }
public Argument addForm ( final String aliasName ) { forms . add ( aliasName ) ; return this ; }
public void write ( CharSequence csq ) throws IOException { if ( _outputStream == null ) throw new IOException ( STRING ) ; final int length = csq . length ( ) ; for ( int i = _NUM ; i < length ; ) { char c = csq . charAt ( i ++ ) ; if ( c < _NUM ) { _bytes [ _index ] = ( byte ) c ; if ( ++ _index >= _bytes . length ) { flushBuffer ( ) ; } } else { write ( c ) ; } } }
public static long longFromProperties ( Properties p , String propName , long defaultValue ) { long ret = defaultValue ; String longString = p . getProperty ( propName ) ; if ( longString != null ) { try { ret = Long . parseLong ( longString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public static long longFromProperties ( Properties p , String propName , long defaultValue ) { long ret = defaultValue ; String longString = p . getProperty ( propName ) ; if ( longString != null ) { try { ret = Long . parseLong ( longString . trim ( ) ) ; } catch ( NumberFormatException e ) { ret = defaultValue ; } } return ret ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public String encodeBuffer ( byte aBuffer [ ] ) { ByteArrayOutputStream outStream = new ByteArrayOutputStream ( ) ; ByteArrayInputStream inStream = new ByteArrayInputStream ( aBuffer ) ; try { encodeBuffer ( inStream , outStream ) ; } catch ( Exception IOException ) { throw new Error ( STRING ) ; } return ( outStream . toString ( ) ) ; }
public void notifyChange ( ) { executeEvent ( ) ; }
public void notifyChange ( ) { executeEvent ( ) ; }
public void notifyChange ( ) { executeEvent ( ) ; }
public boolean hasNameValue ( String name ) { return hmap . containsKey ( name . toLowerCase ( ) ) ; }
public boolean hasNameValue ( String name ) { return hmap . containsKey ( name . toLowerCase ( ) ) ; }
public void moveTo ( float x , float y ) { mPoints . add ( PathPoint . moveTo ( x , y ) ) ; }
public void moveTo ( float x , float y ) { mPoints . add ( PathPoint . moveTo ( x , y ) ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
private String determineStartupScriptPath ( IPath workspaceRelativeHtmlPath , ModuleFile referencedModule ) { IPath outRelativeHtmlPath = getOutDirRelativeHtmlPath ( workspaceRelativeHtmlPath ) ; if ( outRelativeHtmlPath == null ) { return null ; } IPath outRelativeStartupScriptPath = getOutDirRelativeStartupScriptPath ( referencedModule ) ; return getRelativeUrl ( outRelativeHtmlPath , outRelativeStartupScriptPath ) ; }
public static Model readFrom ( VirtualFile file ) throws ServerException , ForbiddenException , IOException { requireNonNull ( file , STRING ) ; return fetchModel ( XMLTree . from ( file . getContent ( ) ) ) ; }
private void startLocal ( final Process process , final String pHostName , final Timestamp pStartupTime ) { ProcessCacheObject processCacheObject = ( ProcessCacheObject ) process ; final Long newPIK = createProcessPIK ( ) ; processCacheObject . setCurrentHost ( pHostName ) ; processCacheObject . setStartupTime ( pStartupTime ) ; processCacheObject . setRequiresReboot ( Boolean . FALSE ) ; processCacheObject . setProcessPIK ( newPIK ) ; processCacheObject . setLocalConfig ( LocalConfig . Y ) ; processCacheObject . setJmsDaqCommandQueue ( jmsDaqQueueTrunk + STRING + processCacheObject . getCurrentHost ( ) + STRING + processCacheObject . getName ( ) + STRING + newPIK . toString ( ) ) ; super . start ( processCacheObject , pStartupTime ) ; }
public void resetFilters ( Boolean enabled ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . keySet ( ) ; for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String title = ( String ) it . next ( ) ; setFilterValue ( title , enabled ) ; } updateInterface ( ) ; }
public void resetFilters ( Boolean enabled ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . keySet ( ) ; for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String title = ( String ) it . next ( ) ; setFilterValue ( title , enabled ) ; } updateInterface ( ) ; }
public void resetFilters ( Boolean enabled ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . keySet ( ) ; for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String title = ( String ) it . next ( ) ; setFilterValue ( title , enabled ) ; } updateInterface ( ) ; }
public void resetFilters ( Boolean enabled ) { if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + enabled ) ; } Set keys = filters . keySet ( ) ; for ( Iterator it = keys . iterator ( ) ; it . hasNext ( ) ; ) { String title = ( String ) it . next ( ) ; setFilterValue ( title , enabled ) ; } updateInterface ( ) ; }
public void add ( Permission perm ) { if ( ! ( perm instanceof ISPermission ) ) { String objs [ ] = { perm . toString ( ) } ; throw ( new IllegalArgumentException ( ResBundleUtils . getString ( STRING , objs ) ) ) ; } if ( isReadOnly ( ) ) { throw new SecurityException ( ResBundleUtils . getString ( STRING ) ) ; } debug . message ( STRING ) ; if ( debug . messageEnabled ( ) ) { debug . message ( STRING + perm . toString ( ) ) ; } perms . put ( perm . getName ( ) , perm ) ; }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
public void receive ( final CallEvent event ) { if ( event . isValid ( ) ) { if ( ! mEvents . contains ( event ) ) { mEvents . add ( _NUM , event ) ; fireTableRowsInserted ( _NUM , _NUM ) ; prune ( ) ; } else { int row = mEvents . indexOf ( event ) ; fireTableRowsUpdated ( row , row ) ; } } else { if ( mEvents . contains ( event ) ) { int row = mEvents . indexOf ( event ) ; mEvents . remove ( event ) ; fireTableRowsDeleted ( row , row ) ; } } }
private void rebuildCriteriumCacheMenu ( ) { m_previousCriteriaMenu . removeAll ( ) ; m_previousCriteriaMenu . setVisible ( _BOOL ) ; for ( final CCachedExpressionTree tree : m_criteriumCache . getTrees ( ) ) { m_previousCriteriaMenu . add ( new JMenuItem ( new CExecuteCachedCriterium ( m_model . getGraph ( ) , tree ) ) ) ; } }
private void rebuildCriteriumCacheMenu ( ) { m_previousCriteriaMenu . removeAll ( ) ; m_previousCriteriaMenu . setVisible ( _BOOL ) ; for ( final CCachedExpressionTree tree : m_criteriumCache . getTrees ( ) ) { m_previousCriteriaMenu . add ( new JMenuItem ( new CExecuteCachedCriterium ( m_model . getGraph ( ) , tree ) ) ) ; } }
private void rebuildCriteriumCacheMenu ( ) { m_previousCriteriaMenu . removeAll ( ) ; m_previousCriteriaMenu . setVisible ( _BOOL ) ; for ( final CCachedExpressionTree tree : m_criteriumCache . getTrees ( ) ) { m_previousCriteriaMenu . add ( new JMenuItem ( new CExecuteCachedCriterium ( m_model . getGraph ( ) , tree ) ) ) ; } }
public StateInteractive key_typed ( char p_key_char ) { StateInteractive curr_return_state = this ; if ( Character . isDigit ( p_key_char ) ) { BrdLayerStructure layer_structure = r_brd . layer_structure ; int digit = Character . digit ( p_key_char , _NUM ) ; digit = Math . min ( digit , layer_structure . signal_layer_count ( ) ) ; digit = Math . max ( digit - _NUM , _NUM ) ; BrdLayer new_layer = layer_structure . get_signal_layer ( digit ) ; digit = layer_structure . get_no ( new_layer ) ; if ( digit >= _NUM ) { change_layer_action ( digit ) ; } } else if ( p_key_char == STRING ) { BrdLayerStructure layer_structure = r_brd . layer_structure ; int current_layer_no = i_brd . itera_settings . layer_no ; for ( ; ; ) { ++ current_layer_no ; if ( current_layer_no >= layer_structure . size ( ) || layer_structure . is_signal ( current_layer_no ) ) { break ; } } if ( current_layer_no < layer_structure . size ( ) ) { change_layer_action ( current_layer_no ) ; } } else if ( p_key_char == STRING ) { board . BrdLayerStructure layer_structure = r_brd . layer_structure ; int current_layer_no = i_brd . itera_settings . layer_no ; for ( ; ; ) { -- current_layer_no ; if ( current_layer_no < _NUM || layer_structure . is_signal ( current_layer_no ) ) { break ; } } if ( current_layer_no >= _NUM ) { change_layer_action ( current_layer_no ) ; } } else { curr_return_state = super . key_typed ( p_key_char ) ; } return curr_return_state ; }
private static String unsignedToString ( final int value ) { if ( value >= _NUM ) { return Integer . toString ( value ) ; } else { return Long . toString ( ( ( long ) value ) & _NUM ) ; } }
private byte postDecryption ( CipherState state , ByteBuffer inByteBuffer , long position , byte [ ] iv ) throws IOException { byte padding = _NUM ; if ( state . isReset ( ) ) { resetCipher ( state , position , iv ) ; padding = getPadding ( position ) ; inByteBuffer . position ( padding ) ; } return padding ; }
public static String copyToString ( Reader in ) throws IOException { StringWriter out = new StringWriter ( ) ; copy ( in , out ) ; String str = out . toString ( ) ; if ( str . startsWith ( STRING ) ) { return str . substring ( _NUM ) ; } return str ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public WritableRaster createWritableChild ( int x , int y , int width , int height , int x0 , int y0 , int bandList [ ] ) { if ( x < this . minX ) { throw new RasterFormatException ( STRING ) ; } if ( y < this . minY ) { throw new RasterFormatException ( STRING ) ; } if ( ( x + width < x ) || ( x + width > this . width + this . minX ) ) { throw new RasterFormatException ( STRING ) ; } if ( ( y + height < y ) || ( y + height > this . height + this . minY ) ) { throw new RasterFormatException ( STRING ) ; } SampleModel sm ; if ( bandList != null ) sm = sampleModel . createSubsetSampleModel ( bandList ) ; else sm = sampleModel ; int deltaX = x0 - x ; int deltaY = y0 - y ; return new ByteBandedRaster ( sm , dataBuffer , new Rectangle ( x0 , y0 , width , height ) , new Point ( sampleModelTranslateX + deltaX , sampleModelTranslateY + deltaY ) , this ) ; }
public ScriptBuilder addChunk ( ScriptChunk chunk ) { return addChunk ( chunks . size ( ) , chunk ) ; }
public ScriptBuilder addChunk ( ScriptChunk chunk ) { return addChunk ( chunks . size ( ) , chunk ) ; }
@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { String pathInfo = request . getPathInfo ( ) ; if ( pathInfo == null ) { printError ( response , STRING ) ; return ; } URL url = null ; try { url = new URL ( destinationUrl + pathInfo ) ; } catch ( MalformedURLException e ) { printError ( response , STRING ) ; return ; } HttpURLConnection connection = null ; try { connection = openConnection ( url ) ; } catch ( IOException e ) { printError ( response , e . getMessage ( ) ) ; return ; } try { forwardPost ( connection , request , response ) ; } catch ( IOException e ) { printError ( response , e . getMessage ( ) ) ; return ; } finally { closeConnection ( connection ) ; } }
@ Override protected void doPost ( HttpServletRequest request , HttpServletResponse response ) throws ServletException , IOException { String pathInfo = request . getPathInfo ( ) ; if ( pathInfo == null ) { printError ( response , STRING ) ; return ; } URL url = null ; try { url = new URL ( destinationUrl + pathInfo ) ; } catch ( MalformedURLException e ) { printError ( response , STRING ) ; return ; } HttpURLConnection connection = null ; try { connection = openConnection ( url ) ; } catch ( IOException e ) { printError ( response , e . getMessage ( ) ) ; return ; } try { forwardPost ( connection , request , response ) ; } catch ( IOException e ) { printError ( response , e . getMessage ( ) ) ; return ; } finally { closeConnection ( connection ) ; } }
public void emitRetainedVars ( GenerateJsVisitor gen ) { if ( ! retainedVars . isEmpty ( ) ) { gen . out ( STRING ) ; boolean first = _BOOL ; for ( String varName : retainedVars ) { if ( ! first ) { gen . out ( STRING ) ; } first = _BOOL ; gen . out ( varName ) ; } gen . endLine ( _BOOL ) ; retainedVars . clear ( ) ; } }
public void emitRetainedVars ( GenerateJsVisitor gen ) { if ( ! retainedVars . isEmpty ( ) ) { gen . out ( STRING ) ; boolean first = _BOOL ; for ( String varName : retainedVars ) { if ( ! first ) { gen . out ( STRING ) ; } first = _BOOL ; gen . out ( varName ) ; } gen . endLine ( _BOOL ) ; retainedVars . clear ( ) ; } }
public static String consistentToString ( BigDecimal decimal ) { if ( decimal == null ) { return null ; } if ( toPlainStringMethod != null ) { try { return ( String ) toPlainStringMethod . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( InvocationTargetException invokeEx ) { } catch ( IllegalAccessException accessEx ) { } } return decimal . toString ( ) ; }
public static String consistentToString ( BigDecimal decimal ) { if ( decimal == null ) { return null ; } if ( toPlainStringMethod != null ) { try { return ( String ) toPlainStringMethod . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( InvocationTargetException invokeEx ) { } catch ( IllegalAccessException accessEx ) { } } return decimal . toString ( ) ; }
public static String consistentToString ( BigDecimal decimal ) { if ( decimal == null ) { return null ; } if ( toPlainStringMethod != null ) { try { return ( String ) toPlainStringMethod . invoke ( decimal , ( Object [ ] ) null ) ; } catch ( InvocationTargetException invokeEx ) { } catch ( IllegalAccessException accessEx ) { } } return decimal . toString ( ) ; }
protected synchronized void rememberLastThing ( UndoEvent event ) { if ( undoStack . size ( ) >= stackSize ) { undoStack . removeElementAt ( _NUM ) ; } if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + event . getDescription ( ) + STRING ) ; } undoStack . push ( event ) ; }
protected synchronized void rememberLastThing ( UndoEvent event ) { if ( undoStack . size ( ) >= stackSize ) { undoStack . removeElementAt ( _NUM ) ; } if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + event . getDescription ( ) + STRING ) ; } undoStack . push ( event ) ; }
protected synchronized void rememberLastThing ( UndoEvent event ) { if ( undoStack . size ( ) >= stackSize ) { undoStack . removeElementAt ( _NUM ) ; } if ( logger . isLoggable ( Level . FINE ) ) { logger . fine ( STRING + event . getDescription ( ) + STRING ) ; } undoStack . push ( event ) ; }
private JTabbedPane createTabbedPane ( final boolean isDefaultSettingsDialog , final boolean isCallgraph ) { final JTabbedPane tab = new JTabbedPane ( ) ; addTab ( tab , STRING , new CAutomatismPanel ( m_settings , isDefaultSettingsDialog ) ) ; addTab ( tab , STRING , new CEdgePanel ( m_settings ) ) ; addTab ( tab , STRING , new CHierarchicPanel ( m_settings ) ) ; addTab ( tab , STRING , new COrthogonalPanel ( m_settings ) ) ; addTab ( tab , STRING , new CCircularPanel ( m_settings ) ) ; if ( ! isCallgraph ) { addTab ( tab , STRING , new CDisassemblyPanel ( m_settings ) ) ; } addTab ( tab , STRING , new CControlsPanel ( m_settings ) ) ; addTab ( tab , STRING , new CMiscPanel ( m_settings , ! isDefaultSettingsDialog || isCallgraph ) ) ; tab . setPreferredSize ( new Dimension ( FRAME_WIDTH , FRAME_HEIGHT ) ) ; return tab ; }
private JTabbedPane createTabbedPane ( final boolean isDefaultSettingsDialog , final boolean isCallgraph ) { final JTabbedPane tab = new JTabbedPane ( ) ; addTab ( tab , STRING , new CAutomatismPanel ( m_settings , isDefaultSettingsDialog ) ) ; addTab ( tab , STRING , new CEdgePanel ( m_settings ) ) ; addTab ( tab , STRING , new CHierarchicPanel ( m_settings ) ) ; addTab ( tab , STRING , new COrthogonalPanel ( m_settings ) ) ; addTab ( tab , STRING , new CCircularPanel ( m_settings ) ) ; if ( ! isCallgraph ) { addTab ( tab , STRING , new CDisassemblyPanel ( m_settings ) ) ; } addTab ( tab , STRING , new CControlsPanel ( m_settings ) ) ; addTab ( tab , STRING , new CMiscPanel ( m_settings , ! isDefaultSettingsDialog || isCallgraph ) ) ; tab . setPreferredSize ( new Dimension ( FRAME_WIDTH , FRAME_HEIGHT ) ) ; return tab ; }
private JTabbedPane createTabbedPane ( final boolean isDefaultSettingsDialog , final boolean isCallgraph ) { final JTabbedPane tab = new JTabbedPane ( ) ; addTab ( tab , STRING , new CAutomatismPanel ( m_settings , isDefaultSettingsDialog ) ) ; addTab ( tab , STRING , new CEdgePanel ( m_settings ) ) ; addTab ( tab , STRING , new CHierarchicPanel ( m_settings ) ) ; addTab ( tab , STRING , new COrthogonalPanel ( m_settings ) ) ; addTab ( tab , STRING , new CCircularPanel ( m_settings ) ) ; if ( ! isCallgraph ) { addTab ( tab , STRING , new CDisassemblyPanel ( m_settings ) ) ; } addTab ( tab , STRING , new CControlsPanel ( m_settings ) ) ; addTab ( tab , STRING , new CMiscPanel ( m_settings , ! isDefaultSettingsDialog || isCallgraph ) ) ; tab . setPreferredSize ( new Dimension ( FRAME_WIDTH , FRAME_HEIGHT ) ) ; return tab ; }
public static boolean containsProperty ( String value , String property ) { return null != value && ( value . contains ( DELIM_START_AMPERSAND + property + DELIM_STOP ) || value . contains ( DELIM_START_DOLLAR + property + DELIM_STOP ) ) ; }
public static boolean containsProperty ( String value , String property ) { return null != value && ( value . contains ( DELIM_START_AMPERSAND + property + DELIM_STOP ) || value . contains ( DELIM_START_DOLLAR + property + DELIM_STOP ) ) ; }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseEntered ( e ) ; autoZoom = _BOOL ; }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseEntered ( e ) ; autoZoom = _BOOL ; }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseEntered ( e ) ; autoZoom = _BOOL ; }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseEntered ( e ) ; autoZoom = _BOOL ; }
public void mouseEntered ( MouseEvent e ) { if ( Debug . debugging ( STRING ) ) { Debug . output ( getID ( ) + STRING ) ; } super . mouseEntered ( e ) ; autoZoom = _BOOL ; }
protected Packet ( short packettype ) { sig = new byte [ ] { STRING , STRING , STRING , STRING } ; minver = _NUM ; majver = _NUM ; this . packettype = packettype ; }
protected Packet ( short packettype ) { sig = new byte [ ] { STRING , STRING , STRING , STRING } ; minver = _NUM ; majver = _NUM ; this . packettype = packettype ; }
public boolean compareAndSet ( final long expectedValue , final long newValue ) { return UNSAFE . compareAndSwapLong ( this , VALUE_OFFSET , expectedValue , newValue ) ; }
public URI ( String nuri ) throws MalformedURIException { uri = nuri ; colonLocation = nuri . indexOf ( STRING ) ; fragmentLocation = URIClassifier . getFragmentLocation ( nuri ) ; if ( colonLocation == - _NUM || colonLocation > fragmentLocation || colonLocation == _NUM ) throw new MalformedURIException ( STRING + uri + STRING , uri ) ; }
public void startExecutionEveryDayAt ( CustomTimerTask task , int targetHour , int targetMin , int targetSec ) { BotLogger . warn ( LOGTAG , STRING + task . getTaskName ( ) ) ; final Runnable taskWrapper = null ; if ( task . getTimes ( ) != _NUM ) { final long delay = computNextDilay ( targetHour , targetMin , targetSec ) ; executorService . schedule ( taskWrapper , delay , TimeUnit . SECONDS ) ; } }
public void mouseMoved ( MouseEvent e ) { mouseSupport . fireMapMouseMoved ( e ) ; if ( e . getSource ( ) instanceof MapBean ) { if ( drawDistanceObjects && theMap != null ) { double lat1 , lat2 , long1 , long2 ; rPoint2 = theMap . getCoordinates ( e ) ; theMap . repaint ( ) ; if ( infoDelegator != null ) { Debug . message ( STRING , STRING ) ; lat1 = rPoint1 . getY ( ) ; long1 = rPoint1 . getX ( ) ; lat2 = rPoint2 . getY ( ) ; long2 = rPoint2 . getX ( ) ; distance = GreatCircle . sphericalDistance ( ProjMath . degToRad ( lat1 ) , ProjMath . degToRad ( long1 ) , ProjMath . degToRad ( lat2 ) , ProjMath . degToRad ( long2 ) ) ; double azimuth = getSphericalAzimuth ( lat1 , long1 , lat2 , long2 ) ; double tmpDistance = totalDistance + distance ; String infoLine = createDistanceInformationLine ( rPoint2 , tmpDistance , azimuth ) ; InfoDisplayEvent info = new InfoDisplayEvent ( this , infoLine , InformationDelegator . COORDINATE_INFO_LINE ) ; infoDelegator . requestInfoLine ( info ) ; } } else { fireMouseLocation ( e ) ; } } }
public void mouseMoved ( MouseEvent e ) { mouseSupport . fireMapMouseMoved ( e ) ; if ( e . getSource ( ) instanceof MapBean ) { if ( drawDistanceObjects && theMap != null ) { double lat1 , lat2 , long1 , long2 ; rPoint2 = theMap . getCoordinates ( e ) ; theMap . repaint ( ) ; if ( infoDelegator != null ) { Debug . message ( STRING , STRING ) ; lat1 = rPoint1 . getY ( ) ; long1 = rPoint1 . getX ( ) ; lat2 = rPoint2 . getY ( ) ; long2 = rPoint2 . getX ( ) ; distance = GreatCircle . sphericalDistance ( ProjMath . degToRad ( lat1 ) , ProjMath . degToRad ( long1 ) , ProjMath . degToRad ( lat2 ) , ProjMath . degToRad ( long2 ) ) ; double azimuth = getSphericalAzimuth ( lat1 , long1 , lat2 , long2 ) ; double tmpDistance = totalDistance + distance ; String infoLine = createDistanceInformationLine ( rPoint2 , tmpDistance , azimuth ) ; InfoDisplayEvent info = new InfoDisplayEvent ( this , infoLine , InformationDelegator . COORDINATE_INFO_LINE ) ; infoDelegator . requestInfoLine ( info ) ; } } else { fireMouseLocation ( e ) ; } } }
public RemoveBreakpointsCommand ( final int packetId , final Set < RelocatedAddress > addresses , final BreakpointType type ) { super ( getCommandForType ( type ) , packetId ) ; Preconditions . checkNotNull ( addresses , STRING ) ; addArgument ( new DebugMessageIntegerArgument ( addresses . size ( ) ) ) ; for ( final RelocatedAddress address : addresses ) { addArgument ( new DebugMessageAddressArgument ( address . getAddress ( ) ) ) ; } }
public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( STRING ) ) m_inExternalDTD = _BOOL ; if ( ! m_expandDTDEntities && ! m_inExternalDTD ) { startNonEscaping ( ) ; characters ( STRING + name + STRING ) ; endNonEscaping ( ) ; } m_inEntityRef = _BOOL ; }
public void startEntity ( String name ) throws org . xml . sax . SAXException { if ( name . equals ( STRING ) ) m_inExternalDTD = _BOOL ; if ( ! m_expandDTDEntities && ! m_inExternalDTD ) { startNonEscaping ( ) ; characters ( STRING + name + STRING ) ; endNonEscaping ( ) ; } m_inEntityRef = _BOOL ; }
public static String leftPad ( String s , int minLength , char filling ) { int ln = s . length ( ) ; if ( minLength <= ln ) { return s ; } StringBuilder res = new StringBuilder ( minLength ) ; int dif = minLength - ln ; for ( int i = _NUM ; i < dif ; i ++ ) { res . append ( filling ) ; } res . append ( s ) ; return res . toString ( ) ; }
public int numberOfDisconnectedGroups ( Collection < String > genomes ) { final String [ ] genomes2 = genomes . toArray ( new String [ genomes . size ( ) ] ) ; final int [ ] connectionsMatrix = new int [ genomes . size ( ) * genomes . size ( ) ] ; final HashSet < Integer > groupIds = new HashSet < > ( ) ; for ( int j = _NUM ; j < genomes2 . length ; j ++ ) { int min = j + _NUM ; final String g1 = genomes2 [ j ] ; for ( int i = _NUM ; i < genomes2 . length ; i ++ ) { final String g2 = genomes2 [ i ] ; if ( areRelated ( g1 , g2 ) ) { connectionsMatrix [ j * genomes2 . length + i ] = j + _NUM ; for ( int k = _NUM ; k < j ; k ++ ) { final int value = connectionsMatrix [ k * genomes2 . length + i ] ; if ( value != _NUM && value < min ) { min = value ; } } } } for ( int i = _NUM ; i < genomes2 . length ; i ++ ) { if ( connectionsMatrix [ j * genomes2 . length + i ] != _NUM ) { connectionsMatrix [ j * genomes2 . length + i ] = min ; groupIds . add ( min ) ; } } } return groupIds . size ( ) ; }
public int numberOfDisconnectedGroups ( Collection < String > genomes ) { final String [ ] genomes2 = genomes . toArray ( new String [ genomes . size ( ) ] ) ; final int [ ] connectionsMatrix = new int [ genomes . size ( ) * genomes . size ( ) ] ; final HashSet < Integer > groupIds = new HashSet < > ( ) ; for ( int j = _NUM ; j < genomes2 . length ; j ++ ) { int min = j + _NUM ; final String g1 = genomes2 [ j ] ; for ( int i = _NUM ; i < genomes2 . length ; i ++ ) { final String g2 = genomes2 [ i ] ; if ( areRelated ( g1 , g2 ) ) { connectionsMatrix [ j * genomes2 . length + i ] = j + _NUM ; for ( int k = _NUM ; k < j ; k ++ ) { final int value = connectionsMatrix [ k * genomes2 . length + i ] ; if ( value != _NUM && value < min ) { min = value ; } } } } for ( int i = _NUM ; i < genomes2 . length ; i ++ ) { if ( connectionsMatrix [ j * genomes2 . length + i ] != _NUM ) { connectionsMatrix [ j * genomes2 . length + i ] = min ; groupIds . add ( min ) ; } } } return groupIds . size ( ) ; }
public static void flush ( ) { clearBuffer ( ) ; try { out . flush ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } }
public static Element svgText ( Document document , double x , double y , String text ) { Element elem = SVGUtil . svgElement ( document , SVGConstants . SVG_TEXT_TAG ) ; SVGUtil . setAtt ( elem , SVGConstants . SVG_X_ATTRIBUTE , x ) ; SVGUtil . setAtt ( elem , SVGConstants . SVG_Y_ATTRIBUTE , y ) ; elem . setTextContent ( text ) ; return elem ; }
public void addMessageListener ( IMessageListener listener ) { listeners . add ( listener ) ; }
public void addMessageListener ( IMessageListener listener ) { listeners . add ( listener ) ; }
public void addMessageListener ( IMessageListener listener ) { listeners . add ( listener ) ; }
public boolean parseKMLFile ( File file ) { mLocalFile = file ; Log . d ( BonusPackHelper . LOG_TAG , STRING + mLocalFile . getAbsolutePath ( ) ) ; InputStream stream ; boolean ok ; try { stream = new BufferedInputStream ( new FileInputStream ( mLocalFile ) ) ; ok = parseKMLStream ( stream , null ) ; stream . close ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; ok = _BOOL ; } return ok ; }
public final Location locationForType ( Class < ? > type , EnumSet < LocationModifier > modifiers ) { return locationForType ( type , modifiers . contains ( LocationModifier . Final ) , modifiers . contains ( LocationModifier . NonNull ) ) ; }
public Collection < EvictableEntry < K , V > > queue ( ) { Set < EvictableEntry < K , V > > cp = new LinkedHashSet < > ( ) ; for ( Holder < K , V > holder : set ) cp . add ( holder . entry ) ; return Collections . unmodifiableCollection ( cp ) ; }
private OpenReplicatorManagerMBean createInternalService ( String serviceName ) throws ReplicatorException { logger . info ( STRING + serviceName ) ; try { OpenReplicatorManager orm = new OpenReplicatorManager ( serviceName ) ; orm . setRmiHost ( managerRMIHost ) ; orm . setRmiPort ( managerRMIPort ) ; orm . setHostTimeZone ( hostTimeZone ) ; orm . setReplicatorTimeZone ( replicatorTimeZone ) ; orm . advertiseInternal ( ) ; orm . setSecurityInfo ( this . securityInfo ) ; return ( OpenReplicatorManagerMBean ) orm ; } catch ( Exception e ) { throw new ReplicatorException ( String . format ( STRING , serviceName ) , e ) ; } }
private OpenReplicatorManagerMBean createInternalService ( String serviceName ) throws ReplicatorException { logger . info ( STRING + serviceName ) ; try { OpenReplicatorManager orm = new OpenReplicatorManager ( serviceName ) ; orm . setRmiHost ( managerRMIHost ) ; orm . setRmiPort ( managerRMIPort ) ; orm . setHostTimeZone ( hostTimeZone ) ; orm . setReplicatorTimeZone ( replicatorTimeZone ) ; orm . advertiseInternal ( ) ; orm . setSecurityInfo ( this . securityInfo ) ; return ( OpenReplicatorManagerMBean ) orm ; } catch ( Exception e ) { throw new ReplicatorException ( String . format ( STRING , serviceName ) , e ) ; } }
public boolean containsAttribute ( Object name , Object value ) { return value . equals ( getAttribute ( name ) ) ; }
public boolean containsAttribute ( Object name , Object value ) { return value . equals ( getAttribute ( name ) ) ; }
public static String removeExtension ( String fileName ) { int index = fileName . lastIndexOf ( STRING ) ; if ( index == - _NUM ) { return fileName ; } else { return fileName . substring ( _NUM , index ) ; } }
private static void verifyDevice ( IDevice d , long mac , Short vlan , Integer ip , long swId , int port ) { assertNotNull ( d ) ; assertEquals ( MacAddress . of ( mac ) , d . getMACAddress ( ) ) ; if ( vlan == null ) assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( - _NUM ) } , d . getVlanId ( ) ) ; else assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( vlan ) } , d . getVlanId ( ) ) ; if ( ip == null ) assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( _NUM ) } , d . getIPv4Addresses ( ) ) ; else assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( ip ) } , d . getIPv4Addresses ( ) ) ; SwitchPort expectedAp = new SwitchPort ( DatapathId . of ( swId ) , OFPort . of ( port ) ) ; assertArrayEquals ( new SwitchPort [ ] { expectedAp } , d . getAttachmentPoints ( ) ) ; }
private static void verifyDevice ( IDevice d , long mac , Short vlan , Integer ip , long swId , int port ) { assertNotNull ( d ) ; assertEquals ( MacAddress . of ( mac ) , d . getMACAddress ( ) ) ; if ( vlan == null ) assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( - _NUM ) } , d . getVlanId ( ) ) ; else assertArrayEquals ( new VlanVid [ ] { VlanVid . ofVlan ( vlan ) } , d . getVlanId ( ) ) ; if ( ip == null ) assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( _NUM ) } , d . getIPv4Addresses ( ) ) ; else assertArrayEquals ( new IPv4Address [ ] { IPv4Address . of ( ip ) } , d . getIPv4Addresses ( ) ) ; SwitchPort expectedAp = new SwitchPort ( DatapathId . of ( swId ) , OFPort . of ( port ) ) ; assertArrayEquals ( new SwitchPort [ ] { expectedAp } , d . getAttachmentPoints ( ) ) ; }
protected static void addLine ( PrintWriter file , String level , String string ) { log . debug ( string ) ; if ( file != null ) { String [ ] lines = string . split ( NEW_LINE ) ; for ( String line : lines ) { printLine ( file , level , line ) ; } } }
public static void updateActorPosition ( final Actor actor , final Stage stage , final Vector2 newScreenSizeInStageCoords ) { if ( actor != null && stage != null ) { actor . setPosition ( ( int ) ( ( actor . getX ( ) + actor . getWidth ( ) / _NUM ) / stage . getWidth ( ) * newScreenSizeInStageCoords . x - actor . getWidth ( ) / _NUM ) , ( int ) ( ( actor . getY ( ) + actor . getHeight ( ) / _NUM ) / stage . getHeight ( ) * newScreenSizeInStageCoords . y - actor . getHeight ( ) / _NUM ) ) ; } }
public static void updateActorPosition ( final Actor actor , final Stage stage , final Vector2 newScreenSizeInStageCoords ) { if ( actor != null && stage != null ) { actor . setPosition ( ( int ) ( ( actor . getX ( ) + actor . getWidth ( ) / _NUM ) / stage . getWidth ( ) * newScreenSizeInStageCoords . x - actor . getWidth ( ) / _NUM ) , ( int ) ( ( actor . getY ( ) + actor . getHeight ( ) / _NUM ) / stage . getHeight ( ) * newScreenSizeInStageCoords . y - actor . getHeight ( ) / _NUM ) ) ; } }
@ Override public long skip ( long bytes ) { if ( closed ) { throw new FormItem . ItemSkippedException ( ) ; } int av = available ( ) ; if ( av == _NUM ) { av = makeAvailable ( ) ; if ( av == _NUM ) { return _NUM ; } } long res = Math . min ( av , bytes ) ; head += res ; return res ; }
public void registerBiome ( BiomeGenBase biome ) { registeredBiomes . add ( biome ) ; }
public static void e ( String tag , String msg , Object ... args ) { if ( sLevel > LEVEL_ERROR ) { return ; } if ( args . length > _NUM ) { msg = String . format ( msg , args ) ; } Log . e ( tag , msg ) ; }
public void selectMetaObject ( int index , PdfCanvas cb ) { MetaObject obj = MetaObjects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . getType ( ) ) { case MetaObject . META_BRUSH : currentBrush = ( MetaBrush ) obj ; style = currentBrush . getStyle ( ) ; if ( style == MetaBrush . BS_SOLID ) { Color color = currentBrush . getColor ( ) ; cb . setFillColor ( color ) ; } else if ( style == MetaBrush . BS_HATCHED ) { Color color = currentBackgroundColor ; cb . setFillColor ( color ) ; } break ; case MetaObject . META_PEN : { currentPen = ( MetaPen ) obj ; style = currentPen . getStyle ( ) ; if ( style != MetaPen . PS_NULL ) { Color color = currentPen . getColor ( ) ; cb . setStrokeColor ( color ) ; cb . setLineWidth ( Math . abs ( currentPen . getPenWidth ( ) * scalingX / extentWx ) ) ; switch ( style ) { case MetaPen . PS_DASH : cb . setLineDash ( _NUM , _NUM , _NUM ) ; break ; case MetaPen . PS_DASHDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DASHDOTDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DOT : cb . setLineDash ( _NUM , _NUM ) ; break ; default : cb . setLineDash ( _NUM ) ; break ; } } break ; } case MetaObject . META_FONT : { currentFont = ( MetaFont ) obj ; break ; } } }
public void selectMetaObject ( int index , PdfCanvas cb ) { MetaObject obj = MetaObjects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . getType ( ) ) { case MetaObject . META_BRUSH : currentBrush = ( MetaBrush ) obj ; style = currentBrush . getStyle ( ) ; if ( style == MetaBrush . BS_SOLID ) { Color color = currentBrush . getColor ( ) ; cb . setFillColor ( color ) ; } else if ( style == MetaBrush . BS_HATCHED ) { Color color = currentBackgroundColor ; cb . setFillColor ( color ) ; } break ; case MetaObject . META_PEN : { currentPen = ( MetaPen ) obj ; style = currentPen . getStyle ( ) ; if ( style != MetaPen . PS_NULL ) { Color color = currentPen . getColor ( ) ; cb . setStrokeColor ( color ) ; cb . setLineWidth ( Math . abs ( currentPen . getPenWidth ( ) * scalingX / extentWx ) ) ; switch ( style ) { case MetaPen . PS_DASH : cb . setLineDash ( _NUM , _NUM , _NUM ) ; break ; case MetaPen . PS_DASHDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DASHDOTDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DOT : cb . setLineDash ( _NUM , _NUM ) ; break ; default : cb . setLineDash ( _NUM ) ; break ; } } break ; } case MetaObject . META_FONT : { currentFont = ( MetaFont ) obj ; break ; } } }
public void selectMetaObject ( int index , PdfCanvas cb ) { MetaObject obj = MetaObjects . get ( index ) ; if ( obj == null ) return ; int style ; switch ( obj . getType ( ) ) { case MetaObject . META_BRUSH : currentBrush = ( MetaBrush ) obj ; style = currentBrush . getStyle ( ) ; if ( style == MetaBrush . BS_SOLID ) { Color color = currentBrush . getColor ( ) ; cb . setFillColor ( color ) ; } else if ( style == MetaBrush . BS_HATCHED ) { Color color = currentBackgroundColor ; cb . setFillColor ( color ) ; } break ; case MetaObject . META_PEN : { currentPen = ( MetaPen ) obj ; style = currentPen . getStyle ( ) ; if ( style != MetaPen . PS_NULL ) { Color color = currentPen . getColor ( ) ; cb . setStrokeColor ( color ) ; cb . setLineWidth ( Math . abs ( currentPen . getPenWidth ( ) * scalingX / extentWx ) ) ; switch ( style ) { case MetaPen . PS_DASH : cb . setLineDash ( _NUM , _NUM , _NUM ) ; break ; case MetaPen . PS_DASHDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DASHDOTDOT : cb . writeLiteral ( STRING ) ; break ; case MetaPen . PS_DOT : cb . setLineDash ( _NUM , _NUM ) ; break ; default : cb . setLineDash ( _NUM ) ; break ; } } break ; } case MetaObject . META_FONT : { currentFont = ( MetaFont ) obj ; break ; } } }
public void focusGained ( FocusEvent e ) { Component c = e . getComponent ( ) ; if ( c instanceof JFormattedTextField ) { selectItLater ( c ) ; } }
public void focusGained ( FocusEvent e ) { Component c = e . getComponent ( ) ; if ( c instanceof JFormattedTextField ) { selectItLater ( c ) ; } }
public void focusGained ( FocusEvent e ) { Component c = e . getComponent ( ) ; if ( c instanceof JFormattedTextField ) { selectItLater ( c ) ; } }
public final void addTab ( final String title , final JComponent component ) { Preconditions . checkNotNull ( title , STRING ) ; Preconditions . checkNotNull ( component , STRING ) ; m_tabbedPane . addTab ( title , component ) ; }
String transformName ( String className ) { String newName = mRenameClasses . get ( className ) ; if ( newName != null ) { return newName ; } int pos = className . indexOf ( STRING ) ; if ( pos > _NUM ) { String base = className . substring ( _NUM , pos ) ; newName = mRenameClasses . get ( base ) ; if ( newName != null ) { return newName + className . substring ( pos ) ; } } return className ; }
String transformName ( String className ) { String newName = mRenameClasses . get ( className ) ; if ( newName != null ) { return newName ; } int pos = className . indexOf ( STRING ) ; if ( pos > _NUM ) { String base = className . substring ( _NUM , pos ) ; newName = mRenameClasses . get ( base ) ; if ( newName != null ) { return newName + className . substring ( pos ) ; } } return className ; }
String transformName ( String className ) { String newName = mRenameClasses . get ( className ) ; if ( newName != null ) { return newName ; } int pos = className . indexOf ( STRING ) ; if ( pos > _NUM ) { String base = className . substring ( _NUM , pos ) ; newName = mRenameClasses . get ( base ) ; if ( newName != null ) { return newName + className . substring ( pos ) ; } } return className ; }
public final boolean unify ( final JIPTerm term , final Hashtable varsTbl ) { Hashtable varTable1 = new Hashtable ( _NUM ) ; if ( m_obj . unify ( term . m_obj , varTable1 ) ) { Variable var ; Enumeration en = varTable1 . elements ( ) ; while ( en . hasMoreElements ( ) ) { var = ( ( Variable ) en . nextElement ( ) ) ; varsTbl . put ( var , new JIPVariable ( var ) ) ; } return _BOOL ; } else { return _BOOL ; } }
public final boolean unify ( final JIPTerm term , final Hashtable varsTbl ) { Hashtable varTable1 = new Hashtable ( _NUM ) ; if ( m_obj . unify ( term . m_obj , varTable1 ) ) { Variable var ; Enumeration en = varTable1 . elements ( ) ; while ( en . hasMoreElements ( ) ) { var = ( ( Variable ) en . nextElement ( ) ) ; varsTbl . put ( var , new JIPVariable ( var ) ) ; } return _BOOL ; } else { return _BOOL ; } }
public final boolean unify ( final JIPTerm term , final Hashtable varsTbl ) { Hashtable varTable1 = new Hashtable ( _NUM ) ; if ( m_obj . unify ( term . m_obj , varTable1 ) ) { Variable var ; Enumeration en = varTable1 . elements ( ) ; while ( en . hasMoreElements ( ) ) { var = ( ( Variable ) en . nextElement ( ) ) ; varsTbl . put ( var , new JIPVariable ( var ) ) ; } return _BOOL ; } else { return _BOOL ; } }
public InternalColorPanelListener ( final ITypeDescription description ) { m_description = description ; }
protected int mapDragOperationFromModifiers ( MouseEvent e ) { int mods = e . getModifiersEx ( ) ; int btns = mods & ButtonMask ; if ( ! ( btns == InputEvent . BUTTON1_DOWN_MASK || btns == InputEvent . BUTTON2_DOWN_MASK ) ) { return DnDConstants . ACTION_NONE ; } return SunDragSourceContextPeer . convertModifiersToDropAction ( mods , getSourceActions ( ) ) ; }
@ BeforeClass public static void deleteIndicationsFile ( ) { boolean wasException = _BOOL ; try { StringBuffer fileNameBuff = new StringBuffer ( System . getProperty ( FileCimIndicationConsumer . WORKING_DIR_SYSTEM_VARIABLE ) ) ; fileNameBuff . append ( File . separator ) ; fileNameBuff . append ( FileCimIndicationConsumer . INDICATIONS_FILE_NAME ) ; File outFile = new File ( fileNameBuff . toString ( ) ) ; if ( outFile . exists ( ) ) { Assert . assertTrue ( outFile . delete ( ) ) ; Assert . assertFalse ( outFile . exists ( ) ) ; } } catch ( Exception e ) { wasException = _BOOL ; } finally { Assert . assertFalse ( wasException ) ; } }
public void compactBuffer ( ) { if ( offset != buffer . length ) { byte [ ] newBuffer = new byte [ offset ] ; System . arraycopy ( buffer , _NUM , newBuffer , _NUM , offset ) ; buffer = newBuffer ; } }
public void compactBuffer ( ) { if ( offset != buffer . length ) { byte [ ] newBuffer = new byte [ offset ] ; System . arraycopy ( buffer , _NUM , newBuffer , _NUM , offset ) ; buffer = newBuffer ; } }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
public static boolean needsRecalculation ( long queryStartTime , long lastModifiedTime ) { return ENABLE_UPDATE_IN_PROGRESS_INDEX_CALCULATION && queryStartTime <= SAFE_QUERY_TIME . get ( ) - queryStartTime + lastModifiedTime ; }
protected static boolean regexReplace ( JTextArea textArea , String toFind , String replaceWith , boolean forward , boolean matchCase , boolean wholeWord ) throws PatternSyntaxException { Caret c = textArea . getCaret ( ) ; int start = makeMarkAndDotEqual ( textArea , forward ) ; String findIn = getFindInText ( textArea , start , forward ) ; if ( findIn == null ) return _BOOL ; RegExReplaceInfo info = getRegExReplaceInfo ( toFind , findIn , forward , matchCase , wholeWord , replaceWith ) ; findIn = null ; if ( info != null ) { c . setSelectionVisible ( _BOOL ) ; int matchStart = info . getStartIndex ( ) ; int matchEnd = info . getEndIndex ( ) ; if ( forward ) { matchStart += start ; matchEnd += start ; } selectAndPossiblyCenter ( textArea , matchStart , matchEnd ) ; textArea . replaceSelection ( info . getReplacement ( ) ) ; return _BOOL ; } return _BOOL ; }
public void deleteAlertingDefinition ( AlertingDefinition alertingDefinition ) throws IOException { String id = alertingDefinition . getId ( ) ; AlertingDefinition local = existingAlertingDefinitions . remove ( id ) ; if ( local != null ) { Files . deleteIfExists ( pathResolver . getAlertingDefinitionFilePath ( local ) ) ; eventPublisher . publishEvent ( new AbstractAlertingDefinitionEvent . AlertingDefinitionDeletedEvent ( this , local ) ) ; } }
public TDoubleDoubleHashMap absoluteDistributionLog2 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( _NUM ) ) ; bin = Math . max ( bin , _NUM ) ; double binWidth = Math . pow ( _NUM , bin ) - Math . pow ( _NUM , bin - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
public TDoubleDoubleHashMap absoluteDistributionLog2 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( _NUM ) ) ; bin = Math . max ( bin , _NUM ) ; double binWidth = Math . pow ( _NUM , bin ) - Math . pow ( _NUM , bin - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
public TDoubleDoubleHashMap absoluteDistributionLog2 ( double descretization ) { TDoubleDoubleHashMap freq = new TDoubleDoubleHashMap ( ) ; int size = values . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { double bin = Math . ceil ( Math . log ( values . get ( i ) / descretization ) / Math . log ( _NUM ) ) ; bin = Math . max ( bin , _NUM ) ; double binWidth = Math . pow ( _NUM , bin ) - Math . pow ( _NUM , bin - _NUM ) ; binWidth = Math . max ( _NUM , binWidth ) ; freq . adjustOrPutValue ( Math . pow ( _NUM , bin ) * descretization , weights . get ( i ) / binWidth , weights . get ( i ) / binWidth ) ; } return freq ; }
protected final boolean init ( ) throws AdeException { boolean initialized ; final Properties prop = new Properties ( ) ; try ( FileInputStream fis = new FileInputStream ( propertiesFileName ) ) { prop . load ( fis ) ; initialized = _BOOL ; } catch ( FileNotFoundException e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } catch ( IOException e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } catch ( Exception e ) { throw new AdeExtUsageException ( STRING + propertiesFileName + STRING , e ) ; } return initialized ; }
public void add ( String key , String value ) { keys . add ( key ) ; values . add ( value ) ; }
public static Map < String , Object > updatePaymentApplication ( DispatchContext dctx , Map < String , Object > context ) { if ( ! context . containsKey ( STRING ) ) { context . put ( STRING , STRING ) ; } BigDecimal amountApplied = ( BigDecimal ) context . get ( STRING ) ; if ( amountApplied != null ) { context . put ( STRING , amountApplied ) ; } else { context . put ( STRING , ZERO ) ; } return updatePaymentApplicationDefBd ( dctx , context ) ; }
public static Map < String , Object > updatePaymentApplication ( DispatchContext dctx , Map < String , Object > context ) { if ( ! context . containsKey ( STRING ) ) { context . put ( STRING , STRING ) ; } BigDecimal amountApplied = ( BigDecimal ) context . get ( STRING ) ; if ( amountApplied != null ) { context . put ( STRING , amountApplied ) ; } else { context . put ( STRING , ZERO ) ; } return updatePaymentApplicationDefBd ( dctx , context ) ; }
public static Map < String , Object > updatePaymentApplication ( DispatchContext dctx , Map < String , Object > context ) { if ( ! context . containsKey ( STRING ) ) { context . put ( STRING , STRING ) ; } BigDecimal amountApplied = ( BigDecimal ) context . get ( STRING ) ; if ( amountApplied != null ) { context . put ( STRING , amountApplied ) ; } else { context . put ( STRING , ZERO ) ; } return updatePaymentApplicationDefBd ( dctx , context ) ; }
public static Map < String , Object > updatePaymentApplication ( DispatchContext dctx , Map < String , Object > context ) { if ( ! context . containsKey ( STRING ) ) { context . put ( STRING , STRING ) ; } BigDecimal amountApplied = ( BigDecimal ) context . get ( STRING ) ; if ( amountApplied != null ) { context . put ( STRING , amountApplied ) ; } else { context . put ( STRING , ZERO ) ; } return updatePaymentApplicationDefBd ( dctx , context ) ; }
public static double coefficient ( double [ ] x , double [ ] y ) { final int xdim = x . length ; final int ydim = y . length ; if ( xdim != ydim ) { throw new IllegalArgumentException ( STRING ) ; } double sumXX = _NUM , sumYY = _NUM , sumXY = _NUM ; double meanX = x [ _NUM ] , meanY = y [ _NUM ] ; int i = _NUM ; while ( i < xdim ) { final double xv = x [ i ] , yv = y [ i ] ; final double deltaX = xv - meanX ; final double deltaY = yv - meanY ; ++ i ; meanX += deltaX / i ; meanY += deltaY / i ; final double neltaX = xv - meanX ; final double neltaY = yv - meanY ; sumXX += deltaX * neltaX ; sumYY += deltaY * neltaY ; sumXY += deltaX * neltaY ; } if ( ! ( sumXX > _NUM && sumYY > _NUM ) ) { return ( sumXX == sumYY ) ? _NUM : _NUM ; } return sumXY / Math . sqrt ( sumXX * sumYY ) ; }
private void paint ( SeaGlassPainter p , SynthContext ctx , Graphics g , int x , int y , int w , int h , AffineTransform transform ) { if ( p != null ) { if ( g instanceof Graphics2D ) { Graphics2D gfx = ( Graphics2D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . createInverse ( ) ) ; } catch ( NoninvertibleTransformException e ) { e . printStackTrace ( ) ; } } } else { BufferedImage img = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D gfx = img . createGraphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . dispose ( ) ; g . drawImage ( img , x , y , null ) ; img = null ; } } }
private void paint ( SeaGlassPainter p , SynthContext ctx , Graphics g , int x , int y , int w , int h , AffineTransform transform ) { if ( p != null ) { if ( g instanceof Graphics2D ) { Graphics2D gfx = ( Graphics2D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . createInverse ( ) ) ; } catch ( NoninvertibleTransformException e ) { e . printStackTrace ( ) ; } } } else { BufferedImage img = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D gfx = img . createGraphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . dispose ( ) ; g . drawImage ( img , x , y , null ) ; img = null ; } } }
private void paint ( SeaGlassPainter p , SynthContext ctx , Graphics g , int x , int y , int w , int h , AffineTransform transform ) { if ( p != null ) { if ( g instanceof Graphics2D ) { Graphics2D gfx = ( Graphics2D ) g ; if ( transform != null ) { gfx . transform ( transform ) ; } gfx . translate ( x , y ) ; p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . translate ( - x , - y ) ; if ( transform != null ) { try { gfx . transform ( transform . createInverse ( ) ) ; } catch ( NoninvertibleTransformException e ) { e . printStackTrace ( ) ; } } } else { BufferedImage img = new BufferedImage ( w , h , BufferedImage . TYPE_INT_ARGB ) ; Graphics2D gfx = img . createGraphics ( ) ; if ( transform != null ) { gfx . transform ( transform ) ; } p . paint ( gfx , ctx . getComponent ( ) , w , h ) ; gfx . dispose ( ) ; g . drawImage ( img , x , y , null ) ; img = null ; } } }
boolean runAfter ( List tasks , int size ) ;
public static String bind ( String key , Object [ ] args ) { try { return MessageFormat . format ( bind ( key ) , args ) ; } catch ( MissingResourceException e ) { return key ; } catch ( NullPointerException e ) { return STRING + key + STRING ; } }
public static String bind ( String key , Object [ ] args ) { try { return MessageFormat . format ( bind ( key ) , args ) ; } catch ( MissingResourceException e ) { return key ; } catch ( NullPointerException e ) { return STRING + key + STRING ; } }
protected void closeResources ( Connection connection ) { if ( cacheConnection ) return ; if ( connection != null && dataSource != null ) { try { connection . close ( ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } }
protected void closeResources ( Connection connection ) { if ( cacheConnection ) return ; if ( connection != null && dataSource != null ) { try { connection . close ( ) ; } catch ( SQLException e ) { LOG . finest ( STRING + e . getMessage ( ) + STRING ) ; } } }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public Class load ( String type ) throws Exception { ClassLoader loader = getClassLoader ( ) ; if ( loader == null ) { loader = getCallerClassLoader ( ) ; } return loader . loadClass ( type ) ; }
public List < String > compactAttributeValue ( String value , int start ) { List < String > result = new ArrayList < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } WbXmlAttributeValueDef valueDef = new WbXmlAttributeValueDef ( value . substring ( start ) , ( byte ) _NUM , ( byte ) _NUM ) ; for ( WbXmlAttributeValueDef attrVal : attrValuesByValue . tailSet ( valueDef ) ) { List < String > found = matches ( value , attrVal . getValue ( ) , start , _BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compactAttributeValue ( String value , int start ) { List < String > result = new ArrayList < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } WbXmlAttributeValueDef valueDef = new WbXmlAttributeValueDef ( value . substring ( start ) , ( byte ) _NUM , ( byte ) _NUM ) ; for ( WbXmlAttributeValueDef attrVal : attrValuesByValue . tailSet ( valueDef ) ) { List < String > found = matches ( value , attrVal . getValue ( ) , start , _BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compactAttributeValue ( String value , int start ) { List < String > result = new ArrayList < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } WbXmlAttributeValueDef valueDef = new WbXmlAttributeValueDef ( value . substring ( start ) , ( byte ) _NUM , ( byte ) _NUM ) ; for ( WbXmlAttributeValueDef attrVal : attrValuesByValue . tailSet ( valueDef ) ) { List < String > found = matches ( value , attrVal . getValue ( ) , start , _BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public List < String > compactAttributeValue ( String value , int start ) { List < String > result = new ArrayList < String > ( ) ; if ( start > value . length ( ) ) { result . add ( value ) ; return result ; } WbXmlAttributeValueDef valueDef = new WbXmlAttributeValueDef ( value . substring ( start ) , ( byte ) _NUM , ( byte ) _NUM ) ; for ( WbXmlAttributeValueDef attrVal : attrValuesByValue . tailSet ( valueDef ) ) { List < String > found = matches ( value , attrVal . getValue ( ) , start , _BOOL ) ; if ( found != null ) { return found ; } } result . add ( value ) ; return result ; }
public static int receiveChar ( ) throws IOException { log . trace ( String . format ( STRING ) ) ; int result = receiveChar ( serialPortDescriptor ) ; if ( result < _NUM ) { throw new IOException ( String . format ( STRING , result ) ) ; } return result ; }
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == _NUM ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( _BOOL ) ; } return r ; }
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == _NUM ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( _BOOL ) ; } return r ; }
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == _NUM ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( _BOOL ) ; } return r ; }
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == _NUM ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( _BOOL ) ; } return r ; }
private boolean _removeActivity ( Activity a ) { boolean r ; synchronized ( this ) { r = m_activities . remove ( a ) ; if ( r ) { if ( m_activities . size ( ) == _NUM ) { m_nextTime = Long . MAX_VALUE ; } } } if ( r ) { a . setScheduled ( _BOOL ) ; } return r ; }
protected final void resolveIssue ( HealthIssue healthIssue ) { EventBus eventBus ; boolean wasIssueActive ; synchronized ( mLock ) { if ( mHealthEventBus == null ) { LOG . w ( STRING + STRING , healthIssue . toString ( ) ) ; return ; } eventBus = mHealthEventBus ; wasIssueActive = mActiveIssues . remove ( healthIssue ) ; } if ( wasIssueActive ) { eventBus . post ( healthIssue . resolved ) ; } }
protected final void resolveIssue ( HealthIssue healthIssue ) { EventBus eventBus ; boolean wasIssueActive ; synchronized ( mLock ) { if ( mHealthEventBus == null ) { LOG . w ( STRING + STRING , healthIssue . toString ( ) ) ; return ; } eventBus = mHealthEventBus ; wasIssueActive = mActiveIssues . remove ( healthIssue ) ; } if ( wasIssueActive ) { eventBus . post ( healthIssue . resolved ) ; } }
public void releaseExternalResources ( ) { if ( ! isClosed . get ( ) ) { logger . info ( STRING ) ; ActorConfig . shutDownActorSystemForce ( ) ; httpClientStore . shutdown ( ) ; tcpSshPingResourceStore . shutdown ( ) ; taskManager . cleanWaitTaskQueue ( ) ; taskManager . cleanInprogressJobMap ( ) ; isClosed . set ( _BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void releaseExternalResources ( ) { if ( ! isClosed . get ( ) ) { logger . info ( STRING ) ; ActorConfig . shutDownActorSystemForce ( ) ; httpClientStore . shutdown ( ) ; tcpSshPingResourceStore . shutdown ( ) ; taskManager . cleanWaitTaskQueue ( ) ; taskManager . cleanInprogressJobMap ( ) ; isClosed . set ( _BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void releaseExternalResources ( ) { if ( ! isClosed . get ( ) ) { logger . info ( STRING ) ; ActorConfig . shutDownActorSystemForce ( ) ; httpClientStore . shutdown ( ) ; tcpSshPingResourceStore . shutdown ( ) ; taskManager . cleanWaitTaskQueue ( ) ; taskManager . cleanInprogressJobMap ( ) ; isClosed . set ( _BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public void releaseExternalResources ( ) { if ( ! isClosed . get ( ) ) { logger . info ( STRING ) ; ActorConfig . shutDownActorSystemForce ( ) ; httpClientStore . shutdown ( ) ; tcpSshPingResourceStore . shutdown ( ) ; taskManager . cleanWaitTaskQueue ( ) ; taskManager . cleanInprogressJobMap ( ) ; isClosed . set ( _BOOL ) ; logger . info ( STRING + STRING + STRING ) ; } else { logger . debug ( STRING ) ; } }
public FibonacciHeap ( ) { }
public FibonacciHeap ( ) { }
private void checkIfUpdate ( int columnIndex ) { if ( ! oldDuplicateNameColumn . equals ( duplicateNameColumn ) || ! oldDuplicateRoleColumn . equals ( duplicateRoleColumn ) ) { Set < Integer > columnsUpdate = new HashSet < Integer > ( ) ; columnsUpdate . addAll ( oldDuplicateNameColumn ) ; columnsUpdate . addAll ( duplicateNameColumn ) ; columnsUpdate . addAll ( oldDuplicateRoleColumn ) ; columnsUpdate . addAll ( duplicateRoleColumn ) ; fireUpdate ( columnsUpdate ) ; } else if ( ! oldColumnErrorList . equals ( columnErrorList ) || parsingErrorAffectedColumns . contains ( columnIndex ) ) { fireUpdate ( ) ; } }
private void checkIfUpdate ( int columnIndex ) { if ( ! oldDuplicateNameColumn . equals ( duplicateNameColumn ) || ! oldDuplicateRoleColumn . equals ( duplicateRoleColumn ) ) { Set < Integer > columnsUpdate = new HashSet < Integer > ( ) ; columnsUpdate . addAll ( oldDuplicateNameColumn ) ; columnsUpdate . addAll ( duplicateNameColumn ) ; columnsUpdate . addAll ( oldDuplicateRoleColumn ) ; columnsUpdate . addAll ( duplicateRoleColumn ) ; fireUpdate ( columnsUpdate ) ; } else if ( ! oldColumnErrorList . equals ( columnErrorList ) || parsingErrorAffectedColumns . contains ( columnIndex ) ) { fireUpdate ( ) ; } }
protected Array < Actor > parse ( ) { actors = GdxArrays . newArray ( Actor . class ) ; invokePreListeners ( actors ) ; final StringBuilder builder = new StringBuilder ( ) ; while ( templateReader . hasNextCharacter ( ) ) { final char character = templateReader . nextCharacter ( ) ; if ( character == syntax . getArgumentOpening ( ) ) { processArgument ( ) ; } else if ( character == syntax . getTagOpening ( ) ) { if ( isNextCharacterCommentOpening ( ) ) { processComment ( ) ; continue ; } if ( currentParentTag != null ) { currentParentTag . handleDataBetweenTags ( builder ) ; } Strings . clearBuilder ( builder ) ; processTag ( builder ) ; } else { builder . append ( character ) ; } } if ( currentParentTag != null ) { throwError ( STRING + currentParentTag . getTagName ( ) + STRING ) ; } invokePortListeners ( actors ) ; return actors ; }
private void attachToRoot ( ) { WaitForAsyncUtils . waitForAsyncFx ( _NUM , null ) ; WaitForAsyncUtils . waitForFxEvents ( ) ; }
private void attachToRoot ( ) { WaitForAsyncUtils . waitForAsyncFx ( _NUM , null ) ; WaitForAsyncUtils . waitForFxEvents ( ) ; }
private void attachToRoot ( ) { WaitForAsyncUtils . waitForAsyncFx ( _NUM , null ) ; WaitForAsyncUtils . waitForFxEvents ( ) ; }
public static void sort ( byte [ ] array , int start , int end ) { DualPivotQuicksort . sort ( array , start , end ) ; }
public final Flux < T > sample ( Duration timespan ) { return sampleMillis ( timespan . toMillis ( ) ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
@ Override public Double zincrby ( final String key , final double score , final String member ) { checkIsInMultiOrPipeline ( ) ; client . zincrby ( key , score , member ) ; String newscore = client . getBulkReply ( ) ; return Double . valueOf ( newscore ) ; }
private void checkOrMarkPrivateAccess ( Expression source , MethodNode mn ) { if ( mn == null ) { return ; } ClassNode declaringClass = mn . getDeclaringClass ( ) ; ClassNode enclosingClassNode = typeCheckingContext . getEnclosingClassNode ( ) ; if ( declaringClass != enclosingClassNode || typeCheckingContext . getEnclosingClosure ( ) != null ) { int mods = mn . getModifiers ( ) ; boolean sameModule = declaringClass . getModule ( ) == enclosingClassNode . getModule ( ) ; String packageName = declaringClass . getPackageName ( ) ; if ( packageName == null ) { packageName = STRING ; } if ( ( Modifier . isPrivate ( mods ) && sameModule ) ) { addPrivateFieldOrMethodAccess ( source , declaringClass , StaticTypesMarker . PV_METHODS_ACCESS , mn ) ; } else if ( Modifier . isProtected ( mods ) && ! packageName . equals ( enclosingClassNode . getPackageName ( ) ) && ! implementsInterfaceOrIsSubclassOf ( enclosingClassNode , declaringClass ) ) { ClassNode cn = enclosingClassNode ; while ( ( cn = cn . getOuterClass ( ) ) != null ) { if ( implementsInterfaceOrIsSubclassOf ( cn , declaringClass ) ) { addPrivateFieldOrMethodAccess ( source , cn , StaticTypesMarker . PV_METHODS_ACCESS , mn ) ; break ; } } } } }
protected void drawImage ( Graphics g , Object nativeGraphics , int x , int y ) { g . drawImage ( image , x , y , transform ) ; }
protected void drawImage ( Graphics g , Object nativeGraphics , int x , int y ) { g . drawImage ( image , x , y , transform ) ; }
protected void drawImage ( Graphics g , Object nativeGraphics , int x , int y ) { g . drawImage ( image , x , y , transform ) ; }
protected void drawImage ( Graphics g , Object nativeGraphics , int x , int y ) { g . drawImage ( image , x , y , transform ) ; }
private void addSourceCodeRemark ( TestSolution testSolution , Element element , String message , String defaultLang , String currentLang , String detectedLang , String testedText ) { if ( testSolution . equals ( TestSolution . PASSED ) || StringUtils . isBlank ( message ) ) { return ; } List < EvidenceElement > evidenceElementList = new ArrayList < > ( ) ; if ( StringUtils . isNotBlank ( currentLang ) ) { evidenceElementList . add ( getEvidenceElement ( DEFAULT_LANGUAGE_EE , defaultLang ) ) ; evidenceElementList . add ( getEvidenceElement ( CURRENT_LANGUAGE_EE , currentLang ) ) ; } else { evidenceElementList . add ( getEvidenceElement ( LANGUAGE_EE , defaultLang ) ) ; } evidenceElementList . add ( getEvidenceElement ( DETECTED_LANGUAGE_EE , detectedLang ) ) ; if ( testedText . length ( ) > DISPLAYABLE_TEXT_SIZE ) { testedText = testedText . substring ( _NUM , DISPLAYABLE_TEXT_SIZE ) ; } evidenceElementList . add ( getEvidenceElement ( EXTRACTED_TEXT_EE , testedText ) ) ; addSourceCodeRemark ( testSolution , element , message , evidenceElementList ) ; }
public static < T > CompletableFuture < T > waitForAll ( List < CompletableFuture < T > > futures ) { if ( futures . isEmpty ( ) ) { return CompletableFuture . completedFuture ( null ) ; } final CompletableFuture < T > compositeFuture = new CompletableFuture < > ( ) ; final AtomicInteger count = new AtomicInteger ( futures . size ( ) ) ; final AtomicReference < Throwable > exception = new AtomicReference < > ( ) ; for ( CompletableFuture < T > future : futures ) { future . whenComplete ( null ) ; } return compositeFuture ; }
boolean stitchInitializer ( TypeDeclaration d ) { final VirtualFile f = compiler . getStitchedFile ( d , STRING ) ; if ( f != null && f . exists ( ) ) { jsout . outputFile ( f ) ; return _BOOL ; } return _BOOL ; }
boolean stitchInitializer ( TypeDeclaration d ) { final VirtualFile f = compiler . getStitchedFile ( d , STRING ) ; if ( f != null && f . exists ( ) ) { jsout . outputFile ( f ) ; return _BOOL ; } return _BOOL ; }
public void testConstructorSignBytesNegative5 ( ) { byte aBytes [ ] = { - _NUM , _NUM , _NUM , - _NUM } ; int aSign = - _NUM ; byte rBytes [ ] = { - _NUM , _NUM , - _NUM , - _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = aNumber . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , - _NUM , aNumber . signum ( ) ) ; }
private void createLicenseObject ( List < LicenseInfoExt > licenseInfoExts , License license ) { if ( licenseInfoExts . isEmpty ( ) ) { return ; } for ( LicenseInfoExt licenseExt : licenseInfoExts ) { LicenseFeature licenseFeature = createLicenseFeatureFromLicenseInfoExt ( licenseExt ) ; license . addLicenseFeature ( licenseFeature ) ; } }
public Calculable ( String id , double value ) { setId ( id ) ; setValue ( value ) ; setWhen ( System . currentTimeMillis ( ) ) ; }
public Calculable ( String id , double value ) { setId ( id ) ; setValue ( value ) ; setWhen ( System . currentTimeMillis ( ) ) ; }
public void removeWorkspaceComponentListener ( final WorkspaceComponentListener listener ) { workspaceComponentListeners . remove ( listener ) ; }
private void calculateAndSetSignedMutualInformation ( int i , int j , double [ ] [ ] jointProbabilities ) { jointProbabilities [ _NUM ] [ _NUM ] = ( double ) Math . round ( mCoOccurrencesAndMiMatrix . get ( i , j ) ) / m_totalNumIntervals ; jointProbabilities [ _NUM ] [ _NUM ] = ( double ) Math . round ( mCoOccurrencesAndMiMatrix . get ( i , i ) - mCoOccurrencesAndMiMatrix . get ( i , j ) ) / m_totalNumIntervals ; jointProbabilities [ _NUM ] [ _NUM ] = ( double ) Math . round ( mCoOccurrencesAndMiMatrix . get ( j , j ) - mCoOccurrencesAndMiMatrix . get ( i , j ) ) / m_totalNumIntervals ; jointProbabilities [ _NUM ] [ _NUM ] = ( double ) Math . round ( m_totalNumIntervals - mCoOccurrencesAndMiMatrix . get ( i , i ) - mCoOccurrencesAndMiMatrix . get ( j , j ) + mCoOccurrencesAndMiMatrix . get ( i , j ) ) / m_totalNumIntervals ; final double mi = calculateSign ( jointProbabilities ) * calculateMutualInformation ( jointProbabilities ) ; mCoOccurrencesAndMiMatrix . set ( i , j , mi ) ; }
public void drawString ( String str , float x , float y ) { mGraphics . drawString ( str , x , y ) ; }
public void expectServerProxyFailed ( MessageInfo messageInfo ) { expectedApiCalls . add ( new ApiCall ( SERVER_PROXY_FAILED , new Object [ ] { messageInfo . getOrigin ( ) , messageInfo . getClient ( ) , messageInfo . getService ( ) } ) ) ; }
public final TextBuilder append ( char chars [ ] , int offset , int length ) { final int end = offset + length ; if ( ( offset < _NUM ) || ( length < _NUM ) || ( end > chars . length ) ) throw new IndexOutOfBoundsException ( ) ; int newLength = _length + length ; while ( _capacity < newLength ) { increaseCapacity ( ) ; } for ( int i = offset , j = _length ; i < end ; ) { char [ ] dstChars = _high [ j > > B1 ] ; int dstBegin = j & M1 ; int inc = MathLib . min ( C1 - dstBegin , end - i ) ; System . arraycopy ( chars , i , dstChars , dstBegin , inc ) ; i += inc ; j += inc ; } _length = newLength ; return this ; }
public static float [ ] concatAllFloat ( float [ ] ... arrays ) { int totalLength = _NUM ; final int subArrayCount = arrays . length ; for ( int i = _NUM ; i < subArrayCount ; ++ i ) { totalLength += arrays [ i ] . length ; } float [ ] result = Arrays . copyOf ( arrays [ _NUM ] , totalLength ) ; int offset = arrays [ _NUM ] . length ; for ( int i = _NUM ; i < subArrayCount ; ++ i ) { System . arraycopy ( arrays [ i ] , _NUM , result , offset , arrays [ i ] . length ) ; offset += arrays [ i ] . length ; } return result ; }
public static void registerDynamicTypeConverter ( JavaDynamicTypeConverter theConverter ) { if ( ! m_dynConverters . contains ( theConverter ) ) { m_dynConverters . addElement ( theConverter ) ; } }
public NamedColumnProjection ( String [ ] names , boolean include ) { m_names = new HashSet ( ) ; for ( int i = _NUM ; i < names . length ; ++ i ) m_names . add ( names [ i ] ) ; m_include = include ; }
private Automaton deletionsOf ( String s ) { List < Automaton > list = new ArrayList < > ( ) ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . makeString ( s . substring ( _NUM , i ) ) ; a = Operations . concatenate ( a , Automata . makeString ( s . substring ( i + _NUM ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = MinimizationOperations . minimize ( a , DEFAULT_MAX_DETERMINIZED_STATES ) ; return a ; }
private Automaton deletionsOf ( String s ) { List < Automaton > list = new ArrayList < > ( ) ; for ( int i = _NUM ; i < s . length ( ) ; i ++ ) { Automaton a = Automata . makeString ( s . substring ( _NUM , i ) ) ; a = Operations . concatenate ( a , Automata . makeString ( s . substring ( i + _NUM ) ) ) ; list . add ( a ) ; } Automaton a = Operations . union ( list ) ; a = MinimizationOperations . minimize ( a , DEFAULT_MAX_DETERMINIZED_STATES ) ; return a ; }
public void run ( int k , String kstr ) ;
public static IStatus validateQualifiedModuleName ( String qualifiedName ) { String pckg = Signature . getQualifier ( qualifiedName ) ; if ( ! Util . isValidPackageName ( pckg ) ) { return Util . newErrorStatus ( STRING ) ; } return validateSimpleModuleName ( Signature . getSimpleName ( qualifiedName ) ) ; }
protected LayerPane findSelectedPane ( ) { for ( LayerPane pane : getPanes ( ) ) { if ( pane . isSelected ( ) ) { return pane ; } } return null ; }
public Set < String > find ( T object ) { if ( ! locations . containsKey ( object ) ) { locations . put ( object , new HashSet < > ( ) ) ; } return Collections . unmodifiableSet ( locations . get ( object ) ) ; }
@ Override public void disconnect ( ) throws IOException { clientCache . close ( ) ; }
@ Override public void disconnect ( ) throws IOException { clientCache . close ( ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
private void createEditModeView ( Context context ) { String [ ] entries = new String [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { entries [ i ] = STRING + i ; } List < String > entriesList = Arrays . asList ( entries ) ; mPickerUIAdapter = new PickerUIAdapter ( context , R . layout . pickerui_item , entriesList , entriesList . size ( ) / _NUM , _BOOL , _BOOL ) ; setAdapter ( mPickerUIAdapter ) ; setSelection ( entriesList . size ( ) / _NUM ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public void registerFontMetrics ( String name , Font font , float lineHeight ) { HtmlFontMetrics metrics = getFontMetrics ( font ) ; fontMetrics . put ( font , new HtmlFontMetrics ( font , lineHeight , metrics . emwidth ) ) ; }
public static byte [ ] multiple ( byte [ ] srcBytes , int multiNum ) { if ( multiNum <= _NUM ) { return new byte [ _NUM ] ; } byte [ ] result = new byte [ srcBytes . length * multiNum ] ; for ( int i = _NUM ; i < multiNum ; i ++ ) { System . arraycopy ( srcBytes , _NUM , result , i * srcBytes . length , srcBytes . length ) ; } return result ; }
public static byte [ ] multiple ( byte [ ] srcBytes , int multiNum ) { if ( multiNum <= _NUM ) { return new byte [ _NUM ] ; } byte [ ] result = new byte [ srcBytes . length * multiNum ] ; for ( int i = _NUM ; i < multiNum ; i ++ ) { System . arraycopy ( srcBytes , _NUM , result , i * srcBytes . length , srcBytes . length ) ; } return result ; }
public void saveDomain ( ) { saveDomain ( editorTab . getShownFile ( ) ) ; system . refreshDomain ( ) ; }
public static int findNonwhitespaceCharacter ( String s , int index ) { int sLength = s . length ( ) ; while ( index < sLength && Character . isWhitespace ( s . charAt ( index ) ) ) { index ++ ; } return index ; }
public static int findNonwhitespaceCharacter ( String s , int index ) { int sLength = s . length ( ) ; while ( index < sLength && Character . isWhitespace ( s . charAt ( index ) ) ) { index ++ ; } return index ; }
public static int findNonwhitespaceCharacter ( String s , int index ) { int sLength = s . length ( ) ; while ( index < sLength && Character . isWhitespace ( s . charAt ( index ) ) ) { index ++ ; } return index ; }
private void arrayFill ( Node t , NodeInfo [ ] l , EdgeInfo [ ] k ) { if ( t == null || l == null ) { System . exit ( _NUM ) ; } Edge e ; Node r , s ; l [ _NUM ] = new NodeInfo ( ) ; l [ _NUM ] . m_node = t ; l [ _NUM ] . m_parent = - _NUM ; l [ _NUM ] . m_change = _BOOL ; int floater ; int free_space = _NUM ; double height = t . getTop ( ) ; for ( floater = _NUM ; floater < free_space ; floater ++ ) { r = l [ floater ] . m_node ; for ( int noa = _NUM ; ( e = r . getChild ( noa ) ) != null ; noa ++ ) { s = e . getTarget ( ) ; l [ free_space ] = new NodeInfo ( ) ; l [ free_space ] . m_node = s ; l [ free_space ] . m_parent = free_space - _NUM ; k [ free_space - _NUM ] = new EdgeInfo ( ) ; k [ free_space - _NUM ] . m_edge = e ; k [ free_space - _NUM ] . m_parent = floater ; k [ free_space - _NUM ] . m_child = free_space ; if ( height != s . getTop ( ) ) { l [ free_space ] . m_change = _BOOL ; height = s . getTop ( ) ; } else { l [ free_space ] . m_change = _BOOL ; } free_space ++ ; } } }
private void arrayFill ( Node t , NodeInfo [ ] l , EdgeInfo [ ] k ) { if ( t == null || l == null ) { System . exit ( _NUM ) ; } Edge e ; Node r , s ; l [ _NUM ] = new NodeInfo ( ) ; l [ _NUM ] . m_node = t ; l [ _NUM ] . m_parent = - _NUM ; l [ _NUM ] . m_change = _BOOL ; int floater ; int free_space = _NUM ; double height = t . getTop ( ) ; for ( floater = _NUM ; floater < free_space ; floater ++ ) { r = l [ floater ] . m_node ; for ( int noa = _NUM ; ( e = r . getChild ( noa ) ) != null ; noa ++ ) { s = e . getTarget ( ) ; l [ free_space ] = new NodeInfo ( ) ; l [ free_space ] . m_node = s ; l [ free_space ] . m_parent = free_space - _NUM ; k [ free_space - _NUM ] = new EdgeInfo ( ) ; k [ free_space - _NUM ] . m_edge = e ; k [ free_space - _NUM ] . m_parent = floater ; k [ free_space - _NUM ] . m_child = free_space ; if ( height != s . getTop ( ) ) { l [ free_space ] . m_change = _BOOL ; height = s . getTop ( ) ; } else { l [ free_space ] . m_change = _BOOL ; } free_space ++ ; } } }
private static CreateDisksResponse checkCreateDisksResponse ( CreateDisksResponse createDisksResponse ) throws RpcException { logger . info ( STRING , createDisksResponse ) ; switch ( createDisksResponse . getResult ( ) ) { case OK : break ; case INVALID_RESERVATION : throw new InvalidReservationException ( createDisksResponse . getError ( ) ) ; case SYSTEM_ERROR : throw new SystemErrorException ( createDisksResponse . getError ( ) ) ; default : throw new RpcException ( String . format ( STRING , createDisksResponse . getResult ( ) ) ) ; } return createDisksResponse ; }
private static void checkPermission ( ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkPermission ( modifyThreadPermission ) ; }
private static void checkPermission ( ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkPermission ( modifyThreadPermission ) ; }
private static void checkPermission ( ) { SecurityManager security = System . getSecurityManager ( ) ; if ( security != null ) security . checkPermission ( modifyThreadPermission ) ; }
public WebServiceProxy ( URL serverURL , ExecutorService executorService ) { this ( serverURL , executorService , _NUM , _NUM ) ; }
private static String padString ( String s , Align alignment , int minLength ) { if ( alignment == Align . Left ) { return padRight ( s , minLength ) ; } else if ( alignment == Align . Right ) { return padLeft ( s , minLength ) ; } else { throw new IndexOutOfBoundsException ( STRING ) ; } }
public static boolean isAllIndices ( List < String > aliasesOrIndices ) { return aliasesOrIndices == null || aliasesOrIndices . isEmpty ( ) || isExplicitAllPattern ( aliasesOrIndices ) ; }
public static boolean isAllIndices ( List < String > aliasesOrIndices ) { return aliasesOrIndices == null || aliasesOrIndices . isEmpty ( ) || isExplicitAllPattern ( aliasesOrIndices ) ; }
public static long abs ( Long number ) { return Math . abs ( number . longValue ( ) ) ; }
private void configureButton ( JButton button ) { Font buttonFont = ( Font ) DefaultLookup . get ( optionPane , this , STRING ) ; if ( buttonFont != null ) { button . setFont ( buttonFont ) ; } }
private void configureButton ( JButton button ) { Font buttonFont = ( Font ) DefaultLookup . get ( optionPane , this , STRING ) ; if ( buttonFont != null ) { button . setFont ( buttonFont ) ; } }
public MiniSolrCloudCluster ( int numServers , Path baseDir , JettyConfig jettyConfig ) throws Exception { this ( numServers , baseDir , DEFAULT_CLOUD_SOLR_XML , jettyConfig , null ) ; }
private void cancelPreviousWebRtcNotifications ( ) { Set < String > notificationIds = mSharedPreferences . getStringSet ( MEDIA_NOTIFICATION_IDS , null ) ; if ( notificationIds == null ) return ; Iterator < String > iterator = notificationIds . iterator ( ) ; while ( iterator . hasNext ( ) ) { mNotificationManager . cancel ( NOTIFICATION_NAMESPACE , Integer . parseInt ( iterator . next ( ) ) ) ; } SharedPreferences . Editor sharedPreferenceEditor = mSharedPreferences . edit ( ) ; sharedPreferenceEditor . remove ( MediaNotificationService . MEDIA_NOTIFICATION_IDS ) ; sharedPreferenceEditor . apply ( ) ; }
private void cancelPreviousWebRtcNotifications ( ) { Set < String > notificationIds = mSharedPreferences . getStringSet ( MEDIA_NOTIFICATION_IDS , null ) ; if ( notificationIds == null ) return ; Iterator < String > iterator = notificationIds . iterator ( ) ; while ( iterator . hasNext ( ) ) { mNotificationManager . cancel ( NOTIFICATION_NAMESPACE , Integer . parseInt ( iterator . next ( ) ) ) ; } SharedPreferences . Editor sharedPreferenceEditor = mSharedPreferences . edit ( ) ; sharedPreferenceEditor . remove ( MediaNotificationService . MEDIA_NOTIFICATION_IDS ) ; sharedPreferenceEditor . apply ( ) ; }
private void cancelPreviousWebRtcNotifications ( ) { Set < String > notificationIds = mSharedPreferences . getStringSet ( MEDIA_NOTIFICATION_IDS , null ) ; if ( notificationIds == null ) return ; Iterator < String > iterator = notificationIds . iterator ( ) ; while ( iterator . hasNext ( ) ) { mNotificationManager . cancel ( NOTIFICATION_NAMESPACE , Integer . parseInt ( iterator . next ( ) ) ) ; } SharedPreferences . Editor sharedPreferenceEditor = mSharedPreferences . edit ( ) ; sharedPreferenceEditor . remove ( MediaNotificationService . MEDIA_NOTIFICATION_IDS ) ; sharedPreferenceEditor . apply ( ) ; }
private void cancelPreviousWebRtcNotifications ( ) { Set < String > notificationIds = mSharedPreferences . getStringSet ( MEDIA_NOTIFICATION_IDS , null ) ; if ( notificationIds == null ) return ; Iterator < String > iterator = notificationIds . iterator ( ) ; while ( iterator . hasNext ( ) ) { mNotificationManager . cancel ( NOTIFICATION_NAMESPACE , Integer . parseInt ( iterator . next ( ) ) ) ; } SharedPreferences . Editor sharedPreferenceEditor = mSharedPreferences . edit ( ) ; sharedPreferenceEditor . remove ( MediaNotificationService . MEDIA_NOTIFICATION_IDS ) ; sharedPreferenceEditor . apply ( ) ; }
public void delete ( ) { mBaseName . delete ( ) ; mBackupName . delete ( ) ; }
public void delete ( ) { mBaseName . delete ( ) ; mBackupName . delete ( ) ; }
public void delete ( ) { mBaseName . delete ( ) ; mBackupName . delete ( ) ; }
@ Override public double totalEstimatedQuantityForRE ( final Long woActivityId , Long estimateId , final Long activityId , final WorkOrder workOrder ) { if ( estimateId == null ) estimateId = - _NUM ; Object [ ] params = null ; Double estQuantity = null ; params = new Object [ ] { estimateId , workOrder , workOrder , woActivityId , activityId } ; estQuantity = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; Double estQuantityRE = null ; if ( workOrder . getParent ( ) != null ) params = new Object [ ] { estimateId , workOrder . getParent ( ) , workOrder . getParent ( ) , activityId } ; else params = new Object [ ] { estimateId , workOrder , workOrder , activityId } ; estQuantityRE = ( Double ) genericService . findByNamedQuery ( STRING , params ) ; if ( estQuantity != null && estQuantityRE != null ) estQuantity = estQuantity + estQuantityRE ; if ( estQuantity == null && estQuantityRE != null ) estQuantity = estQuantityRE ; if ( estQuantity == null ) return _NUM ; else return estQuantity . doubleValue ( ) ; }
public static synchronized int register ( DebugValue value ) { String name = value . getName ( ) ; if ( ! keyMap . containsKey ( name ) ) { keyMap . put ( name , debugValues . size ( ) ) ; debugValues . add ( value ) ; } return keyMap . get ( name ) ; }
void saveEntities ( DataOutputStream out ) throws IOException { int num = _NUM ; for ( Enumeration < Entity > e = entityHash . elements ( ) ; e . hasMoreElements ( ) ; ) { Entity ent = e . nextElement ( ) ; if ( ent . isGeneral ( ) ) { num ++ ; } } out . writeShort ( ( short ) num ) ; for ( Enumeration < Entity > e = entityHash . elements ( ) ; e . hasMoreElements ( ) ; ) { Entity ent = e . nextElement ( ) ; if ( ent . isGeneral ( ) ) { out . writeShort ( getNameId ( ent . getName ( ) ) ) ; out . writeByte ( ent . getType ( ) & ~ GENERAL ) ; out . writeUTF ( ent . getString ( ) ) ; } } }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; while ( i < s . length ( ) ) { int codepoint = Character . codePointAt ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return _BOOL ; } if ( ! e . is ( expected ) ) { return _BOOL ; } i += codepoint >= _NUM ? _NUM : _NUM ; } return _BOOL ; }
public static boolean contains ( String s , Property expected ) { if ( s == null || s . length ( ) == _NUM ) { return _BOOL ; } int i = _NUM ; while ( i < s . length ( ) ) { int codepoint = Character . codePointAt ( s , i ) ; Emoji e = map . get ( codepoint ) ; if ( e == null ) { return _BOOL ; } if ( ! e . is ( expected ) ) { return _BOOL ; } i += codepoint >= _NUM ? _NUM : _NUM ; } return _BOOL ; }
private Segment createMemorySegment ( SegmentDescriptor descriptor ) { File segmentFile = SegmentFile . createSegmentFile ( name , storage . directory ( ) , descriptor . id ( ) , descriptor . version ( ) ) ; Buffer buffer = HeapBuffer . allocate ( Math . min ( DEFAULT_BUFFER_SIZE , descriptor . maxSegmentSize ( ) ) , Integer . MAX_VALUE ) ; descriptor . copyTo ( buffer ) ; Segment segment = new Segment ( new SegmentFile ( segmentFile ) , buffer . slice ( ) , descriptor , createIndex ( descriptor ) , new OffsetPredicate ( ) , serializer . clone ( ) , this ) ; LOGGER . debug ( STRING , segment ) ; return segment ; }
protected double updateDistance ( double currDist , double diff ) { double result ; result = currDist ; result += Math . abs ( diff ) ; return result ; }
protected double updateDistance ( double currDist , double diff ) { double result ; result = currDist ; result += Math . abs ( diff ) ; return result ; }
protected double updateDistance ( double currDist , double diff ) { double result ; result = currDist ; result += Math . abs ( diff ) ; return result ; }
protected double updateDistance ( double currDist , double diff ) { double result ; result = currDist ; result += Math . abs ( diff ) ; return result ; }
public RepeatedFieldBuilder < MType , BType , IType > addMessage ( MType message ) { if ( message == null ) { throw new NullPointerException ( ) ; } ensureMutableMessageList ( ) ; messages . add ( message ) ; if ( builders != null ) { builders . add ( null ) ; } onChanged ( ) ; incrementModCounts ( ) ; return this ; }
public String readNextWord ( ) { if ( tokenizer . hasMoreTokens ( ) ) { return tokenizer . nextToken ( ) ; } else { return null ; } }
public static < IN > byte [ ] serialize ( IN object , TypeSerializer < IN > serializer ) throws IOException { ByteArrayOutputStream baos = new ByteArrayOutputStream ( ) ; DataOutputViewStreamWrapper wrapper = new DataOutputViewStreamWrapper ( new DataOutputStream ( baos ) ) ; serializer . serialize ( object , wrapper ) ; return baos . toByteArray ( ) ; }
private void logMax ( String type , String value , String arg , long amount ) { Key key = new Key ( type , value , arg + MAXIMUM_INDICATOR ) ; synchronized ( counts ) { Long oldMax = counts . get ( key ) ; if ( oldMax == null ) { oldMax = amount ; } counts . put ( key , Math . max ( oldMax , amount ) ) ; } }
public Iterator < RecordID > sortedScan ( ) { LeafNode firstLeaf = new LeafNode ( this , firstLeafPageNum ) ; return new BPlusIterator ( firstLeaf ) ; }
public static double nextAfter ( final double start , final double direction ) { if ( Double . isNaN ( start ) || Double . isNaN ( direction ) ) { return Double . NaN ; } if ( start == direction ) { return direction ; } final double absStart = Math . abs ( start ) ; final double absDir = Math . abs ( direction ) ; final boolean toZero = ! isSameSign ( start , direction ) || absDir < absStart ; if ( toZero ) { if ( absStart == Double . MIN_VALUE ) { return copySign ( _NUM , start ) ; } if ( Double . isInfinite ( absStart ) ) { return copySign ( Double . MAX_VALUE , start ) ; } return copySign ( Double . longBitsToDouble ( Double . doubleToLongBits ( absStart ) - _NUM ) , start ) ; } else { if ( start == _NUM ) { return copySign ( Double . MIN_VALUE , direction ) ; } if ( absStart == Double . MAX_VALUE ) { return copySign ( Double . POSITIVE_INFINITY , start ) ; } return copySign ( Double . longBitsToDouble ( Double . doubleToLongBits ( absStart ) + _NUM ) , start ) ; } }
public void addAll ( final CasualtyList casualtyList ) { m_damaged . addAll ( casualtyList . getDamaged ( ) ) ; m_killed . addAll ( casualtyList . getKilled ( ) ) ; }
private void drawDragBorder ( final ExecutionUnit process , final Graphics2D g2 ) { double width = model . getProcessWidth ( process ) ; double height = model . getProcessHeight ( process ) ; Shape dragFrame = new RoundRectangle2D . Double ( DRAG_BORDER_PADDING , DRAG_BORDER_PADDING , width - _NUM * DRAG_BORDER_PADDING , height - _NUM * DRAG_BORDER_PADDING , DRAG_BORDER_CORNER , DRAG_BORDER_CORNER ) ; g2 . setColor ( BORDER_DRAG_COLOR ) ; g2 . setStroke ( BORDER_DRAG_STROKE ) ; g2 . draw ( dragFrame ) ; }
public List < Page > normalize ( List < Page > pages ) { double hubTotal = _NUM ; double authTotal = _NUM ; for ( Page p : pages ) { hubTotal += Math . pow ( p . hub , _NUM ) ; authTotal += Math . pow ( p . authority , _NUM ) ; } for ( Page p : pages ) { if ( hubTotal > _NUM ) { p . hub /= hubTotal ; } else { p . hub = _NUM ; } if ( authTotal > _NUM ) { p . authority /= authTotal ; } else { p . authority = _NUM ; } } return pages ; }
public List < Page > normalize ( List < Page > pages ) { double hubTotal = _NUM ; double authTotal = _NUM ; for ( Page p : pages ) { hubTotal += Math . pow ( p . hub , _NUM ) ; authTotal += Math . pow ( p . authority , _NUM ) ; } for ( Page p : pages ) { if ( hubTotal > _NUM ) { p . hub /= hubTotal ; } else { p . hub = _NUM ; } if ( authTotal > _NUM ) { p . authority /= authTotal ; } else { p . authority = _NUM ; } } return pages ; }
private void increaseEventCount ( Map < String , Integer > eventCounts , Predicate < String > predicate ) { int impressionCount = eventCounts . getOrDefault ( STRING , _NUM ) ; int impressionUniqueCount = Math . min ( impressionCount , _NUM ) ; int jointCounts = _NUM ; if ( ! predicate . test ( STRING ) ) { jointCounts += eventCounts . getOrDefault ( STRING , _NUM ) ; } if ( ! predicate . test ( STRING ) ) { jointCounts += eventCounts . getOrDefault ( STRING , _NUM ) ; } int jointUniqueCount = Math . min ( jointCounts , _NUM ) ; impressionCounts . put ( STRING , impressionCounts . getOrDefault ( STRING , _NUM ) + impressionCount ) ; impressionCounts . put ( STRING , impressionCounts . getOrDefault ( STRING , _NUM ) + impressionUniqueCount ) ; jointActionCounts . put ( STRING , jointActionCounts . getOrDefault ( STRING , _NUM ) + jointCounts ) ; jointActionCounts . put ( STRING , jointActionCounts . getOrDefault ( STRING , _NUM ) + jointUniqueCount ) ; }
private static String mungeCharName ( String source ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = _NUM ; i < source . length ( ) ; ) { int ch = UTF16 . charAt ( source , i ) ; i += UTF16 . getCharCount ( ch ) ; if ( UCharacterProperty . isRuleWhiteSpace ( ch ) ) { if ( buf . length ( ) == _NUM || buf . charAt ( buf . length ( ) - _NUM ) == STRING ) { continue ; } ch = STRING ; } UTF16 . append ( buf , ch ) ; } if ( buf . length ( ) != _NUM && buf . charAt ( buf . length ( ) - _NUM ) == STRING ) { buf . setLength ( buf . length ( ) - _NUM ) ; } return buf . toString ( ) ; }
private static String mungeCharName ( String source ) { StringBuffer buf = new StringBuffer ( ) ; for ( int i = _NUM ; i < source . length ( ) ; ) { int ch = UTF16 . charAt ( source , i ) ; i += UTF16 . getCharCount ( ch ) ; if ( UCharacterProperty . isRuleWhiteSpace ( ch ) ) { if ( buf . length ( ) == _NUM || buf . charAt ( buf . length ( ) - _NUM ) == STRING ) { continue ; } ch = STRING ; } UTF16 . append ( buf , ch ) ; } if ( buf . length ( ) != _NUM && buf . charAt ( buf . length ( ) - _NUM ) == STRING ) { buf . setLength ( buf . length ( ) - _NUM ) ; } return buf . toString ( ) ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
@ Override public int onStartCommand ( Intent intent , int flags , int startId ) { Log_OC . d ( TAG , STRING + startId ) ; if ( ACTION_SYNC_FOLDER . equals ( intent . getAction ( ) ) ) { if ( ! intent . hasExtra ( EXTRA_ACCOUNT ) || ! intent . hasExtra ( EXTRA_REMOTE_PATH ) ) { Log_OC . e ( TAG , STRING ) ; return START_NOT_STICKY ; } Account account = intent . getParcelableExtra ( EXTRA_ACCOUNT ) ; String remotePath = intent . getStringExtra ( EXTRA_REMOTE_PATH ) ; Pair < Account , String > itemSyncKey = new Pair < Account , String > ( account , remotePath ) ; Pair < Target , RemoteOperation > itemToQueue = newOperation ( intent ) ; if ( itemToQueue != null ) { mSyncFolderHandler . add ( account , remotePath , ( SynchronizeFolderOperation ) itemToQueue . second ) ; Message msg = mSyncFolderHandler . obtainMessage ( ) ; msg . arg1 = startId ; msg . obj = itemSyncKey ; mSyncFolderHandler . sendMessage ( msg ) ; } } else { Message msg = mOperationsHandler . obtainMessage ( ) ; msg . arg1 = startId ; mOperationsHandler . sendMessage ( msg ) ; } return START_NOT_STICKY ; }
private void createRecordHolderQueue ( File [ ] listFiles ) { this . recordHolderHeap = new PriorityQueue < SortTempFileChunkHolder > ( listFiles . length ) ; }
private void createRecordHolderQueue ( File [ ] listFiles ) { this . recordHolderHeap = new PriorityQueue < SortTempFileChunkHolder > ( listFiles . length ) ; }
private void createRecordHolderQueue ( File [ ] listFiles ) { this . recordHolderHeap = new PriorityQueue < SortTempFileChunkHolder > ( listFiles . length ) ; }
public void defineProperty ( String propertyName , Class < ? > clazz , int attributes ) { int length = propertyName . length ( ) ; if ( length == _NUM ) throw new IllegalArgumentException ( ) ; char [ ] buf = new char [ _NUM + length ] ; propertyName . getChars ( _NUM , length , buf , _NUM ) ; buf [ _NUM ] = Character . toUpperCase ( buf [ _NUM ] ) ; buf [ _NUM ] = STRING ; buf [ _NUM ] = STRING ; buf [ _NUM ] = STRING ; String getterName = new String ( buf ) ; buf [ _NUM ] = STRING ; String setterName = new String ( buf ) ; Method [ ] methods = FunctionObject . getMethodList ( clazz ) ; Method getter = FunctionObject . findSingleMethod ( methods , getterName ) ; Method setter = FunctionObject . findSingleMethod ( methods , setterName ) ; if ( setter == null ) attributes |= ScriptableObject . READONLY ; defineProperty ( propertyName , null , getter , setter == null ? null : setter , attributes ) ; }
private List < IRuntimeClasspathEntry > dependenciesForProject ( IJavaProject project ) throws CoreException { ArrayList < IRuntimeClasspathEntry > out = new ArrayList < IRuntimeClasspathEntry > ( ) ; String [ ] deps = JavaRuntime . computeDefaultRuntimeClassPath ( project ) ; for ( String dep : deps ) { IRuntimeClasspathEntry cpEntry = JavaRuntime . newArchiveRuntimeClasspathEntry ( new Path ( dep ) ) ; out . add ( cpEntry ) ; } return out ; }
public void delete ( String name ) throws CertificateException , IOException { if ( readOnly ) throw new CertificateException ( STRING + STRING ) ; X509AttributeName attr = new X509AttributeName ( name ) ; String id = attr . getPrefix ( ) ; if ( ! ( id . equalsIgnoreCase ( NAME ) ) ) { throw new CertificateException ( STRING + STRING + NAME + STRING + id ) ; } attr = new X509AttributeName ( attr . getSuffix ( ) ) ; id = attr . getPrefix ( ) ; if ( id . equalsIgnoreCase ( INFO ) ) { if ( attr . getSuffix ( ) != null ) { info = null ; } else { info . delete ( attr . getSuffix ( ) ) ; } } else if ( id . equalsIgnoreCase ( ALG_ID ) ) { algId = null ; } else if ( id . equalsIgnoreCase ( SIGNATURE ) ) { signature = null ; } else if ( id . equalsIgnoreCase ( SIGNED_CERT ) ) { signedCert = null ; } else { throw new CertificateException ( STRING + STRING + id ) ; } }
public void testLongConversionAndOrdering ( ) throws Exception { BytesRef previous = null ; BytesRef current = new BytesRef ( new byte [ Long . BYTES ] ) ; for ( long value = - _NUM ; value < _NUM ; value ++ ) { NumericUtils . longToSortableBytes ( value , current . bytes , current . offset ) ; if ( previous == null ) { previous = new BytesRef ( new byte [ Long . BYTES ] ) ; } else { assertTrue ( STRING , previous . compareTo ( current ) < _NUM ) ; } assertEquals ( STRING , value , NumericUtils . sortableBytesToLong ( current . bytes , current . offset ) ) ; System . arraycopy ( current . bytes , current . offset , previous . bytes , previous . offset , current . length ) ; } }
private void applyChanges ( ) { region . setFill ( new RadialGradient ( _NUM , _NUM , region . getWidth ( ) / _NUM , region . getHeight ( ) / _NUM , radius , _BOOL , CycleMethod . NO_CYCLE , new Stop ( _NUM , Color . TRANSPARENT ) , new Stop ( _NUM , Color . color ( color . getRed ( ) , color . getGreen ( ) , color . getBlue ( ) , intensity ) ) ) ) ; }
public void write ( byte [ ] buf ) throws IOException { output . write ( buf ) ; bytesWritten += buf . length ; }
public void writeMapping ( Writer w ) throws IOException { w . write ( STRING + ( new Date ( ) ) + STRING ) ; for ( Integer key : id2name . keySet ( ) ) { w . write ( key + STRING + id2name . get ( key ) + STRING ) ; } }
@ HLEFunction ( nid = _NUM , version = _NUM , checkInsideInterrupt = _BOOL ) public int __sceSasRevParam ( int sasCore , int delay , int feedback ) { checkSasHandleGood ( sasCore ) ; waveformEffectDelay = delay ; waveformEffectFeedback = feedback ; return _NUM ; }
private static JSONObject createFileTransferError ( int errorCode , String source , String target , String body , Integer httpStatus ) { JSONObject error = null ; try { error = new JSONObject ( ) ; error . put ( STRING , errorCode ) ; error . put ( STRING , source ) ; error . put ( STRING , target ) ; if ( body != null ) { error . put ( STRING , body ) ; } if ( httpStatus != null ) { error . put ( STRING , httpStatus ) ; } } catch ( JSONException e ) { Log . e ( LOG_TAG , e . getMessage ( ) , e ) ; } return error ; }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
public void accept ( final Path file ) throws InterruptedException { logger . info ( String . format ( STRING , file ) ) ; permits . acquire ( ) ; executor . execute ( new ConsumerTask ( file ) ) ; }
@ Override public void clearRect ( int x , int y , int width , int height ) { setStateToLocal ( ) ; Color saveColor = getColor ( ) ; setColor ( Color . white ) ; m_printstream . println ( xTransform ( xScale ( x ) ) + STRING + yTransform ( yScale ( y ) ) + STRING + xScale ( width ) + STRING + yScale ( height ) + STRING ) ; setColor ( saveColor ) ; }
public GossipService ( String cluster , String ipAddress , int port , String id , List < GossipMember > gossipMembers , GossipSettings settings , GossipListener listener ) throws InterruptedException , UnknownHostException { gossipManager = new RandomGossipManager ( cluster , ipAddress , port , id , settings , gossipMembers , listener ) ; }
public GossipService ( String cluster , String ipAddress , int port , String id , List < GossipMember > gossipMembers , GossipSettings settings , GossipListener listener ) throws InterruptedException , UnknownHostException { gossipManager = new RandomGossipManager ( cluster , ipAddress , port , id , settings , gossipMembers , listener ) ; }
private void addToContent ( final String name , final byte [ ] byteContents ) { Iterator < TransferContent > it = contents . iterator ( ) ; while ( it . hasNext ( ) ) { if ( name . equals ( it . next ( ) . name ) ) { logger . info ( STRING + name + STRING ) ; it . remove ( ) ; } } final TransferContent content = new TransferContent ( ) ; content . name = name ; content . cacheable = _BOOL ; logger . debug ( STRING + Integer . toString ( content . timestamp ) ) ; content . data = byteContents ; content . timestamp = CRC . cmpCRC ( content . data ) ; contents . add ( content ) ; }
@ SuppressWarnings ( STRING ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return _BOOL ; } return _BOOL ; }
@ SuppressWarnings ( STRING ) private static boolean isRegex ( String s ) { try { Pattern . compile ( s ) ; } catch ( PatternSyntaxException e ) { return _BOOL ; } return _BOOL ; }
protected String convertWithConvertMap ( String sqlStatement ) { try { sqlStatement = applyConvertMap ( cleanUpStatement ( sqlStatement ) ) ; } catch ( RuntimeException e ) { log . warning ( e . getLocalizedMessage ( ) ) ; m_exception = e ; } return sqlStatement ; }
public void translate ( double dx , double dy ) { if ( ! isRelative ( ) ) { x += dx ; y += dy ; } if ( sourcePoint != null ) { sourcePoint . setX ( sourcePoint . getX ( ) + dx ) ; sourcePoint . setY ( sourcePoint . getY ( ) + dy ) ; } if ( targetPoint != null ) { targetPoint . setX ( targetPoint . getX ( ) + dx ) ; targetPoint . setY ( targetPoint . getY ( ) + dy ) ; } if ( TRANSLATE_CONTROL_POINTS && points != null ) { int count = points . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { mxPoint pt = ( mxPoint ) points . get ( i ) ; pt . setX ( pt . getX ( ) + dx ) ; pt . setY ( pt . getY ( ) + dy ) ; } } }
public void translate ( double dx , double dy ) { if ( ! isRelative ( ) ) { x += dx ; y += dy ; } if ( sourcePoint != null ) { sourcePoint . setX ( sourcePoint . getX ( ) + dx ) ; sourcePoint . setY ( sourcePoint . getY ( ) + dy ) ; } if ( targetPoint != null ) { targetPoint . setX ( targetPoint . getX ( ) + dx ) ; targetPoint . setY ( targetPoint . getY ( ) + dy ) ; } if ( TRANSLATE_CONTROL_POINTS && points != null ) { int count = points . size ( ) ; for ( int i = _NUM ; i < count ; i ++ ) { mxPoint pt = ( mxPoint ) points . get ( i ) ; pt . setX ( pt . getX ( ) + dx ) ; pt . setY ( pt . getY ( ) + dy ) ; } } }
public FrameAnalysisResult [ ] analyseAllFrames ( ) { if ( analysisResults == null ) { ArrayList results = new ArrayList ( ) ; FrameAnalysisResult oneResult ; while ( ( oneResult = analyseNextFrame ( ) ) != null ) { results . add ( oneResult ) ; } analysisResults = ( FrameAnalysisResult [ ] ) results . toArray ( new FrameAnalysisResult [ _NUM ] ) ; } return analysisResults ; }
public FrameAnalysisResult [ ] analyseAllFrames ( ) { if ( analysisResults == null ) { ArrayList results = new ArrayList ( ) ; FrameAnalysisResult oneResult ; while ( ( oneResult = analyseNextFrame ( ) ) != null ) { results . add ( oneResult ) ; } analysisResults = ( FrameAnalysisResult [ ] ) results . toArray ( new FrameAnalysisResult [ _NUM ] ) ; } return analysisResults ; }
public FrameAnalysisResult [ ] analyseAllFrames ( ) { if ( analysisResults == null ) { ArrayList results = new ArrayList ( ) ; FrameAnalysisResult oneResult ; while ( ( oneResult = analyseNextFrame ( ) ) != null ) { results . add ( oneResult ) ; } analysisResults = ( FrameAnalysisResult [ ] ) results . toArray ( new FrameAnalysisResult [ _NUM ] ) ; } return analysisResults ; }
public FrameAnalysisResult [ ] analyseAllFrames ( ) { if ( analysisResults == null ) { ArrayList results = new ArrayList ( ) ; FrameAnalysisResult oneResult ; while ( ( oneResult = analyseNextFrame ( ) ) != null ) { results . add ( oneResult ) ; } analysisResults = ( FrameAnalysisResult [ ] ) results . toArray ( new FrameAnalysisResult [ _NUM ] ) ; } return analysisResults ; }
public FrameAnalysisResult [ ] analyseAllFrames ( ) { if ( analysisResults == null ) { ArrayList results = new ArrayList ( ) ; FrameAnalysisResult oneResult ; while ( ( oneResult = analyseNextFrame ( ) ) != null ) { results . add ( oneResult ) ; } analysisResults = ( FrameAnalysisResult [ ] ) results . toArray ( new FrameAnalysisResult [ _NUM ] ) ; } return analysisResults ; }
private String saveFileOnDisk ( String filePathToSave , String fileContent ) throws IOException { File file = new File ( filePathToSave ) ; Files . createParentDirs ( file ) ; Files . write ( fileContent , file , Charset . defaultCharset ( ) ) ; return filePathToSave ; }
private String saveFileOnDisk ( String filePathToSave , String fileContent ) throws IOException { File file = new File ( filePathToSave ) ; Files . createParentDirs ( file ) ; Files . write ( fileContent , file , Charset . defaultCharset ( ) ) ; return filePathToSave ; }
@ KnownFailure ( STRING ) public void testUpdate7 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . executeUpdate ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING + DatabaseCreator . PARENT_TABLE + STRING ) ; ResultSet r = statement . executeQuery ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING ) ; r . next ( ) ; assertEquals ( STRING , _NUM , r . getInt ( _NUM ) ) ; r . close ( ) ; }
@ KnownFailure ( STRING ) public void testUpdate7 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . executeUpdate ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING + DatabaseCreator . PARENT_TABLE + STRING ) ; ResultSet r = statement . executeQuery ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING ) ; r . next ( ) ; assertEquals ( STRING , _NUM , r . getInt ( _NUM ) ) ; r . close ( ) ; }
@ KnownFailure ( STRING ) public void testUpdate7 ( ) throws SQLException { DatabaseCreator . fillFKStrictTable ( conn ) ; statement . executeUpdate ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING + DatabaseCreator . PARENT_TABLE + STRING ) ; ResultSet r = statement . executeQuery ( STRING + DatabaseCreator . FKSTRICT_TABLE + STRING ) ; r . next ( ) ; assertEquals ( STRING , _NUM , r . getInt ( _NUM ) ) ; r . close ( ) ; }
public static PcRunner serializableInstance ( ) { return PcRunner . serializableInstance ( ) ; }
public static PcRunner serializableInstance ( ) { return PcRunner . serializableInstance ( ) ; }
protected void testGet ( ) throws Throwable { Operation op = Operation . createGet ( URI . create ( echoServiceUri ) ) ; testEchoOperation ( op ) ; }
protected void testGet ( ) throws Throwable { Operation op = Operation . createGet ( URI . create ( echoServiceUri ) ) ; testEchoOperation ( op ) ; }
protected void testGet ( ) throws Throwable { Operation op = Operation . createGet ( URI . create ( echoServiceUri ) ) ; testEchoOperation ( op ) ; }
protected void testGet ( ) throws Throwable { Operation op = Operation . createGet ( URI . create ( echoServiceUri ) ) ; testEchoOperation ( op ) ; }
public final List checkPatientsAssess ( Village v ) { List up = new List ( ) ; for ( Enumeration e = assess . elements ( ) ; e . hasMoreElements ( ) ; ) { Patient p = ( Patient ) e . nextElement ( ) ; p . timeLeft -= _NUM ; if ( p . timeLeft == _NUM ) { if ( v . staysHere ( ) ) { assess . delete ( p ) ; inside . add ( p ) ; p . timeLeft = _NUM ; p . time += _NUM ; } else { freePersonnel ++ ; assess . delete ( p ) ; up . add ( p ) ; } } } return up ; }
public static synchronized boolean prepareDirectory ( File directory ) { if ( directory . exists ( ) ) return _BOOL ; directory . mkdirs ( ) ; return directory . exists ( ) ; }
public void drawInRect ( GL10 gl , CGRect rect ) { gl . glEnable ( GL_TEXTURE_2D ) ; loadTexture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; mVertices . put ( vertices ) ; mVertices . position ( _NUM ) ; float coordinates [ ] = { _NUM , _maxT , _maxS , _maxT , _NUM , _NUM , _maxS , _NUM } ; mCoordinates . put ( coordinates ) ; mCoordinates . position ( _NUM ) ; gl . glEnableClientState ( GL_VERTEX_ARRAY ) ; gl . glEnableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glBindTexture ( GL_TEXTURE_2D , _name ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_REPEAT ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_REPEAT ) ; gl . glVertexPointer ( _NUM , GL_FLOAT , _NUM , mVertices ) ; gl . glTexCoordPointer ( _NUM , GL_FLOAT , _NUM , mCoordinates ) ; gl . glDrawArrays ( GL_TRIANGLE_STRIP , _NUM , _NUM ) ; gl . glDisableClientState ( GL_VERTEX_ARRAY ) ; gl . glDisableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glDisable ( GL_TEXTURE_2D ) ; }
public void drawInRect ( GL10 gl , CGRect rect ) { gl . glEnable ( GL_TEXTURE_2D ) ; loadTexture ( gl ) ; float vertices [ ] = { rect . origin . x , rect . origin . y , rect . origin . x + rect . size . width , rect . origin . y , rect . origin . x , rect . origin . y + rect . size . height , rect . origin . x + rect . size . width , rect . origin . y + rect . size . height } ; mVertices . put ( vertices ) ; mVertices . position ( _NUM ) ; float coordinates [ ] = { _NUM , _maxT , _maxS , _maxT , _NUM , _NUM , _maxS , _NUM } ; mCoordinates . put ( coordinates ) ; mCoordinates . position ( _NUM ) ; gl . glEnableClientState ( GL_VERTEX_ARRAY ) ; gl . glEnableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glBindTexture ( GL_TEXTURE_2D , _name ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_REPEAT ) ; gl . glTexParameterx ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_REPEAT ) ; gl . glVertexPointer ( _NUM , GL_FLOAT , _NUM , mVertices ) ; gl . glTexCoordPointer ( _NUM , GL_FLOAT , _NUM , mCoordinates ) ; gl . glDrawArrays ( GL_TRIANGLE_STRIP , _NUM , _NUM ) ; gl . glDisableClientState ( GL_VERTEX_ARRAY ) ; gl . glDisableClientState ( GL_TEXTURE_COORD_ARRAY ) ; gl . glDisable ( GL_TEXTURE_2D ) ; }
public FieldFrameBodyIMG ( Lyrics3Image image ) { images . add ( image ) ; }
private static Counter < String > loadWeights ( String wtsInitialFile , boolean uniformStartWeights , boolean randomizeStartWeights , TranslationModel < IString , String > translationModel ) { Counter < String > weights = IOTools . readWeights ( wtsInitialFile ) ; if ( weights == null ) weights = new ClassicCounter < > ( ) ; if ( uniformStartWeights ) { Set < String > featureNames = new HashSet < > ( weights . keySet ( ) ) ; featureNames . addAll ( FeatureUtils . getBaselineFeatures ( translationModel ) ) ; for ( String key : featureNames ) { if ( key . startsWith ( NGramLanguageModelFeaturizer . DEFAULT_FEATURE_NAME ) ) { weights . setCount ( key , _NUM ) ; } else if ( key . startsWith ( WordPenaltyFeaturizer . FEATURE_NAME ) ) { weights . setCount ( key , - _NUM ) ; } else { weights . setCount ( key , _NUM ) ; } } } if ( randomizeStartWeights ) { double scale = _NUM ; OptimizerUtils . randomizeWeightsInPlace ( weights , scale ) ; } return weights ; }
private static Counter < String > loadWeights ( String wtsInitialFile , boolean uniformStartWeights , boolean randomizeStartWeights , TranslationModel < IString , String > translationModel ) { Counter < String > weights = IOTools . readWeights ( wtsInitialFile ) ; if ( weights == null ) weights = new ClassicCounter < > ( ) ; if ( uniformStartWeights ) { Set < String > featureNames = new HashSet < > ( weights . keySet ( ) ) ; featureNames . addAll ( FeatureUtils . getBaselineFeatures ( translationModel ) ) ; for ( String key : featureNames ) { if ( key . startsWith ( NGramLanguageModelFeaturizer . DEFAULT_FEATURE_NAME ) ) { weights . setCount ( key , _NUM ) ; } else if ( key . startsWith ( WordPenaltyFeaturizer . FEATURE_NAME ) ) { weights . setCount ( key , - _NUM ) ; } else { weights . setCount ( key , _NUM ) ; } } } if ( randomizeStartWeights ) { double scale = _NUM ; OptimizerUtils . randomizeWeightsInPlace ( weights , scale ) ; } return weights ; }
public void unpinConnection ( String host , Integer port ) { connectionLock . lock ( ) ; try { String hostAndPort = ConnectionManager . generateConnectionCacheKey ( host , port ) ; if ( pinnedConnections . containsKey ( hostAndPort ) ) { Integer count = pinnedConnections . get ( hostAndPort ) - _NUM ; if ( count == _NUM ) { s_logger . info ( STRING , hostAndPort ) ; pinnedConnections . remove ( hostAndPort ) ; } else { s_logger . info ( STRING , hostAndPort , count ) ; pinnedConnections . put ( hostAndPort , count ) ; } } } finally { connectionLock . unlock ( ) ; } }
public void unpinConnection ( String host , Integer port ) { connectionLock . lock ( ) ; try { String hostAndPort = ConnectionManager . generateConnectionCacheKey ( host , port ) ; if ( pinnedConnections . containsKey ( hostAndPort ) ) { Integer count = pinnedConnections . get ( hostAndPort ) - _NUM ; if ( count == _NUM ) { s_logger . info ( STRING , hostAndPort ) ; pinnedConnections . remove ( hostAndPort ) ; } else { s_logger . info ( STRING , hostAndPort , count ) ; pinnedConnections . put ( hostAndPort , count ) ; } } } finally { connectionLock . unlock ( ) ; } }
public void unpinConnection ( String host , Integer port ) { connectionLock . lock ( ) ; try { String hostAndPort = ConnectionManager . generateConnectionCacheKey ( host , port ) ; if ( pinnedConnections . containsKey ( hostAndPort ) ) { Integer count = pinnedConnections . get ( hostAndPort ) - _NUM ; if ( count == _NUM ) { s_logger . info ( STRING , hostAndPort ) ; pinnedConnections . remove ( hostAndPort ) ; } else { s_logger . info ( STRING , hostAndPort , count ) ; pinnedConnections . put ( hostAndPort , count ) ; } } } finally { connectionLock . unlock ( ) ; } }
public String poll ( long timeout ) throws InterruptedException { lastTimeMillis = System . currentTimeMillis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == _NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > _NUM ) { result = STRING + buffer . toString ( ) + STRING ; buffer = new StringBuffer ( ) ; } notify ( ) ; } return result ; }
public String poll ( long timeout ) throws InterruptedException { lastTimeMillis = System . currentTimeMillis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == _NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > _NUM ) { result = STRING + buffer . toString ( ) + STRING ; buffer = new StringBuffer ( ) ; } notify ( ) ; } return result ; }
public String poll ( long timeout ) throws InterruptedException { lastTimeMillis = System . currentTimeMillis ( ) ; String result = STRING ; synchronized ( this ) { if ( buffer . length ( ) == _NUM ) { wait ( timeout ) ; } if ( buffer . length ( ) > _NUM ) { result = STRING + buffer . toString ( ) + STRING ; buffer = new StringBuffer ( ) ; } notify ( ) ; } return result ; }
@ Override public boolean hasFeature ( String feature , String version ) { return super . hasFeature ( feature , version ) || feature . equalsIgnoreCase ( STRING ) ; }
@ Override public boolean hasFeature ( String feature , String version ) { return super . hasFeature ( feature , version ) || feature . equalsIgnoreCase ( STRING ) ; }
@ Override public boolean hasFeature ( String feature , String version ) { return super . hasFeature ( feature , version ) || feature . equalsIgnoreCase ( STRING ) ; }
@ Override public boolean hasFeature ( String feature , String version ) { return super . hasFeature ( feature , version ) || feature . equalsIgnoreCase ( STRING ) ; }
@ Override public boolean hasFeature ( String feature , String version ) { return super . hasFeature ( feature , version ) || feature . equalsIgnoreCase ( STRING ) ; }
public void removeAt ( int index ) { System . arraycopy ( mKeys , index + _NUM , mKeys , index , mSize - ( index + _NUM ) ) ; System . arraycopy ( mValues , index + _NUM , mValues , index , mSize - ( index + _NUM ) ) ; -- mSize ; }
private boolean convergence ( List < Page > pages ) { double aveHubDelta = _NUM ; double aveAuthDelta = _NUM ; if ( pages == null ) { return _BOOL ; } double [ ] currHubVals = new double [ pages . size ( ) ] ; double [ ] currAuthVals = new double [ pages . size ( ) ] ; for ( int i = _NUM ; i < pages . size ( ) ; i ++ ) { Page currPage = pages . get ( i ) ; currHubVals [ i ] = currPage . hub ; currHubVals [ i ] = currPage . authority ; } if ( prevHubVals == null || prevAuthVals == null ) { prevHubVals = currHubVals ; prevAuthVals = currAuthVals ; return _BOOL ; } aveHubDelta = getAveDelta ( currHubVals , prevHubVals ) ; aveAuthDelta = getAveDelta ( currAuthVals , prevAuthVals ) ; if ( aveHubDelta + aveAuthDelta < DELTA_TOLERANCE || ( Math . abs ( prevAveHubDelta - aveHubDelta ) < _NUM && Math . abs ( prevAveAuthDelta - aveAuthDelta ) < _NUM ) ) { return _BOOL ; } else { prevHubVals = currHubVals ; prevAuthVals = currAuthVals ; prevAveHubDelta = aveHubDelta ; prevAveAuthDelta = aveAuthDelta ; return _BOOL ; } }
private boolean convergence ( List < Page > pages ) { double aveHubDelta = _NUM ; double aveAuthDelta = _NUM ; if ( pages == null ) { return _BOOL ; } double [ ] currHubVals = new double [ pages . size ( ) ] ; double [ ] currAuthVals = new double [ pages . size ( ) ] ; for ( int i = _NUM ; i < pages . size ( ) ; i ++ ) { Page currPage = pages . get ( i ) ; currHubVals [ i ] = currPage . hub ; currHubVals [ i ] = currPage . authority ; } if ( prevHubVals == null || prevAuthVals == null ) { prevHubVals = currHubVals ; prevAuthVals = currAuthVals ; return _BOOL ; } aveHubDelta = getAveDelta ( currHubVals , prevHubVals ) ; aveAuthDelta = getAveDelta ( currAuthVals , prevAuthVals ) ; if ( aveHubDelta + aveAuthDelta < DELTA_TOLERANCE || ( Math . abs ( prevAveHubDelta - aveHubDelta ) < _NUM && Math . abs ( prevAveAuthDelta - aveAuthDelta ) < _NUM ) ) { return _BOOL ; } else { prevHubVals = currHubVals ; prevAuthVals = currAuthVals ; prevAveHubDelta = aveHubDelta ; prevAveAuthDelta = aveAuthDelta ; return _BOOL ; } }
public AWS4SignerBase ( URL endpointUrl , String httpMethod , String serviceName , String regionName ) { this . endpointUrl = endpointUrl ; this . httpMethod = httpMethod ; this . serviceName = serviceName ; this . regionName = regionName ; dateTimeFormat = new SimpleDateFormat ( ISO8601BasicFormat ) ; dateTimeFormat . setTimeZone ( new SimpleTimeZone ( _NUM , STRING ) ) ; dateStampFormat = new SimpleDateFormat ( DateStringFormat ) ; dateStampFormat . setTimeZone ( new SimpleTimeZone ( _NUM , STRING ) ) ; }
public AccessPath dropFirstField ( ) { if ( fields == null || fields . length == _NUM ) return this ; final SootField [ ] newFields ; final Type [ ] newTypes ; if ( fields . length > _NUM ) { newFields = new SootField [ fields . length - _NUM ] ; System . arraycopy ( fields , _NUM , newFields , _NUM , fields . length - _NUM ) ; newTypes = new Type [ fields . length - _NUM ] ; System . arraycopy ( fieldTypes , _NUM , newTypes , _NUM , fields . length - _NUM ) ; } else { newFields = null ; newTypes = null ; } return new AccessPath ( value , newFields , fieldTypes [ _NUM ] , newTypes , taintSubFields ) ; }
public AccessPath dropFirstField ( ) { if ( fields == null || fields . length == _NUM ) return this ; final SootField [ ] newFields ; final Type [ ] newTypes ; if ( fields . length > _NUM ) { newFields = new SootField [ fields . length - _NUM ] ; System . arraycopy ( fields , _NUM , newFields , _NUM , fields . length - _NUM ) ; newTypes = new Type [ fields . length - _NUM ] ; System . arraycopy ( fieldTypes , _NUM , newTypes , _NUM , fields . length - _NUM ) ; } else { newFields = null ; newTypes = null ; } return new AccessPath ( value , newFields , fieldTypes [ _NUM ] , newTypes , taintSubFields ) ; }
public AccessPath dropFirstField ( ) { if ( fields == null || fields . length == _NUM ) return this ; final SootField [ ] newFields ; final Type [ ] newTypes ; if ( fields . length > _NUM ) { newFields = new SootField [ fields . length - _NUM ] ; System . arraycopy ( fields , _NUM , newFields , _NUM , fields . length - _NUM ) ; newTypes = new Type [ fields . length - _NUM ] ; System . arraycopy ( fieldTypes , _NUM , newTypes , _NUM , fields . length - _NUM ) ; } else { newFields = null ; newTypes = null ; } return new AccessPath ( value , newFields , fieldTypes [ _NUM ] , newTypes , taintSubFields ) ; }
public AccessPath dropFirstField ( ) { if ( fields == null || fields . length == _NUM ) return this ; final SootField [ ] newFields ; final Type [ ] newTypes ; if ( fields . length > _NUM ) { newFields = new SootField [ fields . length - _NUM ] ; System . arraycopy ( fields , _NUM , newFields , _NUM , fields . length - _NUM ) ; newTypes = new Type [ fields . length - _NUM ] ; System . arraycopy ( fieldTypes , _NUM , newTypes , _NUM , fields . length - _NUM ) ; } else { newFields = null ; newTypes = null ; } return new AccessPath ( value , newFields , fieldTypes [ _NUM ] , newTypes , taintSubFields ) ; }
public int addTmpStore ( IMXStore store ) { if ( null != store ) { int pos = mTmpStores . indexOf ( store ) ; if ( pos < _NUM ) { mTmpStores . add ( store ) ; pos = mTmpStores . indexOf ( store ) ; } return pos ; } return - _NUM ; }
public int addTmpStore ( IMXStore store ) { if ( null != store ) { int pos = mTmpStores . indexOf ( store ) ; if ( pos < _NUM ) { mTmpStores . add ( store ) ; pos = mTmpStores . indexOf ( store ) ; } return pos ; } return - _NUM ; }
public int addTmpStore ( IMXStore store ) { if ( null != store ) { int pos = mTmpStores . indexOf ( store ) ; if ( pos < _NUM ) { mTmpStores . add ( store ) ; pos = mTmpStores . indexOf ( store ) ; } return pos ; } return - _NUM ; }
public void start ( ) { if ( runner == null ) { runner = new Thread ( this , STRING ) ; runner . start ( ) ; } }
public void timeToSpeech ( String time ) { String theTime = timeToString ( time ) ; if ( theTime != null ) { textToSpeech ( theTime ) ; } else { throw new IllegalArgumentException ( STRING ) ; } }
public void timeToSpeech ( String time ) { String theTime = timeToString ( time ) ; if ( theTime != null ) { textToSpeech ( theTime ) ; } else { throw new IllegalArgumentException ( STRING ) ; } }
public void timeToSpeech ( String time ) { String theTime = timeToString ( time ) ; if ( theTime != null ) { textToSpeech ( theTime ) ; } else { throw new IllegalArgumentException ( STRING ) ; } }
private void fillCommentCombo ( Combo combo ) { if ( previousComments == null ) { previousComments = new ArrayList ( ) ; } for ( int i = previousComments . size ( ) - _NUM ; i >= _NUM ; i -- ) { combo . add ( ( ( String ) previousComments . get ( i ) ) ) ; } combo . select ( _NUM ) ; }
public ManifestEntryVerifier ( Manifest man ) { createdDigests = new HashMap < String , MessageDigest > ( _NUM ) ; digests = new ArrayList < MessageDigest > ( ) ; manifestHashes = new ArrayList < byte [ ] > ( ) ; this . man = man ; }
public void test_copyStream_fullBlockPlusOne ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE + _NUM ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM , _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
public void test_copyStream_fullBlockPlusOne ( ) throws IOException { final String id = STRING ; final int version = _NUM ; Random r = new Random ( ) ; final byte [ ] expected = new byte [ BLOCK_SIZE + _NUM ] ; r . nextBytes ( expected ) ; assertEquals ( STRING , expected . length , repo . copyStream ( id , version , new ByteArrayInputStream ( expected ) ) ) ; assertEquals ( STRING , _NUM , repo . getBlockCount ( id , version ) ) ; assertSameIterator ( STRING , new Long [ ] { _NUM , _NUM } , repo . blocks ( id , version ) ) ; assertEquals ( STRING , expected , read ( repo . inputStream ( id , version ) ) ) ; }
@ Deprecated public ConcurrentUpdateSolrClient ( String solrServerUrl , int queueSize , int threadCount ) { this ( solrServerUrl , null , queueSize , threadCount ) ; shutdownExecutor = _BOOL ; internalHttpClient = _BOOL ; }
final boolean tryWriteLock ( ) { Thread current = Thread . currentThread ( ) ; int c = getState ( ) ; if ( c != _NUM ) { int w = exclusiveCount ( c ) ; if ( w == _NUM || current != getExclusiveOwnerThread ( ) ) return _BOOL ; if ( w == MAX_COUNT ) throw new Error ( STRING ) ; } if ( ! compareAndSetState ( c , c + _NUM ) ) return _BOOL ; setExclusiveOwnerThread ( current ) ; return _BOOL ; }
final public void println ( char [ ] v ) { try { _out . println ( v ) ; } catch ( IOException e ) { log . log ( Level . FINE , e . toString ( ) , e ) ; } }
public Dimension preferredLayoutSize ( Container parent ) { return calculateLayoutSize ( parent , STRING ) ; }
public static void expandNumber ( String numberString , WordRelation wordRelation , Item tokenItem ) { int numDigits = numberString . length ( ) ; if ( numDigits == _NUM ) { } else if ( numDigits == _NUM ) { expandDigits ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits == _NUM ) { expand2DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits == _NUM ) { expand3DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < _NUM ) { expandBelow7DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < _NUM ) { expandBelow10DigitNumber ( numberString , wordRelation , tokenItem ) ; } else if ( numDigits < _NUM ) { expandBelow13DigitNumber ( numberString , wordRelation , tokenItem ) ; } else { expandDigits ( numberString , wordRelation , tokenItem ) ; } }
@ NotNull public static String normalize ( @ NotNull String path ) { int start = _NUM ; boolean separator = _BOOL ; if ( SystemInfo . isWindows ) { if ( path . startsWith ( STRING ) ) { start = _NUM ; separator = _BOOL ; } else if ( path . startsWith ( STRING ) ) { return normalizeTail ( _NUM , path , _BOOL ) ; } } for ( int i = start ; i < path . length ( ) ; ++ i ) { final char c = path . charAt ( i ) ; if ( c == STRING ) { if ( separator ) { return normalizeTail ( i , path , _BOOL ) ; } separator = _BOOL ; } else if ( c == STRING ) { return normalizeTail ( i , path , separator ) ; } else { separator = _BOOL ; } } return path ; }
@ NotNull public static String normalize ( @ NotNull String path ) { int start = _NUM ; boolean separator = _BOOL ; if ( SystemInfo . isWindows ) { if ( path . startsWith ( STRING ) ) { start = _NUM ; separator = _BOOL ; } else if ( path . startsWith ( STRING ) ) { return normalizeTail ( _NUM , path , _BOOL ) ; } } for ( int i = start ; i < path . length ( ) ; ++ i ) { final char c = path . charAt ( i ) ; if ( c == STRING ) { if ( separator ) { return normalizeTail ( i , path , _BOOL ) ; } separator = _BOOL ; } else if ( c == STRING ) { return normalizeTail ( i , path , separator ) ; } else { separator = _BOOL ; } } return path ; }
void bindWith ( final Circle circle ) { circles . add ( circle ) ; }
void bindWith ( final Circle circle ) { circles . add ( circle ) ; }
void bindWith ( final Circle circle ) { circles . add ( circle ) ; }
protected int x ( double xW ) { return ( int ) Math . round ( scale * ( xW + offsetX ) + borderLeft ) ; }
protected int x ( double xW ) { return ( int ) Math . round ( scale * ( xW + offsetX ) + borderLeft ) ; }
public void release ( PluginContext context ) throws ReplicatorException , InterruptedException { try { if ( lineReader != null ) { lineReader . close ( ) ; } } catch ( IOException e ) { throw new ReplicatorException ( STRING ) ; } }
public TypesItemProviderAdapterFactory ( ) { supportedTypes . add ( IEditingDomainItemProvider . class ) ; supportedTypes . add ( IStructuredItemContentProvider . class ) ; supportedTypes . add ( ITreeItemContentProvider . class ) ; supportedTypes . add ( IItemLabelProvider . class ) ; supportedTypes . add ( IItemPropertySource . class ) ; }
public TypesItemProviderAdapterFactory ( ) { supportedTypes . add ( IEditingDomainItemProvider . class ) ; supportedTypes . add ( IStructuredItemContentProvider . class ) ; supportedTypes . add ( ITreeItemContentProvider . class ) ; supportedTypes . add ( IItemLabelProvider . class ) ; supportedTypes . add ( IItemPropertySource . class ) ; }
public static String [ ] stringArrayFromString ( String string ) { return stringArrayFromString ( string , STRING ) ; }
protected final ResultSet executeScrollInsensitiveQuery ( String sqlString ) throws SQLException { final PreparedStatement ps = prepareStatement ( sqlString , ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; ps . execute ( ) ; return ps . getResultSet ( ) ; }
protected final ResultSet executeScrollInsensitiveQuery ( String sqlString ) throws SQLException { final PreparedStatement ps = prepareStatement ( sqlString , ResultSet . TYPE_SCROLL_INSENSITIVE , ResultSet . CONCUR_READ_ONLY ) ; ps . execute ( ) ; return ps . getResultSet ( ) ; }
@ SuppressWarnings ( STRING ) protected void doAppend ( Node el , Node parent ) { parent . appendChild ( el ) ; }
@ SuppressWarnings ( STRING ) protected void doAppend ( Node el , Node parent ) { parent . appendChild ( el ) ; }
@ SuppressWarnings ( STRING ) protected void doAppend ( Node el , Node parent ) { parent . appendChild ( el ) ; }
@ SuppressWarnings ( STRING ) protected void doAppend ( Node el , Node parent ) { parent . appendChild ( el ) ; }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
protected Object evaluateLeftGreaterRight ( List elements , String lvalue , String rvalue ) { List array ; if ( elements instanceof java . util . Vector ) { array = new java . util . Vector ( ) ; } else { array = new ArrayList ( ) ; } for ( Iterator e = elements . iterator ( ) ; e . hasNext ( ) ; ) { Object o = e . next ( ) ; if ( o instanceof StructuredContent ) { if ( ( o = evaluateLeftGreaterRight ( ( StructuredContent ) o , lvalue , rvalue ) ) != null ) { array . add ( o ) ; } } } if ( array . size ( ) == _NUM ) { return ( StructuredContent ) array . get ( _NUM ) ; } return array ; }
public ResultSet select ( String query ) throws SQLException { if ( ! isConnected ( ) ) { throw new IllegalStateException ( STRING ) ; } Statement statement ; if ( ! isCursorScrollable ( ) ) { statement = m_Connection . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; } else { statement = m_Connection . createStatement ( getSupportedCursorScrollType ( ) , ResultSet . CONCUR_READ_ONLY ) ; } ResultSet result = statement . executeQuery ( query ) ; return result ; }
public ResultSet select ( String query ) throws SQLException { if ( ! isConnected ( ) ) { throw new IllegalStateException ( STRING ) ; } Statement statement ; if ( ! isCursorScrollable ( ) ) { statement = m_Connection . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; } else { statement = m_Connection . createStatement ( getSupportedCursorScrollType ( ) , ResultSet . CONCUR_READ_ONLY ) ; } ResultSet result = statement . executeQuery ( query ) ; return result ; }
public ResultSet select ( String query ) throws SQLException { if ( ! isConnected ( ) ) { throw new IllegalStateException ( STRING ) ; } Statement statement ; if ( ! isCursorScrollable ( ) ) { statement = m_Connection . createStatement ( ResultSet . TYPE_FORWARD_ONLY , ResultSet . CONCUR_READ_ONLY ) ; } else { statement = m_Connection . createStatement ( getSupportedCursorScrollType ( ) , ResultSet . CONCUR_READ_ONLY ) ; } ResultSet result = statement . executeQuery ( query ) ; return result ; }
public void wakeUpUpdateThread ( ) { synchronized ( runLock ) { runLock . notifyAll ( ) ; } }
public void wakeUpUpdateThread ( ) { synchronized ( runLock ) { runLock . notifyAll ( ) ; } }
public void wakeUpUpdateThread ( ) { synchronized ( runLock ) { runLock . notifyAll ( ) ; } }
public void wakeUpUpdateThread ( ) { synchronized ( runLock ) { runLock . notifyAll ( ) ; } }
public static void writeExtensionMedia ( OutputStream theOs , String theStr ) throws IOException { theOs . write ( theStr . getBytes ( StandardCharsets . UTF_8 ) ) ; theOs . write ( ( byte ) _NUM ) ; }
public static void writeExtensionMedia ( OutputStream theOs , String theStr ) throws IOException { theOs . write ( theStr . getBytes ( StandardCharsets . UTF_8 ) ) ; theOs . write ( ( byte ) _NUM ) ; }
public static void writeExtensionMedia ( OutputStream theOs , String theStr ) throws IOException { theOs . write ( theStr . getBytes ( StandardCharsets . UTF_8 ) ) ; theOs . write ( ( byte ) _NUM ) ; }
public static void writeExtensionMedia ( OutputStream theOs , String theStr ) throws IOException { theOs . write ( theStr . getBytes ( StandardCharsets . UTF_8 ) ) ; theOs . write ( ( byte ) _NUM ) ; }
public static void writeExtensionMedia ( OutputStream theOs , String theStr ) throws IOException { theOs . write ( theStr . getBytes ( StandardCharsets . UTF_8 ) ) ; theOs . write ( ( byte ) _NUM ) ; }
public GradleDistribution deserializeFromString ( String distributionString ) { Preconditions . checkNotNull ( distributionString ) ; String localInstallationPrefix = STRING ; if ( distributionString . startsWith ( localInstallationPrefix ) && distributionString . endsWith ( STRING ) ) { String localInstallationDir = distributionString . substring ( localInstallationPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forLocalInstallation ( new File ( localInstallationDir ) ) ; } String remoteDistributionPrefix = STRING ; if ( distributionString . startsWith ( remoteDistributionPrefix ) && distributionString . endsWith ( STRING ) ) { String remoteDistributionUri = distributionString . substring ( remoteDistributionPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forRemoteDistribution ( createURI ( remoteDistributionUri ) ) ; } String versionPrefix = STRING ; if ( distributionString . startsWith ( versionPrefix ) && distributionString . endsWith ( STRING ) ) { String version = distributionString . substring ( versionPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forVersion ( version ) ; } String wrapperString = STRING ; if ( distributionString . equals ( wrapperString ) ) { return GradleDistribution . fromBuild ( ) ; } String message = String . format ( STRING , distributionString ) ; throw new RuntimeException ( message ) ; }
public GradleDistribution deserializeFromString ( String distributionString ) { Preconditions . checkNotNull ( distributionString ) ; String localInstallationPrefix = STRING ; if ( distributionString . startsWith ( localInstallationPrefix ) && distributionString . endsWith ( STRING ) ) { String localInstallationDir = distributionString . substring ( localInstallationPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forLocalInstallation ( new File ( localInstallationDir ) ) ; } String remoteDistributionPrefix = STRING ; if ( distributionString . startsWith ( remoteDistributionPrefix ) && distributionString . endsWith ( STRING ) ) { String remoteDistributionUri = distributionString . substring ( remoteDistributionPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forRemoteDistribution ( createURI ( remoteDistributionUri ) ) ; } String versionPrefix = STRING ; if ( distributionString . startsWith ( versionPrefix ) && distributionString . endsWith ( STRING ) ) { String version = distributionString . substring ( versionPrefix . length ( ) , distributionString . length ( ) - _NUM ) ; return GradleDistribution . forVersion ( version ) ; } String wrapperString = STRING ; if ( distributionString . equals ( wrapperString ) ) { return GradleDistribution . fromBuild ( ) ; } String message = String . format ( STRING , distributionString ) ; throw new RuntimeException ( message ) ; }
protected KeyPairGenerator ( String algorithm ) { this . algorithm = algorithm ; }
public void testActiveJoin ( ) throws Throwable { testServerJoin ( Member . Type . ACTIVE ) ; }
public void writeNoScale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getWidth ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= prFirst ) { page . drawImage ( c , x , y , c . getWidth ( null ) , c . getHeight ( null ) , null ) ; } }
public void writeNoScale ( Image c , Component i ) { if ( page == null ) { newpage ( ) ; } int x = x0 + width - ( c . getWidth ( null ) + charwidth ) ; int y = y0 + ( linenum * lineheight ) + lineascent ; if ( page != null && pagenum >= prFirst ) { page . drawImage ( c , x , y , c . getWidth ( null ) , c . getHeight ( null ) , null ) ; } }
private void removeInterest ( SelectableChannel channel , int operation ) { SelectionKey key = channel . keyFor ( selector ) ; key . interestOps ( key . interestOps ( ) & ( ~ operation ) ) ; }
private void removeInterest ( SelectableChannel channel , int operation ) { SelectionKey key = channel . keyFor ( selector ) ; key . interestOps ( key . interestOps ( ) & ( ~ operation ) ) ; }
public PrivateKey loadPrivateKey ( ) throws Exception { if ( defaultKeys ) { return getPrivateKeyFromString ( RSAKeyLoader . DEFAULT_PKEY ) ; } if ( priKey == null ) { FileReader f = new FileReader ( path + STRING + this . id ) ; BufferedReader r = new BufferedReader ( f ) ; String tmp = STRING ; String key = STRING ; while ( ( tmp = r . readLine ( ) ) != null ) { key = key + tmp ; } f . close ( ) ; r . close ( ) ; priKey = getPrivateKeyFromString ( key ) ; } return priKey ; }
public Consensus removeConsensus ( int id ) { consensusesLock . lock ( ) ; Consensus consensus = consensuses . remove ( id ) ; for ( int i = lastRemovedCID ; i < id ; i ++ ) consensuses . remove ( i ) ; lastRemovedCID = id ; consensusesLock . unlock ( ) ; outOfContextLock . lock ( ) ; outOfContextProposes . remove ( id ) ; outOfContext . remove ( id ) ; outOfContextLock . unlock ( ) ; return consensus ; }
protected void estimateCardinality ( StatementPatternNode sp , final AST2BOpContext ctx , final IBindingSet exogenousBindings , final int nrExogeneousBindings ) { final AtomicBoolean usesExogeneousBindings = new AtomicBoolean ( _BOOL ) ; final IV < ? , ? > s = getIV ( sp . s ( ) , exogenousBindings , usesExogeneousBindings ) ; final IV < ? , ? > p = getIV ( sp . p ( ) , exogenousBindings , usesExogeneousBindings ) ; final IV < ? , ? > o = getIV ( sp . o ( ) , exogenousBindings , usesExogeneousBindings ) ; final IV < ? , ? > c = getIV ( sp . c ( ) , exogenousBindings , usesExogeneousBindings ) ; final int exogenousBindingsAdjustmentFactor = usesExogeneousBindings . get ( ) ? Math . max ( _NUM , nrExogeneousBindings ) : _NUM ; estimateCardinalities ( sp , s , p , o , c , ctx , exogenousBindingsAdjustmentFactor ) ; }
private int keepSpriteOnMapY ( Sprite sprite , int sy ) { sy = Math . max ( sy , _NUM ) ; if ( wh != _NUM ) { sy = Math . min ( sy , Math . max ( getHeight ( ) + svy , convertWorldYToScaledScreen ( wh ) ) - sprite . getHeight ( ) ) ; } return sy ; }
private int keepSpriteOnMapY ( Sprite sprite , int sy ) { sy = Math . max ( sy , _NUM ) ; if ( wh != _NUM ) { sy = Math . min ( sy , Math . max ( getHeight ( ) + svy , convertWorldYToScaledScreen ( wh ) ) - sprite . getHeight ( ) ) ; } return sy ; }
public boolean offer ( E event , int taskId ) throws InterruptedException { assertNotDone ( ) ; if ( predicate . match ( event ) ) { this . matched [ taskId ] = _BOOL ; for ( boolean match : matched ) { if ( ! match ) return _BOOL ; } responseQueue . put ( new EventHolder ( event ) ) ; done = _BOOL ; return _BOOL ; } else return _BOOL ; }
public void findAndUndo ( Iterator it ) { while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
public void findAndUndo ( Iterator it ) { while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
public void findAndUndo ( Iterator it ) { while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
public void findAndUndo ( Iterator it ) { while ( it . hasNext ( ) ) { findAndUndo ( it . next ( ) ) ; } }
public static String removeOrderTerm ( HttpServletRequest request , HttpServletResponse response ) { ShoppingCart cart = getCartObject ( request ) ; String termIndexStr = request . getParameter ( STRING ) ; if ( UtilValidate . isNotEmpty ( termIndexStr ) ) { try { Integer termIndex = Integer . parseInt ( termIndexStr ) ; if ( termIndex >= _NUM ) { List < GenericValue > orderTerms = cart . getOrderTerms ( ) ; if ( orderTerms != null && orderTerms . size ( ) > termIndex ) { cart . removeOrderTerm ( termIndex ) ; } } } catch ( NumberFormatException e ) { Debug . logWarning ( e , STRING + termIndexStr , module ) ; } } return STRING ; }
@ Override public < V > MethodVault < V > newMethod ( Class < ? > type , String methodName , Class < ? > [ ] paramTypes ) { Objects . requireNonNull ( type ) ; MethodVault < V > method = newMethodRec ( type , methodName , paramTypes ) ; if ( method != null ) { return method ; } throw new IllegalStateException ( L . l ( STRING , type . getSimpleName ( ) , methodName , Arrays . asList ( paramTypes ) ) ) ; }
private void cleanUpHistory ( ) { if ( ! mHistoryOfNumbers . isEmpty ( ) && mHistoryOfNumbers . size ( ) >= MAX_HISTORY_SIZE ) { for ( int i = _NUM ; i < Math . max ( _NUM , MAX_HISTORY_SIZE / _NUM ) ; i ++ ) { mPreviousNumbers . remove ( mHistoryOfNumbers . removeFirst ( ) ) ; } } }
public Edge ( S src , Symbol symbol , S dest ) { this . src = src ; this . symbol = symbol ; this . dest = dest ; this . srcItem = src . getFirstItem ( ) ; this . hashCache = calcHashCode ( ) ; }
private void create ( ) { DocumentBuilderFactory docBFac ; DocumentBuilder docBuild ; try { docBFac = DocumentBuilderFactory . newInstance ( ) ; docBuild = docBFac . newDocumentBuilder ( ) ; doc = docBuild . newDocument ( ) ; } catch ( Exception ex ) { ex . printStackTrace ( ) ; return ; } rootElement = doc . createElement ( STRING ) ; doc . appendChild ( rootElement ) ; nonValidatedRequestsElement = doc . createElement ( STRING ) ; validatedRequestsElement = doc . createElement ( STRING ) ; rootElement . appendChild ( nonValidatedRequestsElement ) ; rootElement . appendChild ( validatedRequestsElement ) ; writeXMLFile ( ) ; }
public IgniteSpiVersionCheckException ( Throwable cause ) { this ( cause . getMessage ( ) , cause ) ; }
private static CInliningResult inlineFunctionSilently ( final JFrame parent , final IViewContainer viewContainer , final ZyGraph graph , final INaviCodeNode node , final INaviInstruction instruction , final INaviFunction function ) { final INaviFunction inlineFunction = prepareFunctionInlining ( parent , node , instruction , function , viewContainer ) ; if ( inlineFunction == null ) { return null ; } else if ( inlineFunction . getBasicBlockCount ( ) == _NUM ) { return null ; } else { try { if ( ! inlineFunction . isLoaded ( ) ) { inlineFunction . load ( ) ; } return CInliningHelper . inlineCodeNode ( graph . getRawView ( ) , node , instruction , inlineFunction ) ; } catch ( final CouldntLoadDataException e ) { exceptionDialog ( parent , inlineFunction , e ) ; } } return null ; }
public void onError ( DiagnosticListener < JavaFileObject > callback ) { errorsDelegate = callback ; }
public void onError ( DiagnosticListener < JavaFileObject > callback ) { errorsDelegate = callback ; }
protected void responseSent ( StreamResponseMessage responseMessage ) { if ( syncProtocol != null ) syncProtocol . responseSent ( responseMessage ) ; }
@ ExceptionHandler ( { RegionNotFoundException . class , ResourceNotFoundException . class } ) @ ResponseBody @ ResponseStatus ( HttpStatus . NOT_FOUND ) public String handle ( final RuntimeException e ) { return convertErrorAsJson ( e . getMessage ( ) ) ; }
@ ExceptionHandler ( { RegionNotFoundException . class , ResourceNotFoundException . class } ) @ ResponseBody @ ResponseStatus ( HttpStatus . NOT_FOUND ) public String handle ( final RuntimeException e ) { return convertErrorAsJson ( e . getMessage ( ) ) ; }
@ ExceptionHandler ( { RegionNotFoundException . class , ResourceNotFoundException . class } ) @ ResponseBody @ ResponseStatus ( HttpStatus . NOT_FOUND ) public String handle ( final RuntimeException e ) { return convertErrorAsJson ( e . getMessage ( ) ) ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STRING ) ; } stack . remove ( stack . size ( ) - _NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STRING ) ; } stack . remove ( stack . size ( ) - _NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
JSONStringer close ( Scope empty , Scope nonempty , String closeBracket ) throws JSONException { Scope context = peek ( ) ; if ( context != nonempty && context != empty ) { throw new JSONException ( STRING ) ; } stack . remove ( stack . size ( ) - _NUM ) ; if ( context == nonempty ) { newline ( ) ; } out . append ( closeBracket ) ; return this ; }
public int arrayIndexScale ( Class clazz ) { if ( ! clazz . isArray ( ) ) { throw new IllegalArgumentException ( STRING ) ; } return arrayIndexScale0 ( clazz ) ; }
@ Override public void writeAttribute ( String localName , String value ) throws XMLStreamException { writeAttribute ( null , null , localName , value ) ; }
private List < MBrowseField > initBrowserTable ( ) { List < MBrowseField > list = initBrowserData ( ) ; if ( list . size ( ) == _NUM ) { FDialog . error ( getWindowNo ( ) , m_frame , STRING , STRING ) ; log . log ( Level . SEVERE , STRING + m_View . getName ( ) ) ; return null ; } log . finest ( STRING + list . size ( ) ) ; return list ; }
private List < MBrowseField > initBrowserTable ( ) { List < MBrowseField > list = initBrowserData ( ) ; if ( list . size ( ) == _NUM ) { FDialog . error ( getWindowNo ( ) , m_frame , STRING , STRING ) ; log . log ( Level . SEVERE , STRING + m_View . getName ( ) ) ; return null ; } log . finest ( STRING + list . size ( ) ) ; return list ; }
public static Object tryParse ( String value ) { try { return parseByDatatypeName ( value , UUIDDatatype . NAME ) ; } catch ( Exception ignored ) { } try { return parseByDatatypeName ( value , DateTimeDatatype . NAME ) ; } catch ( ParseException ignored ) { } try { return parseByDatatypeName ( value , TimeDatatype . NAME ) ; } catch ( ParseException ignored ) { } try { return parseByDatatypeName ( value , DateDatatype . NAME ) ; } catch ( ParseException ignored ) { } try { return parseByDatatypeName ( value , BigDecimalDatatype . NAME ) ; } catch ( ParseException ignored ) { } try { return parseByDatatypeName ( value , DoubleDatatype . NAME ) ; } catch ( ParseException ignored ) { } try { if ( value . equalsIgnoreCase ( STRING ) || value . equalsIgnoreCase ( STRING ) ) { return parseByDatatypeName ( value , BooleanDatatype . NAME ) ; } } catch ( ParseException ignored ) { } return value ; }
public DSubjectKeyIdentifier ( JDialog parent , PublicKey subjectPublicKey ) { super ( parent ) ; setTitle ( res . getString ( STRING ) ) ; this . subjectPublicKey = subjectPublicKey ; initComponents ( ) ; }
public void drawLine ( List < mxPoint > pts , Map < String , Object > style ) { String strokeColor = mxUtils . getString ( style , mxConstants . STYLE_STROKECOLOR ) ; int strokeWidth = ( int ) ( mxUtils . getInt ( style , mxConstants . STYLE_STROKEWIDTH , _NUM ) * scale ) ; if ( strokeColor != null && strokeWidth > _NUM ) { mxPoint last = pts . get ( _NUM ) ; for ( int i = _NUM ; i < pts . size ( ) ; i ++ ) { mxPoint pt = pts . get ( i ) ; drawSegment ( ( int ) last . getX ( ) , ( int ) last . getY ( ) , ( int ) pt . getX ( ) , ( int ) pt . getY ( ) , strokeColor , strokeWidth ) ; last = pt ; } } }
public void clear ( ) { m_textArea . setText ( STRING ) ; }
public RestApi ( String name ) { if ( name . startsWith ( STRING ) ) { name = name . substring ( _NUM ) ; } url = new StringBuilder ( ) ; url . append ( GWT . getHostPageBaseURL ( ) ) ; url . append ( name ) ; }
public RestApi ( String name ) { if ( name . startsWith ( STRING ) ) { name = name . substring ( _NUM ) ; } url = new StringBuilder ( ) ; url . append ( GWT . getHostPageBaseURL ( ) ) ; url . append ( name ) ; }
@ SuppressWarnings ( { STRING , STRING } ) public static int selectPivotIndex ( Object ar [ ] , int left , int right , Comparator comparator ) { int midIndex = ( left + right ) / _NUM ; int lowIndex = left ; if ( comparator . compare ( ar [ lowIndex ] , ar [ midIndex ] ) >= _NUM ) { lowIndex = midIndex ; midIndex = left ; } if ( comparator . compare ( ar [ right ] , ar [ lowIndex ] ) <= _NUM ) { return lowIndex ; } else if ( comparator . compare ( ar [ right ] , ar [ midIndex ] ) <= _NUM ) { return right ; } return midIndex ; }
public static InputStream executeSolrCommandAndGetInputStreamWithTimeout ( int timeout , String command ) throws IOException { URL obj = new URL ( command ) ; HttpURLConnection con = ( HttpURLConnection ) obj . openConnection ( ) ; con . setRequestMethod ( STRING ) ; con . setConnectTimeout ( timeout ) ; con . setReadTimeout ( timeout ) ; return con . getInputStream ( ) ; }
protected Function < Object [ ] , Object > createKeyGenerator ( Schema schema , TableId columnSetName , List < Column > columns ) { if ( schema != null ) { int [ ] recordIndexes = indexesForColumns ( columns ) ; Field [ ] fields = fieldsForColumns ( schema , columns ) ; int numFields = recordIndexes . length ; ValueConverter [ ] converters = convertersForColumns ( schema , columnSetName , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > createKeyGenerator ( Schema schema , TableId columnSetName , List < Column > columns ) { if ( schema != null ) { int [ ] recordIndexes = indexesForColumns ( columns ) ; Field [ ] fields = fieldsForColumns ( schema , columns ) ; int numFields = recordIndexes . length ; ValueConverter [ ] converters = convertersForColumns ( schema , columnSetName , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > createKeyGenerator ( Schema schema , TableId columnSetName , List < Column > columns ) { if ( schema != null ) { int [ ] recordIndexes = indexesForColumns ( columns ) ; Field [ ] fields = fieldsForColumns ( schema , columns ) ; int numFields = recordIndexes . length ; ValueConverter [ ] converters = convertersForColumns ( schema , columnSetName , columns , null , null ) ; return null ; } return null ; }
protected Function < Object [ ] , Object > createKeyGenerator ( Schema schema , TableId columnSetName , List < Column > columns ) { if ( schema != null ) { int [ ] recordIndexes = indexesForColumns ( columns ) ; Field [ ] fields = fieldsForColumns ( schema , columns ) ; int numFields = recordIndexes . length ; ValueConverter [ ] converters = convertersForColumns ( schema , columnSetName , columns , null , null ) ; return null ; } return null ; }
protected Object takeGetMethodValueByField ( DataSupport dataSupport , Field field ) throws SecurityException , NoSuchMethodException , IllegalArgumentException , IllegalAccessException , InvocationTargetException { if ( shouldGetOrSet ( dataSupport , field ) ) { String getMethodName = makeGetterMethodName ( field ) ; return DynamicExecutor . send ( dataSupport , getMethodName , null , dataSupport . getClass ( ) , null ) ; } return null ; }
public static PlaceholderFragment newInstance ( int sectionNumber ) { PlaceholderFragment fragment = new PlaceholderFragment ( ) ; Bundle args = new Bundle ( ) ; args . putInt ( ARG_SECTION_NUMBER , sectionNumber ) ; fragment . setArguments ( args ) ; return fragment ; }
private static Marker [ ] createMarkerArray ( final List < Double > initialFive , final double p ) { final int countObserved = initialFive == null ? - _NUM : initialFive . size ( ) ; if ( countObserved < PSQUARE_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedCoreFormats . INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE , countObserved , PSQUARE_CONSTANT ) ; } Collections . sort ( initialFive ) ; return new Marker [ ] { new Marker ( ) , new Marker ( initialFive . get ( _NUM ) , _NUM , _NUM , _NUM ) , new Marker ( initialFive . get ( _NUM ) , _NUM + _NUM * p , p / _NUM , _NUM ) , new Marker ( initialFive . get ( _NUM ) , _NUM + _NUM * p , p , _NUM ) , new Marker ( initialFive . get ( _NUM ) , _NUM + _NUM * p , ( _NUM + p ) / _NUM , _NUM ) , new Marker ( initialFive . get ( _NUM ) , _NUM , _NUM , _NUM ) } ; }
public void writingRequestHeaders ( ) { if ( sentRequestMillis != - _NUM ) throw new IllegalStateException ( ) ; sentRequestMillis = System . currentTimeMillis ( ) ; }
public void writingRequestHeaders ( ) { if ( sentRequestMillis != - _NUM ) throw new IllegalStateException ( ) ; sentRequestMillis = System . currentTimeMillis ( ) ; }
public void writingRequestHeaders ( ) { if ( sentRequestMillis != - _NUM ) throw new IllegalStateException ( ) ; sentRequestMillis = System . currentTimeMillis ( ) ; }
private boolean putInternal ( String variable , Object value ) { Object oldValue = values . get ( variable ) ; values . put ( variable , value ) ; if ( oldValue == null ) { return value != null ; } else { return ! oldValue . equals ( value ) ; } }
private boolean putInternal ( String variable , Object value ) { Object oldValue = values . get ( variable ) ; values . put ( variable , value ) ; if ( oldValue == null ) { return value != null ; } else { return ! oldValue . equals ( value ) ; } }
private List < Object > createObjectList ( Object object , List < Object > objectList ) { if ( areFiltersPassed ( object ) && ! getExpandedState ( object ) ) { if ( childrenLoaded ( object ) ) { expandToLevel ( object , _NUM ) ; } else { if ( objectList == null ) { objectList = new ArrayList < > ( ) ; } objectList . add ( object ) ; } } Object parent = getParentElement ( object ) ; if ( null != parent ) { createObjectList ( parent , objectList ) ; } return objectList ; }
private List < Object > createObjectList ( Object object , List < Object > objectList ) { if ( areFiltersPassed ( object ) && ! getExpandedState ( object ) ) { if ( childrenLoaded ( object ) ) { expandToLevel ( object , _NUM ) ; } else { if ( objectList == null ) { objectList = new ArrayList < > ( ) ; } objectList . add ( object ) ; } } Object parent = getParentElement ( object ) ; if ( null != parent ) { createObjectList ( parent , objectList ) ; } return objectList ; }
private List < Object > createObjectList ( Object object , List < Object > objectList ) { if ( areFiltersPassed ( object ) && ! getExpandedState ( object ) ) { if ( childrenLoaded ( object ) ) { expandToLevel ( object , _NUM ) ; } else { if ( objectList == null ) { objectList = new ArrayList < > ( ) ; } objectList . add ( object ) ; } } Object parent = getParentElement ( object ) ; if ( null != parent ) { createObjectList ( parent , objectList ) ; } return objectList ; }
public void copyReader ( String encoding , Reader r ) throws IOException { super . setContentEncoding ( encoding ) ; String s = readString ( r ) ; content = s . getBytes ( encoding ) ; }
public void load ( Path settingsPath ) { mLoadingSettings = _BOOL ; if ( Files . exists ( settingsPath ) ) { mLog . info ( STRING + settingsPath . toString ( ) + STRING ) ; JAXBContext context = null ; InputStream in = null ; try { in = new FileInputStream ( settingsPath . toString ( ) ) ; try { context = JAXBContext . newInstance ( Settings . class ) ; Unmarshaller m = context . createUnmarshaller ( ) ; mSettings = ( Settings ) m . unmarshal ( in ) ; } catch ( JAXBException e ) { mLog . error ( STRING + STRING , e ) ; } } catch ( Exception e ) { mLog . error ( STRING + STRING + settingsPath . toString ( ) + STRING , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { mLog . error ( STRING + STRING , e ) ; } } } } else { mLog . info ( STRING + settingsPath . toString ( ) + STRING ) ; } if ( mSettings == null ) { mSettings = new Settings ( ) ; } loadTunerConfigurationModel ( ) ; mLoadingSettings = _BOOL ; }
public void load ( Path settingsPath ) { mLoadingSettings = _BOOL ; if ( Files . exists ( settingsPath ) ) { mLog . info ( STRING + settingsPath . toString ( ) + STRING ) ; JAXBContext context = null ; InputStream in = null ; try { in = new FileInputStream ( settingsPath . toString ( ) ) ; try { context = JAXBContext . newInstance ( Settings . class ) ; Unmarshaller m = context . createUnmarshaller ( ) ; mSettings = ( Settings ) m . unmarshal ( in ) ; } catch ( JAXBException e ) { mLog . error ( STRING + STRING , e ) ; } } catch ( Exception e ) { mLog . error ( STRING + STRING + settingsPath . toString ( ) + STRING , e ) ; } finally { if ( in != null ) { try { in . close ( ) ; } catch ( IOException e ) { mLog . error ( STRING + STRING , e ) ; } } } } else { mLog . info ( STRING + settingsPath . toString ( ) + STRING ) ; } if ( mSettings == null ) { mSettings = new Settings ( ) ; } loadTunerConfigurationModel ( ) ; mLoadingSettings = _BOOL ; }
public void savePc ( int pc ) { savedPc = pc ; }
@ Override public void drawRangeGridline ( Graphics2D g2 , CategoryPlot plot , ValueAxis axis , Rectangle2D dataArea , double value ) { Range range = axis . getRange ( ) ; if ( ! range . contains ( value ) ) { return ; } PlotOrientation orientation = plot . getOrientation ( ) ; double v = axis . valueToJava2D ( value , dataArea , plot . getRangeAxisEdge ( ) ) ; Line2D line = null ; if ( orientation == PlotOrientation . HORIZONTAL ) { line = new Line2D . Double ( v , dataArea . getMinY ( ) , v , dataArea . getMaxY ( ) ) ; } else if ( orientation == PlotOrientation . VERTICAL ) { line = new Line2D . Double ( dataArea . getMinX ( ) , v , dataArea . getMaxX ( ) , v ) ; } Paint paint = plot . getRangeGridlinePaint ( ) ; if ( paint == null ) { paint = CategoryPlot . DEFAULT_GRIDLINE_PAINT ; } g2 . setPaint ( paint ) ; Stroke stroke = plot . getRangeGridlineStroke ( ) ; if ( stroke == null ) { stroke = CategoryPlot . DEFAULT_GRIDLINE_STROKE ; } g2 . setStroke ( stroke ) ; g2 . draw ( line ) ; }
public void addPassThroughCondition ( PassThroughOrGenerateRuleCondition condition ) { passThroughConditions . add ( condition ) ; }
@ Override public ToDoubleFunction < Stream < Tuple2 < F , Double > > > dist ( Stream < Tuple2 < F , Double > > features1 ) { Object2DoubleMap < F > auxMap = new Object2DoubleOpenHashMap < > ( ) ; auxMap . defaultReturnValue ( _NUM ) ; DoubleAdder norm1 = new DoubleAdder ( ) ; features1 . forEach ( null ) ; if ( norm1 . doubleValue ( ) == _NUM ) { return null ; } return null ; }
@ Override public ToDoubleFunction < Stream < Tuple2 < F , Double > > > dist ( Stream < Tuple2 < F , Double > > features1 ) { Object2DoubleMap < F > auxMap = new Object2DoubleOpenHashMap < > ( ) ; auxMap . defaultReturnValue ( _NUM ) ; DoubleAdder norm1 = new DoubleAdder ( ) ; features1 . forEach ( null ) ; if ( norm1 . doubleValue ( ) == _NUM ) { return null ; } return null ; }
private void write ( Coordinate [ ] coords , int level , StringBuffer buf ) { startLine ( STRING , level , buf ) ; boolean isNewLine = _BOOL ; for ( int i = _NUM ; i < coords . length ; i ++ ) { if ( i > _NUM ) { buf . append ( TUPLE_SEPARATOR ) ; } if ( isNewLine ) { startLine ( STRING , level , buf ) ; isNewLine = _BOOL ; } write ( coords [ i ] , buf ) ; if ( ( i + _NUM ) % maxCoordinatesPerLine == _NUM && i < coords . length - _NUM ) { buf . append ( STRING ) ; isNewLine = _BOOL ; } } buf . append ( STRING ) ; }
public synchronized void updatePatientObsUi ( int chartNum ) { mObservations = mChartHelper . getObservations ( mPatientUuid ) ; Map < String , Obs > latestObservations = new HashMap < > ( mChartHelper . getLatestObservations ( mPatientUuid ) ) ; List < Order > orders = mChartHelper . getOrders ( mPatientUuid ) ; mOrdersByUuid = new HashMap < > ( ) ; for ( Order order : orders ) { mOrdersByUuid . put ( order . uuid , order ) ; } LOG . d ( STRING + mObservations . size ( ) + STRING + orders . size ( ) + STRING ) ; LocalDate admissionDate = getObservedDate ( latestObservations , ConceptUuids . ADMISSION_DATE_UUID ) ; LocalDate firstSymptomsDate = getObservedDate ( latestObservations , ConceptUuids . FIRST_SYMPTOM_DATE_UUID ) ; mUi . updateAdmissionDateAndFirstSymptomsDateUi ( admissionDate , firstSymptomsDate ) ; mUi . updateWeightUi ( latestObservations ) ; mUi . updateEbolaPcrTestResultUi ( latestObservations ) ; mUi . updatePregnancyAndIvStatusUi ( latestObservations ) ; lastChartIndex = chartNum ; mUi . updateTilesAndGrid ( mCharts . get ( chartNum ) , latestObservations , mObservations , orders , admissionDate , firstSymptomsDate ) ; }
public synchronized void updatePatientObsUi ( int chartNum ) { mObservations = mChartHelper . getObservations ( mPatientUuid ) ; Map < String , Obs > latestObservations = new HashMap < > ( mChartHelper . getLatestObservations ( mPatientUuid ) ) ; List < Order > orders = mChartHelper . getOrders ( mPatientUuid ) ; mOrdersByUuid = new HashMap < > ( ) ; for ( Order order : orders ) { mOrdersByUuid . put ( order . uuid , order ) ; } LOG . d ( STRING + mObservations . size ( ) + STRING + orders . size ( ) + STRING ) ; LocalDate admissionDate = getObservedDate ( latestObservations , ConceptUuids . ADMISSION_DATE_UUID ) ; LocalDate firstSymptomsDate = getObservedDate ( latestObservations , ConceptUuids . FIRST_SYMPTOM_DATE_UUID ) ; mUi . updateAdmissionDateAndFirstSymptomsDateUi ( admissionDate , firstSymptomsDate ) ; mUi . updateWeightUi ( latestObservations ) ; mUi . updateEbolaPcrTestResultUi ( latestObservations ) ; mUi . updatePregnancyAndIvStatusUi ( latestObservations ) ; lastChartIndex = chartNum ; mUi . updateTilesAndGrid ( mCharts . get ( chartNum ) , latestObservations , mObservations , orders , admissionDate , firstSymptomsDate ) ; }
public static List < Entry > loadEntriesFromFile ( String path ) { File sdcard = Environment . getExternalStorageDirectory ( ) ; File file = new File ( sdcard , path ) ; List < Entry > entries = new ArrayList < Entry > ( ) ; try { @ SuppressWarnings ( STRING ) BufferedReader br = new BufferedReader ( new FileReader ( file ) ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] split = line . split ( STRING ) ; if ( split . length <= _NUM ) { entries . add ( new Entry ( Float . parseFloat ( split [ _NUM ] ) , Integer . parseInt ( split [ _NUM ] ) ) ) ; } else { float [ ] vals = new float [ split . length - _NUM ] ; for ( int i = _NUM ; i < vals . length ; i ++ ) { vals [ i ] = Float . parseFloat ( split [ i ] ) ; } entries . add ( new BarEntry ( vals , Integer . parseInt ( split [ split . length - _NUM ] ) ) ) ; } } } catch ( IOException e ) { Log . e ( LOG , e . toString ( ) ) ; } return entries ; }
@ SuppressWarnings ( STRING ) @ GwtIncompatible ( STRING ) public static < K extends Object , V extends Object > void writeMap ( Map < K , V > map , ObjectOutputStream stream ) throws IOException { stream . writeInt ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } }
@ SuppressWarnings ( STRING ) @ GwtIncompatible ( STRING ) public static < K extends Object , V extends Object > void writeMap ( Map < K , V > map , ObjectOutputStream stream ) throws IOException { stream . writeInt ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } }
@ SuppressWarnings ( STRING ) @ GwtIncompatible ( STRING ) public static < K extends Object , V extends Object > void writeMap ( Map < K , V > map , ObjectOutputStream stream ) throws IOException { stream . writeInt ( map . size ( ) ) ; for ( Map . Entry < K , V > entry : map . entrySet ( ) ) { stream . writeObject ( entry . getKey ( ) ) ; stream . writeObject ( entry . getValue ( ) ) ; } }
public boolean removeCapabilitiesFilterListener ( CapabilitiesFilterChangeListener l ) { return m_CapabilitiesFilterChangeListeners . remove ( l ) ; }
public String [ ] createUserFlags ( ) { String [ ] flags = new String [ userFlags . size ( ) ] ; for ( int i = _NUM ; i < userFlags . size ( ) ; i ++ ) { flags [ i ] = userFlags . get ( i ) ; } return flags ; }
public void endOfSuite ( ) throws InterruptedException { if ( asynchronousThread == null ) { throw new IllegalStateException ( STRING ) ; } this . keepRunning = _BOOL ; asynchronousThread . join ( ) ; }
public void endOfSuite ( ) throws InterruptedException { if ( asynchronousThread == null ) { throw new IllegalStateException ( STRING ) ; } this . keepRunning = _BOOL ; asynchronousThread . join ( ) ; }
public void endOfSuite ( ) throws InterruptedException { if ( asynchronousThread == null ) { throw new IllegalStateException ( STRING ) ; } this . keepRunning = _BOOL ; asynchronousThread . join ( ) ; }
public void addZoneChangeListener ( ZoneChangeListener listener ) { zoneChangeListeners . add ( listener ) ; }
public void addZoneChangeListener ( ZoneChangeListener listener ) { zoneChangeListeners . add ( listener ) ; }
protected static void execute ( ReviewDb db , String sql ) throws SQLException { try ( Statement s = newStatement ( db ) ) { s . execute ( sql ) ; } }
private int count ( boolean [ ] arraySetted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = _NUM ; for ( int i = _NUM ; i < array . length ; i ++ ) { if ( arraySetted != null && arraySetted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return _NUM ; }
private int count ( boolean [ ] arraySetted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = _NUM ; for ( int i = _NUM ; i < array . length ; i ++ ) { if ( arraySetted != null && arraySetted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return _NUM ; }
private int count ( boolean [ ] arraySetted , byte [ ] [ ] array , byte [ ] value ) { if ( value != null ) { int counter = _NUM ; for ( int i = _NUM ; i < array . length ; i ++ ) { if ( arraySetted != null && arraySetted [ i ] && Arrays . equals ( value , array [ i ] ) ) { counter ++ ; } } return counter ; } return _NUM ; }
public SimpleTree simulateTree ( TaxonList taxa , DemographicModel model ) { return simulator . simulateTree ( taxa , model . getDemographicFunction ( ) ) ; }
public Select < T > include ( String ... columns ) { Collections . addAll ( mIncludedColumns , columns ) ; return this ; }
public Select < T > include ( String ... columns ) { Collections . addAll ( mIncludedColumns , columns ) ; return this ; }
public boolean hasEmptyRow ( ) { if ( m_dataVector . size ( ) == _NUM ) { return _BOOL ; } List < String > dataRow = m_dataVector . get ( m_dataVector . size ( ) - _NUM ) ; for ( String s : dataRow ) { if ( s . length ( ) != _NUM ) { return _BOOL ; } } return _BOOL ; }
public boolean hasEmptyRow ( ) { if ( m_dataVector . size ( ) == _NUM ) { return _BOOL ; } List < String > dataRow = m_dataVector . get ( m_dataVector . size ( ) - _NUM ) ; for ( String s : dataRow ) { if ( s . length ( ) != _NUM ) { return _BOOL ; } } return _BOOL ; }
public HaskellCatalog ( ) { this ( HaskellCatalog . XML_PATH ) ; }
public HaskellCatalog ( ) { this ( HaskellCatalog . XML_PATH ) ; }
public HaskellCatalog ( ) { this ( HaskellCatalog . XML_PATH ) ; }
@ Override public int columnCount ( ) { return columnList . size ( ) ; }
public static void registerGauge ( String key , Gauge g ) { try { MetricRegistry reg = SharedMetricRegistries . getOrCreate ( STRING ) ; reg . removeMatching ( null ) ; reg . register ( key , g ) ; } catch ( Exception e ) { logger . warn ( STRING + e . getMessage ( ) ) ; } }
public static void registerGauge ( String key , Gauge g ) { try { MetricRegistry reg = SharedMetricRegistries . getOrCreate ( STRING ) ; reg . removeMatching ( null ) ; reg . register ( key , g ) ; } catch ( Exception e ) { logger . warn ( STRING + e . getMessage ( ) ) ; } }
void endOptional ( boolean successful ) { if ( successful ) { parsed . remove ( parsed . size ( ) - _NUM ) ; } else { parsed . remove ( parsed . size ( ) - _NUM ) ; } }
public static final boolean isPDFLinearized ( final String pdfUrl ) { if ( pdfUrl . startsWith ( STRING ) ) { return _BOOL ; } boolean isLinear = _BOOL ; final URL url ; final InputStream is ; try { url = new URL ( pdfUrl ) ; is = url . openStream ( ) ; final byte [ ] buffer = new byte [ _NUM ] ; is . read ( buffer ) ; is . close ( ) ; final int len = buffer . length ; for ( int i = _NUM ; i < len ; i ++ ) { if ( buffer [ i ] == STRING && buffer [ i + _NUM ] == STRING && buffer [ i + _NUM ] == STRING && buffer [ i + _NUM ] == STRING && buffer [ i + _NUM ] == STRING && buffer [ i + _NUM ] == STRING && buffer [ i + _NUM ] == STRING ) { isLinear = _BOOL ; i = len ; } } } catch ( final IOException e ) { LogWriter . writeLog ( STRING + e + STRING + pdfUrl ) ; } return isLinear ; }
public static double distance ( Vector2 a , Vector2 b ) { Vector2 tempVector = Vector2 . pow ( Vector2 . subtract ( a , b ) , _NUM ) ; return Math . sqrt ( tempVector . x + tempVector . z ) ; }
public static void validateSecurityGroupsFormat ( List < String > securityGroups ) throws InvalidSecurityGroupFormatException { if ( securityGroups != null ) { for ( String sg : securityGroups ) { if ( StringUtils . isBlank ( sg ) || sg . split ( STRING ) . length != _NUM ) { throw new InvalidSecurityGroupFormatException ( STRING ) ; } } } }
public static GaplessInfo createFromComment ( String name , String data ) { if ( ! GAPLESS_COMMENT_ID . equals ( name ) ) { return null ; } Matcher matcher = GAPLESS_COMMENT_PATTERN . matcher ( data ) ; if ( matcher . find ( ) ) { try { int encoderDelay = Integer . parseInt ( matcher . group ( _NUM ) , _NUM ) ; int encoderPadding = Integer . parseInt ( matcher . group ( _NUM ) , _NUM ) ; return encoderDelay == _NUM && encoderPadding == _NUM ? null : new GaplessInfo ( encoderDelay , encoderPadding ) ; } catch ( NumberFormatException e ) { } } return null ; }
public static GaplessInfo createFromComment ( String name , String data ) { if ( ! GAPLESS_COMMENT_ID . equals ( name ) ) { return null ; } Matcher matcher = GAPLESS_COMMENT_PATTERN . matcher ( data ) ; if ( matcher . find ( ) ) { try { int encoderDelay = Integer . parseInt ( matcher . group ( _NUM ) , _NUM ) ; int encoderPadding = Integer . parseInt ( matcher . group ( _NUM ) , _NUM ) ; return encoderDelay == _NUM && encoderPadding == _NUM ? null : new GaplessInfo ( encoderDelay , encoderPadding ) ; } catch ( NumberFormatException e ) { } } return null ; }
public void addObject ( String s ) throws Exception { inspect ( Class . forName ( s ) ) ; }
public void addObject ( String s ) throws Exception { inspect ( Class . forName ( s ) ) ; }
@ Override public void addPropertyChangeListener ( PropertyChangeListener pcl ) { m_pcs . addPropertyChangeListener ( pcl ) ; }
public String signMessage ( String message , @ Nullable KeyParameter aesKey ) throws KeyCrypterException { byte [ ] data = Utils . formatMessageForSigning ( message ) ; Sha256Hash hash = Sha256Hash . createDouble ( data ) ; ECDSASignature sig = sign ( hash , aesKey ) ; if ( sig == null ) { log . debug ( STRING ) ; return null ; } int recId = - _NUM ; for ( int i = _NUM ; i < _NUM ; i ++ ) { ECKey k = ECKey . recoverFromSignature ( i , sig , hash , isCompressed ( ) ) ; if ( k != null && Arrays . equals ( k . pub , pub ) ) { recId = i ; break ; } } if ( recId == - _NUM ) throw new RuntimeException ( STRING ) ; int headerByte = recId + _NUM + ( isCompressed ( ) ? _NUM : _NUM ) ; byte [ ] sigData = new byte [ _NUM ] ; sigData [ _NUM ] = ( byte ) headerByte ; System . arraycopy ( Utils . bigIntegerToBytes ( sig . r , _NUM ) , _NUM , sigData , _NUM , _NUM ) ; System . arraycopy ( Utils . bigIntegerToBytes ( sig . s , _NUM ) , _NUM , sigData , _NUM , _NUM ) ; return new String ( Base64 . encode ( sigData ) , Charset . forName ( STRING ) ) ; }
public String signMessage ( String message , @ Nullable KeyParameter aesKey ) throws KeyCrypterException { byte [ ] data = Utils . formatMessageForSigning ( message ) ; Sha256Hash hash = Sha256Hash . createDouble ( data ) ; ECDSASignature sig = sign ( hash , aesKey ) ; if ( sig == null ) { log . debug ( STRING ) ; return null ; } int recId = - _NUM ; for ( int i = _NUM ; i < _NUM ; i ++ ) { ECKey k = ECKey . recoverFromSignature ( i , sig , hash , isCompressed ( ) ) ; if ( k != null && Arrays . equals ( k . pub , pub ) ) { recId = i ; break ; } } if ( recId == - _NUM ) throw new RuntimeException ( STRING ) ; int headerByte = recId + _NUM + ( isCompressed ( ) ? _NUM : _NUM ) ; byte [ ] sigData = new byte [ _NUM ] ; sigData [ _NUM ] = ( byte ) headerByte ; System . arraycopy ( Utils . bigIntegerToBytes ( sig . r , _NUM ) , _NUM , sigData , _NUM , _NUM ) ; System . arraycopy ( Utils . bigIntegerToBytes ( sig . s , _NUM ) , _NUM , sigData , _NUM , _NUM ) ; return new String ( Base64 . encode ( sigData ) , Charset . forName ( STRING ) ) ; }
private static int snapHorizontal ( Collection < ConstraintWidget > widgets , ConstraintWidget widget , ConstraintAnchor anchor , int position , ArrayList < SnapCandidate > snapCandidates ) { SnapCandidate candidate = new SnapCandidate ( ) ; ConstraintHandle handle = WidgetInteractionTargets . constraintHandle ( anchor ) ; handle . setDrawX ( position ) ; SnapPlacement . snapAnchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { ConstraintHandle targetHandle = WidgetInteractionTargets . constraintHandle ( candidate . target ) ; int tx = candidate . x ; if ( targetHandle != null ) { tx = targetHandle . getDrawX ( ) ; } position = tx + candidate . margin ; snapCandidates . add ( candidate ) ; } return position ; }
private static int snapHorizontal ( Collection < ConstraintWidget > widgets , ConstraintWidget widget , ConstraintAnchor anchor , int position , ArrayList < SnapCandidate > snapCandidates ) { SnapCandidate candidate = new SnapCandidate ( ) ; ConstraintHandle handle = WidgetInteractionTargets . constraintHandle ( anchor ) ; handle . setDrawX ( position ) ; SnapPlacement . snapAnchor ( widgets , widget , anchor , candidate ) ; if ( candidate . target != null ) { ConstraintHandle targetHandle = WidgetInteractionTargets . constraintHandle ( candidate . target ) ; int tx = candidate . x ; if ( targetHandle != null ) { tx = targetHandle . getDrawX ( ) ; } position = tx + candidate . margin ; snapCandidates . add ( candidate ) ; } return position ; }
public static boolean checkVirtualPoolProtocols ( VirtualPool cos , HashSet < String > protocols , boolean matchAll ) { if ( ( protocols != null ) && ! protocols . isEmpty ( ) ) { StringSet cosProtocols = cos . getProtocols ( ) ; if ( ( matchAll ) && ( ! cosProtocols . containsAll ( protocols ) ) ) { _log . info ( STRING , protocols ) ; return _BOOL ; } else if ( ! matchAll ) { boolean hasMatch = _BOOL ; Iterator < String > protocolIter = protocols . iterator ( ) ; while ( protocolIter . hasNext ( ) ) { String protocol = protocolIter . next ( ) ; if ( cosProtocols . contains ( protocol ) ) { _log . debug ( STRING , protocol ) ; hasMatch = _BOOL ; break ; } } return hasMatch ; } } return _BOOL ; }
boolean boundaryApproxEquals ( S2Polygon b , double maxError ) { if ( numLoops ( ) != b . numLoops ( ) ) { log . severe ( STRING + Integer . toString ( numLoops ( ) ) + STRING + Integer . toString ( b . numLoops ( ) ) ) ; return _BOOL ; } for ( int i = _NUM ; i < numLoops ( ) ; ++ i ) { S2Loop aLoop = loop ( i ) ; boolean success = _BOOL ; for ( int j = _NUM ; j < numLoops ( ) ; ++ j ) { S2Loop bLoop = b . loop ( j ) ; if ( bLoop . depth ( ) == aLoop . depth ( ) && bLoop . boundaryApproxEquals ( aLoop , maxError ) ) { success = _BOOL ; break ; } } if ( ! success ) { return _BOOL ; } } return _BOOL ; }
boolean boundaryApproxEquals ( S2Polygon b , double maxError ) { if ( numLoops ( ) != b . numLoops ( ) ) { log . severe ( STRING + Integer . toString ( numLoops ( ) ) + STRING + Integer . toString ( b . numLoops ( ) ) ) ; return _BOOL ; } for ( int i = _NUM ; i < numLoops ( ) ; ++ i ) { S2Loop aLoop = loop ( i ) ; boolean success = _BOOL ; for ( int j = _NUM ; j < numLoops ( ) ; ++ j ) { S2Loop bLoop = b . loop ( j ) ; if ( bLoop . depth ( ) == aLoop . depth ( ) && bLoop . boundaryApproxEquals ( aLoop , maxError ) ) { success = _BOOL ; break ; } } if ( ! success ) { return _BOOL ; } } return _BOOL ; }
boolean boundaryApproxEquals ( S2Polygon b , double maxError ) { if ( numLoops ( ) != b . numLoops ( ) ) { log . severe ( STRING + Integer . toString ( numLoops ( ) ) + STRING + Integer . toString ( b . numLoops ( ) ) ) ; return _BOOL ; } for ( int i = _NUM ; i < numLoops ( ) ; ++ i ) { S2Loop aLoop = loop ( i ) ; boolean success = _BOOL ; for ( int j = _NUM ; j < numLoops ( ) ; ++ j ) { S2Loop bLoop = b . loop ( j ) ; if ( bLoop . depth ( ) == aLoop . depth ( ) && bLoop . boundaryApproxEquals ( aLoop , maxError ) ) { success = _BOOL ; break ; } } if ( ! success ) { return _BOOL ; } } return _BOOL ; }
boolean boundaryApproxEquals ( S2Polygon b , double maxError ) { if ( numLoops ( ) != b . numLoops ( ) ) { log . severe ( STRING + Integer . toString ( numLoops ( ) ) + STRING + Integer . toString ( b . numLoops ( ) ) ) ; return _BOOL ; } for ( int i = _NUM ; i < numLoops ( ) ; ++ i ) { S2Loop aLoop = loop ( i ) ; boolean success = _BOOL ; for ( int j = _NUM ; j < numLoops ( ) ; ++ j ) { S2Loop bLoop = b . loop ( j ) ; if ( bLoop . depth ( ) == aLoop . depth ( ) && bLoop . boundaryApproxEquals ( aLoop , maxError ) ) { success = _BOOL ; break ; } } if ( ! success ) { return _BOOL ; } } return _BOOL ; }
protected List < List < T > > splitData ( Iterable < T > data , int dataSize ) { List < List < T > > splits = new ArrayList < > ( ) ; int size = ( int ) Math . ceil ( ( double ) dataSize / numFolds ) ; int current = _NUM ; List < T > l = new ArrayList < > ( ) ; int count = _NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > dataSize ) break ; } Collections . shuffle ( l , randomSeed ) ; for ( int i = _NUM ; i < numFolds ; i ++ ) { int start = current ; int end = Math . min ( current + size , dataSize ) ; splits . add ( l . subList ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > splitData ( Iterable < T > data , int dataSize ) { List < List < T > > splits = new ArrayList < > ( ) ; int size = ( int ) Math . ceil ( ( double ) dataSize / numFolds ) ; int current = _NUM ; List < T > l = new ArrayList < > ( ) ; int count = _NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > dataSize ) break ; } Collections . shuffle ( l , randomSeed ) ; for ( int i = _NUM ; i < numFolds ; i ++ ) { int start = current ; int end = Math . min ( current + size , dataSize ) ; splits . add ( l . subList ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > splitData ( Iterable < T > data , int dataSize ) { List < List < T > > splits = new ArrayList < > ( ) ; int size = ( int ) Math . ceil ( ( double ) dataSize / numFolds ) ; int current = _NUM ; List < T > l = new ArrayList < > ( ) ; int count = _NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > dataSize ) break ; } Collections . shuffle ( l , randomSeed ) ; for ( int i = _NUM ; i < numFolds ; i ++ ) { int start = current ; int end = Math . min ( current + size , dataSize ) ; splits . add ( l . subList ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > splitData ( Iterable < T > data , int dataSize ) { List < List < T > > splits = new ArrayList < > ( ) ; int size = ( int ) Math . ceil ( ( double ) dataSize / numFolds ) ; int current = _NUM ; List < T > l = new ArrayList < > ( ) ; int count = _NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > dataSize ) break ; } Collections . shuffle ( l , randomSeed ) ; for ( int i = _NUM ; i < numFolds ; i ++ ) { int start = current ; int end = Math . min ( current + size , dataSize ) ; splits . add ( l . subList ( start , end ) ) ; current = end ; } return splits ; }
protected List < List < T > > splitData ( Iterable < T > data , int dataSize ) { List < List < T > > splits = new ArrayList < > ( ) ; int size = ( int ) Math . ceil ( ( double ) dataSize / numFolds ) ; int current = _NUM ; List < T > l = new ArrayList < > ( ) ; int count = _NUM ; for ( T item : data ) { l . add ( item ) ; count ++ ; if ( count > dataSize ) break ; } Collections . shuffle ( l , randomSeed ) ; for ( int i = _NUM ; i < numFolds ; i ++ ) { int start = current ; int end = Math . min ( current + size , dataSize ) ; splits . add ( l . subList ( start , end ) ) ; current = end ; } return splits ; }
@ Override public int lengthOfMonth ( ) { return isoDate . lengthOfMonth ( ) ; }
@ Override public int lengthOfMonth ( ) { return isoDate . lengthOfMonth ( ) ; }
@ Override public int lengthOfMonth ( ) { return isoDate . lengthOfMonth ( ) ; }
@ Override public int lengthOfMonth ( ) { return isoDate . lengthOfMonth ( ) ; }
public Object extFunction ( String ns , String funcName , Vector argVec , Object methodKey , ExpressionContext exprContext ) throws javax . xml . transform . TransformerException { Object result = null ; if ( null != ns ) { ExtensionHandler extNS = ( ExtensionHandler ) m_extensionFunctionNamespaces . get ( ns ) ; if ( null != extNS ) { try { result = extNS . callFunction ( funcName , argVec , methodKey , exprContext ) ; } catch ( javax . xml . transform . TransformerException e ) { throw e ; } catch ( Exception e ) { throw new javax . xml . transform . TransformerException ( e ) ; } } else { throw new XPathProcessorException ( XSLMessages . createMessage ( XSLTErrorResources . ER_EXTENSION_FUNC_UNKNOWN , new Object [ ] { ns , funcName } ) ) ; } } return result ; }
public boolean ensureLibraryIsIncluded ( @ NotNull Module module , @ NotNull Iterable < GradleCoordinate > dependencies , @ Nullable Runnable callback ) { GradleBuildModel buildModel = GradleBuildModel . get ( module ) ; if ( buildModel == null ) { return _BOOL ; } List < GradleCoordinate > missing = findMissingLibrariesFromGradleBuildFile ( buildModel , dependencies ) ; if ( missing . isEmpty ( ) ) { return _BOOL ; } if ( userWantToAddDependencies ( module , missing ) ) { addDependenciesInTransaction ( buildModel , module , missing , callback ) ; return _BOOL ; } return _BOOL ; }
public boolean ensureLibraryIsIncluded ( @ NotNull Module module , @ NotNull Iterable < GradleCoordinate > dependencies , @ Nullable Runnable callback ) { GradleBuildModel buildModel = GradleBuildModel . get ( module ) ; if ( buildModel == null ) { return _BOOL ; } List < GradleCoordinate > missing = findMissingLibrariesFromGradleBuildFile ( buildModel , dependencies ) ; if ( missing . isEmpty ( ) ) { return _BOOL ; } if ( userWantToAddDependencies ( module , missing ) ) { addDependenciesInTransaction ( buildModel , module , missing , callback ) ; return _BOOL ; } return _BOOL ; }
public boolean ensureLibraryIsIncluded ( @ NotNull Module module , @ NotNull Iterable < GradleCoordinate > dependencies , @ Nullable Runnable callback ) { GradleBuildModel buildModel = GradleBuildModel . get ( module ) ; if ( buildModel == null ) { return _BOOL ; } List < GradleCoordinate > missing = findMissingLibrariesFromGradleBuildFile ( buildModel , dependencies ) ; if ( missing . isEmpty ( ) ) { return _BOOL ; } if ( userWantToAddDependencies ( module , missing ) ) { addDependenciesInTransaction ( buildModel , module , missing , callback ) ; return _BOOL ; } return _BOOL ; }
public boolean ensureLibraryIsIncluded ( @ NotNull Module module , @ NotNull Iterable < GradleCoordinate > dependencies , @ Nullable Runnable callback ) { GradleBuildModel buildModel = GradleBuildModel . get ( module ) ; if ( buildModel == null ) { return _BOOL ; } List < GradleCoordinate > missing = findMissingLibrariesFromGradleBuildFile ( buildModel , dependencies ) ; if ( missing . isEmpty ( ) ) { return _BOOL ; } if ( userWantToAddDependencies ( module , missing ) ) { addDependenciesInTransaction ( buildModel , module , missing , callback ) ; return _BOOL ; } return _BOOL ; }
protected void writeTableCreationStmt ( Table table , StringBuilder ddl ) { ddl . append ( STRING ) ; ddl . append ( getFullyQualifiedTableNameShorten ( table ) ) ; println ( STRING , ddl ) ; writeColumns ( table , ddl ) ; if ( databaseInfo . isPrimaryKeyEmbedded ( ) ) { writeEmbeddedPrimaryKeysStmt ( table , ddl ) ; } if ( databaseInfo . isForeignKeysEmbedded ( ) ) { writeEmbeddedForeignKeysStmt ( table , ddl ) ; } if ( databaseInfo . isIndicesEmbedded ( ) ) { writeEmbeddedIndicesStmt ( table , ddl ) ; } println ( ddl ) ; ddl . append ( STRING ) ; if ( isSpecifyIdentityGapLimit ( ) ) { writeIdentityGapLimit ( ddl ) ; } }
protected void writeTableCreationStmt ( Table table , StringBuilder ddl ) { ddl . append ( STRING ) ; ddl . append ( getFullyQualifiedTableNameShorten ( table ) ) ; println ( STRING , ddl ) ; writeColumns ( table , ddl ) ; if ( databaseInfo . isPrimaryKeyEmbedded ( ) ) { writeEmbeddedPrimaryKeysStmt ( table , ddl ) ; } if ( databaseInfo . isForeignKeysEmbedded ( ) ) { writeEmbeddedForeignKeysStmt ( table , ddl ) ; } if ( databaseInfo . isIndicesEmbedded ( ) ) { writeEmbeddedIndicesStmt ( table , ddl ) ; } println ( ddl ) ; ddl . append ( STRING ) ; if ( isSpecifyIdentityGapLimit ( ) ) { writeIdentityGapLimit ( ddl ) ; } }
private void addMitreJoin ( Coordinate p , LineSegment offset0 , LineSegment offset1 , double distance ) { boolean isMitreWithinLimit = _BOOL ; Coordinate intPt = null ; try { intPt = HCoordinate . intersection ( offset0 . p0 , offset0 . p1 , offset1 . p0 , offset1 . p1 ) ; double mitreRatio = distance <= _NUM ? _NUM : intPt . distance ( p ) / Math . abs ( distance ) ; if ( mitreRatio > bufParams . getMitreLimit ( ) ) isMitreWithinLimit = _BOOL ; } catch ( NotRepresentableException ex ) { intPt = new Coordinate ( _NUM , _NUM ) ; isMitreWithinLimit = _BOOL ; } if ( isMitreWithinLimit ) { segList . addPt ( intPt ) ; } else { addLimitedMitreJoin ( offset0 , offset1 , distance , bufParams . getMitreLimit ( ) ) ; } }
private void addMitreJoin ( Coordinate p , LineSegment offset0 , LineSegment offset1 , double distance ) { boolean isMitreWithinLimit = _BOOL ; Coordinate intPt = null ; try { intPt = HCoordinate . intersection ( offset0 . p0 , offset0 . p1 , offset1 . p0 , offset1 . p1 ) ; double mitreRatio = distance <= _NUM ? _NUM : intPt . distance ( p ) / Math . abs ( distance ) ; if ( mitreRatio > bufParams . getMitreLimit ( ) ) isMitreWithinLimit = _BOOL ; } catch ( NotRepresentableException ex ) { intPt = new Coordinate ( _NUM , _NUM ) ; isMitreWithinLimit = _BOOL ; } if ( isMitreWithinLimit ) { segList . addPt ( intPt ) ; } else { addLimitedMitreJoin ( offset0 , offset1 , distance , bufParams . getMitreLimit ( ) ) ; } }
public ZkConfigManager ( SolrZkClient zkClient ) { this . zkClient = zkClient ; }
public Translation decode ( Sentence sentence ) { try { DecoderTask decoderTask = new DecoderTask ( this . grammars , Decoder . weights , this . featureFunctions , joshuaConfiguration ) ; return decoderTask . translate ( sentence ) ; } catch ( IOException e ) { throw new RuntimeException ( String . format ( STRING , sentence . id ( ) , e . getMessage ( ) ) , e ) ; } }
private void computeStatistics ( ProfileRequest req , int accessTime , int egressTime ) { int count = _NUM ; int sum = _NUM ; this . min = Integer . MAX_VALUE ; this . max = _NUM ; for ( int start = req . fromTime ; start < req . toTime ; start += _NUM ) { int timeAtOriginStop = start + accessTime + RaptorWorker . BOARD_SLACK_SECONDS ; int bestTimeAtDestinationStop = Integer . MAX_VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . boardTimes [ _NUM ] < timeAtOriginStop ) continue ; if ( itin . alightTimes [ this . length - _NUM ] < bestTimeAtDestinationStop ) bestTimeAtDestinationStop = itin . alightTimes [ this . length - _NUM ] ; } if ( bestTimeAtDestinationStop == Integer . MAX_VALUE ) continue ; int bestTimeAtDestination = bestTimeAtDestinationStop + egressTime ; int travelTime = bestTimeAtDestination - start ; count ++ ; sum += travelTime ; min = Math . min ( min , travelTime ) ; max = Math . max ( max , travelTime ) ; } if ( count == _NUM ) throw new IllegalStateException ( STRING ) ; avg = sum / count ; }
private void computeStatistics ( ProfileRequest req , int accessTime , int egressTime ) { int count = _NUM ; int sum = _NUM ; this . min = Integer . MAX_VALUE ; this . max = _NUM ; for ( int start = req . fromTime ; start < req . toTime ; start += _NUM ) { int timeAtOriginStop = start + accessTime + RaptorWorker . BOARD_SLACK_SECONDS ; int bestTimeAtDestinationStop = Integer . MAX_VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . boardTimes [ _NUM ] < timeAtOriginStop ) continue ; if ( itin . alightTimes [ this . length - _NUM ] < bestTimeAtDestinationStop ) bestTimeAtDestinationStop = itin . alightTimes [ this . length - _NUM ] ; } if ( bestTimeAtDestinationStop == Integer . MAX_VALUE ) continue ; int bestTimeAtDestination = bestTimeAtDestinationStop + egressTime ; int travelTime = bestTimeAtDestination - start ; count ++ ; sum += travelTime ; min = Math . min ( min , travelTime ) ; max = Math . max ( max , travelTime ) ; } if ( count == _NUM ) throw new IllegalStateException ( STRING ) ; avg = sum / count ; }
private void computeStatistics ( ProfileRequest req , int accessTime , int egressTime ) { int count = _NUM ; int sum = _NUM ; this . min = Integer . MAX_VALUE ; this . max = _NUM ; for ( int start = req . fromTime ; start < req . toTime ; start += _NUM ) { int timeAtOriginStop = start + accessTime + RaptorWorker . BOARD_SLACK_SECONDS ; int bestTimeAtDestinationStop = Integer . MAX_VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . boardTimes [ _NUM ] < timeAtOriginStop ) continue ; if ( itin . alightTimes [ this . length - _NUM ] < bestTimeAtDestinationStop ) bestTimeAtDestinationStop = itin . alightTimes [ this . length - _NUM ] ; } if ( bestTimeAtDestinationStop == Integer . MAX_VALUE ) continue ; int bestTimeAtDestination = bestTimeAtDestinationStop + egressTime ; int travelTime = bestTimeAtDestination - start ; count ++ ; sum += travelTime ; min = Math . min ( min , travelTime ) ; max = Math . max ( max , travelTime ) ; } if ( count == _NUM ) throw new IllegalStateException ( STRING ) ; avg = sum / count ; }
private void computeStatistics ( ProfileRequest req , int accessTime , int egressTime ) { int count = _NUM ; int sum = _NUM ; this . min = Integer . MAX_VALUE ; this . max = _NUM ; for ( int start = req . fromTime ; start < req . toTime ; start += _NUM ) { int timeAtOriginStop = start + accessTime + RaptorWorker . BOARD_SLACK_SECONDS ; int bestTimeAtDestinationStop = Integer . MAX_VALUE ; for ( Itinerary itin : this . itineraries ) { if ( itin . boardTimes [ _NUM ] < timeAtOriginStop ) continue ; if ( itin . alightTimes [ this . length - _NUM ] < bestTimeAtDestinationStop ) bestTimeAtDestinationStop = itin . alightTimes [ this . length - _NUM ] ; } if ( bestTimeAtDestinationStop == Integer . MAX_VALUE ) continue ; int bestTimeAtDestination = bestTimeAtDestinationStop + egressTime ; int travelTime = bestTimeAtDestination - start ; count ++ ; sum += travelTime ; min = Math . min ( min , travelTime ) ; max = Math . max ( max , travelTime ) ; } if ( count == _NUM ) throw new IllegalStateException ( STRING ) ; avg = sum / count ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
@ SuppressWarnings ( STRING ) default T add ( String ... rows ) { requireNonNullElements ( rows ) ; for ( final String row : rows ) { Collections . addAll ( getCode ( ) , row . split ( nl ( ) ) ) ; } return ( T ) this ; }
protected static int [ ] insert ( int [ ] old , int oldSize , int pos , int x ) { int [ ] result ; if ( old != null && old . length > oldSize ) { result = old ; } else { result = new int [ oldSize + _NUM + COPY_THRESHOLD ] ; if ( pos > _NUM && old != null ) { System . arraycopy ( old , _NUM , result , _NUM , pos ) ; } } if ( old != null && oldSize - pos > _NUM ) { System . arraycopy ( old , pos , result , pos + _NUM , oldSize - pos ) ; } result [ pos ] = x ; return result ; }
protected static int [ ] insert ( int [ ] old , int oldSize , int pos , int x ) { int [ ] result ; if ( old != null && old . length > oldSize ) { result = old ; } else { result = new int [ oldSize + _NUM + COPY_THRESHOLD ] ; if ( pos > _NUM && old != null ) { System . arraycopy ( old , _NUM , result , _NUM , pos ) ; } } if ( old != null && oldSize - pos > _NUM ) { System . arraycopy ( old , pos , result , pos + _NUM , oldSize - pos ) ; } result [ pos ] = x ; return result ; }
public static double L_LogLoss ( double y , double rpred , double C ) { double ans = Math . min ( Utils . eq ( y , rpred ) ? _NUM : - ( ( y * Math . log ( rpred ) ) + ( ( _NUM - y ) * Math . log ( _NUM - rpred ) ) ) , C ) ; return ( Double . isNaN ( ans ) ? _NUM : ans ) ; }
public void updateMaxTextWidths ( float requiredWidth , float matchContentsWidth ) { mMaxRequiredWidth = Math . max ( mMaxRequiredWidth , requiredWidth ) ; mMaxMatchContentsWidth = Math . max ( mMaxMatchContentsWidth , matchContentsWidth ) ; }
public java . lang . StringBuilder insert ( int offset , double d ) { return insert ( offset , Double . toString ( d ) ) ; }
public java . lang . StringBuilder insert ( int offset , double d ) { return insert ( offset , Double . toString ( d ) ) ; }
public java . lang . StringBuilder insert ( int offset , double d ) { return insert ( offset , Double . toString ( d ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
public RegisteredProject removeProjectType ( String projectPath , String type ) throws ConflictException , ForbiddenException , NotFoundException , ServerException { final RegisteredProject project = getProject ( projectPath ) ; if ( project == null ) { return null ; } List < String > newMixins = project . getMixins ( ) ; String newType = project . getType ( ) ; if ( newMixins . contains ( type ) ) { newMixins . remove ( type ) ; } else if ( newType . equals ( type ) ) { if ( project . isDetected ( ) ) { projects . remove ( project . getPath ( ) ) ; return null ; } newType = BaseProjectType . ID ; } final NewProjectConfig conf = new NewProjectConfig ( project . getPath ( ) , newType , newMixins , project . getName ( ) , project . getDescription ( ) , project . getAttributes ( ) , project . getSource ( ) ) ; return putProject ( conf , project . getBaseFolder ( ) , _BOOL , project . isDetected ( ) ) ; }
@ Override public boolean addSensorToRoute ( String sensorName , int mode ) { if ( _controlSensorList . size ( ) >= MAX_CONTROL_SENSORS ) { log . warn ( STRING , getSystemName ( ) ) ; } ControlSensor sensor = new ControlSensor ( sensorName ) ; log . debug ( STRING , getSystemName ( ) , sensorName ) ; if ( ! sensor . setState ( mode ) ) { return _BOOL ; } if ( isControlSensorIncluded ( sensor ) ) { log . debug ( STRING , sensorName , getSystemName ( ) ) ; } else { _controlSensorList . add ( sensor ) ; } return _BOOL ; }
@ Override public boolean addSensorToRoute ( String sensorName , int mode ) { if ( _controlSensorList . size ( ) >= MAX_CONTROL_SENSORS ) { log . warn ( STRING , getSystemName ( ) ) ; } ControlSensor sensor = new ControlSensor ( sensorName ) ; log . debug ( STRING , getSystemName ( ) , sensorName ) ; if ( ! sensor . setState ( mode ) ) { return _BOOL ; } if ( isControlSensorIncluded ( sensor ) ) { log . debug ( STRING , sensorName , getSystemName ( ) ) ; } else { _controlSensorList . add ( sensor ) ; } return _BOOL ; }
public static int [ ] parseIntArray ( int [ ] dest , String value ) { String [ ] parts = value . split ( STRING ) ; if ( dest == null ) { dest = new int [ parts . length ] ; } for ( int i = _NUM ; i < dest . length ; i ++ ) { dest [ i ] = Integer . parseInt ( parts [ i ] ) ; } return dest ; }
public static long locationAtTick ( GeoTimeSerie gts , long tick ) { if ( null == gts . locations ) { return GeoTimeSerie . NO_LOCATION ; } sort ( gts , _BOOL ) ; int idx = Arrays . binarySearch ( gts . ticks , _NUM , gts . values , tick ) ; if ( idx < _NUM ) { return GeoTimeSerie . NO_LOCATION ; } else { return gts . locations [ idx ] ; } }
public static long locationAtTick ( GeoTimeSerie gts , long tick ) { if ( null == gts . locations ) { return GeoTimeSerie . NO_LOCATION ; } sort ( gts , _BOOL ) ; int idx = Arrays . binarySearch ( gts . ticks , _NUM , gts . values , tick ) ; if ( idx < _NUM ) { return GeoTimeSerie . NO_LOCATION ; } else { return gts . locations [ idx ] ; } }
public GondolaRc ( ) throws Exception { config = new Config ( new File ( STRING ) ) ; for ( String h : config . getHostIds ( ) ) { for ( String s : config . getShardIds ( h ) ) { if ( s . equals ( STRING ) ) { gondolas . add ( new Gondola ( config , h ) ) ; } } } }
public GondolaRc ( ) throws Exception { config = new Config ( new File ( STRING ) ) ; for ( String h : config . getHostIds ( ) ) { for ( String s : config . getShardIds ( h ) ) { if ( s . equals ( STRING ) ) { gondolas . add ( new Gondola ( config , h ) ) ; } } } }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } if ( k != null ) { String id = ( String ) localIds . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) keyCerts . remove ( id ) ; } if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } } }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } if ( k != null ) { String id = ( String ) localIds . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) keyCerts . remove ( id ) ; } if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } } }
public void engineDeleteEntry ( String alias ) throws KeyStoreException { Key k = ( Key ) keys . remove ( alias ) ; Certificate c = ( Certificate ) certs . remove ( alias ) ; if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } if ( k != null ) { String id = ( String ) localIds . remove ( alias ) ; if ( id != null ) { c = ( Certificate ) keyCerts . remove ( id ) ; } if ( c != null ) { chainCerts . remove ( new CertId ( c . getPublicKey ( ) ) ) ; } } }
@ Override public void onCanStartVideoServiceChanged ( boolean canStartVideoService ) { Log . i ( STRING , STRING + String . valueOf ( canStartVideoService ) ) ; if ( canStartVideoService == _BOOL ) { mConversationHelper . startOutgoingVideo ( ) ; mConversationHelper . startIncomingVideo ( ) ; } }
@ Override public void onCanStartVideoServiceChanged ( boolean canStartVideoService ) { Log . i ( STRING , STRING + String . valueOf ( canStartVideoService ) ) ; if ( canStartVideoService == _BOOL ) { mConversationHelper . startOutgoingVideo ( ) ; mConversationHelper . startIncomingVideo ( ) ; } }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public int nextInt ( ) { int ret = counter . getAndIncrement ( ) ; setLastInt ( ret ) ; return ret ; }
public mxCoordinateAssignment ( mxHierarchicalLayout layout , double intraCellSpacing , double interRankCellSpacing , int orientation , double initialX , double parallelEdgeSpacing ) { this . layout = layout ; this . intraCellSpacing = intraCellSpacing ; this . interRankCellSpacing = interRankCellSpacing ; this . orientation = orientation ; this . initialX = initialX ; this . parallelEdgeSpacing = parallelEdgeSpacing ; setLoggerLevel ( Level . OFF ) ; }
public void addRootBlock ( Block block , boolean isNewBlock ) { if ( block == null ) { throw new IllegalArgumentException ( STRING ) ; } if ( block . getPreviousBlock ( ) != null ) { throw new IllegalArgumentException ( STRING ) ; } if ( mRootBlocks . contains ( block ) ) { throw new IllegalArgumentException ( STRING ) ; } mRootBlocks . add ( block ) ; if ( isNewBlock ) { mStats . collectStats ( block , _BOOL ) ; } }
public static < T > DatabaseTableConfig < T > fromReader ( BufferedReader reader ) throws SQLException { DatabaseTableConfig < T > config = new DatabaseTableConfig < T > ( ) ; boolean anything = _BOOL ; while ( _BOOL ) { String line ; try { line = reader . readLine ( ) ; } catch ( IOException e ) { throw SqlExceptionUtil . create ( STRING , e ) ; } if ( line == null ) { break ; } if ( line . equals ( CONFIG_FILE_END_MARKER ) ) { break ; } if ( line . equals ( CONFIG_FILE_FIELDS_START ) ) { readFields ( reader , config ) ; continue ; } if ( line . length ( ) == _NUM || line . startsWith ( STRING ) || line . equals ( CONFIG_FILE_START_MARKER ) ) { continue ; } String [ ] parts = line . split ( STRING , - _NUM ) ; if ( parts . length != _NUM ) { throw new SQLException ( STRING + line ) ; } readTableField ( config , parts [ _NUM ] , parts [ _NUM ] ) ; anything = _BOOL ; } if ( anything ) { return config ; } else { return null ; } }
public LocalizedText ( String text , String localeId ) { this . text = text ; this . locale = localeId ; }
public void add ( Key key ) { if ( key == null ) throw new NullPointerException ( STRING ) ; set . add ( key ) ; }
public static Corleone context ( String jobContext ) { if ( jobContext == null || jobContext . equals ( STRING ) ) { throw new IllegalArgumentException ( STRING ) ; } contexts . clear ( ) ; contexts . add ( jobContext ) ; return getInstance ( ) ; }
public final void testGenerateSeedint03 ( ) { byte [ ] myBytes1 ; byte [ ] myBytes2 ; for ( int i = _NUM ; i < LENGTH ; i += INCR ) { int n = _NUM ; myBytes1 = sr . generateSeed ( i ) ; myBytes2 = sr . generateSeed ( i ) ; for ( int j = _NUM ; j < i ; j ++ ) { if ( myBytes1 [ j ] == myBytes2 [ j ] ) { n ++ ; } } assertFalse ( STRING + i + STRING + n , n * _NUM > i ) ; } }
public void addTimeline ( final JSONObject timeline ) { TimelineChannel . notifyTimeline ( timeline ) ; timelines . addFirst ( timeline ) ; final int maxCnt = Symphonys . getInt ( STRING ) ; if ( timelines . size ( ) > maxCnt ) { timelines . remove ( maxCnt ) ; } }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < > ( ) ; } mListeners . add ( listener ) ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < > ( ) ; } mListeners . add ( listener ) ; }
public void add ( int primaryCode , int [ ] codes ) { mTypedWord . append ( ( char ) primaryCode ) ; correctPrimaryJuxtapos ( primaryCode , codes ) ; correctCodesCase ( codes ) ; mCodes . add ( codes ) ; if ( Character . isUpperCase ( ( char ) primaryCode ) ) mCapsCount ++ ; }
public void add ( int primaryCode , int [ ] codes ) { mTypedWord . append ( ( char ) primaryCode ) ; correctPrimaryJuxtapos ( primaryCode , codes ) ; correctCodesCase ( codes ) ; mCodes . add ( codes ) ; if ( Character . isUpperCase ( ( char ) primaryCode ) ) mCapsCount ++ ; }
public void add ( int primaryCode , int [ ] codes ) { mTypedWord . append ( ( char ) primaryCode ) ; correctPrimaryJuxtapos ( primaryCode , codes ) ; correctCodesCase ( codes ) ; mCodes . add ( codes ) ; if ( Character . isUpperCase ( ( char ) primaryCode ) ) mCapsCount ++ ; }
public void add ( int primaryCode , int [ ] codes ) { mTypedWord . append ( ( char ) primaryCode ) ; correctPrimaryJuxtapos ( primaryCode , codes ) ; correctCodesCase ( codes ) ; mCodes . add ( codes ) ; if ( Character . isUpperCase ( ( char ) primaryCode ) ) mCapsCount ++ ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
@ Override public Enumeration < Option > listOptions ( ) { Vector < Option > newVector = new Vector < Option > ( _NUM ) ; newVector . addElement ( new Option ( STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; newVector . addElement ( new Option ( STRING + STRING + STRING , STRING , _NUM , STRING ) ) ; return newVector . elements ( ) ; }
public ReplDBMSHeader lastCommitSeqno ( ) throws ReplicatorException { try { ReplDBMSHeaderData header = null ; ResultSet res = null ; try { lastSeqnoQuery . setInt ( _NUM , taskId ) ; res = lastSeqnoQuery . executeQuery ( ) ; if ( res . next ( ) ) { header = headerFromResult ( res ) ; } } finally { connectionManager . close ( res ) ; } return header ; } catch ( SQLException e ) { throw new ReplicatorException ( STRING + e . getMessage ( ) , e ) ; } }
public ReplDBMSHeader lastCommitSeqno ( ) throws ReplicatorException { try { ReplDBMSHeaderData header = null ; ResultSet res = null ; try { lastSeqnoQuery . setInt ( _NUM , taskId ) ; res = lastSeqnoQuery . executeQuery ( ) ; if ( res . next ( ) ) { header = headerFromResult ( res ) ; } } finally { connectionManager . close ( res ) ; } return header ; } catch ( SQLException e ) { throw new ReplicatorException ( STRING + e . getMessage ( ) , e ) ; } }
public ReplDBMSHeader lastCommitSeqno ( ) throws ReplicatorException { try { ReplDBMSHeaderData header = null ; ResultSet res = null ; try { lastSeqnoQuery . setInt ( _NUM , taskId ) ; res = lastSeqnoQuery . executeQuery ( ) ; if ( res . next ( ) ) { header = headerFromResult ( res ) ; } } finally { connectionManager . close ( res ) ; } return header ; } catch ( SQLException e ) { throw new ReplicatorException ( STRING + e . getMessage ( ) , e ) ; } }
protected boolean beforeRelease ( ) { return deque . size ( ) < maxSize ; }
public void addElement ( ErStackTraceElement element ) { if ( className == null ) { declaringClass = element . getDeclaringClass ( ) ; if ( declaringClass . contains ( STRING ) ) { className = declaringClass . substring ( declaringClass . lastIndexOf ( STRING ) + _NUM ) ; packageName = declaringClass . substring ( _NUM , declaringClass . lastIndexOf ( STRING ) ) ; } else { className = declaringClass ; packageName = STRING ; } fileName = element . getFileName ( ) ; if ( checkBasePackages ( declaringClass ) ) { isBasePackage = _BOOL ; } } stackTraceElements . add ( element ) ; }
public int hashCode ( ) { return ( Float . floatToIntBits ( extraAlpha ) * _NUM + rule ) ; }
public Searcher ( ) throws IOException { searcher = new IndexSearcher ( DirectoryReader . open ( FSDirectory . open ( Paths . get ( INDEX_DIR ) ) ) ) ; parser = new QueryParser ( CONTENT_FIELD , new StandardAnalyzer ( ) ) ; }
public void addColumnListener ( ColumnListener listener ) { m_listeners . add ( listener ) ; }
public void addColumnListener ( ColumnListener listener ) { m_listeners . add ( listener ) ; }
@ SuppressWarnings ( STRING ) protected void stopAssociator ( ) { if ( m_RunThread != null ) { m_RunThread . interrupt ( ) ; m_RunThread . stop ( ) ; } }
@ SuppressWarnings ( STRING ) protected void stopAssociator ( ) { if ( m_RunThread != null ) { m_RunThread . interrupt ( ) ; m_RunThread . stop ( ) ; } }
public static < T > Rule < T > fromUri ( final String uri , final List < String > methods , final T target ) { return new Rule < > ( uri , methods , target ) ; }
@ Override public int hashCode ( ) { throw new UnsupportedOperationException ( STRING ) ; }
@ Override public void sendMail ( MimeMessage message ) throws MessagingException { MailAddress sender = new MailAddress ( ( InternetAddress ) message . getFrom ( ) [ _NUM ] ) ; Collection < MailAddress > recipients = new HashSet < MailAddress > ( ) ; Address addresses [ ] = message . getAllRecipients ( ) ; if ( addresses != null ) { for ( Address address : addresses ) { if ( address instanceof InternetAddress ) { recipients . add ( new MailAddress ( ( InternetAddress ) address ) ) ; } } } sendMail ( sender , recipients , message ) ; }
@ Override protected void finalize ( ) throws Throwable { try { synchronized ( buf ) { if ( buf . isOpen ( ) ) { close ( ) ; if ( log . isInfoEnabled ( ) ) log . info ( STRING ) ; } } } catch ( Throwable t ) { log . error ( STRING + t , t ) ; } super . finalize ( ) ; }
public static boolean isPrimitive ( TypeMirror type ) { switch ( type . getKind ( ) ) { case BOOLEAN : case BYTE : case CHAR : case DOUBLE : case FLOAT : case INT : case LONG : case SHORT : return _BOOL ; default : return _BOOL ; } }
private static void createOperandExpression ( final SQLProvider provider , final INaviOperandTreeNode rootNode , final int parent , final Set < INaviOperandTreeNode > nodes ) throws SQLException { createOperandExpression ( provider , rootNode , parent ) ; nodes . add ( rootNode ) ; for ( final INaviOperandTreeNode child : rootNode . getChildren ( ) ) { createOperandExpression ( provider , child , rootNode . getId ( ) , nodes ) ; } }
public static boolean needsUID ( String classname ) { boolean result ; try { result = needsUID ( Class . forName ( classname ) ) ; } catch ( Exception e ) { result = _BOOL ; } return result ; }
public static boolean needsUID ( String classname ) { boolean result ; try { result = needsUID ( Class . forName ( classname ) ) ; } catch ( Exception e ) { result = _BOOL ; } return result ; }
public OfferRequirement ( String taskType , Collection < TaskInfo > taskInfos ) throws InvalidRequirementException { this ( taskType , taskInfos , Optional . empty ( ) ) ; }
public void sort ( Comparator < File > comparator ) { synchronized ( mLock ) { Collections . sort ( fileList , comparator ) ; } notifyDataSetChanged ( ) ; }
public void start ( ) { Thread t = m_threadVar . get ( ) ; if ( t != null ) t . start ( ) ; }
@ Override public void onDownloadProgress ( DownloadProgressInfo progress ) { mAverageSpeed . setText ( getString ( R . string . kilobytes_per_second , Helpers . getSpeedString ( progress . mCurrentSpeed ) ) ) ; mTimeRemaining . setText ( getString ( R . string . time_remaining , Helpers . getTimeRemaining ( progress . mTimeRemaining ) ) ) ; progress . mOverallTotal = progress . mOverallTotal ; mPB . setMax ( ( int ) ( progress . mOverallTotal > > _NUM ) ) ; mPB . setProgress ( ( int ) ( progress . mOverallProgress > > _NUM ) ) ; mProgressPercent . setText ( Long . toString ( progress . mOverallProgress * _NUM / progress . mOverallTotal ) + STRING ) ; mProgressFraction . setText ( Helpers . getDownloadProgressString ( progress . mOverallProgress , progress . mOverallTotal ) ) ; }
public static < FF extends FileFormat > Optional < FF > matchMIMEType ( String mimeType , Iterable < FF > fileFormats ) { for ( FF fileFormat : fileFormats ) { if ( fileFormat . hasDefaultMIMEType ( mimeType ) ) { return Optional . of ( fileFormat ) ; } } for ( FF fileFormat : fileFormats ) { if ( fileFormat . hasMIMEType ( mimeType ) ) { return Optional . of ( fileFormat ) ; } } return Optional . empty ( ) ; }
public static < FF extends FileFormat > Optional < FF > matchMIMEType ( String mimeType , Iterable < FF > fileFormats ) { for ( FF fileFormat : fileFormats ) { if ( fileFormat . hasDefaultMIMEType ( mimeType ) ) { return Optional . of ( fileFormat ) ; } } for ( FF fileFormat : fileFormats ) { if ( fileFormat . hasMIMEType ( mimeType ) ) { return Optional . of ( fileFormat ) ; } } return Optional . empty ( ) ; }
public GroovyClassLoader ( ClassLoader loader ) { this ( loader , null ) ; }
public GroovyClassLoader ( ClassLoader loader ) { this ( loader , null ) ; }
public MessageVersion ( String version ) { this . version = version ; try { getVersionParts ( ) ; } catch ( NumberFormatException e ) { throw new IllegalArgumentException ( String . format ( STRING , version ) , e ) ; } }
@ Override public void resumeAllMutators ( ) { synchronized ( trigger ) { setState ( MUTATOR ) ; trigger . notifyAll ( ) ; } }
private boolean start ( String type ) { long timePassed = System . currentTimeMillis ( ) - start ; if ( timePassed > MAX_TIME ) { close ( ) ; } if ( ! type . equals ( mode ) ) { close ( ) ; } if ( mode == null ) { mode = type ; start = System . currentTimeMillis ( ) ; length = _NUM ; return _BOOL ; } return _BOOL ; }
public void addContainerRequest ( Map < StreamingContainerAgent . ContainerStartRequest , MutablePair < Integer , ContainerRequest > > requestedResources , int loopCounter , List < ContainerRequest > containerRequests , StreamingContainerAgent . ContainerStartRequest csr , ContainerRequest cr ) { MutablePair < Integer , ContainerRequest > pair = new MutablePair < Integer , ContainerRequest > ( loopCounter , cr ) ; requestedResources . put ( csr , pair ) ; containerRequests . add ( cr ) ; }
protected void initInstances ( Operation post , ServiceDocument ... states ) { initInstances ( post , _BOOL , _BOOL , states ) ; }
public void addPriorityUnit ( int id ) { priorityUnitTargets . add ( id ) ; }
@ Override public void mouseClicked ( MouseEvent e ) { int col ; boolean popup ; col = m_TableData . columnAtPoint ( e . getPoint ( ) ) ; popup = ( ( e . getButton ( ) == MouseEvent . BUTTON3 ) && ( e . getClickCount ( ) == _NUM ) ) || ( ( e . getButton ( ) == MouseEvent . BUTTON1 ) && ( e . getClickCount ( ) == _NUM ) && e . isAltDown ( ) && ! e . isControlDown ( ) && ! e . isShiftDown ( ) ) ; popup = popup && ( getInstances ( ) != null ) ; if ( e . getSource ( ) == m_TableData . getTableHeader ( ) ) { m_CurrentCol = col ; if ( popup ) { e . consume ( ) ; setMenu ( ) ; initPopupMenus ( ) ; m_PopupHeader . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } } else if ( e . getSource ( ) == m_TableData ) { if ( popup ) { e . consume ( ) ; setMenu ( ) ; initPopupMenus ( ) ; m_PopupRows . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } } if ( ( e . getButton ( ) == MouseEvent . BUTTON1 ) && ( e . getClickCount ( ) == _NUM ) && ( ! e . isAltDown ( ) ) && ( col > - _NUM ) ) { m_TableData . setSelectedColumn ( col ) ; } }
@ Override public void mouseClicked ( MouseEvent e ) { int col ; boolean popup ; col = m_TableData . columnAtPoint ( e . getPoint ( ) ) ; popup = ( ( e . getButton ( ) == MouseEvent . BUTTON3 ) && ( e . getClickCount ( ) == _NUM ) ) || ( ( e . getButton ( ) == MouseEvent . BUTTON1 ) && ( e . getClickCount ( ) == _NUM ) && e . isAltDown ( ) && ! e . isControlDown ( ) && ! e . isShiftDown ( ) ) ; popup = popup && ( getInstances ( ) != null ) ; if ( e . getSource ( ) == m_TableData . getTableHeader ( ) ) { m_CurrentCol = col ; if ( popup ) { e . consume ( ) ; setMenu ( ) ; initPopupMenus ( ) ; m_PopupHeader . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } } else if ( e . getSource ( ) == m_TableData ) { if ( popup ) { e . consume ( ) ; setMenu ( ) ; initPopupMenus ( ) ; m_PopupRows . show ( e . getComponent ( ) , e . getX ( ) , e . getY ( ) ) ; } } if ( ( e . getButton ( ) == MouseEvent . BUTTON1 ) && ( e . getClickCount ( ) == _NUM ) && ( ! e . isAltDown ( ) ) && ( col > - _NUM ) ) { m_TableData . setSelectedColumn ( col ) ; } }
private static boolean isExcluded ( Spatial s , Spatial exclude ) { if ( s . equals ( exclude ) ) { return _BOOL ; } if ( s . getParent ( ) != null ) { return isExcluded ( s . getParent ( ) , exclude ) ; } return _BOOL ; }
public void perform ( List < Action < Void > > actions , long timeBoundInMillis ) { List < TimeBoundedThread < Void > > tasks = createTimeBoundedThreads ( actions ) ; try { _executerService . invokeAll ( tasks , timeBoundInMillis , TimeUnit . MILLISECONDS ) ; } catch ( Throwable thrown ) { _logger . error ( String . format ( STRING , actions ) , thrown ) ; } }
public void perform ( List < Action < Void > > actions , long timeBoundInMillis ) { List < TimeBoundedThread < Void > > tasks = createTimeBoundedThreads ( actions ) ; try { _executerService . invokeAll ( tasks , timeBoundInMillis , TimeUnit . MILLISECONDS ) ; } catch ( Throwable thrown ) { _logger . error ( String . format ( STRING , actions ) , thrown ) ; } }
@ Override public void addToWorld ( ) { fillQuestInfo ( STRING , STRING , _BOOL ) ; step_1 ( ) ; }
public void testCase1 ( ) { byte aBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; byte bBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; int aSign = _NUM ; int bSign = _NUM ; byte rBytes [ ] = { _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM , _NUM } ; BigInteger aNumber = new BigInteger ( aSign , aBytes ) ; BigInteger bNumber = new BigInteger ( bSign , bBytes ) ; BigInteger result = aNumber . add ( bNumber ) ; byte resBytes [ ] = new byte [ rBytes . length ] ; resBytes = result . toByteArray ( ) ; for ( int i = _NUM ; i < resBytes . length ; i ++ ) { assertTrue ( resBytes [ i ] == rBytes [ i ] ) ; } assertEquals ( STRING , _NUM , result . signum ( ) ) ; }
private static Method findOverloadedMethod ( Class baseClass , String methodName , Class [ ] types , boolean publicOnly ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + StringUtil . methodString ( methodName , types ) + STRING + baseClass . getName ( ) + STRING ) ; Method [ ] methods = getCandidateMethods ( baseClass , methodName , types . length , publicOnly ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + methodName ) ; Method method = findMostSpecificMethod ( types , methods ) ; return method ; }
private static Method findOverloadedMethod ( Class baseClass , String methodName , Class [ ] types , boolean publicOnly ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + StringUtil . methodString ( methodName , types ) + STRING + baseClass . getName ( ) + STRING ) ; Method [ ] methods = getCandidateMethods ( baseClass , methodName , types . length , publicOnly ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + methodName ) ; Method method = findMostSpecificMethod ( types , methods ) ; return method ; }
private static Method findOverloadedMethod ( Class baseClass , String methodName , Class [ ] types , boolean publicOnly ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + StringUtil . methodString ( methodName , types ) + STRING + baseClass . getName ( ) + STRING ) ; Method [ ] methods = getCandidateMethods ( baseClass , methodName , types . length , publicOnly ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + methodName ) ; Method method = findMostSpecificMethod ( types , methods ) ; return method ; }
private static Method findOverloadedMethod ( Class baseClass , String methodName , Class [ ] types , boolean publicOnly ) { if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + StringUtil . methodString ( methodName , types ) + STRING + baseClass . getName ( ) + STRING ) ; Method [ ] methods = getCandidateMethods ( baseClass , methodName , types . length , publicOnly ) ; if ( Interpreter . DEBUG ) Interpreter . debug ( STRING + methodName ) ; Method method = findMostSpecificMethod ( types , methods ) ; return method ; }
public boolean addElement ( Object obj ) { synchronized ( actions ) { if ( allowToChange ) { return actions . add ( obj ) ; } } return _BOOL ; }
public void testAddDiffScaleNegPos ( ) { String a = STRING ; int aScale = - _NUM ; String b = STRING ; int bScale = _NUM ; String c = STRING ; int cScale = _NUM ; BigDecimal aNumber = new BigDecimal ( new BigInteger ( a ) , aScale ) ; BigDecimal bNumber = new BigDecimal ( new BigInteger ( b ) , bScale ) ; BigDecimal result = aNumber . add ( bNumber ) ; assertEquals ( STRING , c , result . toString ( ) ) ; assertEquals ( STRING , cScale , result . scale ( ) ) ; }
@ Override protected void recordVersions ( RegionVersionHolder vh , BitSet bs ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = _NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . recordVersion ( version ) ; } }
@ Override protected void recordVersions ( RegionVersionHolder vh , BitSet bs ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = _NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . recordVersion ( version ) ; } }
@ Override protected void recordVersions ( RegionVersionHolder vh , BitSet bs ) { List < Integer > list = new ArrayList < Integer > ( ) ; for ( int i = _NUM ; i < bs . length ( ) ; i ++ ) { if ( bs . get ( i ) ) { list . add ( i ) ; } } Collections . shuffle ( list , random ) ; for ( Integer version : list ) { vh . recordVersion ( version ) ; } }
private void showPopup ( Component source ) { actionSource = source ; actionSource . addComponentListener ( this ) ; if ( actionSource instanceof JToggleButton ) { JToggleButton toggleSource = ( JToggleButton ) actionSource ; toggleSource . setSelected ( _BOOL ) ; } containingWindow = SwingUtilities . windowForComponent ( actionSource ) ; containingWindow . addComponentListener ( this ) ; Point position = calculatePosition ( source ) ; popupComponent . setLocation ( position ) ; popupComponent . setVisible ( _BOOL ) ; popup = new ContainerPopupDialog ( containingWindow , popupComponent , position ) ; popup . setVisible ( _BOOL ) ; popup . requestFocus ( ) ; popupComponent . startTracking ( containingWindow , actionSource ) ; }
private void showPopup ( Component source ) { actionSource = source ; actionSource . addComponentListener ( this ) ; if ( actionSource instanceof JToggleButton ) { JToggleButton toggleSource = ( JToggleButton ) actionSource ; toggleSource . setSelected ( _BOOL ) ; } containingWindow = SwingUtilities . windowForComponent ( actionSource ) ; containingWindow . addComponentListener ( this ) ; Point position = calculatePosition ( source ) ; popupComponent . setLocation ( position ) ; popupComponent . setVisible ( _BOOL ) ; popup = new ContainerPopupDialog ( containingWindow , popupComponent , position ) ; popup . setVisible ( _BOOL ) ; popup . requestFocus ( ) ; popupComponent . startTracking ( containingWindow , actionSource ) ; }
public static Element firstChildElement ( Element element , String childElementName , String attrName , String attrValue ) { if ( element == null ) return null ; Node node = element . getFirstChild ( ) ; if ( node != null ) { do { if ( node . getNodeType ( ) == Node . ELEMENT_NODE && ( childElementName == null || childElementName . equals ( node . getLocalName ( ) != null ? node . getLocalName ( ) : node . getNodeName ( ) ) ) ) { Element childElement = ( Element ) node ; String value = childElement . getAttribute ( attrName ) ; if ( value != null && value . equals ( attrValue ) ) { return childElement ; } } } while ( ( node = node . getNextSibling ( ) ) != null ) ; } return null ; }
private void loadFileRecursively ( String path , Map < String , ThriftFileElement > loadedFiles ) throws IOException { ThriftFileElement element = null ; File dir = null ; File file = findFirstExisting ( path , null ) ; if ( file != null ) { file = file . getCanonicalFile ( ) ; if ( loadedFiles . containsKey ( file . getAbsolutePath ( ) ) ) { return ; } dir = file . getParentFile ( ) ; element = loadSingleFile ( file . getParentFile ( ) , file . getName ( ) ) ; } if ( element == null ) { throw new FileNotFoundException ( STRING + path + STRING + includePaths ) ; } loadedFiles . put ( file . getAbsolutePath ( ) , element ) ; ImmutableList < IncludeElement > includes = element . includes ( ) ; if ( includes . size ( ) > _NUM ) { includePaths . addFirst ( dir ) ; for ( IncludeElement include : includes ) { if ( ! include . isCpp ( ) ) { loadFileRecursively ( include . path ( ) , loadedFiles ) ; } } includePaths . removeFirst ( ) ; } }
public void handleCreateInstanceButtonRequest ( RequestInvocationEvent event ) { removePageSessionAttribute ( AUTH_INSTANCE_TABLE ) ; NewAuthInstanceViewBean vb = ( NewAuthInstanceViewBean ) getViewBean ( NewAuthInstanceViewBean . class ) ; unlockPageTrail ( ) ; passPgSessionMap ( vb ) ; vb . forwardTo ( getRequestContext ( ) ) ; }
public void removeNavigationListener ( NavigationListener l ) { navigationListeners . remove ( l ) ; }
public void writeCountsComparisonList ( final String filename , final String format ) { if ( format . compareToIgnoreCase ( STRING ) == _NUM ) { CountSimComparisonKMLWriter kmlWriter = new CountSimComparisonKMLWriter ( countsComparisonList , this . network , TransformationFactory . getCoordinateTransformation ( this . coordinateSystem , TransformationFactory . WGS84 ) ) ; kmlWriter . writeFile ( filename ) ; } else if ( format . compareToIgnoreCase ( STRING ) == _NUM ) { CountSimComparisonTableWriter writer = new CountSimComparisonTableWriter ( countsComparisonList , Locale . US ) ; writer . writeFile ( filename ) ; } else { throw new IllegalArgumentException ( STRING ) ; } ComparisonErrorStatsCalculator errorStats = new ComparisonErrorStatsCalculator ( countsComparisonList ) ; double [ ] hours = new double [ _NUM ] ; for ( int i = _NUM ; i < _NUM ; i ++ ) { hours [ i - _NUM ] = i ; } DoubleArrayTableWriter tableWriter = new DoubleArrayTableWriter ( ) ; tableWriter . addColumn ( hours ) ; tableWriter . addColumn ( errorStats . getMeanRelError ( ) ) ; tableWriter . writeFile ( filename + STRING ) ; }
public int sync ( String entityId , Collection < Statement > statements , Collection < String > valueList ) { long start = System . currentTimeMillis ( ) ; int modified = execute ( STRING , UPDATE_COUNT_RESPONSE , getSyncQuery ( entityId , statements , valueList ) ) ; log . debug ( STRING , entityId , System . currentTimeMillis ( ) - start , modified ) ; return modified ; }
public int sync ( String entityId , Collection < Statement > statements , Collection < String > valueList ) { long start = System . currentTimeMillis ( ) ; int modified = execute ( STRING , UPDATE_COUNT_RESPONSE , getSyncQuery ( entityId , statements , valueList ) ) ; log . debug ( STRING , entityId , System . currentTimeMillis ( ) - start , modified ) ; return modified ; }
public int sync ( String entityId , Collection < Statement > statements , Collection < String > valueList ) { long start = System . currentTimeMillis ( ) ; int modified = execute ( STRING , UPDATE_COUNT_RESPONSE , getSyncQuery ( entityId , statements , valueList ) ) ; log . debug ( STRING , entityId , System . currentTimeMillis ( ) - start , modified ) ; return modified ; }
public int sync ( String entityId , Collection < Statement > statements , Collection < String > valueList ) { long start = System . currentTimeMillis ( ) ; int modified = execute ( STRING , UPDATE_COUNT_RESPONSE , getSyncQuery ( entityId , statements , valueList ) ) ; log . debug ( STRING , entityId , System . currentTimeMillis ( ) - start , modified ) ; return modified ; }
public static boolean jwtHasAuthorizedPartyClaim ( JwtClaimsSet jwtClaims ) throws AuthLoginException { String authorizedPartyClaim = ( String ) jwtClaims . getClaim ( AUTHORIZED_PARTY_CLAIM_KEY ) ; return ( authorizedPartyClaim != null && ! authorizedPartyClaim . isEmpty ( ) ) ; }
public static boolean jwtHasAuthorizedPartyClaim ( JwtClaimsSet jwtClaims ) throws AuthLoginException { String authorizedPartyClaim = ( String ) jwtClaims . getClaim ( AUTHORIZED_PARTY_CLAIM_KEY ) ; return ( authorizedPartyClaim != null && ! authorizedPartyClaim . isEmpty ( ) ) ; }
public static < T > ParallelFlowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . bufferSize ( ) ) ; }
public static < T > ParallelFlowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . bufferSize ( ) ) ; }
public static < T > ParallelFlowable < T > from ( Publisher < ? extends T > source , int parallelism ) { return from ( source , parallelism , Flowable . bufferSize ( ) ) ; }
@ SuppressWarnings ( STRING ) public static boolean equals ( cn . nukkit . level . Location a , cn . nukkit . level . Location b ) { if ( Math . abs ( a . getX ( ) - b . getX ( ) ) > EQUALS_PRECISION ) return _BOOL ; if ( Math . abs ( a . getY ( ) - b . getY ( ) ) > EQUALS_PRECISION ) return _BOOL ; if ( Math . abs ( a . getZ ( ) - b . getZ ( ) ) > EQUALS_PRECISION ) return _BOOL ; return _BOOL ; }
@ SuppressWarnings ( STRING ) public static boolean equals ( cn . nukkit . level . Location a , cn . nukkit . level . Location b ) { if ( Math . abs ( a . getX ( ) - b . getX ( ) ) > EQUALS_PRECISION ) return _BOOL ; if ( Math . abs ( a . getY ( ) - b . getY ( ) ) > EQUALS_PRECISION ) return _BOOL ; if ( Math . abs ( a . getZ ( ) - b . getZ ( ) ) > EQUALS_PRECISION ) return _BOOL ; return _BOOL ; }
public void remove ( int position ) { synchronized ( lock ) { if ( items == null || position < _NUM || position > getItemCount ( ) ) { return ; } items . remove ( position ) ; } if ( notifyOnChange ) { notifyItemRemoved ( position ) ; } }
public void addTasks ( List < Task > tasks ) { myTasks . addAll ( tasks ) ; }
public static byte [ ] stringToBytesASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = _NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . charAt ( i ) ; } return b ; }
public static byte [ ] stringToBytesASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = _NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . charAt ( i ) ; } return b ; }
public static byte [ ] stringToBytesASCII ( String str ) { byte [ ] b = new byte [ str . length ( ) ] ; for ( int i = _NUM ; i < b . length ; i ++ ) { b [ i ] = ( byte ) str . charAt ( i ) ; } return b ; }
public static Resources open ( InputStream resource , int dpi ) throws IOException { return new Resources ( resource , dpi ) ; }
public static Resources open ( InputStream resource , int dpi ) throws IOException { return new Resources ( resource , dpi ) ; }
private void writeMessage ( final ByteBuffer buffer ) { boolean threadShouldWrite = _BOOL ; synchronized ( queue ) { queue . add ( buffer ) ; if ( ! writing ) { writing = _BOOL ; threadShouldWrite = _BOOL ; } } if ( threadShouldWrite ) { writeFromQueue ( ) ; } }
private void writeMessage ( final ByteBuffer buffer ) { boolean threadShouldWrite = _BOOL ; synchronized ( queue ) { queue . add ( buffer ) ; if ( ! writing ) { writing = _BOOL ; threadShouldWrite = _BOOL ; } } if ( threadShouldWrite ) { writeFromQueue ( ) ; } }
public static void addColTimes ( Matrix matrix , long diag , long fromRow , long col , double factor ) { long rows = matrix . getRowCount ( ) ; for ( long row = fromRow ; row < rows ; row ++ ) { matrix . setAsDouble ( matrix . getAsDouble ( row , col ) - factor * matrix . getAsDouble ( row , diag ) , row , col ) ; } }
private void userSelectedADate ( LocalDate selectedDate ) { if ( settings == null ) { return ; } if ( selectedDate != null ) { DateVetoPolicy vetoPolicy = settings . getVetoPolicy ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , selectedDate ) ) { return ; } } if ( selectedDate != null ) { YearMonth selectedDateYearMonth = YearMonth . from ( selectedDate ) ; displayedYearMonth = selectedDateYearMonth ; } else { displayedYearMonth = YearMonth . now ( ) ; } zInternalChangeSelectedDateProcedure ( selectedDate ) ; if ( settings . getParentDatePicker ( ) != null ) { DatePicker parent = settings . getParentDatePicker ( ) ; parent . setDate ( selectedDate ) ; parent . closePopup ( ) ; } }
private void userSelectedADate ( LocalDate selectedDate ) { if ( settings == null ) { return ; } if ( selectedDate != null ) { DateVetoPolicy vetoPolicy = settings . getVetoPolicy ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , selectedDate ) ) { return ; } } if ( selectedDate != null ) { YearMonth selectedDateYearMonth = YearMonth . from ( selectedDate ) ; displayedYearMonth = selectedDateYearMonth ; } else { displayedYearMonth = YearMonth . now ( ) ; } zInternalChangeSelectedDateProcedure ( selectedDate ) ; if ( settings . getParentDatePicker ( ) != null ) { DatePicker parent = settings . getParentDatePicker ( ) ; parent . setDate ( selectedDate ) ; parent . closePopup ( ) ; } }
private void userSelectedADate ( LocalDate selectedDate ) { if ( settings == null ) { return ; } if ( selectedDate != null ) { DateVetoPolicy vetoPolicy = settings . getVetoPolicy ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , selectedDate ) ) { return ; } } if ( selectedDate != null ) { YearMonth selectedDateYearMonth = YearMonth . from ( selectedDate ) ; displayedYearMonth = selectedDateYearMonth ; } else { displayedYearMonth = YearMonth . now ( ) ; } zInternalChangeSelectedDateProcedure ( selectedDate ) ; if ( settings . getParentDatePicker ( ) != null ) { DatePicker parent = settings . getParentDatePicker ( ) ; parent . setDate ( selectedDate ) ; parent . closePopup ( ) ; } }
private void userSelectedADate ( LocalDate selectedDate ) { if ( settings == null ) { return ; } if ( selectedDate != null ) { DateVetoPolicy vetoPolicy = settings . getVetoPolicy ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , selectedDate ) ) { return ; } } if ( selectedDate != null ) { YearMonth selectedDateYearMonth = YearMonth . from ( selectedDate ) ; displayedYearMonth = selectedDateYearMonth ; } else { displayedYearMonth = YearMonth . now ( ) ; } zInternalChangeSelectedDateProcedure ( selectedDate ) ; if ( settings . getParentDatePicker ( ) != null ) { DatePicker parent = settings . getParentDatePicker ( ) ; parent . setDate ( selectedDate ) ; parent . closePopup ( ) ; } }
private void userSelectedADate ( LocalDate selectedDate ) { if ( settings == null ) { return ; } if ( selectedDate != null ) { DateVetoPolicy vetoPolicy = settings . getVetoPolicy ( ) ; if ( InternalUtilities . isDateVetoed ( vetoPolicy , selectedDate ) ) { return ; } } if ( selectedDate != null ) { YearMonth selectedDateYearMonth = YearMonth . from ( selectedDate ) ; displayedYearMonth = selectedDateYearMonth ; } else { displayedYearMonth = YearMonth . now ( ) ; } zInternalChangeSelectedDateProcedure ( selectedDate ) ; if ( settings . getParentDatePicker ( ) != null ) { DatePicker parent = settings . getParentDatePicker ( ) ; parent . setDate ( selectedDate ) ; parent . closePopup ( ) ; } }
public void updatePoints ( mxCellState state , List < mxPoint > points , Object source , Object target ) { if ( state != null ) { List < mxPoint > pts = new ArrayList < mxPoint > ( ) ; pts . add ( state . getAbsolutePoint ( _NUM ) ) ; mxEdgeStyleFunction edgeStyle = getEdgeStyle ( state , points , source , target ) ; if ( edgeStyle != null ) { mxCellState src = getState ( getTerminalPort ( state , source , _BOOL ) ) ; mxCellState trg = getState ( getTerminalPort ( state , target , _BOOL ) ) ; edgeStyle . apply ( state , src , trg , points , pts ) ; } else if ( points != null ) { for ( int i = _NUM ; i < points . size ( ) ; i ++ ) { pts . add ( transformControlPoint ( state , points . get ( i ) ) ) ; } } pts . add ( state . getAbsolutePoint ( state . getAbsolutePointCount ( ) - _NUM ) ) ; state . setAbsolutePoints ( pts ) ; } }
public void updatePoints ( mxCellState state , List < mxPoint > points , Object source , Object target ) { if ( state != null ) { List < mxPoint > pts = new ArrayList < mxPoint > ( ) ; pts . add ( state . getAbsolutePoint ( _NUM ) ) ; mxEdgeStyleFunction edgeStyle = getEdgeStyle ( state , points , source , target ) ; if ( edgeStyle != null ) { mxCellState src = getState ( getTerminalPort ( state , source , _BOOL ) ) ; mxCellState trg = getState ( getTerminalPort ( state , target , _BOOL ) ) ; edgeStyle . apply ( state , src , trg , points , pts ) ; } else if ( points != null ) { for ( int i = _NUM ; i < points . size ( ) ; i ++ ) { pts . add ( transformControlPoint ( state , points . get ( i ) ) ) ; } } pts . add ( state . getAbsolutePoint ( state . getAbsolutePointCount ( ) - _NUM ) ) ; state . setAbsolutePoints ( pts ) ; } }
public Operation removePragmaDirective ( String directive ) { String existingDirectives = getRequestHeader ( PRAGMA_HEADER ) ; if ( existingDirectives != null ) { directive = existingDirectives . replace ( directive , STRING ) ; addRequestHeader ( PRAGMA_HEADER , directive ) ; } return this ; }