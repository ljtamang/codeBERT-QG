public int children ( ) { return children . size ( ) ; }
public boolean contains ( String str ) { for ( String text : logs ) if ( text != null && text . contains ( str ) ) return BOOL ; return BOOL ; }
private boolean is Accepted Method ( String method ) { for ( String allowed : ALLOWED METHODS ) { if ( allowed . equals ( method ) ) { return BOOL ; } } return BOOL ; }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IO Exception { if ( len == NUM ) { return NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < NUM ) { return - NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , NUM , Math . min ( len , MAX BLOCK SIZE ) ) ; if ( nread > NUM ) { System . arraycopy ( buf , NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IO Exception { if ( len == NUM ) { return NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < NUM ) { return - NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , NUM , Math . min ( len , MAX BLOCK SIZE ) ) ; if ( nread > NUM ) { System . arraycopy ( buf , NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IO Exception { if ( len == NUM ) { return NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < NUM ) { return - NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , NUM , Math . min ( len , MAX BLOCK SIZE ) ) ; if ( nread > NUM ) { System . arraycopy ( buf , NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IO Exception { if ( len == NUM ) { return NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < NUM ) { return - NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , NUM , Math . min ( len , MAX BLOCK SIZE ) ) ; if ( nread > NUM ) { System . arraycopy ( buf , NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IO Exception { if ( len == NUM ) { return NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < NUM ) { return - NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , NUM , Math . min ( len , MAX BLOCK SIZE ) ) ; if ( nread > NUM ) { System . arraycopy ( buf , NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
public static boolean check If Any Export Groups Contain Initiator ( Db Client db Client , Set < URI > export Group UR Is , Initiator initiator ) { Iterator < Export Group > export Group Iterator = db Client . query Iterative Objects ( Export Group . class , export Group UR Is , BOOL ) ; while ( export Group Iterator . has Next ( ) ) { Export Group export Group = export Group Iterator . next ( ) ; if ( export Group . has Initiator ( initiator ) ) { return BOOL ; } } return BOOL ; }
private static String check And Replace Code ( final String search For , final String replace With , String script ) { final int index = script . index Of ( search For ) ; if ( index != - NUM ) { final String Builder buf = new String Builder ( script . length ( ) ) ; buf . append ( script . substring ( NUM , index ) ) ; buf . append ( replace With ) ; buf . append ( check And Replace Code ( search For , replace With , script . substring ( index + search For . length ( ) , script . length ( ) ) ) ) ; script = buf . to String ( ) ; } return script ; }
@ Deprecated public static void assert Not Equals ( String item Name , double not Expected , double actual , double delta ) { try { if ( Double . is Infinite ( not Expected ) && not Expected == actual || Math . abs ( not Expected - actual ) <= delta ) { Assert . fail ( item Name + STRING + not Expected + STRING ) ; } } catch ( Assertion Error e ) { Verify . throw Mangled Exception ( e ) ; } }
@ Override public void toggle Selection ( Photo photo ) { if ( selected Photos . contains ( photo . get Path ( ) ) ) { selected Photos . remove ( photo . get Path ( ) ) ; } else { selected Photos . add ( photo . get Path ( ) ) ; } }
@ Override public void toggle Selection ( Photo photo ) { if ( selected Photos . contains ( photo . get Path ( ) ) ) { selected Photos . remove ( photo . get Path ( ) ) ; } else { selected Photos . add ( photo . get Path ( ) ) ; } }
public static final String trim Front ( String str ) { int position = NUM ; while ( ( position < str . length ( ) ) && Character . is Whitespace ( str . char At ( position ) ) ) { position ++ ; } return str . substring ( position , str . length ( ) ) ; }
@ Log Message Doc ( level = STRING , message = STRING + STRING , explanation = STRING + STRING , recommendation = STRING + STRING + STRING ) public void add Listener ( U type , T listener ) { List < T > newlisteners = new Array List < T > ( ) ; if ( listeners != null ) newlisteners . add All ( listeners ) ; newlisteners . add ( listener ) ; List < T > terminals = new Array List < T > ( ) ; for ( T i : newlisteners ) { boolean isterm = BOOL ; for ( T j : newlisteners ) { if ( ispre ( type , i , j ) ) { isterm = BOOL ; break ; } } if ( isterm ) { terminals . add ( i ) ; } } if ( terminals . size ( ) == NUM ) { logger . error ( STRING + STRING ) ; listeners = newlisteners ; return ; } Hash Set < T > visited = new Hash Set < T > ( ) ; List < T > ordering = new Array List < T > ( ) ; for ( T term : terminals ) { visit ( newlisteners , type , visited , ordering , term ) ; } listeners = ordering ; }
public String split Keywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; contents = contents . replace All ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( NUM , MAXSPLITLENGTH ) + STRING ; } for ( String split Contents : contents . split ( STRING ) ) { if ( split Contents . length ( ) >= NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) { String [ ] split Strings = split Contents . split ( STRING ) ; if ( split Strings . length > NUM ) { index Contents . append ( STRING ) ; index Contents . append ( String Utils . join ( split Strings , STRING ) ) ; } } } } return index Contents . to String ( ) ; }
public String split Keywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; contents = contents . replace All ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( NUM , MAXSPLITLENGTH ) + STRING ; } for ( String split Contents : contents . split ( STRING ) ) { if ( split Contents . length ( ) >= NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) { String [ ] split Strings = split Contents . split ( STRING ) ; if ( split Strings . length > NUM ) { index Contents . append ( STRING ) ; index Contents . append ( String Utils . join ( split Strings , STRING ) ) ; } } } } return index Contents . to String ( ) ; }
public String split Keywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; contents = contents . replace All ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( NUM , MAXSPLITLENGTH ) + STRING ; } for ( String split Contents : contents . split ( STRING ) ) { if ( split Contents . length ( ) >= NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) { String [ ] split Strings = split Contents . split ( STRING ) ; if ( split Strings . length > NUM ) { index Contents . append ( STRING ) ; index Contents . append ( String Utils . join ( split Strings , STRING ) ) ; } } } } return index Contents . to String ( ) ; }
public String split Keywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; contents = contents . replace All ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( NUM , MAXSPLITLENGTH ) + STRING ; } for ( String split Contents : contents . split ( STRING ) ) { if ( split Contents . length ( ) >= NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) { String [ ] split Strings = split Contents . split ( STRING ) ; if ( split Strings . length > NUM ) { index Contents . append ( STRING ) ; index Contents . append ( String Utils . join ( split Strings , STRING ) ) ; } } } } return index Contents . to String ( ) ; }
public String split Keywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } String Builder index Contents = new String Builder ( ) ; contents = contents . replace All ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( NUM , MAXSPLITLENGTH ) + STRING ; } for ( String split Contents : contents . split ( STRING ) ) { if ( split Contents . length ( ) >= NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( split Contents ) ; if ( ! m . find ( ) ) { String [ ] split Strings = split Contents . split ( STRING ) ; if ( split Strings . length > NUM ) { index Contents . append ( STRING ) ; index Contents . append ( String Utils . join ( split Strings , STRING ) ) ; } } } } return index Contents . to String ( ) ; }
private static String number To String ( Number number ) { if ( number == null ) { throw new Runtime Exception ( STRING ) ; } test Validity ( number ) ; String string = number . to String ( ) ; if ( string . index Of ( STRING ) > NUM && string . index Of ( STRING ) < NUM && string . index Of ( STRING ) < NUM ) { while ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } if ( string . ends With ( STRING ) ) { string = string . substring ( NUM , string . length ( ) - NUM ) ; } } return string ; }
public int invalidate By Prefix ( String prefix ) { int deleted = NUM ; for ( String key : keys ( ) ) { if ( key . starts With ( prefix ) ) { invalidate ( key ) ; deleted ++ ; } } return deleted ; }
public void make Map ( String data ) { int n1 = data . index Of ( STRING ) ; m Path = new Path ( data . substring ( NUM , n1 ) ) ; int n2 = data . index Of ( STRING ) ; m Select = new Selection ( data . substring ( n1 , n2 ) ) ; enemy Cnt = m Select . Get Enemy Count ( ) ; n1 = data . index Of ( STRING ) ; m Delay = new Delay Time ( data . substring ( n2 , n1 ) ) ; attack Time = m Delay . get Delay ( NUM , NUM ) ; n2 = data . index Of ( STRING ) ; m Pos = new Position ( data . substring ( n1 , n2 ) ) ; m Eny life = new Enemy life ( data . substring ( n2 ) ) ; }
public void make Map ( String data ) { int n1 = data . index Of ( STRING ) ; m Path = new Path ( data . substring ( NUM , n1 ) ) ; int n2 = data . index Of ( STRING ) ; m Select = new Selection ( data . substring ( n1 , n2 ) ) ; enemy Cnt = m Select . Get Enemy Count ( ) ; n1 = data . index Of ( STRING ) ; m Delay = new Delay Time ( data . substring ( n2 , n1 ) ) ; attack Time = m Delay . get Delay ( NUM , NUM ) ; n2 = data . index Of ( STRING ) ; m Pos = new Position ( data . substring ( n1 , n2 ) ) ; m Eny life = new Enemy life ( data . substring ( n2 ) ) ; }
Selector Model ( int n ) { if ( n <= NUM ) { throw new Illegal Argument Exception ( STRING + n + STRING ) ; } this . n = n ; }
@ Override public int preceding ( int offset ) { Character Iterator text = get Text ( ) ; check Offset ( offset , text ) ; text . set Index ( offset ) ; return previous ( ) ; }
public static void v ( String msg ) { if ( s Is Log Enabled ) { Log . v ( s Application Tag , get Contents ( get Current Stack Trace Element ( ) ) + STRING + msg ) ; } }
public void add Virtual Method ( Encoded Method method ) { if ( method == null ) { throw new Null Pointer Exception ( STRING ) ; } virtual Methods . add ( method ) ; }
@ Override public void mouse Pressed ( Mouse Event e ) { events . clear ( ) ; if ( map Drag Operation From Modifiers ( e ) != Dn D Constants . ACTION NONE ) { try { motion Threshold = Drag Source . get Drag Threshold ( ) ; } catch ( Exception exc ) { motion Threshold = NUM ; } append Event ( e ) ; } }
public void close ( ) { Preconditions . check State ( channel != null , STRING ) ; try { if ( channel . is Open ( ) ) channel . close ( ) ; } catch ( IO Exception e ) { LOGGER . error ( STRING , path , e ) ; } finally { channel = null ; } }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
public Ids Query ( Class < T > type , Object [ ] ids ) { this ( type . get Name ( ) , ids , null , null , Query Result Type . DEFAULT ) ; }
@ Suppress Warnings ( STRING ) Symbol select Best ( Env < Attr Context > env , Type site , List < Type > argtypes , List < Type > typeargtypes , Symbol sym , Symbol best So Far , boolean allow Boxing , boolean use Varargs , boolean operator ) { if ( sym . kind == ERR || ! sym . is Inherited In ( site . tsym , types ) ) { return best So Far ; } else if ( use Varargs && ( sym . flags ( ) & VARARGS ) == NUM ) { return best So Far . kind >= ERRONEOUS ? new Bad Varargs Method ( ( Resolve Error ) best So Far ) : best So Far ; } Assert . check ( sym . kind < AMBIGUOUS ) ; try { Type mt = raw Instantiate ( env , site , sym , null , argtypes , typeargtypes , allow Boxing , use Varargs , types . no Warnings ) ; if ( ! operator || verbose Resolution Mode . contains ( Verbose Resolution Mode . PREDEF ) ) current Resolution Context . add Applicable Candidate ( sym , mt ) ; } catch ( Inapplicable Method Exception ex ) { if ( ! operator ) current Resolution Context . add Inapplicable Candidate ( sym , ex . get Diagnostic ( ) ) ; switch ( best So Far . kind ) { case ABSENT MTH : return new Inapplicable Symbol Error ( current Resolution Context ) ; case WRONG MTH : if ( operator ) return best So Far ; best So Far = new Inapplicable Symbols Error ( current Resolution Context ) ; default : return best So Far ; } } if ( ! is Accessible ( env , site , sym ) ) { return ( best So Far . kind == ABSENT MTH ) ? new Access Error ( env , site , sym ) : best So Far ; } return ( best So Far . kind > AMBIGUOUS ) ? sym : most Specific ( argtypes , sym , best So Far , env , site , allow Boxing && operator , use Varargs ) ; }
public static final Authentication create ( String auth Plugin Class Name , String auth Params String ) throws Unsupported Authentication Exception { Map < String , String > auth Params = new Hash Map < String , String > ( ) ; if ( is Not Blank ( auth Params String ) ) { String [ ] params = auth Params String . split ( STRING ) ; for ( String p : params ) { String [ ] kv = p . split ( STRING ) ; if ( kv . length == NUM ) { auth Params . put ( kv [ NUM ] , kv [ NUM ] ) ; } } } return Authentication Factory . create ( auth Plugin Class Name , auth Params ) ; }
public T remove Index ( int index ) { if ( index >= size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; T [ ] items = this . items ; T value = ( T ) items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; }
public T remove Index ( int index ) { if ( index >= size ) throw new Index Out Of Bounds Exception ( String . value Of ( index ) ) ; T [ ] items = this . items ; T value = ( T ) items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; }
public static URI append Query ( final URI uri , final Form query ) { Reject . if Null ( uri ) ; if ( query == null || query . is Empty ( ) ) { return uri ; } if ( uri . get Raw Query ( ) != null ) { query . from Query String ( uri . get Raw Query ( ) ) ; } try { return create ( uri . get Scheme ( ) , uri . get Raw User Info ( ) , uri . get Host ( ) , uri . get Port ( ) , uri . get Raw Path ( ) , query . to Query String ( ) , uri . get Raw Fragment ( ) ) ; } catch ( final URI Syntax Exception e ) { throw new Illegal State Exception ( e ) ; } }
public void remove Index ( int n ) { if ( n >= size ) { throw new Index Out Of Bounds Exception ( STRING ) ; } System . arraycopy ( values , n + NUM , values , n , size - n - NUM ) ; size -- ; }
public void remove Index ( int n ) { if ( n >= size ) { throw new Index Out Of Bounds Exception ( STRING ) ; } System . arraycopy ( values , n + NUM , values , n , size - n - NUM ) ; size -- ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Monitor Train Speed ( Transit Section Action tsa ) { tsa = tsa ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public Sided Plane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sig Num = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sig Num == NUM ) throw new Illegal Argument Exception ( STRING ) ; }
public double slide Subtree ( Mutable Tree tree ) { double log Hastings Ratio ; Node Ref i , new Parent , new Child ; do { i = tree . get Node ( Math Utils . next Int ( tree . get Node Count ( ) ) ) ; } while ( tree . get Root ( ) == i ) ; Node Ref iP = tree . get Parent ( i ) ; Node Ref Ci P = get Other Child ( tree , iP , i ) ; Node Ref Pi P = tree . get Parent ( iP ) ; double delta = get Delta ( ) ; double old Height = tree . get Node Height ( iP ) ; double new Height = old Height + delta ; if ( delta > NUM ) { if ( Pi P != null && tree . get Node Height ( Pi P ) < new Height ) { new Parent = Pi P ; new Child = iP ; while ( tree . get Node Height ( new Parent ) < new Height ) { new Child = new Parent ; new Parent = tree . get Parent ( new Parent ) ; if ( new Parent == null ) break ; } tree . begin Tree Edit ( ) ; if ( tree . is Root ( new Child ) ) { tree . remove Child ( iP , Ci P ) ; tree . remove Child ( Pi P , iP ) ; tree . add Child ( iP , new Child ) ; tree . add Child ( Pi P , Ci P ) ; tree . set Root ( iP ) ; } else { tree . remove Child ( iP , Ci P ) ; tree . remove Child ( Pi P , iP ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( iP , new Child ) ; tree . add Child ( Pi P , Ci P ) ; tree . add Child ( new Parent , iP ) ; } tree . set Node Height ( iP , new Height ) ; tree . end Tree Edit ( ) ; int possible Sources = intersecting Edges ( tree , new Child , old Height , null ) ; log Hastings Ratio = Math . log ( NUM / ( double ) possible Sources ) ; } else { tree . set Node Height ( iP , new Height ) ; log Hastings Ratio = NUM ; } } else { if ( tree . get Node Height ( i ) > new Height ) { return Double . NEGATIVE INFINITY ; } if ( tree . get Node Height ( Ci P ) > new Height ) { Array List new Children = new Array List ( ) ; int possible Destinations = intersecting Edges ( tree , Ci P , new Height , new Children ) ; if ( new Children . size ( ) == NUM ) { return Double . NEGATIVE INFINITY ; } int child Index = Math Utils . next Int ( new Children . size ( ) ) ; new Child = ( Node Ref ) new Children . get ( child Index ) ; new Parent = tree . get Parent ( new Child ) ; tree . begin Tree Edit ( ) ; if ( tree . is Root ( iP ) ) { tree . remove Child ( iP , Ci P ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( iP , new Child ) ; tree . add Child ( new Parent , iP ) ; tree . set Root ( Ci P ) ; } else { tree . remove Child ( iP , Ci P ) ; tree . remove Child ( Pi P , iP ) ; tree . remove Child ( new Parent , new Child ) ; tree . add Child ( iP , new Child ) ; tree . add Child ( Pi P , Ci P ) ; tree . add Child ( new Parent , iP ) ; } tree . set Node Height ( iP , new Height ) ; tree . end Tree Edit ( ) ; log Hastings Ratio = Math . log ( ( double ) possible Destinations ) ; } else { tree . set Node Height ( iP , new Height ) ; log Hastings Ratio = NUM ; } } return log Hastings Ratio ; }
@ Override public String next ( ) { String result ; result = m Current Leaf . get String ( ) ; result = result . substring ( NUM , result . length ( ) - NUM ) ; if ( m Current Leaf != m Last Leaf ) { m Current Leaf = ( Trie Node ) m Current Leaf . get Next Leaf ( ) ; } else { m Current Leaf = null ; } return result ; }
@ Override public String next ( ) { String result ; result = m Current Leaf . get String ( ) ; result = result . substring ( NUM , result . length ( ) - NUM ) ; if ( m Current Leaf != m Last Leaf ) { m Current Leaf = ( Trie Node ) m Current Leaf . get Next Leaf ( ) ; } else { m Current Leaf = null ; } return result ; }
public static String find ( Char Sequence self , Char Sequence regex , @ Closure Params ( value = Simple Type . class , options = STRING ) Closure closure ) { return find ( self , Pattern . compile ( regex . to String ( ) ) , closure ) ; }
public static String find ( Char Sequence self , Char Sequence regex , @ Closure Params ( value = Simple Type . class , options = STRING ) Closure closure ) { return find ( self , Pattern . compile ( regex . to String ( ) ) , closure ) ; }
private static String do Get Full Path ( String filename , boolean include Separator ) { if ( filename == null ) return null ; int prefix = get Prefix Length ( filename ) ; if ( prefix < NUM ) return null ; if ( prefix >= filename . length ( ) ) { if ( include Separator ) return get Prefix ( filename ) ; else return filename ; } int index = index Of Last Separator ( filename ) ; if ( index < NUM ) return filename . substring ( NUM , prefix ) ; int end = index + ( include Separator ? NUM : NUM ) ; if ( end == NUM ) end ++ ; return filename . substring ( NUM , end ) ; }
public Path bin ( ) { return root . resolve ( STRING ) ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private boolean move Within Selected Range ( J Table table , int dx , int dy , List Selection Model rsm , List Selection Model csm ) { int total Count ; int min X , max X , min Y , max Y ; boolean rs = table . get Row Selection Allowed ( ) ; boolean cs = table . get Column Selection Allowed ( ) ; if ( rs && cs ) { total Count = table . get Selected Row Count ( ) * table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( rs ) { total Count = table . get Selected Row Count ( ) ; min X = NUM ; max X = table . get Column Count ( ) - NUM ; min Y = rsm . get Min Selection Index ( ) ; max Y = rsm . get Max Selection Index ( ) ; } else if ( cs ) { total Count = table . get Selected Column Count ( ) ; min X = csm . get Min Selection Index ( ) ; max X = csm . get Max Selection Index ( ) ; min Y = NUM ; max Y = table . get Row Count ( ) - NUM ; } else { total Count = NUM ; min X = max X = min Y = max Y = NUM ; } boolean stay In Selection ; if ( total Count == NUM || ( total Count == NUM && table . is Cell Selected ( lead Row , lead Column ) ) ) { stay In Selection = BOOL ; max X = table . get Column Count ( ) - NUM ; max Y = table . get Row Count ( ) - NUM ; min X = Math . min ( NUM , max X ) ; min Y = Math . min ( NUM , max Y ) ; } else { stay In Selection = BOOL ; } if ( dy == NUM && lead Column == - NUM ) { lead Column = min X ; lead Row = - NUM ; } else if ( dx == NUM && lead Row == - NUM ) { lead Row = min Y ; lead Column = - NUM ; } else if ( dy == - NUM && lead Column == - NUM ) { lead Column = max X ; lead Row = max Y + NUM ; } else if ( dx == - NUM && lead Row == - NUM ) { lead Row = max Y ; lead Column = max X + NUM ; } lead Row = Math . min ( Math . max ( lead Row , min Y - NUM ) , max Y + NUM ) ; lead Column = Math . min ( Math . max ( lead Column , min X - NUM ) , max X + NUM ) ; do { calc Next Pos ( dx , min X , max X , dy , min Y , max Y ) ; } while ( stay In Selection && ! table . is Cell Selected ( lead Row , lead Column ) ) ; return stay In Selection ; }
private void write Handshake ( Web Socket Output Stream output , String key ) throws Web Socket Exception { m Handshake Builder . set Key ( key ) ; String request Line = m Handshake Builder . build Request Line ( ) ; List < String [ ] > headers = m Handshake Builder . build Headers ( ) ; String handshake = Handshake Builder . build ( request Line , headers ) ; m Listener Manager . call On Sending Handshake ( request Line , headers ) ; try { output . write ( handshake ) ; output . flush ( ) ; } catch ( IO Exception e ) { throw new Web Socket Exception ( Web Socket Error . OPENING HAHDSHAKE REQUEST FAILURE , STRING + e . get Message ( ) , e ) ; } }
public void test Value Of Double Pos 2 ( ) { double a = NUM ; Big Decimal result = Big Decimal . value Of ( a ) ; String res = STRING ; int res Scale = NUM ; assert Equals ( STRING , res , result . to String ( ) ) ; assert Equals ( STRING , res Scale , result . scale ( ) ) ; }
public static boolean is Letter ( char c ) { return Character . is Letter ( c ) ; }
public void write Long ( final long data , final int num Bits ) { if ( num Bits < NUM && data >= ( NUM << num Bits ) ) { throw new Illegal Argument Exception ( String . format ( STRING , data , num Bits ) ) ; } for ( int i = num Bits - NUM ; i >= NUM ; i -- ) { boolean bit = ( data > > i & NUM ) != NUM ; if ( bit ) { current Byte |= ( NUM << current Bit Index ) ; } -- current Bit Index ; if ( current Bit Index < NUM ) { write Current Byte ( ) ; } } }
private void unubscribe By Event Type ( Object subscriber , Class < ? > event Type ) { List < Subscription > subscriptions = subscriptions By Event Type . get ( event Type ) ; if ( subscriptions != null ) { int size = subscriptions . size ( ) ; for ( int i = NUM ; i < size ; i ++ ) { if ( subscriptions . get ( i ) . subscriber == subscriber ) { subscriptions . remove ( i ) ; i -- ; size -- ; } } } }
private Jsp Property Group select Property ( Jsp Property Group prev , Jsp Property Group curr ) { if ( prev == null ) { return curr ; } if ( prev . get Extension ( ) == null ) { return prev ; } if ( curr . get Extension ( ) == null ) { return curr ; } String prev Path = prev . get Path ( ) ; String curr Path = curr . get Path ( ) ; if ( prev Path == null && curr Path == null ) { return prev ; } if ( prev Path == null && curr Path != null ) { return curr ; } if ( prev Path != null && curr Path == null ) { return prev ; } if ( prev Path . length ( ) >= curr Path . length ( ) ) { return prev ; } return curr ; }
private Jsp Property Group select Property ( Jsp Property Group prev , Jsp Property Group curr ) { if ( prev == null ) { return curr ; } if ( prev . get Extension ( ) == null ) { return prev ; } if ( curr . get Extension ( ) == null ) { return curr ; } String prev Path = prev . get Path ( ) ; String curr Path = curr . get Path ( ) ; if ( prev Path == null && curr Path == null ) { return prev ; } if ( prev Path == null && curr Path != null ) { return curr ; } if ( prev Path != null && curr Path == null ) { return prev ; } if ( prev Path . length ( ) >= curr Path . length ( ) ) { return prev ; } return curr ; }
private Jsp Property Group select Property ( Jsp Property Group prev , Jsp Property Group curr ) { if ( prev == null ) { return curr ; } if ( prev . get Extension ( ) == null ) { return prev ; } if ( curr . get Extension ( ) == null ) { return curr ; } String prev Path = prev . get Path ( ) ; String curr Path = curr . get Path ( ) ; if ( prev Path == null && curr Path == null ) { return prev ; } if ( prev Path == null && curr Path != null ) { return curr ; } if ( prev Path != null && curr Path == null ) { return prev ; } if ( prev Path . length ( ) >= curr Path . length ( ) ) { return prev ; } return curr ; }
public final boolean is Crypto Allowed ( Key key ) throws Exemption Mechanism Exception { boolean ret = BOOL ; if ( done && ( key != null ) ) { ret = key Stored . equals ( key ) ; } return ret ; }
public final boolean is Crypto Allowed ( Key key ) throws Exemption Mechanism Exception { boolean ret = BOOL ; if ( done && ( key != null ) ) { ret = key Stored . equals ( key ) ; } return ret ; }
public final boolean is Crypto Allowed ( Key key ) throws Exemption Mechanism Exception { boolean ret = BOOL ; if ( done && ( key != null ) ) { ret = key Stored . equals ( key ) ; } return ret ; }
public static Compound Tag read Compound ( Byte Buf buf ) { return read Compound ( buf , BOOL ) ; }
@ Override protected void key Typed ( char par 1 , int par 2 ) { name Box . textbox Key Typed ( par 1 , par 2 ) ; if ( par 2 == NUM || par 2 == NUM ) action Performed ( ( Gui Button ) button List . get ( NUM ) ) ; }
protected static String standardize Keyword ( String keyword ) { if ( keyword == null ) return null ; keyword = keyword . trim ( ) ; if ( keyword . length ( ) == NUM ) return null ; keyword = keyword . to Upper Case ( ) ; String Buffer sb = new String Buffer ( ) ; char [ ] chars = keyword . to Char Array ( ) ; for ( int i = NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; sb . append ( standardize Character ( c ) ) ; } return sb . to String ( ) ; }
public Method Ref Constant add Method Ref ( String class Name , String name , String type ) { Method Ref Constant entry = get Method Ref ( class Name , name , type ) ; if ( entry != null ) return entry ; Class Constant class Entry = add Class ( class Name ) ; Name And Type Constant type Entry = add Name And Type ( name , type ) ; entry = new Method Ref Constant ( this , entries . size ( ) , class Entry . get Index ( ) , type Entry . get Index ( ) ) ; add Constant ( entry ) ; return entry ; }
public double [ ] extract Parameter Jacobian ( final ODE State state , final String p Name ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] d Yd P = new double [ jode . get Dimension ( ) ] ; int i = jode . get Dimension ( ) * jode . get Dimension ( ) ; for ( final String known Parameter : jode . get Parameters Names ( ) ) { if ( p Name . equals ( known Parameter ) ) { System . arraycopy ( p , i , d Yd P , NUM , jode . get Dimension ( ) ) ; break ; } i += jode . get Dimension ( ) ; } return d Yd P ; }
public double [ ] extract Parameter Jacobian ( final ODE State state , final String p Name ) { final double [ ] p = state . get Secondary State ( index ) ; final double [ ] d Yd P = new double [ jode . get Dimension ( ) ] ; int i = jode . get Dimension ( ) * jode . get Dimension ( ) ; for ( final String known Parameter : jode . get Parameters Names ( ) ) { if ( p Name . equals ( known Parameter ) ) { System . arraycopy ( p , i , d Yd P , NUM , jode . get Dimension ( ) ) ; break ; } i += jode . get Dimension ( ) ; } return d Yd P ; }
public static void sort ( short [ ] array ) { Dual Pivot Quicksort . sort ( array ) ; }
public static Map < String , Object > entity Maint Perm Check ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Generic Value user Login = ( Generic Value ) context . get ( STRING ) ; Locale locale = ( Locale ) context . get ( STRING ) ; Security security = dctx . get Security ( ) ; Map < String , Object > result Map = null ; if ( security . has Permission ( STRING , user Login ) ) { result Map = Service Util . return Success ( ) ; result Map . put ( STRING , BOOL ) ; } else { result Map = Service Util . return Failure ( Util Properties . get Message ( resource , STRING , locale ) ) ; result Map . put ( STRING , BOOL ) ; } return result Map ; }
public static Map < String , Object > entity Maint Perm Check ( Dispatch Context dctx , Map < String , ? extends Object > context ) { Generic Value user Login = ( Generic Value ) context . get ( STRING ) ; Locale locale = ( Locale ) context . get ( STRING ) ; Security security = dctx . get Security ( ) ; Map < String , Object > result Map = null ; if ( security . has Permission ( STRING , user Login ) ) { result Map = Service Util . return Success ( ) ; result Map . put ( STRING , BOOL ) ; } else { result Map = Service Util . return Failure ( Util Properties . get Message ( resource , STRING , locale ) ) ; result Map . put ( STRING , BOOL ) ; } return result Map ; }
@ Override public final void write Boolean ( boolean v ) throws IO Exception { dis . write Boolean ( v ) ; }
public Tab Set ( Tab Stop [ ] tabs ) { if ( tabs != null ) { int tab Count = tabs . length ; this . tabs = new Tab Stop [ tab Count ] ; System . arraycopy ( tabs , NUM , this . tabs , NUM , tab Count ) ; } else this . tabs = null ; }
static int [ ] divide ( int quot [ ] , int quot Length , int a [ ] , int a Length , int b [ ] , int b Length ) { int norm A [ ] = new int [ a Length + NUM ] ; int norm B [ ] = new int [ b Length + NUM ] ; int norm B Length = b Length ; int divisor Shift = T Big Decimal . number Of Leading Zeros ( b [ b Length - NUM ] ) ; if ( divisor Shift != NUM ) { T Bit Level . shift Left ( norm B , b , NUM , divisor Shift ) ; T Bit Level . shift Left ( norm A , a , NUM , divisor Shift ) ; } else { System . arraycopy ( a , NUM , norm A , NUM , a Length ) ; System . arraycopy ( b , NUM , norm B , NUM , b Length ) ; } int first Divisor Digit = norm B [ norm B Length - NUM ] ; int i = quot Length - NUM ; int j = a Length ; while ( i >= NUM ) { int guess Digit = NUM ; if ( norm A [ j ] == first Divisor Digit ) { guess Digit = - NUM ; } else { long product = ( ( ( norm A [ j ] & NUM ) << NUM ) + ( norm A [ j - NUM ] & NUM ) ) ; long res = T Division . divide Long By Int ( product , first Divisor Digit ) ; guess Digit = ( int ) res ; int rem = ( int ) ( res > > NUM ) ; if ( guess Digit != NUM ) { long left Hand = NUM ; long right Hand = NUM ; boolean r Overflowed = BOOL ; guess Digit ++ ; do { guess Digit -- ; if ( r Overflowed ) { break ; } left Hand = ( guess Digit & NUM ) * ( norm B [ norm B Length - NUM ] & NUM ) ; right Hand = ( ( long ) rem << NUM ) + ( norm A [ j - NUM ] & NUM ) ; long long R = ( rem & NUM ) + ( first Divisor Digit & NUM ) ; if ( T Big Decimal . number Of Leading Zeros ( ( int ) ( long R > > > NUM ) ) < NUM ) { r Overflowed = BOOL ; } else { rem = ( int ) long R ; } } while ( ( ( left Hand ^ NUM ) > ( right Hand ^ NUM ) ) ) ; } } if ( guess Digit != NUM ) { int borrow = T Division . multiply And Subtract ( norm A , j - norm B Length , norm B , norm B Length , guess Digit ) ; if ( borrow != NUM ) { guess Digit -- ; long carry = NUM ; for ( int k = NUM ; k < norm B Length ; k ++ ) { carry += ( norm A [ j - norm B Length + k ] & NUM ) + ( norm B [ k ] & NUM ) ; norm A [ j - norm B Length + k ] = ( int ) carry ; carry >>>= NUM ; } } } if ( quot != null ) { quot [ i ] = guess Digit ; } j -- ; i -- ; } if ( divisor Shift != NUM ) { T Bit Level . shift Right ( norm B , norm B Length , norm A , NUM , divisor Shift ) ; return norm B ; } System . arraycopy ( norm A , NUM , norm B , NUM , b Length ) ; return norm A ; }
static int [ ] divide ( int quot [ ] , int quot Length , int a [ ] , int a Length , int b [ ] , int b Length ) { int norm A [ ] = new int [ a Length + NUM ] ; int norm B [ ] = new int [ b Length + NUM ] ; int norm B Length = b Length ; int divisor Shift = T Big Decimal . number Of Leading Zeros ( b [ b Length - NUM ] ) ; if ( divisor Shift != NUM ) { T Bit Level . shift Left ( norm B , b , NUM , divisor Shift ) ; T Bit Level . shift Left ( norm A , a , NUM , divisor Shift ) ; } else { System . arraycopy ( a , NUM , norm A , NUM , a Length ) ; System . arraycopy ( b , NUM , norm B , NUM , b Length ) ; } int first Divisor Digit = norm B [ norm B Length - NUM ] ; int i = quot Length - NUM ; int j = a Length ; while ( i >= NUM ) { int guess Digit = NUM ; if ( norm A [ j ] == first Divisor Digit ) { guess Digit = - NUM ; } else { long product = ( ( ( norm A [ j ] & NUM ) << NUM ) + ( norm A [ j - NUM ] & NUM ) ) ; long res = T Division . divide Long By Int ( product , first Divisor Digit ) ; guess Digit = ( int ) res ; int rem = ( int ) ( res > > NUM ) ; if ( guess Digit != NUM ) { long left Hand = NUM ; long right Hand = NUM ; boolean r Overflowed = BOOL ; guess Digit ++ ; do { guess Digit -- ; if ( r Overflowed ) { break ; } left Hand = ( guess Digit & NUM ) * ( norm B [ norm B Length - NUM ] & NUM ) ; right Hand = ( ( long ) rem << NUM ) + ( norm A [ j - NUM ] & NUM ) ; long long R = ( rem & NUM ) + ( first Divisor Digit & NUM ) ; if ( T Big Decimal . number Of Leading Zeros ( ( int ) ( long R > > > NUM ) ) < NUM ) { r Overflowed = BOOL ; } else { rem = ( int ) long R ; } } while ( ( ( left Hand ^ NUM ) > ( right Hand ^ NUM ) ) ) ; } } if ( guess Digit != NUM ) { int borrow = T Division . multiply And Subtract ( norm A , j - norm B Length , norm B , norm B Length , guess Digit ) ; if ( borrow != NUM ) { guess Digit -- ; long carry = NUM ; for ( int k = NUM ; k < norm B Length ; k ++ ) { carry += ( norm A [ j - norm B Length + k ] & NUM ) + ( norm B [ k ] & NUM ) ; norm A [ j - norm B Length + k ] = ( int ) carry ; carry >>>= NUM ; } } } if ( quot != null ) { quot [ i ] = guess Digit ; } j -- ; i -- ; } if ( divisor Shift != NUM ) { T Bit Level . shift Right ( norm B , norm B Length , norm A , NUM , divisor Shift ) ; return norm B ; } System . arraycopy ( norm A , NUM , norm B , NUM , b Length ) ; return norm A ; }
static int [ ] divide ( int quot [ ] , int quot Length , int a [ ] , int a Length , int b [ ] , int b Length ) { int norm A [ ] = new int [ a Length + NUM ] ; int norm B [ ] = new int [ b Length + NUM ] ; int norm B Length = b Length ; int divisor Shift = T Big Decimal . number Of Leading Zeros ( b [ b Length - NUM ] ) ; if ( divisor Shift != NUM ) { T Bit Level . shift Left ( norm B , b , NUM , divisor Shift ) ; T Bit Level . shift Left ( norm A , a , NUM , divisor Shift ) ; } else { System . arraycopy ( a , NUM , norm A , NUM , a Length ) ; System . arraycopy ( b , NUM , norm B , NUM , b Length ) ; } int first Divisor Digit = norm B [ norm B Length - NUM ] ; int i = quot Length - NUM ; int j = a Length ; while ( i >= NUM ) { int guess Digit = NUM ; if ( norm A [ j ] == first Divisor Digit ) { guess Digit = - NUM ; } else { long product = ( ( ( norm A [ j ] & NUM ) << NUM ) + ( norm A [ j - NUM ] & NUM ) ) ; long res = T Division . divide Long By Int ( product , first Divisor Digit ) ; guess Digit = ( int ) res ; int rem = ( int ) ( res > > NUM ) ; if ( guess Digit != NUM ) { long left Hand = NUM ; long right Hand = NUM ; boolean r Overflowed = BOOL ; guess Digit ++ ; do { guess Digit -- ; if ( r Overflowed ) { break ; } left Hand = ( guess Digit & NUM ) * ( norm B [ norm B Length - NUM ] & NUM ) ; right Hand = ( ( long ) rem << NUM ) + ( norm A [ j - NUM ] & NUM ) ; long long R = ( rem & NUM ) + ( first Divisor Digit & NUM ) ; if ( T Big Decimal . number Of Leading Zeros ( ( int ) ( long R > > > NUM ) ) < NUM ) { r Overflowed = BOOL ; } else { rem = ( int ) long R ; } } while ( ( ( left Hand ^ NUM ) > ( right Hand ^ NUM ) ) ) ; } } if ( guess Digit != NUM ) { int borrow = T Division . multiply And Subtract ( norm A , j - norm B Length , norm B , norm B Length , guess Digit ) ; if ( borrow != NUM ) { guess Digit -- ; long carry = NUM ; for ( int k = NUM ; k < norm B Length ; k ++ ) { carry += ( norm A [ j - norm B Length + k ] & NUM ) + ( norm B [ k ] & NUM ) ; norm A [ j - norm B Length + k ] = ( int ) carry ; carry >>>= NUM ; } } } if ( quot != null ) { quot [ i ] = guess Digit ; } j -- ; i -- ; } if ( divisor Shift != NUM ) { T Bit Level . shift Right ( norm B , norm B Length , norm A , NUM , divisor Shift ) ; return norm B ; } System . arraycopy ( norm A , NUM , norm B , NUM , b Length ) ; return norm A ; }
static int [ ] divide ( int quot [ ] , int quot Length , int a [ ] , int a Length , int b [ ] , int b Length ) { int norm A [ ] = new int [ a Length + NUM ] ; int norm B [ ] = new int [ b Length + NUM ] ; int norm B Length = b Length ; int divisor Shift = T Big Decimal . number Of Leading Zeros ( b [ b Length - NUM ] ) ; if ( divisor Shift != NUM ) { T Bit Level . shift Left ( norm B , b , NUM , divisor Shift ) ; T Bit Level . shift Left ( norm A , a , NUM , divisor Shift ) ; } else { System . arraycopy ( a , NUM , norm A , NUM , a Length ) ; System . arraycopy ( b , NUM , norm B , NUM , b Length ) ; } int first Divisor Digit = norm B [ norm B Length - NUM ] ; int i = quot Length - NUM ; int j = a Length ; while ( i >= NUM ) { int guess Digit = NUM ; if ( norm A [ j ] == first Divisor Digit ) { guess Digit = - NUM ; } else { long product = ( ( ( norm A [ j ] & NUM ) << NUM ) + ( norm A [ j - NUM ] & NUM ) ) ; long res = T Division . divide Long By Int ( product , first Divisor Digit ) ; guess Digit = ( int ) res ; int rem = ( int ) ( res > > NUM ) ; if ( guess Digit != NUM ) { long left Hand = NUM ; long right Hand = NUM ; boolean r Overflowed = BOOL ; guess Digit ++ ; do { guess Digit -- ; if ( r Overflowed ) { break ; } left Hand = ( guess Digit & NUM ) * ( norm B [ norm B Length - NUM ] & NUM ) ; right Hand = ( ( long ) rem << NUM ) + ( norm A [ j - NUM ] & NUM ) ; long long R = ( rem & NUM ) + ( first Divisor Digit & NUM ) ; if ( T Big Decimal . number Of Leading Zeros ( ( int ) ( long R > > > NUM ) ) < NUM ) { r Overflowed = BOOL ; } else { rem = ( int ) long R ; } } while ( ( ( left Hand ^ NUM ) > ( right Hand ^ NUM ) ) ) ; } } if ( guess Digit != NUM ) { int borrow = T Division . multiply And Subtract ( norm A , j - norm B Length , norm B , norm B Length , guess Digit ) ; if ( borrow != NUM ) { guess Digit -- ; long carry = NUM ; for ( int k = NUM ; k < norm B Length ; k ++ ) { carry += ( norm A [ j - norm B Length + k ] & NUM ) + ( norm B [ k ] & NUM ) ; norm A [ j - norm B Length + k ] = ( int ) carry ; carry >>>= NUM ; } } } if ( quot != null ) { quot [ i ] = guess Digit ; } j -- ; i -- ; } if ( divisor Shift != NUM ) { T Bit Level . shift Right ( norm B , norm B Length , norm A , NUM , divisor Shift ) ; return norm B ; } System . arraycopy ( norm A , NUM , norm B , NUM , b Length ) ; return norm A ; }
static int [ ] divide ( int quot [ ] , int quot Length , int a [ ] , int a Length , int b [ ] , int b Length ) { int norm A [ ] = new int [ a Length + NUM ] ; int norm B [ ] = new int [ b Length + NUM ] ; int norm B Length = b Length ; int divisor Shift = T Big Decimal . number Of Leading Zeros ( b [ b Length - NUM ] ) ; if ( divisor Shift != NUM ) { T Bit Level . shift Left ( norm B , b , NUM , divisor Shift ) ; T Bit Level . shift Left ( norm A , a , NUM , divisor Shift ) ; } else { System . arraycopy ( a , NUM , norm A , NUM , a Length ) ; System . arraycopy ( b , NUM , norm B , NUM , b Length ) ; } int first Divisor Digit = norm B [ norm B Length - NUM ] ; int i = quot Length - NUM ; int j = a Length ; while ( i >= NUM ) { int guess Digit = NUM ; if ( norm A [ j ] == first Divisor Digit ) { guess Digit = - NUM ; } else { long product = ( ( ( norm A [ j ] & NUM ) << NUM ) + ( norm A [ j - NUM ] & NUM ) ) ; long res = T Division . divide Long By Int ( product , first Divisor Digit ) ; guess Digit = ( int ) res ; int rem = ( int ) ( res > > NUM ) ; if ( guess Digit != NUM ) { long left Hand = NUM ; long right Hand = NUM ; boolean r Overflowed = BOOL ; guess Digit ++ ; do { guess Digit -- ; if ( r Overflowed ) { break ; } left Hand = ( guess Digit & NUM ) * ( norm B [ norm B Length - NUM ] & NUM ) ; right Hand = ( ( long ) rem << NUM ) + ( norm A [ j - NUM ] & NUM ) ; long long R = ( rem & NUM ) + ( first Divisor Digit & NUM ) ; if ( T Big Decimal . number Of Leading Zeros ( ( int ) ( long R > > > NUM ) ) < NUM ) { r Overflowed = BOOL ; } else { rem = ( int ) long R ; } } while ( ( ( left Hand ^ NUM ) > ( right Hand ^ NUM ) ) ) ; } } if ( guess Digit != NUM ) { int borrow = T Division . multiply And Subtract ( norm A , j - norm B Length , norm B , norm B Length , guess Digit ) ; if ( borrow != NUM ) { guess Digit -- ; long carry = NUM ; for ( int k = NUM ; k < norm B Length ; k ++ ) { carry += ( norm A [ j - norm B Length + k ] & NUM ) + ( norm B [ k ] & NUM ) ; norm A [ j - norm B Length + k ] = ( int ) carry ; carry >>>= NUM ; } } } if ( quot != null ) { quot [ i ] = guess Digit ; } j -- ; i -- ; } if ( divisor Shift != NUM ) { T Bit Level . shift Right ( norm B , norm B Length , norm A , NUM , divisor Shift ) ; return norm B ; } System . arraycopy ( norm A , NUM , norm B , NUM , b Length ) ; return norm A ; }
public static Client Exception adapt Input Exception ( final Throwable cause ) { return new Client Exception ( Return Code . ERROR USER DATA , ERR CONSOLE INPUT ERROR . get ( cause . get Message ( ) ) , cause ) ; }
public static Ed 25519 Group Element to Representation ( final Ed 25519 Group Element g , final Coordinate System new Coordinate System ) { final Big Integer x ; final Big Integer y ; final Big Integer gX = to Big Integer ( g . get X ( ) . encode ( ) ) ; final Big Integer gY = to Big Integer ( g . get Y ( ) . encode ( ) ) ; final Big Integer gZ = to Big Integer ( g . get Z ( ) . encode ( ) ) ; final Big Integer gT = null == g . get T ( ) ? null : to Big Integer ( g . get T ( ) . encode ( ) ) ; switch ( g . get Coordinate System ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gY . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case P1 x P 1 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; assert gT != null ; y = gY . multiply ( gT . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; default : throw new Unsupported Operation Exception ( ) ; } switch ( new Coordinate System ) { case AFFINE : return Ed 25519 Group Element . affine ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P2 : return Ed 25519 Group Element . p2 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P3 : return Ed 25519 Group Element . p3 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , to Field Element ( x . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case P1 x P 1 : return Ed 25519 Group Element . p1 xp 1 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , Ed 25519 Field . ONE ) ; case CACHED : return Ed 25519 Group Element . cached ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , Ed 25519 Field . ONE , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case PRECOMPUTED : return Ed 25519 Group Element . precomputed ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; default : throw new Unsupported Operation Exception ( ) ; } }
public static Ed 25519 Group Element to Representation ( final Ed 25519 Group Element g , final Coordinate System new Coordinate System ) { final Big Integer x ; final Big Integer y ; final Big Integer gX = to Big Integer ( g . get X ( ) . encode ( ) ) ; final Big Integer gY = to Big Integer ( g . get Y ( ) . encode ( ) ) ; final Big Integer gZ = to Big Integer ( g . get Z ( ) . encode ( ) ) ; final Big Integer gT = null == g . get T ( ) ? null : to Big Integer ( g . get T ( ) . encode ( ) ) ; switch ( g . get Coordinate System ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gY . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case P1 x P 1 : x = gX . multiply ( gZ . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; assert gT != null ; y = gY . multiply ( gT . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new Big Integer ( STRING ) ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; y = gX . add ( gY ) . multiply ( new Big Integer ( STRING ) . mod Inverse ( Ed 25519 Field . P ) ) . mod ( Ed 25519 Field . P ) ; break ; default : throw new Unsupported Operation Exception ( ) ; } switch ( new Coordinate System ) { case AFFINE : return Ed 25519 Group Element . affine ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P2 : return Ed 25519 Group Element . p2 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE ) ; case P3 : return Ed 25519 Group Element . p3 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , to Field Element ( x . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case P1 x P 1 : return Ed 25519 Group Element . p1 xp 1 ( to Field Element ( x ) , to Field Element ( y ) , Ed 25519 Field . ONE , Ed 25519 Field . ONE ) ; case CACHED : return Ed 25519 Group Element . cached ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , Ed 25519 Field . ONE , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; case PRECOMPUTED : return Ed 25519 Group Element . precomputed ( to Field Element ( y . add ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( y . subtract ( x ) . mod ( Ed 25519 Field . P ) ) , to Field Element ( D . multiply ( new Big Integer ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed 25519 Field . P ) ) ) ; default : throw new Unsupported Operation Exception ( ) ; } }