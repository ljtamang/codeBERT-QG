public int children ( ) { return children . size ( ) ; }
public boolean contains ( String str ) { for ( String text : logs ) if ( text != null && text . contains ( str ) ) return _BOOL ; return _BOOL ; }
private boolean isAcceptedMethod ( String method ) { for ( String allowed : ALLOWED_METHODS ) { if ( allowed . equals ( method ) ) { return _BOOL ; } } return _BOOL ; }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IOException { if ( len == _NUM ) { return _NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _NUM ) { return - _NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _NUM , Math . min ( len , MAX_BLOCK_SIZE ) ) ; if ( nread > _NUM ) { System . arraycopy ( buf , _NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IOException { if ( len == _NUM ) { return _NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _NUM ) { return - _NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _NUM , Math . min ( len , MAX_BLOCK_SIZE ) ) ; if ( nread > _NUM ) { System . arraycopy ( buf , _NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IOException { if ( len == _NUM ) { return _NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _NUM ) { return - _NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _NUM , Math . min ( len , MAX_BLOCK_SIZE ) ) ; if ( nread > _NUM ) { System . arraycopy ( buf , _NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IOException { if ( len == _NUM ) { return _NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _NUM ) { return - _NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _NUM , Math . min ( len , MAX_BLOCK_SIZE ) ) ; if ( nread > _NUM ) { System . arraycopy ( buf , _NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
int read ( byte [ ] b , int off , int len , boolean copy ) throws IOException { if ( len == _NUM ) { return _NUM ; } else if ( blkmode ) { if ( pos == end ) { refill ( ) ; } if ( end < _NUM ) { return - _NUM ; } int nread = Math . min ( len , end - pos ) ; System . arraycopy ( buf , pos , b , off , nread ) ; pos += nread ; return nread ; } else if ( copy ) { int nread = in . read ( buf , _NUM , Math . min ( len , MAX_BLOCK_SIZE ) ) ; if ( nread > _NUM ) { System . arraycopy ( buf , _NUM , b , off , nread ) ; } return nread ; } else { return in . read ( b , off , len ) ; } }
public static boolean checkIfAnyExportGroupsContainInitiator ( DbClient dbClient , Set < URI > exportGroupURIs , Initiator initiator ) { Iterator < ExportGroup > exportGroupIterator = dbClient . queryIterativeObjects ( ExportGroup . class , exportGroupURIs , _BOOL ) ; while ( exportGroupIterator . hasNext ( ) ) { ExportGroup exportGroup = exportGroupIterator . next ( ) ; if ( exportGroup . hasInitiator ( initiator ) ) { return _BOOL ; } } return _BOOL ; }
private static String checkAndReplaceCode ( final String searchFor , final String replaceWith , String script ) { final int index = script . indexOf ( searchFor ) ; if ( index != - _NUM ) { final StringBuilder buf = new StringBuilder ( script . length ( ) ) ; buf . append ( script . substring ( _NUM , index ) ) ; buf . append ( replaceWith ) ; buf . append ( checkAndReplaceCode ( searchFor , replaceWith , script . substring ( index + searchFor . length ( ) , script . length ( ) ) ) ) ; script = buf . toString ( ) ; } return script ; }
@ Deprecated public static void assertNotEquals ( String itemName , double notExpected , double actual , double delta ) { try { if ( Double . isInfinite ( notExpected ) && notExpected == actual || Math . abs ( notExpected - actual ) <= delta ) { Assert . fail ( itemName + STRING + notExpected + STRING ) ; } } catch ( AssertionError e ) { Verify . throwMangledException ( e ) ; } }
@ Override public void toggleSelection ( Photo photo ) { if ( selectedPhotos . contains ( photo . getPath ( ) ) ) { selectedPhotos . remove ( photo . getPath ( ) ) ; } else { selectedPhotos . add ( photo . getPath ( ) ) ; } }
@ Override public void toggleSelection ( Photo photo ) { if ( selectedPhotos . contains ( photo . getPath ( ) ) ) { selectedPhotos . remove ( photo . getPath ( ) ) ; } else { selectedPhotos . add ( photo . getPath ( ) ) ; } }
public static final String trimFront ( String str ) { int position = _NUM ; while ( ( position < str . length ( ) ) && Character . isWhitespace ( str . charAt ( position ) ) ) { position ++ ; } return str . substring ( position , str . length ( ) ) ; }
@ LogMessageDoc ( level = STRING , message = STRING + STRING , explanation = STRING + STRING , recommendation = STRING + STRING + STRING ) public void addListener ( U type , T listener ) { List < T > newlisteners = new ArrayList < T > ( ) ; if ( listeners != null ) newlisteners . addAll ( listeners ) ; newlisteners . add ( listener ) ; List < T > terminals = new ArrayList < T > ( ) ; for ( T i : newlisteners ) { boolean isterm = _BOOL ; for ( T j : newlisteners ) { if ( ispre ( type , i , j ) ) { isterm = _BOOL ; break ; } } if ( isterm ) { terminals . add ( i ) ; } } if ( terminals . size ( ) == _NUM ) { logger . error ( STRING + STRING ) ; listeners = newlisteners ; return ; } HashSet < T > visited = new HashSet < T > ( ) ; List < T > ordering = new ArrayList < T > ( ) ; for ( T term : terminals ) { visit ( newlisteners , type , visited , ordering , term ) ; } listeners = ordering ; }
public String splitKeywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; contents = contents . replaceAll ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( _NUM , MAXSPLITLENGTH ) + STRING ; } for ( String splitContents : contents . split ( STRING ) ) { if ( splitContents . length ( ) >= _NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( splitContents ) ; if ( ! m . find ( ) ) { String [ ] splitStrings = splitContents . split ( STRING ) ; if ( splitStrings . length > _NUM ) { indexContents . append ( STRING ) ; indexContents . append ( StringUtils . join ( splitStrings , STRING ) ) ; } } } } return indexContents . toString ( ) ; }
public String splitKeywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; contents = contents . replaceAll ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( _NUM , MAXSPLITLENGTH ) + STRING ; } for ( String splitContents : contents . split ( STRING ) ) { if ( splitContents . length ( ) >= _NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( splitContents ) ; if ( ! m . find ( ) ) { String [ ] splitStrings = splitContents . split ( STRING ) ; if ( splitStrings . length > _NUM ) { indexContents . append ( STRING ) ; indexContents . append ( StringUtils . join ( splitStrings , STRING ) ) ; } } } } return indexContents . toString ( ) ; }
public String splitKeywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; contents = contents . replaceAll ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( _NUM , MAXSPLITLENGTH ) + STRING ; } for ( String splitContents : contents . split ( STRING ) ) { if ( splitContents . length ( ) >= _NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( splitContents ) ; if ( ! m . find ( ) ) { String [ ] splitStrings = splitContents . split ( STRING ) ; if ( splitStrings . length > _NUM ) { indexContents . append ( STRING ) ; indexContents . append ( StringUtils . join ( splitStrings , STRING ) ) ; } } } } return indexContents . toString ( ) ; }
public String splitKeywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; contents = contents . replaceAll ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( _NUM , MAXSPLITLENGTH ) + STRING ; } for ( String splitContents : contents . split ( STRING ) ) { if ( splitContents . length ( ) >= _NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( splitContents ) ; if ( ! m . find ( ) ) { String [ ] splitStrings = splitContents . split ( STRING ) ; if ( splitStrings . length > _NUM ) { indexContents . append ( STRING ) ; indexContents . append ( StringUtils . join ( splitStrings , STRING ) ) ; } } } } return indexContents . toString ( ) ; }
public String splitKeywords ( String contents ) { if ( contents == null ) { return Values . EMPTYSTRING ; } StringBuilder indexContents = new StringBuilder ( ) ; contents = contents . replaceAll ( STRING , STRING ) ; if ( contents . length ( ) > this . MAXSPLITLENGTH ) { contents = contents . substring ( _NUM , MAXSPLITLENGTH ) + STRING ; } for ( String splitContents : contents . split ( STRING ) ) { if ( splitContents . length ( ) >= _NUM ) { Matcher m = MULTIPLEUPPERCASE . matcher ( splitContents ) ; if ( ! m . find ( ) ) { String [ ] splitStrings = splitContents . split ( STRING ) ; if ( splitStrings . length > _NUM ) { indexContents . append ( STRING ) ; indexContents . append ( StringUtils . join ( splitStrings , STRING ) ) ; } } } } return indexContents . toString ( ) ; }
private static String numberToString ( Number number ) { if ( number == null ) { throw new RuntimeException ( STRING ) ; } testValidity ( number ) ; String string = number . toString ( ) ; if ( string . indexOf ( STRING ) > _NUM && string . indexOf ( STRING ) < _NUM && string . indexOf ( STRING ) < _NUM ) { while ( string . endsWith ( STRING ) ) { string = string . substring ( _NUM , string . length ( ) - _NUM ) ; } if ( string . endsWith ( STRING ) ) { string = string . substring ( _NUM , string . length ( ) - _NUM ) ; } } return string ; }
public int invalidateByPrefix ( String prefix ) { int deleted = _NUM ; for ( String key : keys ( ) ) { if ( key . startsWith ( prefix ) ) { invalidate ( key ) ; deleted ++ ; } } return deleted ; }
public void makeMap ( String data ) { int n1 = data . indexOf ( STRING ) ; mPath = new Path ( data . substring ( _NUM , n1 ) ) ; int n2 = data . indexOf ( STRING ) ; mSelect = new Selection ( data . substring ( n1 , n2 ) ) ; enemy_Cnt = mSelect . GetEnemyCount ( ) ; n1 = data . indexOf ( STRING ) ; mDelay = new DelayTime ( data . substring ( n2 , n1 ) ) ; attackTime = mDelay . getDelay ( _NUM , _NUM ) ; n2 = data . indexOf ( STRING ) ; mPos = new Position ( data . substring ( n1 , n2 ) ) ; mEny_life = new Enemy_life ( data . substring ( n2 ) ) ; }
public void makeMap ( String data ) { int n1 = data . indexOf ( STRING ) ; mPath = new Path ( data . substring ( _NUM , n1 ) ) ; int n2 = data . indexOf ( STRING ) ; mSelect = new Selection ( data . substring ( n1 , n2 ) ) ; enemy_Cnt = mSelect . GetEnemyCount ( ) ; n1 = data . indexOf ( STRING ) ; mDelay = new DelayTime ( data . substring ( n2 , n1 ) ) ; attackTime = mDelay . getDelay ( _NUM , _NUM ) ; n2 = data . indexOf ( STRING ) ; mPos = new Position ( data . substring ( n1 , n2 ) ) ; mEny_life = new Enemy_life ( data . substring ( n2 ) ) ; }
SelectorModel ( int n ) { if ( n <= _NUM ) { throw new IllegalArgumentException ( STRING + n + STRING ) ; } this . n = n ; }
@ Override public int preceding ( int offset ) { CharacterIterator text = getText ( ) ; checkOffset ( offset , text ) ; text . setIndex ( offset ) ; return previous ( ) ; }
public static void v ( String msg ) { if ( sIsLogEnabled ) { Log . v ( sApplicationTag , getContents ( getCurrentStackTraceElement ( ) ) + STRING + msg ) ; } }
public void addVirtualMethod ( EncodedMethod method ) { if ( method == null ) { throw new NullPointerException ( STRING ) ; } virtualMethods . add ( method ) ; }
@ Override public void mousePressed ( MouseEvent e ) { events . clear ( ) ; if ( mapDragOperationFromModifiers ( e ) != DnDConstants . ACTION_NONE ) { try { motionThreshold = DragSource . getDragThreshold ( ) ; } catch ( Exception exc ) { motionThreshold = _NUM ; } appendEvent ( e ) ; } }
public void close ( ) { Preconditions . checkState ( channel != null , STRING ) ; try { if ( channel . isOpen ( ) ) channel . close ( ) ; } catch ( IOException e ) { LOGGER . error ( STRING , path , e ) ; } finally { channel = null ; } }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
public IdsQuery ( Class < T > type , Object [ ] ids ) { this ( type . getName ( ) , ids , null , null , QueryResultType . DEFAULT ) ; }
@ SuppressWarnings ( STRING ) Symbol selectBest ( Env < AttrContext > env , Type site , List < Type > argtypes , List < Type > typeargtypes , Symbol sym , Symbol bestSoFar , boolean allowBoxing , boolean useVarargs , boolean operator ) { if ( sym . kind == ERR || ! sym . isInheritedIn ( site . tsym , types ) ) { return bestSoFar ; } else if ( useVarargs && ( sym . flags ( ) & VARARGS ) == _NUM ) { return bestSoFar . kind >= ERRONEOUS ? new BadVarargsMethod ( ( ResolveError ) bestSoFar ) : bestSoFar ; } Assert . check ( sym . kind < AMBIGUOUS ) ; try { Type mt = rawInstantiate ( env , site , sym , null , argtypes , typeargtypes , allowBoxing , useVarargs , types . noWarnings ) ; if ( ! operator || verboseResolutionMode . contains ( VerboseResolutionMode . PREDEF ) ) currentResolutionContext . addApplicableCandidate ( sym , mt ) ; } catch ( InapplicableMethodException ex ) { if ( ! operator ) currentResolutionContext . addInapplicableCandidate ( sym , ex . getDiagnostic ( ) ) ; switch ( bestSoFar . kind ) { case ABSENT_MTH : return new InapplicableSymbolError ( currentResolutionContext ) ; case WRONG_MTH : if ( operator ) return bestSoFar ; bestSoFar = new InapplicableSymbolsError ( currentResolutionContext ) ; default : return bestSoFar ; } } if ( ! isAccessible ( env , site , sym ) ) { return ( bestSoFar . kind == ABSENT_MTH ) ? new AccessError ( env , site , sym ) : bestSoFar ; } return ( bestSoFar . kind > AMBIGUOUS ) ? sym : mostSpecific ( argtypes , sym , bestSoFar , env , site , allowBoxing && operator , useVarargs ) ; }
public static final Authentication create ( String authPluginClassName , String authParamsString ) throws UnsupportedAuthenticationException { Map < String , String > authParams = new HashMap < String , String > ( ) ; if ( isNotBlank ( authParamsString ) ) { String [ ] params = authParamsString . split ( STRING ) ; for ( String p : params ) { String [ ] kv = p . split ( STRING ) ; if ( kv . length == _NUM ) { authParams . put ( kv [ _NUM ] , kv [ _NUM ] ) ; } } } return AuthenticationFactory . create ( authPluginClassName , authParams ) ; }
public T removeIndex ( int index ) { if ( index >= size ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; T [ ] items = this . items ; T value = ( T ) items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + _NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; }
public T removeIndex ( int index ) { if ( index >= size ) throw new IndexOutOfBoundsException ( String . valueOf ( index ) ) ; T [ ] items = this . items ; T value = ( T ) items [ index ] ; size -- ; if ( ordered ) System . arraycopy ( items , index + _NUM , items , index , size - index ) ; else items [ index ] = items [ size ] ; items [ size ] = null ; return value ; }
public static URI appendQuery ( final URI uri , final Form query ) { Reject . ifNull ( uri ) ; if ( query == null || query . isEmpty ( ) ) { return uri ; } if ( uri . getRawQuery ( ) != null ) { query . fromQueryString ( uri . getRawQuery ( ) ) ; } try { return create ( uri . getScheme ( ) , uri . getRawUserInfo ( ) , uri . getHost ( ) , uri . getPort ( ) , uri . getRawPath ( ) , query . toQueryString ( ) , uri . getRawFragment ( ) ) ; } catch ( final URISyntaxException e ) { throw new IllegalStateException ( e ) ; } }
public void removeIndex ( int n ) { if ( n >= size ) { throw new IndexOutOfBoundsException ( STRING ) ; } System . arraycopy ( values , n + _NUM , values , n , size - n - _NUM ) ; size -- ; }
public void removeIndex ( int n ) { if ( n >= size ) { throw new IndexOutOfBoundsException ( STRING ) ; } System . arraycopy ( values , n + _NUM , values , n , size - n - _NUM ) ; size -- ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public MonitorTrainSpeed ( TransitSectionAction tsa ) { _tsa = tsa ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public SidedPlane ( final double pX , final double pY , final double pZ , final Vector A , final Vector B ) { super ( A , B ) ; sigNum = Math . signum ( evaluate ( pX , pY , pZ ) ) ; if ( sigNum == _NUM ) throw new IllegalArgumentException ( STRING ) ; }
public double slideSubtree ( MutableTree tree ) { double logHastingsRatio ; NodeRef i , newParent , newChild ; do { i = tree . getNode ( MathUtils . nextInt ( tree . getNodeCount ( ) ) ) ; } while ( tree . getRoot ( ) == i ) ; NodeRef iP = tree . getParent ( i ) ; NodeRef CiP = getOtherChild ( tree , iP , i ) ; NodeRef PiP = tree . getParent ( iP ) ; double delta = getDelta ( ) ; double oldHeight = tree . getNodeHeight ( iP ) ; double newHeight = oldHeight + delta ; if ( delta > _NUM ) { if ( PiP != null && tree . getNodeHeight ( PiP ) < newHeight ) { newParent = PiP ; newChild = iP ; while ( tree . getNodeHeight ( newParent ) < newHeight ) { newChild = newParent ; newParent = tree . getParent ( newParent ) ; if ( newParent == null ) break ; } tree . beginTreeEdit ( ) ; if ( tree . isRoot ( newChild ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . setRoot ( iP ) ; } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; int possibleSources = intersectingEdges ( tree , newChild , oldHeight , null ) ; logHastingsRatio = Math . log ( _NUM / ( double ) possibleSources ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logHastingsRatio = _NUM ; } } else { if ( tree . getNodeHeight ( i ) > newHeight ) { return Double . NEGATIVE_INFINITY ; } if ( tree . getNodeHeight ( CiP ) > newHeight ) { ArrayList newChildren = new ArrayList ( ) ; int possibleDestinations = intersectingEdges ( tree , CiP , newHeight , newChildren ) ; if ( newChildren . size ( ) == _NUM ) { return Double . NEGATIVE_INFINITY ; } int childIndex = MathUtils . nextInt ( newChildren . size ( ) ) ; newChild = ( NodeRef ) newChildren . get ( childIndex ) ; newParent = tree . getParent ( newChild ) ; tree . beginTreeEdit ( ) ; if ( tree . isRoot ( iP ) ) { tree . removeChild ( iP , CiP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( newParent , iP ) ; tree . setRoot ( CiP ) ; } else { tree . removeChild ( iP , CiP ) ; tree . removeChild ( PiP , iP ) ; tree . removeChild ( newParent , newChild ) ; tree . addChild ( iP , newChild ) ; tree . addChild ( PiP , CiP ) ; tree . addChild ( newParent , iP ) ; } tree . setNodeHeight ( iP , newHeight ) ; tree . endTreeEdit ( ) ; logHastingsRatio = Math . log ( ( double ) possibleDestinations ) ; } else { tree . setNodeHeight ( iP , newHeight ) ; logHastingsRatio = _NUM ; } } return logHastingsRatio ; }
@ Override public String next ( ) { String result ; result = m_CurrentLeaf . getString ( ) ; result = result . substring ( _NUM , result . length ( ) - _NUM ) ; if ( m_CurrentLeaf != m_LastLeaf ) { m_CurrentLeaf = ( TrieNode ) m_CurrentLeaf . getNextLeaf ( ) ; } else { m_CurrentLeaf = null ; } return result ; }
@ Override public String next ( ) { String result ; result = m_CurrentLeaf . getString ( ) ; result = result . substring ( _NUM , result . length ( ) - _NUM ) ; if ( m_CurrentLeaf != m_LastLeaf ) { m_CurrentLeaf = ( TrieNode ) m_CurrentLeaf . getNextLeaf ( ) ; } else { m_CurrentLeaf = null ; } return result ; }
public static String find ( CharSequence self , CharSequence regex , @ ClosureParams ( value = SimpleType . class , options = STRING ) Closure closure ) { return find ( self , Pattern . compile ( regex . toString ( ) ) , closure ) ; }
public static String find ( CharSequence self , CharSequence regex , @ ClosureParams ( value = SimpleType . class , options = STRING ) Closure closure ) { return find ( self , Pattern . compile ( regex . toString ( ) ) , closure ) ; }
private static String doGetFullPath ( String filename , boolean includeSeparator ) { if ( filename == null ) return null ; int prefix = getPrefixLength ( filename ) ; if ( prefix < _NUM ) return null ; if ( prefix >= filename . length ( ) ) { if ( includeSeparator ) return getPrefix ( filename ) ; else return filename ; } int index = indexOfLastSeparator ( filename ) ; if ( index < _NUM ) return filename . substring ( _NUM , prefix ) ; int end = index + ( includeSeparator ? _NUM : _NUM ) ; if ( end == _NUM ) end ++ ; return filename . substring ( _NUM , end ) ; }
public Path bin ( ) { return root . resolve ( STRING ) ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private boolean moveWithinSelectedRange ( JTable table , int dx , int dy , ListSelectionModel rsm , ListSelectionModel csm ) { int totalCount ; int minX , maxX , minY , maxY ; boolean rs = table . getRowSelectionAllowed ( ) ; boolean cs = table . getColumnSelectionAllowed ( ) ; if ( rs && cs ) { totalCount = table . getSelectedRowCount ( ) * table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( rs ) { totalCount = table . getSelectedRowCount ( ) ; minX = _NUM ; maxX = table . getColumnCount ( ) - _NUM ; minY = rsm . getMinSelectionIndex ( ) ; maxY = rsm . getMaxSelectionIndex ( ) ; } else if ( cs ) { totalCount = table . getSelectedColumnCount ( ) ; minX = csm . getMinSelectionIndex ( ) ; maxX = csm . getMaxSelectionIndex ( ) ; minY = _NUM ; maxY = table . getRowCount ( ) - _NUM ; } else { totalCount = _NUM ; minX = maxX = minY = maxY = _NUM ; } boolean stayInSelection ; if ( totalCount == _NUM || ( totalCount == _NUM && table . isCellSelected ( leadRow , leadColumn ) ) ) { stayInSelection = _BOOL ; maxX = table . getColumnCount ( ) - _NUM ; maxY = table . getRowCount ( ) - _NUM ; minX = Math . min ( _NUM , maxX ) ; minY = Math . min ( _NUM , maxY ) ; } else { stayInSelection = _BOOL ; } if ( dy == _NUM && leadColumn == - _NUM ) { leadColumn = minX ; leadRow = - _NUM ; } else if ( dx == _NUM && leadRow == - _NUM ) { leadRow = minY ; leadColumn = - _NUM ; } else if ( dy == - _NUM && leadColumn == - _NUM ) { leadColumn = maxX ; leadRow = maxY + _NUM ; } else if ( dx == - _NUM && leadRow == - _NUM ) { leadRow = maxY ; leadColumn = maxX + _NUM ; } leadRow = Math . min ( Math . max ( leadRow , minY - _NUM ) , maxY + _NUM ) ; leadColumn = Math . min ( Math . max ( leadColumn , minX - _NUM ) , maxX + _NUM ) ; do { calcNextPos ( dx , minX , maxX , dy , minY , maxY ) ; } while ( stayInSelection && ! table . isCellSelected ( leadRow , leadColumn ) ) ; return stayInSelection ; }
private void writeHandshake ( WebSocketOutputStream output , String key ) throws WebSocketException { mHandshakeBuilder . setKey ( key ) ; String requestLine = mHandshakeBuilder . buildRequestLine ( ) ; List < String [ ] > headers = mHandshakeBuilder . buildHeaders ( ) ; String handshake = HandshakeBuilder . build ( requestLine , headers ) ; mListenerManager . callOnSendingHandshake ( requestLine , headers ) ; try { output . write ( handshake ) ; output . flush ( ) ; } catch ( IOException e ) { throw new WebSocketException ( WebSocketError . OPENING_HAHDSHAKE_REQUEST_FAILURE , STRING + e . getMessage ( ) , e ) ; } }
public void testValueOfDoublePos2 ( ) { double a = _NUM ; BigDecimal result = BigDecimal . valueOf ( a ) ; String res = STRING ; int resScale = _NUM ; assertEquals ( STRING , res , result . toString ( ) ) ; assertEquals ( STRING , resScale , result . scale ( ) ) ; }
public static boolean isLetter ( char c ) { return Character . isLetter ( c ) ; }
public void writeLong ( final long data , final int numBits ) { if ( numBits < _NUM && data >= ( _NUM << numBits ) ) { throw new IllegalArgumentException ( String . format ( STRING , data , numBits ) ) ; } for ( int i = numBits - _NUM ; i >= _NUM ; i -- ) { boolean bit = ( data > > i & _NUM ) != _NUM ; if ( bit ) { currentByte |= ( _NUM << currentBitIndex ) ; } -- currentBitIndex ; if ( currentBitIndex < _NUM ) { writeCurrentByte ( ) ; } } }
private void unubscribeByEventType ( Object subscriber , Class < ? > eventType ) { List < Subscription > subscriptions = subscriptionsByEventType . get ( eventType ) ; if ( subscriptions != null ) { int size = subscriptions . size ( ) ; for ( int i = _NUM ; i < size ; i ++ ) { if ( subscriptions . get ( i ) . subscriber == subscriber ) { subscriptions . remove ( i ) ; i -- ; size -- ; } } } }
private JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { if ( prev == null ) { return curr ; } if ( prev . getExtension ( ) == null ) { return prev ; } if ( curr . getExtension ( ) == null ) { return curr ; } String prevPath = prev . getPath ( ) ; String currPath = curr . getPath ( ) ; if ( prevPath == null && currPath == null ) { return prev ; } if ( prevPath == null && currPath != null ) { return curr ; } if ( prevPath != null && currPath == null ) { return prev ; } if ( prevPath . length ( ) >= currPath . length ( ) ) { return prev ; } return curr ; }
private JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { if ( prev == null ) { return curr ; } if ( prev . getExtension ( ) == null ) { return prev ; } if ( curr . getExtension ( ) == null ) { return curr ; } String prevPath = prev . getPath ( ) ; String currPath = curr . getPath ( ) ; if ( prevPath == null && currPath == null ) { return prev ; } if ( prevPath == null && currPath != null ) { return curr ; } if ( prevPath != null && currPath == null ) { return prev ; } if ( prevPath . length ( ) >= currPath . length ( ) ) { return prev ; } return curr ; }
private JspPropertyGroup selectProperty ( JspPropertyGroup prev , JspPropertyGroup curr ) { if ( prev == null ) { return curr ; } if ( prev . getExtension ( ) == null ) { return prev ; } if ( curr . getExtension ( ) == null ) { return curr ; } String prevPath = prev . getPath ( ) ; String currPath = curr . getPath ( ) ; if ( prevPath == null && currPath == null ) { return prev ; } if ( prevPath == null && currPath != null ) { return curr ; } if ( prevPath != null && currPath == null ) { return prev ; } if ( prevPath . length ( ) >= currPath . length ( ) ) { return prev ; } return curr ; }
public final boolean isCryptoAllowed ( Key key ) throws ExemptionMechanismException { boolean ret = _BOOL ; if ( done && ( key != null ) ) { ret = keyStored . equals ( key ) ; } return ret ; }
public final boolean isCryptoAllowed ( Key key ) throws ExemptionMechanismException { boolean ret = _BOOL ; if ( done && ( key != null ) ) { ret = keyStored . equals ( key ) ; } return ret ; }
public final boolean isCryptoAllowed ( Key key ) throws ExemptionMechanismException { boolean ret = _BOOL ; if ( done && ( key != null ) ) { ret = keyStored . equals ( key ) ; } return ret ; }
public static CompoundTag readCompound ( ByteBuf buf ) { return readCompound ( buf , _BOOL ) ; }
@ Override protected void keyTyped ( char par1 , int par2 ) { nameBox . textboxKeyTyped ( par1 , par2 ) ; if ( par2 == _NUM || par2 == _NUM ) actionPerformed ( ( GuiButton ) buttonList . get ( _NUM ) ) ; }
protected static String standardizeKeyword ( String keyword ) { if ( keyword == null ) return null ; keyword = keyword . trim ( ) ; if ( keyword . length ( ) == _NUM ) return null ; keyword = keyword . toUpperCase ( ) ; StringBuffer sb = new StringBuffer ( ) ; char [ ] chars = keyword . toCharArray ( ) ; for ( int i = _NUM ; i < chars . length ; i ++ ) { char c = chars [ i ] ; sb . append ( standardizeCharacter ( c ) ) ; } return sb . toString ( ) ; }
public MethodRefConstant addMethodRef ( String className , String name , String type ) { MethodRefConstant entry = getMethodRef ( className , name , type ) ; if ( entry != null ) return entry ; ClassConstant classEntry = addClass ( className ) ; NameAndTypeConstant typeEntry = addNameAndType ( name , type ) ; entry = new MethodRefConstant ( this , _entries . size ( ) , classEntry . getIndex ( ) , typeEntry . getIndex ( ) ) ; addConstant ( entry ) ; return entry ; }
public double [ ] extractParameterJacobian ( final ODEState state , final String pName ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] dYdP = new double [ jode . getDimension ( ) ] ; int i = jode . getDimension ( ) * jode . getDimension ( ) ; for ( final String knownParameter : jode . getParametersNames ( ) ) { if ( pName . equals ( knownParameter ) ) { System . arraycopy ( p , i , dYdP , _NUM , jode . getDimension ( ) ) ; break ; } i += jode . getDimension ( ) ; } return dYdP ; }
public double [ ] extractParameterJacobian ( final ODEState state , final String pName ) { final double [ ] p = state . getSecondaryState ( index ) ; final double [ ] dYdP = new double [ jode . getDimension ( ) ] ; int i = jode . getDimension ( ) * jode . getDimension ( ) ; for ( final String knownParameter : jode . getParametersNames ( ) ) { if ( pName . equals ( knownParameter ) ) { System . arraycopy ( p , i , dYdP , _NUM , jode . getDimension ( ) ) ; break ; } i += jode . getDimension ( ) ; } return dYdP ; }
public static void sort ( short [ ] array ) { DualPivotQuicksort . sort ( array ) ; }
public static Map < String , Object > entityMaintPermCheck ( DispatchContext dctx , Map < String , ? extends Object > context ) { GenericValue userLogin = ( GenericValue ) context . get ( STRING ) ; Locale locale = ( Locale ) context . get ( STRING ) ; Security security = dctx . getSecurity ( ) ; Map < String , Object > resultMap = null ; if ( security . hasPermission ( STRING , userLogin ) ) { resultMap = ServiceUtil . returnSuccess ( ) ; resultMap . put ( STRING , _BOOL ) ; } else { resultMap = ServiceUtil . returnFailure ( UtilProperties . getMessage ( resource , STRING , locale ) ) ; resultMap . put ( STRING , _BOOL ) ; } return resultMap ; }
public static Map < String , Object > entityMaintPermCheck ( DispatchContext dctx , Map < String , ? extends Object > context ) { GenericValue userLogin = ( GenericValue ) context . get ( STRING ) ; Locale locale = ( Locale ) context . get ( STRING ) ; Security security = dctx . getSecurity ( ) ; Map < String , Object > resultMap = null ; if ( security . hasPermission ( STRING , userLogin ) ) { resultMap = ServiceUtil . returnSuccess ( ) ; resultMap . put ( STRING , _BOOL ) ; } else { resultMap = ServiceUtil . returnFailure ( UtilProperties . getMessage ( resource , STRING , locale ) ) ; resultMap . put ( STRING , _BOOL ) ; } return resultMap ; }
@ Override public final void writeBoolean ( boolean v ) throws IOException { dis . writeBoolean ( v ) ; }
public TabSet ( TabStop [ ] tabs ) { if ( tabs != null ) { int tabCount = tabs . length ; this . tabs = new TabStop [ tabCount ] ; System . arraycopy ( tabs , _NUM , this . tabs , _NUM , tabCount ) ; } else this . tabs = null ; }
static int [ ] divide ( int quot [ ] , int quotLength , int a [ ] , int aLength , int b [ ] , int bLength ) { int normA [ ] = new int [ aLength + _NUM ] ; int normB [ ] = new int [ bLength + _NUM ] ; int normBLength = bLength ; int divisorShift = TBigDecimal . numberOfLeadingZeros ( b [ bLength - _NUM ] ) ; if ( divisorShift != _NUM ) { TBitLevel . shiftLeft ( normB , b , _NUM , divisorShift ) ; TBitLevel . shiftLeft ( normA , a , _NUM , divisorShift ) ; } else { System . arraycopy ( a , _NUM , normA , _NUM , aLength ) ; System . arraycopy ( b , _NUM , normB , _NUM , bLength ) ; } int firstDivisorDigit = normB [ normBLength - _NUM ] ; int i = quotLength - _NUM ; int j = aLength ; while ( i >= _NUM ) { int guessDigit = _NUM ; if ( normA [ j ] == firstDivisorDigit ) { guessDigit = - _NUM ; } else { long product = ( ( ( normA [ j ] & _NUM ) << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ) ; long res = TDivision . divideLongByInt ( product , firstDivisorDigit ) ; guessDigit = ( int ) res ; int rem = ( int ) ( res > > _NUM ) ; if ( guessDigit != _NUM ) { long leftHand = _NUM ; long rightHand = _NUM ; boolean rOverflowed = _BOOL ; guessDigit ++ ; do { guessDigit -- ; if ( rOverflowed ) { break ; } leftHand = ( guessDigit & _NUM ) * ( normB [ normBLength - _NUM ] & _NUM ) ; rightHand = ( ( long ) rem << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ; long longR = ( rem & _NUM ) + ( firstDivisorDigit & _NUM ) ; if ( TBigDecimal . numberOfLeadingZeros ( ( int ) ( longR > > > _NUM ) ) < _NUM ) { rOverflowed = _BOOL ; } else { rem = ( int ) longR ; } } while ( ( ( leftHand ^ _NUM ) > ( rightHand ^ _NUM ) ) ) ; } } if ( guessDigit != _NUM ) { int borrow = TDivision . multiplyAndSubtract ( normA , j - normBLength , normB , normBLength , guessDigit ) ; if ( borrow != _NUM ) { guessDigit -- ; long carry = _NUM ; for ( int k = _NUM ; k < normBLength ; k ++ ) { carry += ( normA [ j - normBLength + k ] & _NUM ) + ( normB [ k ] & _NUM ) ; normA [ j - normBLength + k ] = ( int ) carry ; carry >>>= _NUM ; } } } if ( quot != null ) { quot [ i ] = guessDigit ; } j -- ; i -- ; } if ( divisorShift != _NUM ) { TBitLevel . shiftRight ( normB , normBLength , normA , _NUM , divisorShift ) ; return normB ; } System . arraycopy ( normA , _NUM , normB , _NUM , bLength ) ; return normA ; }
static int [ ] divide ( int quot [ ] , int quotLength , int a [ ] , int aLength , int b [ ] , int bLength ) { int normA [ ] = new int [ aLength + _NUM ] ; int normB [ ] = new int [ bLength + _NUM ] ; int normBLength = bLength ; int divisorShift = TBigDecimal . numberOfLeadingZeros ( b [ bLength - _NUM ] ) ; if ( divisorShift != _NUM ) { TBitLevel . shiftLeft ( normB , b , _NUM , divisorShift ) ; TBitLevel . shiftLeft ( normA , a , _NUM , divisorShift ) ; } else { System . arraycopy ( a , _NUM , normA , _NUM , aLength ) ; System . arraycopy ( b , _NUM , normB , _NUM , bLength ) ; } int firstDivisorDigit = normB [ normBLength - _NUM ] ; int i = quotLength - _NUM ; int j = aLength ; while ( i >= _NUM ) { int guessDigit = _NUM ; if ( normA [ j ] == firstDivisorDigit ) { guessDigit = - _NUM ; } else { long product = ( ( ( normA [ j ] & _NUM ) << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ) ; long res = TDivision . divideLongByInt ( product , firstDivisorDigit ) ; guessDigit = ( int ) res ; int rem = ( int ) ( res > > _NUM ) ; if ( guessDigit != _NUM ) { long leftHand = _NUM ; long rightHand = _NUM ; boolean rOverflowed = _BOOL ; guessDigit ++ ; do { guessDigit -- ; if ( rOverflowed ) { break ; } leftHand = ( guessDigit & _NUM ) * ( normB [ normBLength - _NUM ] & _NUM ) ; rightHand = ( ( long ) rem << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ; long longR = ( rem & _NUM ) + ( firstDivisorDigit & _NUM ) ; if ( TBigDecimal . numberOfLeadingZeros ( ( int ) ( longR > > > _NUM ) ) < _NUM ) { rOverflowed = _BOOL ; } else { rem = ( int ) longR ; } } while ( ( ( leftHand ^ _NUM ) > ( rightHand ^ _NUM ) ) ) ; } } if ( guessDigit != _NUM ) { int borrow = TDivision . multiplyAndSubtract ( normA , j - normBLength , normB , normBLength , guessDigit ) ; if ( borrow != _NUM ) { guessDigit -- ; long carry = _NUM ; for ( int k = _NUM ; k < normBLength ; k ++ ) { carry += ( normA [ j - normBLength + k ] & _NUM ) + ( normB [ k ] & _NUM ) ; normA [ j - normBLength + k ] = ( int ) carry ; carry >>>= _NUM ; } } } if ( quot != null ) { quot [ i ] = guessDigit ; } j -- ; i -- ; } if ( divisorShift != _NUM ) { TBitLevel . shiftRight ( normB , normBLength , normA , _NUM , divisorShift ) ; return normB ; } System . arraycopy ( normA , _NUM , normB , _NUM , bLength ) ; return normA ; }
static int [ ] divide ( int quot [ ] , int quotLength , int a [ ] , int aLength , int b [ ] , int bLength ) { int normA [ ] = new int [ aLength + _NUM ] ; int normB [ ] = new int [ bLength + _NUM ] ; int normBLength = bLength ; int divisorShift = TBigDecimal . numberOfLeadingZeros ( b [ bLength - _NUM ] ) ; if ( divisorShift != _NUM ) { TBitLevel . shiftLeft ( normB , b , _NUM , divisorShift ) ; TBitLevel . shiftLeft ( normA , a , _NUM , divisorShift ) ; } else { System . arraycopy ( a , _NUM , normA , _NUM , aLength ) ; System . arraycopy ( b , _NUM , normB , _NUM , bLength ) ; } int firstDivisorDigit = normB [ normBLength - _NUM ] ; int i = quotLength - _NUM ; int j = aLength ; while ( i >= _NUM ) { int guessDigit = _NUM ; if ( normA [ j ] == firstDivisorDigit ) { guessDigit = - _NUM ; } else { long product = ( ( ( normA [ j ] & _NUM ) << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ) ; long res = TDivision . divideLongByInt ( product , firstDivisorDigit ) ; guessDigit = ( int ) res ; int rem = ( int ) ( res > > _NUM ) ; if ( guessDigit != _NUM ) { long leftHand = _NUM ; long rightHand = _NUM ; boolean rOverflowed = _BOOL ; guessDigit ++ ; do { guessDigit -- ; if ( rOverflowed ) { break ; } leftHand = ( guessDigit & _NUM ) * ( normB [ normBLength - _NUM ] & _NUM ) ; rightHand = ( ( long ) rem << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ; long longR = ( rem & _NUM ) + ( firstDivisorDigit & _NUM ) ; if ( TBigDecimal . numberOfLeadingZeros ( ( int ) ( longR > > > _NUM ) ) < _NUM ) { rOverflowed = _BOOL ; } else { rem = ( int ) longR ; } } while ( ( ( leftHand ^ _NUM ) > ( rightHand ^ _NUM ) ) ) ; } } if ( guessDigit != _NUM ) { int borrow = TDivision . multiplyAndSubtract ( normA , j - normBLength , normB , normBLength , guessDigit ) ; if ( borrow != _NUM ) { guessDigit -- ; long carry = _NUM ; for ( int k = _NUM ; k < normBLength ; k ++ ) { carry += ( normA [ j - normBLength + k ] & _NUM ) + ( normB [ k ] & _NUM ) ; normA [ j - normBLength + k ] = ( int ) carry ; carry >>>= _NUM ; } } } if ( quot != null ) { quot [ i ] = guessDigit ; } j -- ; i -- ; } if ( divisorShift != _NUM ) { TBitLevel . shiftRight ( normB , normBLength , normA , _NUM , divisorShift ) ; return normB ; } System . arraycopy ( normA , _NUM , normB , _NUM , bLength ) ; return normA ; }
static int [ ] divide ( int quot [ ] , int quotLength , int a [ ] , int aLength , int b [ ] , int bLength ) { int normA [ ] = new int [ aLength + _NUM ] ; int normB [ ] = new int [ bLength + _NUM ] ; int normBLength = bLength ; int divisorShift = TBigDecimal . numberOfLeadingZeros ( b [ bLength - _NUM ] ) ; if ( divisorShift != _NUM ) { TBitLevel . shiftLeft ( normB , b , _NUM , divisorShift ) ; TBitLevel . shiftLeft ( normA , a , _NUM , divisorShift ) ; } else { System . arraycopy ( a , _NUM , normA , _NUM , aLength ) ; System . arraycopy ( b , _NUM , normB , _NUM , bLength ) ; } int firstDivisorDigit = normB [ normBLength - _NUM ] ; int i = quotLength - _NUM ; int j = aLength ; while ( i >= _NUM ) { int guessDigit = _NUM ; if ( normA [ j ] == firstDivisorDigit ) { guessDigit = - _NUM ; } else { long product = ( ( ( normA [ j ] & _NUM ) << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ) ; long res = TDivision . divideLongByInt ( product , firstDivisorDigit ) ; guessDigit = ( int ) res ; int rem = ( int ) ( res > > _NUM ) ; if ( guessDigit != _NUM ) { long leftHand = _NUM ; long rightHand = _NUM ; boolean rOverflowed = _BOOL ; guessDigit ++ ; do { guessDigit -- ; if ( rOverflowed ) { break ; } leftHand = ( guessDigit & _NUM ) * ( normB [ normBLength - _NUM ] & _NUM ) ; rightHand = ( ( long ) rem << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ; long longR = ( rem & _NUM ) + ( firstDivisorDigit & _NUM ) ; if ( TBigDecimal . numberOfLeadingZeros ( ( int ) ( longR > > > _NUM ) ) < _NUM ) { rOverflowed = _BOOL ; } else { rem = ( int ) longR ; } } while ( ( ( leftHand ^ _NUM ) > ( rightHand ^ _NUM ) ) ) ; } } if ( guessDigit != _NUM ) { int borrow = TDivision . multiplyAndSubtract ( normA , j - normBLength , normB , normBLength , guessDigit ) ; if ( borrow != _NUM ) { guessDigit -- ; long carry = _NUM ; for ( int k = _NUM ; k < normBLength ; k ++ ) { carry += ( normA [ j - normBLength + k ] & _NUM ) + ( normB [ k ] & _NUM ) ; normA [ j - normBLength + k ] = ( int ) carry ; carry >>>= _NUM ; } } } if ( quot != null ) { quot [ i ] = guessDigit ; } j -- ; i -- ; } if ( divisorShift != _NUM ) { TBitLevel . shiftRight ( normB , normBLength , normA , _NUM , divisorShift ) ; return normB ; } System . arraycopy ( normA , _NUM , normB , _NUM , bLength ) ; return normA ; }
static int [ ] divide ( int quot [ ] , int quotLength , int a [ ] , int aLength , int b [ ] , int bLength ) { int normA [ ] = new int [ aLength + _NUM ] ; int normB [ ] = new int [ bLength + _NUM ] ; int normBLength = bLength ; int divisorShift = TBigDecimal . numberOfLeadingZeros ( b [ bLength - _NUM ] ) ; if ( divisorShift != _NUM ) { TBitLevel . shiftLeft ( normB , b , _NUM , divisorShift ) ; TBitLevel . shiftLeft ( normA , a , _NUM , divisorShift ) ; } else { System . arraycopy ( a , _NUM , normA , _NUM , aLength ) ; System . arraycopy ( b , _NUM , normB , _NUM , bLength ) ; } int firstDivisorDigit = normB [ normBLength - _NUM ] ; int i = quotLength - _NUM ; int j = aLength ; while ( i >= _NUM ) { int guessDigit = _NUM ; if ( normA [ j ] == firstDivisorDigit ) { guessDigit = - _NUM ; } else { long product = ( ( ( normA [ j ] & _NUM ) << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ) ; long res = TDivision . divideLongByInt ( product , firstDivisorDigit ) ; guessDigit = ( int ) res ; int rem = ( int ) ( res > > _NUM ) ; if ( guessDigit != _NUM ) { long leftHand = _NUM ; long rightHand = _NUM ; boolean rOverflowed = _BOOL ; guessDigit ++ ; do { guessDigit -- ; if ( rOverflowed ) { break ; } leftHand = ( guessDigit & _NUM ) * ( normB [ normBLength - _NUM ] & _NUM ) ; rightHand = ( ( long ) rem << _NUM ) + ( normA [ j - _NUM ] & _NUM ) ; long longR = ( rem & _NUM ) + ( firstDivisorDigit & _NUM ) ; if ( TBigDecimal . numberOfLeadingZeros ( ( int ) ( longR > > > _NUM ) ) < _NUM ) { rOverflowed = _BOOL ; } else { rem = ( int ) longR ; } } while ( ( ( leftHand ^ _NUM ) > ( rightHand ^ _NUM ) ) ) ; } } if ( guessDigit != _NUM ) { int borrow = TDivision . multiplyAndSubtract ( normA , j - normBLength , normB , normBLength , guessDigit ) ; if ( borrow != _NUM ) { guessDigit -- ; long carry = _NUM ; for ( int k = _NUM ; k < normBLength ; k ++ ) { carry += ( normA [ j - normBLength + k ] & _NUM ) + ( normB [ k ] & _NUM ) ; normA [ j - normBLength + k ] = ( int ) carry ; carry >>>= _NUM ; } } } if ( quot != null ) { quot [ i ] = guessDigit ; } j -- ; i -- ; } if ( divisorShift != _NUM ) { TBitLevel . shiftRight ( normB , normBLength , normA , _NUM , divisorShift ) ; return normB ; } System . arraycopy ( normA , _NUM , normB , _NUM , bLength ) ; return normA ; }
public static ClientException adaptInputException ( final Throwable cause ) { return new ClientException ( ReturnCode . ERROR_USER_DATA , ERR_CONSOLE_INPUT_ERROR . get ( cause . getMessage ( ) ) , cause ) ; }
public static Ed25519GroupElement toRepresentation ( final Ed25519GroupElement g , final CoordinateSystem newCoordinateSystem ) { final BigInteger x ; final BigInteger y ; final BigInteger gX = toBigInteger ( g . getX ( ) . encode ( ) ) ; final BigInteger gY = toBigInteger ( g . getY ( ) . encode ( ) ) ; final BigInteger gZ = toBigInteger ( g . getZ ( ) . encode ( ) ) ; final BigInteger gT = null == g . getT ( ) ? null : toBigInteger ( g . getT ( ) . encode ( ) ) ; switch ( g . getCoordinateSystem ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gY . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case P1xP1 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; assert gT != null ; y = gY . multiply ( gT . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STRING ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STRING ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new BigInteger ( STRING ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( new BigInteger ( STRING ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; default : throw new UnsupportedOperationException ( ) ; } switch ( newCoordinateSystem ) { case AFFINE : return Ed25519GroupElement . affine ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P2 : return Ed25519GroupElement . p2 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P3 : return Ed25519GroupElement . p3 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , toFieldElement ( x . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case P1xP1 : return Ed25519GroupElement . p1xp1 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , Ed25519Field . ONE ) ; case CACHED : return Ed25519GroupElement . cached ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , Ed25519Field . ONE , toFieldElement ( D . multiply ( new BigInteger ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case PRECOMPUTED : return Ed25519GroupElement . precomputed ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( D . multiply ( new BigInteger ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; default : throw new UnsupportedOperationException ( ) ; } }
public static Ed25519GroupElement toRepresentation ( final Ed25519GroupElement g , final CoordinateSystem newCoordinateSystem ) { final BigInteger x ; final BigInteger y ; final BigInteger gX = toBigInteger ( g . getX ( ) . encode ( ) ) ; final BigInteger gY = toBigInteger ( g . getY ( ) . encode ( ) ) ; final BigInteger gZ = toBigInteger ( g . getZ ( ) . encode ( ) ) ; final BigInteger gT = null == g . getT ( ) ? null : toBigInteger ( g . getT ( ) . encode ( ) ) ; switch ( g . getCoordinateSystem ( ) ) { case AFFINE : x = gX ; y = gY ; break ; case P2 : case P3 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gY . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case P1xP1 : x = gX . multiply ( gZ . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; assert gT != null ; y = gY . multiply ( gT . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case CACHED : x = gX . subtract ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STRING ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( gZ . multiply ( new BigInteger ( STRING ) ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; case PRECOMPUTED : x = gX . subtract ( gY ) . multiply ( new BigInteger ( STRING ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; y = gX . add ( gY ) . multiply ( new BigInteger ( STRING ) . modInverse ( Ed25519Field . P ) ) . mod ( Ed25519Field . P ) ; break ; default : throw new UnsupportedOperationException ( ) ; } switch ( newCoordinateSystem ) { case AFFINE : return Ed25519GroupElement . affine ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P2 : return Ed25519GroupElement . p2 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE ) ; case P3 : return Ed25519GroupElement . p3 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , toFieldElement ( x . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case P1xP1 : return Ed25519GroupElement . p1xp1 ( toFieldElement ( x ) , toFieldElement ( y ) , Ed25519Field . ONE , Ed25519Field . ONE ) ; case CACHED : return Ed25519GroupElement . cached ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , Ed25519Field . ONE , toFieldElement ( D . multiply ( new BigInteger ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; case PRECOMPUTED : return Ed25519GroupElement . precomputed ( toFieldElement ( y . add ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( y . subtract ( x ) . mod ( Ed25519Field . P ) ) , toFieldElement ( D . multiply ( new BigInteger ( STRING ) ) . multiply ( x ) . multiply ( y ) . mod ( Ed25519Field . P ) ) ) ; default : throw new UnsupportedOperationException ( ) ; } }