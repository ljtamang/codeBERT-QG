protected abstract void onSuccess ( T result ) ;
public CacheObject load ( Object key , int x , int y , int zoomLevel , Projection proj ) { if ( key instanceof String ) { String imagePath = ( String ) key ; if ( verbose ) { logger . fine ( STRING + imagePath ) ; } try { URL imageURL = PropUtils . getResourceOrFileOrURL ( imagePath ) ; if ( imageURL != null ) { BufferedImage bi = BufferedImageHelper . getBufferedImage ( imageURL ) ; OMGraphic raster = createOMGraphicFromBufferedImage ( bi , x , y , zoomLevel , proj ) ; if ( raster != null ) { return new CacheObject ( imagePath , raster ) ; } } else { logger . fine ( STRING + imagePath ) ; } } catch ( MalformedURLException e ) { logger . fine ( STRING + imagePath ) ; } catch ( InterruptedException e ) { logger . fine ( STRING + imagePath ) ; } catch ( Exception fnfe ) { logger . fine ( STRING + imagePath ) ; } } return null ; }
public CacheObject load ( Object key , int x , int y , int zoomLevel , Projection proj ) { if ( key instanceof String ) { String imagePath = ( String ) key ; if ( verbose ) { logger . fine ( STRING + imagePath ) ; } try { URL imageURL = PropUtils . getResourceOrFileOrURL ( imagePath ) ; if ( imageURL != null ) { BufferedImage bi = BufferedImageHelper . getBufferedImage ( imageURL ) ; OMGraphic raster = createOMGraphicFromBufferedImage ( bi , x , y , zoomLevel , proj ) ; if ( raster != null ) { return new CacheObject ( imagePath , raster ) ; } } else { logger . fine ( STRING + imagePath ) ; } } catch ( MalformedURLException e ) { logger . fine ( STRING + imagePath ) ; } catch ( InterruptedException e ) { logger . fine ( STRING + imagePath ) ; } catch ( Exception fnfe ) { logger . fine ( STRING + imagePath ) ; } } return null ; }
public CacheObject load ( Object key , int x , int y , int zoomLevel , Projection proj ) { if ( key instanceof String ) { String imagePath = ( String ) key ; if ( verbose ) { logger . fine ( STRING + imagePath ) ; } try { URL imageURL = PropUtils . getResourceOrFileOrURL ( imagePath ) ; if ( imageURL != null ) { BufferedImage bi = BufferedImageHelper . getBufferedImage ( imageURL ) ; OMGraphic raster = createOMGraphicFromBufferedImage ( bi , x , y , zoomLevel , proj ) ; if ( raster != null ) { return new CacheObject ( imagePath , raster ) ; } } else { logger . fine ( STRING + imagePath ) ; } } catch ( MalformedURLException e ) { logger . fine ( STRING + imagePath ) ; } catch ( InterruptedException e ) { logger . fine ( STRING + imagePath ) ; } catch ( Exception fnfe ) { logger . fine ( STRING + imagePath ) ; } } return null ; }
public CacheObject load ( Object key , int x , int y , int zoomLevel , Projection proj ) { if ( key instanceof String ) { String imagePath = ( String ) key ; if ( verbose ) { logger . fine ( STRING + imagePath ) ; } try { URL imageURL = PropUtils . getResourceOrFileOrURL ( imagePath ) ; if ( imageURL != null ) { BufferedImage bi = BufferedImageHelper . getBufferedImage ( imageURL ) ; OMGraphic raster = createOMGraphicFromBufferedImage ( bi , x , y , zoomLevel , proj ) ; if ( raster != null ) { return new CacheObject ( imagePath , raster ) ; } } else { logger . fine ( STRING + imagePath ) ; } } catch ( MalformedURLException e ) { logger . fine ( STRING + imagePath ) ; } catch ( InterruptedException e ) { logger . fine ( STRING + imagePath ) ; } catch ( Exception fnfe ) { logger . fine ( STRING + imagePath ) ; } } return null ; }
public void addPageStreamingDescriptorImports ( ModelTypeTable typeTable ) { }
private boolean partOfURL ( int index ) { if ( inURL != null ) return inURL [ index ] ; inURL = new boolean [ text . length ( ) ] ; Matcher m = pURLs . matcher ( text ) ; while ( m . find ( ) ) for ( int i = m . start ( ) ; i < m . end ( ) ; ++ i ) inURL [ i ] = _BOOL ; return inURL [ index ] ; }
private boolean partOfURL ( int index ) { if ( inURL != null ) return inURL [ index ] ; inURL = new boolean [ text . length ( ) ] ; Matcher m = pURLs . matcher ( text ) ; while ( m . find ( ) ) for ( int i = m . start ( ) ; i < m . end ( ) ; ++ i ) inURL [ i ] = _BOOL ; return inURL [ index ] ; }
private boolean partOfURL ( int index ) { if ( inURL != null ) return inURL [ index ] ; inURL = new boolean [ text . length ( ) ] ; Matcher m = pURLs . matcher ( text ) ; while ( m . find ( ) ) for ( int i = m . start ( ) ; i < m . end ( ) ; ++ i ) inURL [ i ] = _BOOL ; return inURL [ index ] ; }
private boolean partOfURL ( int index ) { if ( inURL != null ) return inURL [ index ] ; inURL = new boolean [ text . length ( ) ] ; Matcher m = pURLs . matcher ( text ) ; while ( m . find ( ) ) for ( int i = m . start ( ) ; i < m . end ( ) ; ++ i ) inURL [ i ] = _BOOL ; return inURL [ index ] ; }
private boolean partOfURL ( int index ) { if ( inURL != null ) return inURL [ index ] ; inURL = new boolean [ text . length ( ) ] ; Matcher m = pURLs . matcher ( text ) ; while ( m . find ( ) ) for ( int i = m . start ( ) ; i < m . end ( ) ; ++ i ) inURL [ i ] = _BOOL ; return inURL [ index ] ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < > ( ) ; } mListeners . add ( listener ) ; }
public void addSwipeListener ( SwipeListener listener ) { if ( mListeners == null ) { mListeners = new ArrayList < > ( ) ; } mListeners . add ( listener ) ; }
public int indexOf ( final Artist a ) { synchronized ( mArtists ) { return mArtists . indexOf ( a ) ; } }
private void handleJsonCreateQuotation ( RequestAndResponse requestAndResponse ) throws IOException , ServletException { requestAndResponse . setResponseContentTypeJson ( ) ; String url ; String title ; String quotation ; String note ; String sessionId ; try { final JsonNodeHelper json = getJsonNode ( requestAndResponse ) ; url = json . getString ( DbLogic . Constants . url ) ; title = json . getString ( DbLogic . Constants . title ) ; quotation = json . getString ( DbLogic . Constants . quotation ) ; note = json . getString ( DbLogic . Constants . note ) ; sessionId = json . getString ( STRING ) ; } catch ( final IOException e ) { returnJson400 ( requestAndResponse , servletText . errorJson ( ) ) ; return ; } if ( ! EntryAttributeValidator . isNoteValid ( note ) ) { returnJson400 ( requestAndResponse , servletText . errorNoteIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isQuotationValid ( quotation ) ) { returnJson400 ( requestAndResponse , servletText . errorQuotationIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isUrlValid ( url ) ) { returnJson400 ( requestAndResponse , servletText . errorUrlIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isSourceTitleValid ( title ) ) { returnJson400 ( requestAndResponse , servletText . errorTitleIsInvalid ( ) ) ; return ; } final Errors errors = new Errors ( ) ; try { final Long time = new Long ( System . currentTimeMillis ( ) ) ; String userId = null ; if ( sessionManager != null ) { final HttpSession session = sessionManager . getSession ( sessionId ) ; if ( session != null && session . getAttribute ( sessionUserIdAttribute ) != null ) { userId = ( String ) session . getAttribute ( sessionUserIdAttribute ) ; } } final User user = dbLogic . getUserById ( userId ) ; if ( user == null ) { returnJson400 ( requestAndResponse , servletText . errorNoAccountFound ( ) ) ; return ; } if ( user . getIsAccountClosed ( ) ) { returnJson400 ( requestAndResponse , servletText . errorAccountIsClosed ( ) ) ; return ; } final Entry source = dbLogic . updateOrCreateSource ( user , null , url , title , time , time , isUserAnAdmin ( requestAndResponse ) , errors ) ; if ( source == null ) { returnJson400 ( requestAndResponse , errors ) ; return ; } final Entry entry = dbLogic . createEntryQuotation ( user , source , quotation , note , time , isUserAnAdmin ( requestAndResponse ) , errors ) ; if ( entry == null ) { returnJson400 ( requestAndResponse , errors ) ; return ; } requestAndResponse . print ( STRING + STRING + entry . getId ( ) + STRING + STRING + source . getId ( ) + STRING ) ; dbLogic . commit ( ) ; } catch ( final PersistenceException e ) { logger . log ( Level . INFO , STRING , e ) ; returnJson500 ( requestAndResponse , servletText . errorInternalDatabase ( ) ) ; } }
private void handleJsonCreateQuotation ( RequestAndResponse requestAndResponse ) throws IOException , ServletException { requestAndResponse . setResponseContentTypeJson ( ) ; String url ; String title ; String quotation ; String note ; String sessionId ; try { final JsonNodeHelper json = getJsonNode ( requestAndResponse ) ; url = json . getString ( DbLogic . Constants . url ) ; title = json . getString ( DbLogic . Constants . title ) ; quotation = json . getString ( DbLogic . Constants . quotation ) ; note = json . getString ( DbLogic . Constants . note ) ; sessionId = json . getString ( STRING ) ; } catch ( final IOException e ) { returnJson400 ( requestAndResponse , servletText . errorJson ( ) ) ; return ; } if ( ! EntryAttributeValidator . isNoteValid ( note ) ) { returnJson400 ( requestAndResponse , servletText . errorNoteIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isQuotationValid ( quotation ) ) { returnJson400 ( requestAndResponse , servletText . errorQuotationIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isUrlValid ( url ) ) { returnJson400 ( requestAndResponse , servletText . errorUrlIsInvalid ( ) ) ; return ; } if ( ! EntryAttributeValidator . isSourceTitleValid ( title ) ) { returnJson400 ( requestAndResponse , servletText . errorTitleIsInvalid ( ) ) ; return ; } final Errors errors = new Errors ( ) ; try { final Long time = new Long ( System . currentTimeMillis ( ) ) ; String userId = null ; if ( sessionManager != null ) { final HttpSession session = sessionManager . getSession ( sessionId ) ; if ( session != null && session . getAttribute ( sessionUserIdAttribute ) != null ) { userId = ( String ) session . getAttribute ( sessionUserIdAttribute ) ; } } final User user = dbLogic . getUserById ( userId ) ; if ( user == null ) { returnJson400 ( requestAndResponse , servletText . errorNoAccountFound ( ) ) ; return ; } if ( user . getIsAccountClosed ( ) ) { returnJson400 ( requestAndResponse , servletText . errorAccountIsClosed ( ) ) ; return ; } final Entry source = dbLogic . updateOrCreateSource ( user , null , url , title , time , time , isUserAnAdmin ( requestAndResponse ) , errors ) ; if ( source == null ) { returnJson400 ( requestAndResponse , errors ) ; return ; } final Entry entry = dbLogic . createEntryQuotation ( user , source , quotation , note , time , isUserAnAdmin ( requestAndResponse ) , errors ) ; if ( entry == null ) { returnJson400 ( requestAndResponse , errors ) ; return ; } requestAndResponse . print ( STRING + STRING + entry . getId ( ) + STRING + STRING + source . getId ( ) + STRING ) ; dbLogic . commit ( ) ; } catch ( final PersistenceException e ) { logger . log ( Level . INFO , STRING , e ) ; returnJson500 ( requestAndResponse , servletText . errorInternalDatabase ( ) ) ; } }
private synchronized void removeLoader ( ClassLoader loader ) { int i ; for ( i = _loaders . size ( ) - _NUM ; i >= _NUM ; i -- ) { WeakReference < ClassLoader > ref = _loaders . get ( i ) ; ClassLoader refLoader = ref . get ( ) ; if ( refLoader == null ) _loaders . remove ( i ) ; else if ( refLoader == loader ) _loaders . remove ( i ) ; } }
public void returnValue ( ) { mv . visitInsn ( returnType . getOpcode ( Opcodes . IRETURN ) ) ; }
public void test_parkUntil_1 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }
public void test_parkUntil_1 ( ) throws Exception { CyclicBarrier barrier = new CyclicBarrier ( _NUM ) ; Parker parker = new Parker ( barrier , _BOOL , _NUM ) ; Thread parkerThread = new Thread ( parker ) ; Thread waiterThread = new Thread ( new WaitAndUnpark ( barrier , _NUM , parkerThread ) ) ; parkerThread . start ( ) ; waiterThread . start ( ) ; parker . assertDurationIsInRange ( _NUM ) ; waiterThread . join ( ) ; parkerThread . join ( ) ; }