@ Nullable public static String merge Xml ( @ Not Null Rendering Context context , String source Xml , String target Xml , File target File ) { boolean ok ; String file Name = target File . get Name ( ) ; String contents ; if ( file Name . equals ( Sdk Constants . FN ANDROID MANIFEST XML ) ) { Document current Document = Xml Utils . parse Document Silently ( target Xml , BOOL ) ; assert current Document != null : target Xml + STRING ; Document fragment = Xml Utils . parse Document Silently ( source Xml , BOOL ) ; assert fragment != null : source Xml + STRING ; contents = merge Manifest ( target File , target Xml , source Xml ) ; ok = contents != null ; } else { String parent Folder Name = target File . get Parent File ( ) . get Name ( ) ; Resource Folder Type folder Type = Resource Folder Type . get Folder Type ( parent Folder Name ) ; contents = merge Resource File ( context , target Xml , source Xml , file Name , folder Type ) ; ok = contents != null ; } if ( ! ok ) { contents = wrap With Merge Conflict ( target Xml , source Xml ) ; context . get Warnings ( ) . add ( String . format ( STRING , target File . get Name ( ) ) ) ; } return contents ; }
@ Nullable public static String merge Xml ( @ Not Null Rendering Context context , String source Xml , String target Xml , File target File ) { boolean ok ; String file Name = target File . get Name ( ) ; String contents ; if ( file Name . equals ( Sdk Constants . FN ANDROID MANIFEST XML ) ) { Document current Document = Xml Utils . parse Document Silently ( target Xml , BOOL ) ; assert current Document != null : target Xml + STRING ; Document fragment = Xml Utils . parse Document Silently ( source Xml , BOOL ) ; assert fragment != null : source Xml + STRING ; contents = merge Manifest ( target File , target Xml , source Xml ) ; ok = contents != null ; } else { String parent Folder Name = target File . get Parent File ( ) . get Name ( ) ; Resource Folder Type folder Type = Resource Folder Type . get Folder Type ( parent Folder Name ) ; contents = merge Resource File ( context , target Xml , source Xml , file Name , folder Type ) ; ok = contents != null ; } if ( ! ok ) { contents = wrap With Merge Conflict ( target Xml , source Xml ) ; context . get Warnings ( ) . add ( String . format ( STRING , target File . get Name ( ) ) ) ; } return contents ; }
public Templates Handler new Templates Handler ( ) throws Transformer Configuration Exception { return new Stylesheet Handler ( this ) ; }
public Templates Handler new Templates Handler ( ) throws Transformer Configuration Exception { return new Stylesheet Handler ( this ) ; }
public Templates Handler new Templates Handler ( ) throws Transformer Configuration Exception { return new Stylesheet Handler ( this ) ; }
public static synchronized void log Start ( ) { I Product product = Platform . get Product ( ) ; String about Text = product . get Property ( STRING ) ; String application = STRING ; if ( about Text != null ) { String lines [ ] = about Text . split ( STRING ) ; if ( lines != null && lines . length > NUM ) { application = lines [ NUM ] ; } } LOG . info ( STRING + application + STRING + DF . format ( System . current Time Millis ( ) ) ) ; }
public static synchronized void log Start ( ) { I Product product = Platform . get Product ( ) ; String about Text = product . get Property ( STRING ) ; String application = STRING ; if ( about Text != null ) { String lines [ ] = about Text . split ( STRING ) ; if ( lines != null && lines . length > NUM ) { application = lines [ NUM ] ; } } LOG . info ( STRING + application + STRING + DF . format ( System . current Time Millis ( ) ) ) ; }
public void sort ( Array List < Value [ ] > rows , int offset , int limit ) { int rows Size = rows . size ( ) ; if ( rows . is Empty ( ) || offset >= rows Size || limit == NUM ) { return ; } if ( offset < NUM ) { offset = NUM ; } if ( offset + limit > rows Size ) { limit = rows Size - offset ; } if ( limit == NUM && offset == NUM ) { rows . set ( NUM , Collections . min ( rows , this ) ) ; return ; } Value [ ] [ ] arr = rows . to Array ( new Value [ rows Size ] [ ] ) ; Utils . sort Top N ( arr , offset , limit , this ) ; for ( int i = NUM , end = Math . min ( offset + limit , rows Size ) ; i < end ; i ++ ) { rows . set ( i , arr [ i ] ) ; } }
protected Object parse ( String text , Type type , Type array Element Type , int flags ) { if ( ! in CDATA ( flags ) ) { if ( ! ignore Binding ( flags ) ) { Binding Expression result = parse Binding Expression ( text ) ; if ( result != null ) { return result ; } else { text = cleanup Binding Escapes ( text ) ; } } if ( ! ignore At Function ( flags ) ) { String at Function Name = get At Function Name ( text ) ; if ( at Function Name != null ) { return parse At Function ( at Function Name , text , type , array Element Type , flags ) ; } else { text = cleanup At Function Escapes ( text ) ; flags = flags | Text Parser . Flag Ignore At Function Escape ; } } } if ( is Rich Text Content ( flags ) ) { String parsed String = parse String ( text , flags ) ; if ( type == type Table . array Type ) { return array ( Collections . singleton ( ( Object ) parsed String ) , array Element Type ) ; } else { return parsed String ; } } else { return parse Value ( text , type , array Element Type , flags ) ; } }
protected Object parse ( String text , Type type , Type array Element Type , int flags ) { if ( ! in CDATA ( flags ) ) { if ( ! ignore Binding ( flags ) ) { Binding Expression result = parse Binding Expression ( text ) ; if ( result != null ) { return result ; } else { text = cleanup Binding Escapes ( text ) ; } } if ( ! ignore At Function ( flags ) ) { String at Function Name = get At Function Name ( text ) ; if ( at Function Name != null ) { return parse At Function ( at Function Name , text , type , array Element Type , flags ) ; } else { text = cleanup At Function Escapes ( text ) ; flags = flags | Text Parser . Flag Ignore At Function Escape ; } } } if ( is Rich Text Content ( flags ) ) { String parsed String = parse String ( text , flags ) ; if ( type == type Table . array Type ) { return array ( Collections . singleton ( ( Object ) parsed String ) , array Element Type ) ; } else { return parsed String ; } } else { return parse Value ( text , type , array Element Type , flags ) ; } }
protected Object parse ( String text , Type type , Type array Element Type , int flags ) { if ( ! in CDATA ( flags ) ) { if ( ! ignore Binding ( flags ) ) { Binding Expression result = parse Binding Expression ( text ) ; if ( result != null ) { return result ; } else { text = cleanup Binding Escapes ( text ) ; } } if ( ! ignore At Function ( flags ) ) { String at Function Name = get At Function Name ( text ) ; if ( at Function Name != null ) { return parse At Function ( at Function Name , text , type , array Element Type , flags ) ; } else { text = cleanup At Function Escapes ( text ) ; flags = flags | Text Parser . Flag Ignore At Function Escape ; } } } if ( is Rich Text Content ( flags ) ) { String parsed String = parse String ( text , flags ) ; if ( type == type Table . array Type ) { return array ( Collections . singleton ( ( Object ) parsed String ) , array Element Type ) ; } else { return parsed String ; } } else { return parse Value ( text , type , array Element Type , flags ) ; } }
public boolean sphere In Frustum ( Vector 3 center , float radius ) { for ( int i = NUM ; i < NUM ; i ++ ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return BOOL ; return BOOL ; }
public boolean sphere In Frustum ( Vector 3 center , float radius ) { for ( int i = NUM ; i < NUM ; i ++ ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return BOOL ; return BOOL ; }
public void wait If Exclusive Mode Enabled ( ) { if ( database . get Lob Session ( ) == this ) { return ; } while ( BOOL ) { Session exclusive = database . get Exclusive Session ( ) ; if ( exclusive == null || exclusive == this ) { break ; } if ( Thread . holds Lock ( exclusive ) ) { break ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } } }
public void wait If Exclusive Mode Enabled ( ) { if ( database . get Lob Session ( ) == this ) { return ; } while ( BOOL ) { Session exclusive = database . get Exclusive Session ( ) ; if ( exclusive == null || exclusive == this ) { break ; } if ( Thread . holds Lock ( exclusive ) ) { break ; } try { Thread . sleep ( NUM ) ; } catch ( Interrupted Exception e ) { } } }
public String report Error ( XML Locator location , String domain , String key , Object [ ] arguments , short severity , Exception exception ) throws XNI Exception { Message Formatter message Formatter = get Message Formatter ( domain ) ; String message ; if ( message Formatter != null ) { message = message Formatter . format Message ( f Locale , key , arguments ) ; } else { String Buffer str = new String Buffer ( ) ; str . append ( domain ) ; str . append ( STRING ) ; str . append ( key ) ; int arg Count = arguments != null ? arguments . length : NUM ; if ( arg Count > NUM ) { str . append ( STRING ) ; for ( int i = NUM ; i < arg Count ; i ++ ) { str . append ( arguments [ i ] ) ; if ( i < arg Count - NUM ) { str . append ( STRING ) ; } } } message = str . to String ( ) ; } XML Parse Exception parse Exception = ( exception != null ) ? new XML Parse Exception ( location , message , exception ) : new XML Parse Exception ( location , message ) ; XML Error Handler error Handler = f Error Handler ; if ( error Handler == null ) { if ( f Default Error Handler == null ) { f Default Error Handler = new Default Error Handler ( ) ; } error Handler = f Default Error Handler ; } switch ( severity ) { case SEVERITY WARNING : { error Handler . warning ( domain , key , parse Exception ) ; break ; } case SEVERITY ERROR : { error Handler . error ( domain , key , parse Exception ) ; break ; } case SEVERITY FATAL ERROR : { error Handler . fatal Error ( domain , key , parse Exception ) ; if ( ! f Continue After Fatal Error ) { throw parse Exception ; } break ; } } return message ; }
private int parse Content Type ( final byte [ ] b , final int off ) throws Parse Exception { content Type Val = Primitives Parser . parse Byte ( b , off ) ; if ( Content Type . deserialize ( content Type Val ) == null ) { throw new Bad Ciphertext Exception ( STRING ) ; } return NUM ; }
private int parse Content Type ( final byte [ ] b , final int off ) throws Parse Exception { content Type Val = Primitives Parser . parse Byte ( b , off ) ; if ( Content Type . deserialize ( content Type Val ) == null ) { throw new Bad Ciphertext Exception ( STRING ) ; } return NUM ; }
private int parse Content Type ( final byte [ ] b , final int off ) throws Parse Exception { content Type Val = Primitives Parser . parse Byte ( b , off ) ; if ( Content Type . deserialize ( content Type Val ) == null ) { throw new Bad Ciphertext Exception ( STRING ) ; } return NUM ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
private static URL [ ] path To UR Ls ( String path ) throws Malformed URL Exception { if ( path == null ) { return null ; } synchronized ( path To UR Ls Cache ) { Object [ ] v = ( Object [ ] ) path To UR Ls Cache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ NUM ] ) ; } } String Tokenizer st = new String Tokenizer ( path ) ; URL [ ] urls = new URL [ st . count Tokens ( ) ] ; for ( int i = NUM ; st . has More Tokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . next Token ( ) ) ; } synchronized ( path To UR Ls Cache ) { path To UR Ls Cache . put ( path , new Object [ ] { urls , new Soft Reference ( path ) } ) ; } return urls ; }
public boolean check Uid Exists ( String uid ) throws Data Access Exception { return get Device Info ( uid ) != null ; }
public boolean check Uid Exists ( String uid ) throws Data Access Exception { return get Device Info ( uid ) != null ; }
public void write ( byte [ ] b ) throws IO Exception { out . write ( b ) ; }
public Entity Load Info create ( Entity entity ) { return create ( entity , null ) ; }
public static String make Tag Class Name ( String component Family , String renderer Type ) { if ( component Family == null ) { return null ; } String tag Class Name = component Family ; if ( renderer Type != null ) { if ( ! component Family . equals ( renderer Type ) ) { tag Class Name = tag Class Name + renderer Type ; } } return tag Class Name + STRING ; }
public synchronized void close ( ) throws IO Exception { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
public synchronized void close ( ) throws IO Exception { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
void unweave ( int id ) throws PT Agent Exception { while ( BOOL ) { Configured Advice [ ] old Woven = woven . get ( ) ; boolean found = BOOL ; for ( int i = NUM ; i < old Woven . length ; i ++ ) { Configured Advice e = old Woven [ i ] ; if ( e . id == id ) { Configured Advice [ ] new Woven = new Configured Advice [ old Woven . length - NUM ] ; System . arraycopy ( old Woven , NUM , new Woven , NUM , i ) ; System . arraycopy ( old Woven , i + NUM , new Woven , i , new Woven . length - i ) ; if ( woven . compare And Set ( old Woven , new Woven ) ) { return ; } else { found = BOOL ; } } } if ( ! found ) { throw new PT Agent Exception ( STRING , id , this . id ) ; } } }
public static boolean files Exist On Dest But Not Src ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Set < File Status > dest File Statuses = get File Statuses Recursive ( conf , dest , filter ) ; Map < String , Long > src File Sizes = null ; Map < String , Long > dest File Sizes = null ; try { src File Sizes = get Rel Path To Sizes ( src , src File Statuses ) ; dest File Sizes = get Rel Path To Sizes ( dest , dest File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STRING , e ) ; } for ( String file : dest File Sizes . key Set ( ) ) { if ( ! src File Sizes . contains Key ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return BOOL ; } } return BOOL ; }
public static boolean files Exist On Dest But Not Src ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Set < File Status > dest File Statuses = get File Statuses Recursive ( conf , dest , filter ) ; Map < String , Long > src File Sizes = null ; Map < String , Long > dest File Sizes = null ; try { src File Sizes = get Rel Path To Sizes ( src , src File Statuses ) ; dest File Sizes = get Rel Path To Sizes ( dest , dest File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STRING , e ) ; } for ( String file : dest File Sizes . key Set ( ) ) { if ( ! src File Sizes . contains Key ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return BOOL ; } } return BOOL ; }
public static boolean files Exist On Dest But Not Src ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Set < File Status > dest File Statuses = get File Statuses Recursive ( conf , dest , filter ) ; Map < String , Long > src File Sizes = null ; Map < String , Long > dest File Sizes = null ; try { src File Sizes = get Rel Path To Sizes ( src , src File Statuses ) ; dest File Sizes = get Rel Path To Sizes ( dest , dest File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STRING , e ) ; } for ( String file : dest File Sizes . key Set ( ) ) { if ( ! src File Sizes . contains Key ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return BOOL ; } } return BOOL ; }
public static boolean files Exist On Dest But Not Src ( Configuration conf , Path src , Path dest , Optional < Path Filter > filter ) throws IO Exception { Set < File Status > src File Statuses = get File Statuses Recursive ( conf , src , filter ) ; Set < File Status > dest File Statuses = get File Statuses Recursive ( conf , dest , filter ) ; Map < String , Long > src File Sizes = null ; Map < String , Long > dest File Sizes = null ; try { src File Sizes = get Rel Path To Sizes ( src , src File Statuses ) ; dest File Sizes = get Rel Path To Sizes ( dest , dest File Statuses ) ; } catch ( Argument Exception e ) { throw new IO Exception ( STRING , e ) ; } for ( String file : dest File Sizes . key Set ( ) ) { if ( ! src File Sizes . contains Key ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return BOOL ; } } return BOOL ; }
public static String join ( Char Sequence delimiter , Iterable tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = BOOL ; for ( Object token : tokens ) { if ( token == null || is Empty ( token . to String ( ) ) ) { continue ; } if ( first Time ) { first Time = BOOL ; } else { sb . append ( delimiter ) ; } sb . append ( token . to String ( ) ) ; } if ( first Time ) { return null ; } return sb . to String ( ) ; }
public static String join ( Char Sequence delimiter , Iterable tokens ) { String Builder sb = new String Builder ( ) ; boolean first Time = BOOL ; for ( Object token : tokens ) { if ( token == null || is Empty ( token . to String ( ) ) ) { continue ; } if ( first Time ) { first Time = BOOL ; } else { sb . append ( delimiter ) ; } sb . append ( token . to String ( ) ) ; } if ( first Time ) { return null ; } return sb . to String ( ) ; }
public Trust Manager Builder use Default ( ) throws No Such Algorithm Exception , Key Store Exception { Trust Manager Factory tmf = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( ( Key Store ) null ) ; add ( tmf . get Trust Managers ( ) ) ; return ( this ) ; }
public Trust Manager Builder use Default ( ) throws No Such Algorithm Exception , Key Store Exception { Trust Manager Factory tmf = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( ( Key Store ) null ) ; add ( tmf . get Trust Managers ( ) ) ; return ( this ) ; }
public Trust Manager Builder use Default ( ) throws No Such Algorithm Exception , Key Store Exception { Trust Manager Factory tmf = Trust Manager Factory . get Instance ( Trust Manager Factory . get Default Algorithm ( ) ) ; tmf . init ( ( Key Store ) null ) ; add ( tmf . get Trust Managers ( ) ) ; return ( this ) ; }
private void can Edit Check ( ) { can Edit = ! profile . is Common Profile ( ) ; if ( ! can Edit ) { add Button . set Enabled ( BOOL ) ; remove Button . set Enabled ( BOOL ) ; } }
public static boolean is Mime Type Image ( String mime Type ) { return mime Type != null && mime Type . starts With ( STRING ) ; }
public static Number div ( Character left , Number right ) { return Number Number Div . div ( Integer . value Of ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return Number Number Div . div ( Integer . value Of ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return Number Number Div . div ( Integer . value Of ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return Number Number Div . div ( Integer . value Of ( left ) , right ) ; }
private static String to String ( double [ ] [ ] m , Number Format nf , List < String > variables ) { String result ; if ( nf == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( variables == null ) { variables = new Array List < > ( ) ; for ( int i = NUM ; i < m [ NUM ] . length ; i ++ ) { variables . add ( STRING + ( i + NUM ) ) ; } } if ( m == null ) { result = null Message ( ) ; } else { Text Table text Table = new Text Table ( m . length + NUM , m [ NUM ] . length ) ; for ( int i = NUM ; i < variables . size ( ) ; i ++ ) { text Table . set Token ( NUM , i , variables . get ( i ) ) ; } for ( int i = NUM ; i < m . length ; i ++ ) { for ( int j = NUM ; j < m [ NUM ] . length ; j ++ ) { text Table . set Token ( i + NUM , j , m [ i ] [ j ] == NUM ? STRING : nf . format ( m [ i ] [ j ] ) ) ; } } result = STRING + text Table . to String ( ) ; } return result ; }
private static String to String ( double [ ] [ ] m , Number Format nf , List < String > variables ) { String result ; if ( nf == null ) { throw new Null Pointer Exception ( STRING ) ; } if ( variables == null ) { variables = new Array List < > ( ) ; for ( int i = NUM ; i < m [ NUM ] . length ; i ++ ) { variables . add ( STRING + ( i + NUM ) ) ; } } if ( m == null ) { result = null Message ( ) ; } else { Text Table text Table = new Text Table ( m . length + NUM , m [ NUM ] . length ) ; for ( int i = NUM ; i < variables . size ( ) ; i ++ ) { text Table . set Token ( NUM , i , variables . get ( i ) ) ; } for ( int i = NUM ; i < m . length ; i ++ ) { for ( int j = NUM ; j < m [ NUM ] . length ; j ++ ) { text Table . set Token ( i + NUM , j , m [ i ] [ j ] == NUM ? STRING : nf . format ( m [ i ] [ j ] ) ) ; } } result = STRING + text Table . to String ( ) ; } return result ; }
private static void s ua Col Sum Eq Ne ( Matrix Block in , Matrix Block out , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int agg 0 = sum Eq Ne ( NUM , bv , b Op ) ; out . allocate Dense Block ( BOOL ) ; Arrays . fill ( out . get Dense Block ( ) , NUM , out . get Num Columns ( ) , agg 0 ) ; if ( agg 0 != NUM ) out . set Non Zeros ( out . get Num Columns ( ) ) ; if ( in . is Empty Block ( BOOL ) ) return ; Sparse Block sblock = in . get Sparse Block ( ) ; for ( int j = NUM ; j < sblock . num Rows ( ) ; j ++ ) if ( ! sblock . is Empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum Eq Ne ( avals [ i ] , bv , b Op ) ; out . quick Set Value ( NUM , aix [ i ] , cnt ) ; } } }
private static void s ua Col Sum Eq Ne ( Matrix Block in , Matrix Block out , double [ ] bv , Binary Operator b Op ) throws DML Runtime Exception { int agg 0 = sum Eq Ne ( NUM , bv , b Op ) ; out . allocate Dense Block ( BOOL ) ; Arrays . fill ( out . get Dense Block ( ) , NUM , out . get Num Columns ( ) , agg 0 ) ; if ( agg 0 != NUM ) out . set Non Zeros ( out . get Num Columns ( ) ) ; if ( in . is Empty Block ( BOOL ) ) return ; Sparse Block sblock = in . get Sparse Block ( ) ; for ( int j = NUM ; j < sblock . num Rows ( ) ; j ++ ) if ( ! sblock . is Empty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sum Eq Ne ( avals [ i ] , bv , b Op ) ; out . quick Set Value ( NUM , aix [ i ] , cnt ) ; } } }
public Week ( Date time ) { this ( time , Time Zone . get Default ( ) , Locale . get Default ( ) ) ; }
public Week ( Date time ) { this ( time , Time Zone . get Default ( ) , Locale . get Default ( ) ) ; }
public Nondominated Population run ( ) { is Canceled . set ( BOOL ) ; return run Single Seed ( NUM , NUM , properties . get Int ( STRING , NUM ) ) ; }
public int decrypt Block ( byte [ ] in , int in Off , byte [ ] out , int out Off ) throws Data Length Exception , Illegal State Exception { if ( ( in Off + block Size ) > in . length ) { throw new Data Length Exception ( STRING ) ; } if ( ( out Off + block Size ) > out . length ) { throw new Data Length Exception ( STRING ) ; } cipher . process Block ( cfb V , NUM , cfb Out V , NUM ) ; System . arraycopy ( cfb V , block Size , cfb V , NUM , cfb V . length - block Size ) ; System . arraycopy ( in , in Off , cfb V , cfb V . length - block Size , block Size ) ; for ( int i = NUM ; i < block Size ; i ++ ) { out [ out Off + i ] = ( byte ) ( cfb Out V [ i ] ^ in [ in Off + i ] ) ; } return block Size ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public Bigdata Statement next ( ) throws Query Evaluation Exception { final Bigdata Statement stmt = src . next ( ) ; { final Bigdata Value s = stmt . get Subject ( ) ; if ( described Resources . contains ( s ) ) { record ( s , stmt ) ; } } { final Bigdata Value o = stmt . get Object ( ) ; if ( described Resources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
private void initialize Scrollbars ( ) { vertical Scrollbar . add Adjustment Listener ( listener ) ; add ( vertical Scrollbar , Border Layout . EAST ) ; horizontal Scrollbar . add Adjustment Listener ( listener ) ; add ( horizontal Scrollbar , Border Layout . SOUTH ) ; }
private void initialize Scrollbars ( ) { vertical Scrollbar . add Adjustment Listener ( listener ) ; add ( vertical Scrollbar , Border Layout . EAST ) ; horizontal Scrollbar . add Adjustment Listener ( listener ) ; add ( horizontal Scrollbar , Border Layout . SOUTH ) ; }
private byte [ ] fetch Guid ( ) { Prepared Statement stmt = null ; Result Set rows = null ; String sqltext = SELECT GUID ; byte [ ] data = null ; try { metrics . start Timing ( ) ; stmt = conn . prepare Statement ( sqltext ) ; rows = stmt . execute Query ( ) ; if ( rows . next ( ) ) { data = rows . get Bytes ( NUM ) ; } rows . close ( ) ; rows = null ; stmt . close ( ) ; stmt = null ; metrics . record GUIDS ( ) ; } catch ( SQL Exception e ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( e . to String ( ) ) ; } finally { for ( String message : SODA Utils . close Cursor ( stmt , rows ) ) { if ( Oracle Log . is Logging Enabled ( ) ) log . severe ( message ) ; } } return ( data ) ; }
public double exact Area ( ) { S2 Point v0 = get Vertex ( NUM ) ; S2 Point v1 = get Vertex ( NUM ) ; S2 Point v2 = get Vertex ( NUM ) ; S2 Point v3 = get Vertex ( NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public double exact Area ( ) { S2 Point v0 = get Vertex ( NUM ) ; S2 Point v1 = get Vertex ( NUM ) ; S2 Point v2 = get Vertex ( NUM ) ; S2 Point v3 = get Vertex ( NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public double exact Area ( ) { S2 Point v0 = get Vertex ( NUM ) ; S2 Point v1 = get Vertex ( NUM ) ; S2 Point v2 = get Vertex ( NUM ) ; S2 Point v3 = get Vertex ( NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public Map < String , Tuple < Coord , Tuple < Double , Double > > > parse Customer File ( String input File ) { Buffered Reader br = IO Utils . get Buffered Reader ( input File ) ; Map < String , Tuple < Coord , Tuple < Double , Double > > > customer Map = new Hash Map < String , Tuple < Coord , Tuple < Double , Double > > > ( ) ; try { br . read Line ( ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) { String [ ] array = line . split ( STRING ) ; String customer = array [ NUM ] ; double longi = Double . parse Double ( array [ NUM ] ) ; double lati = Double . parse Double ( array [ NUM ] ) ; double distance = Double . parse Double ( array [ NUM ] ) ; double earliest Start = Double . parse Double ( array [ NUM ] ) ; double latest End = Double . parse Double ( array [ NUM ] ) ; Coord coord = new Coord ( longi , lati ) ; Tuple < Double , Double > time Window = new Tuple < Double , Double > ( earliest Start , latest End ) ; Tuple < Coord , Tuple < Double , Double > > entry = new Tuple < Coord , Tuple < Double , Double > > ( coord , time Window ) ; customer Map . put ( customer , entry ) ; } } catch ( IO Exception e ) { log . error ( STRING ) ; } finally { try { br . close ( ) ; } catch ( IO Exception e ) { log . info ( STRING ) ; } } return customer Map ; }
public Map < String , Tuple < Coord , Tuple < Double , Double > > > parse Customer File ( String input File ) { Buffered Reader br = IO Utils . get Buffered Reader ( input File ) ; Map < String , Tuple < Coord , Tuple < Double , Double > > > customer Map = new Hash Map < String , Tuple < Coord , Tuple < Double , Double > > > ( ) ; try { br . read Line ( ) ; String line ; while ( ( line = br . read Line ( ) ) != null ) { String [ ] array = line . split ( STRING ) ; String customer = array [ NUM ] ; double longi = Double . parse Double ( array [ NUM ] ) ; double lati = Double . parse Double ( array [ NUM ] ) ; double distance = Double . parse Double ( array [ NUM ] ) ; double earliest Start = Double . parse Double ( array [ NUM ] ) ; double latest End = Double . parse Double ( array [ NUM ] ) ; Coord coord = new Coord ( longi , lati ) ; Tuple < Double , Double > time Window = new Tuple < Double , Double > ( earliest Start , latest End ) ; Tuple < Coord , Tuple < Double , Double > > entry = new Tuple < Coord , Tuple < Double , Double > > ( coord , time Window ) ; customer Map . put ( customer , entry ) ; } } catch ( IO Exception e ) { log . error ( STRING ) ; } finally { try { br . close ( ) ; } catch ( IO Exception e ) { log . info ( STRING ) ; } } return customer Map ; }
private void create Delay Matrix ( Topological Graph graph , boolean directed ) { m Total Node Num = graph . get Number Of Nodes ( ) ; m Delay Matrix = new float [ m Total Node Num ] [ m Total Node Num ] ; for ( int row = NUM ; row < m Total Node Num ; ++ row ) { for ( int col = NUM ; col < m Total Node Num ; ++ col ) { m Delay Matrix [ row ] [ col ] = Float . MAX VALUE ; } } Iterator < Topological Link > itr = graph . get Link Iterator ( ) ; Topological Link edge ; while ( itr . has Next ( ) ) { edge = itr . next ( ) ; m Delay Matrix [ edge . get Src Node ID ( ) ] [ edge . get Dest Node ID ( ) ] = edge . get Link Delay ( ) ; if ( ! directed ) { m Delay Matrix [ edge . get Dest Node ID ( ) ] [ edge . get Src Node ID ( ) ] = edge . get Link Delay ( ) ; } } }
public Lens Transformer ( Component component , Mutable Transformer delegate ) { super ( delegate ) ; set Component ( component ) ; component . add Component Listener ( new Component Listener Impl ( ) ) ; }
void read CNT ( ) throws IO Exception { int [ ] header = new int [ NUM ] ; while ( BOOL ) { String S = isr . read Line ( ) ; if ( S == null ) break ; parse String ( S , header , NUM ) ; int n = header [ NUM ] ; if ( n == - NUM ) break ; for ( int i = NUM ; i < n ; i ++ ) isr . read Line ( ) ; } }
private void inject Dynamically ( ) { injection Request Processor . inject Members ( ) ; stopwatch . reset And Log ( STRING ) ; initializer . inject All ( errors ) ; stopwatch . reset And Log ( STRING ) ; errors . throw Creation Exception If Errors Exist ( ) ; for ( Injector Shell shell : shells ) { load Eager Singletons ( shell . get Injector ( ) , stage , errors ) ; } stopwatch . reset And Log ( STRING ) ; errors . throw Creation Exception If Errors Exist ( ) ; }
private void inject Dynamically ( ) { injection Request Processor . inject Members ( ) ; stopwatch . reset And Log ( STRING ) ; initializer . inject All ( errors ) ; stopwatch . reset And Log ( STRING ) ; errors . throw Creation Exception If Errors Exist ( ) ; for ( Injector Shell shell : shells ) { load Eager Singletons ( shell . get Injector ( ) , stage , errors ) ; } stopwatch . reset And Log ( STRING ) ; errors . throw Creation Exception If Errors Exist ( ) ; }
public void send Message ( String mac , Message Item item , On Send Message Listener listener ) { send Message ( mac , item , BOOL , listener ) ; }
public void cleanup Test Images ( ) { try { File stress Images Directory = new File ( String . format ( STRING , Environment . get External Storage Directory ( ) , CAMERA STRESS IMAGES DIRECTORY ) ) ; File [ ] stress Images = stress Images Directory . list Files ( ) ; for ( File f : stress Images ) { f . delete ( ) ; } } catch ( Security Exception e ) { Log . e ( TAG , STRING + e . to String ( ) ) ; } }
protected boolean supports Transactions ( ) { return BOOL ; }
protected boolean supports Transactions ( ) { return BOOL ; }
private void remove Old Jar ( ) throws IO Exception { if ( output File . exists ( ) ) { if ( output File . is Directory ( ) ) { if ( ! File Utils . recursive Delete ( output File ) ) { throw new IO Exception ( STRING + output File . get Absolute Path ( ) + STRING ) ; } } else { if ( ! output File . delete ( ) ) { throw new IO Exception ( STRING + output File . get Absolute Path ( ) + STRING ) ; } } } }
public Result Set execute Query ( String sql ) throws Generic Data Source Exception , Generic Entity Exception { prepare Statement ( sql ) ; return execute Query ( ) ; }
private static synchronized boolean check Folder Permissions ( String Builder a String Builder , String a Directory ) { File directory = new File ( a Directory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . can Read ( ) ) { a String Builder . append ( STRING + directory + STRING + STRING ) ; return BOOL ; } if ( ! directory . can Write ( ) ) { a String Builder . append ( STRING + directory + STRING + STRING ) ; return BOOL ; } return BOOL ; }
public static Chat Message create Text Message ( Contact Id remote , String msg , long timestamp , long timestamp Sent ) { String msg Id = Id Generator . generate Message ID ( ) ; return new Chat Message ( msg Id , remote , msg , Mime Type . TEXT MESSAGE , timestamp , timestamp Sent , null ) ; }
public static String escape ( String url ) throws Unsupported Encoding Exception { return escape ( url , STRING ) ; }
public static String escape ( String url ) throws Unsupported Encoding Exception { return escape ( url , STRING ) ; }
synchronized void remove ( Notification Manager manager ) { int last = cache . size ( ) - NUM ; manager . cancel ( cache . get ( last ) ) ; cache . remove ( last ) ; }
protected String search For ( final String target , String start ) { return search For ( target , null , start ) ; }
protected String search For ( final String target , String start ) { return search For ( target , null , start ) ; }
public Builder until Date ( Date date ) { until Date = QUERY DATE . format ( date ) ; return this ; }
public void send Data Chunks ( String msg Id , String data , String mime , Type Msrp Chunk type Msrp Chunk ) throws Network Exception { byte [ ] bytes = data . get Bytes ( UTF 8 ) ; Byte Array Input Stream stream = new Byte Array Input Stream ( bytes ) ; m Msrp Mgr . send Chunks ( stream , msg Id , mime , bytes . length , type Msrp Chunk ) ; }
public void send Data Chunks ( String msg Id , String data , String mime , Type Msrp Chunk type Msrp Chunk ) throws Network Exception { byte [ ] bytes = data . get Bytes ( UTF 8 ) ; Byte Array Input Stream stream = new Byte Array Input Stream ( bytes ) ; m Msrp Mgr . send Chunks ( stream , msg Id , mime , bytes . length , type Msrp Chunk ) ; }
public static String normalize Column Value For Its Data Type ( String value , Carbon Dimension dimension ) { try { Object parsed Value = null ; switch ( dimension . get Data Type ( ) ) { case DECIMAL : return parse String To Big Decimal ( value , dimension ) ; case INT : case LONG : parsed Value = normalize Int And Long Values ( value , dimension . get Data Type ( ) ) ; break ; case DOUBLE : parsed Value = Double . parse Double ( value ) ; break ; default : return value ; } if ( null != parsed Value ) { return value ; } return null ; } catch ( Exception e ) { return null ; } }
public void check Hallof Fame ( ) { for ( Player p : players Leaving ) { int gms = p . games Played + p . career Games Played ; int all Conf = p . career All Conference + ( p . won All Conference ? NUM : NUM ) ; int all Amer = p . career All American + ( p . won All American ? NUM : NUM ) ; int poty = p . career Heismans + ( p . won Heisman ? NUM : NUM ) ; if ( gms / NUM + NUM * all Conf + NUM * all Amer + NUM * poty > NUM ) { Array List < String > career Stats = p . get Career Stats List ( ) ; String Builder sb = new String Builder ( ) ; sb . append ( p . get Pos Name Yr Ovr Str ( ) + STRING ) ; for ( String s : career Stats ) { sb . append ( s + STRING ) ; } hall Of Fame . add ( sb . to String ( ) ) ; } } }
public final boolean remove Child ( Text Edit child ) { if ( f Children == null ) return BOOL ; boolean result = f Children . remove ( child ) ; if ( result ) { child . internal Set Parent ( null ) ; if ( f Children . is Empty ( ) ) f Children = null ; } return result ; }
protected void check ( ) { checkmark . remove Attribute ( SVG Constants . SVG STYLE ATTRIBUTE ) ; checked = BOOL ; fire Switch Event ( new Change Event ( SVG Checkbox . this ) ) ; }
protected void check ( ) { checkmark . remove Attribute ( SVG Constants . SVG STYLE ATTRIBUTE ) ; checked = BOOL ; fire Switch Event ( new Change Event ( SVG Checkbox . this ) ) ; }
public static String generate Random String ( int length ) { String AB = STRING ; Random rnd = new Random ( ) ; String Builder sb = new String Builder ( length ) ; for ( int i = NUM ; i < length ; i ++ ) sb . append ( AB . char At ( rnd . next Int ( AB . length ( ) ) ) ) ; return sb . to String ( ) ; }
public final Mono < T > reduce ( Bi Function < T , T , T > reducer ) { Objects . require Non Null ( reducer , STRING ) ; return Mono . on Assembly ( new Parallel Reduce Full < > ( this , reducer ) ) ; }