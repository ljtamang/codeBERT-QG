@ Nullable public static String mergeXml ( @ NotNull RenderingContext context , String sourceXml , String targetXml , File targetFile ) { boolean ok ; String fileName = targetFile . getName ( ) ; String contents ; if ( fileName . equals ( SdkConstants . FN_ANDROID_MANIFEST_XML ) ) { Document currentDocument = XmlUtils . parseDocumentSilently ( targetXml , _BOOL ) ; assert currentDocument != null : targetXml + STRING ; Document fragment = XmlUtils . parseDocumentSilently ( sourceXml , _BOOL ) ; assert fragment != null : sourceXml + STRING ; contents = mergeManifest ( targetFile , targetXml , sourceXml ) ; ok = contents != null ; } else { String parentFolderName = targetFile . getParentFile ( ) . getName ( ) ; ResourceFolderType folderType = ResourceFolderType . getFolderType ( parentFolderName ) ; contents = mergeResourceFile ( context , targetXml , sourceXml , fileName , folderType ) ; ok = contents != null ; } if ( ! ok ) { contents = wrapWithMergeConflict ( targetXml , sourceXml ) ; context . getWarnings ( ) . add ( String . format ( STRING , targetFile . getName ( ) ) ) ; } return contents ; }
@ Nullable public static String mergeXml ( @ NotNull RenderingContext context , String sourceXml , String targetXml , File targetFile ) { boolean ok ; String fileName = targetFile . getName ( ) ; String contents ; if ( fileName . equals ( SdkConstants . FN_ANDROID_MANIFEST_XML ) ) { Document currentDocument = XmlUtils . parseDocumentSilently ( targetXml , _BOOL ) ; assert currentDocument != null : targetXml + STRING ; Document fragment = XmlUtils . parseDocumentSilently ( sourceXml , _BOOL ) ; assert fragment != null : sourceXml + STRING ; contents = mergeManifest ( targetFile , targetXml , sourceXml ) ; ok = contents != null ; } else { String parentFolderName = targetFile . getParentFile ( ) . getName ( ) ; ResourceFolderType folderType = ResourceFolderType . getFolderType ( parentFolderName ) ; contents = mergeResourceFile ( context , targetXml , sourceXml , fileName , folderType ) ; ok = contents != null ; } if ( ! ok ) { contents = wrapWithMergeConflict ( targetXml , sourceXml ) ; context . getWarnings ( ) . add ( String . format ( STRING , targetFile . getName ( ) ) ) ; } return contents ; }
public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; }
public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; }
public TemplatesHandler newTemplatesHandler ( ) throws TransformerConfigurationException { return new StylesheetHandler ( this ) ; }
public static synchronized void logStart ( ) { IProduct product = Platform . getProduct ( ) ; String aboutText = product . getProperty ( STRING ) ; String application = STRING ; if ( aboutText != null ) { String lines [ ] = aboutText . split ( STRING ) ; if ( lines != null && lines . length > _NUM ) { application = lines [ _NUM ] ; } } LOG . info ( STRING + application + STRING + DF . format ( System . currentTimeMillis ( ) ) ) ; }
public static synchronized void logStart ( ) { IProduct product = Platform . getProduct ( ) ; String aboutText = product . getProperty ( STRING ) ; String application = STRING ; if ( aboutText != null ) { String lines [ ] = aboutText . split ( STRING ) ; if ( lines != null && lines . length > _NUM ) { application = lines [ _NUM ] ; } } LOG . info ( STRING + application + STRING + DF . format ( System . currentTimeMillis ( ) ) ) ; }
public void sort ( ArrayList < Value [ ] > rows , int offset , int limit ) { int rowsSize = rows . size ( ) ; if ( rows . isEmpty ( ) || offset >= rowsSize || limit == _NUM ) { return ; } if ( offset < _NUM ) { offset = _NUM ; } if ( offset + limit > rowsSize ) { limit = rowsSize - offset ; } if ( limit == _NUM && offset == _NUM ) { rows . set ( _NUM , Collections . min ( rows , this ) ) ; return ; } Value [ ] [ ] arr = rows . toArray ( new Value [ rowsSize ] [ ] ) ; Utils . sortTopN ( arr , offset , limit , this ) ; for ( int i = _NUM , end = Math . min ( offset + limit , rowsSize ) ; i < end ; i ++ ) { rows . set ( i , arr [ i ] ) ; } }
protected Object parse ( String text , Type type , Type arrayElementType , int flags ) { if ( ! inCDATA ( flags ) ) { if ( ! ignoreBinding ( flags ) ) { BindingExpression result = parseBindingExpression ( text ) ; if ( result != null ) { return result ; } else { text = cleanupBindingEscapes ( text ) ; } } if ( ! ignoreAtFunction ( flags ) ) { String atFunctionName = getAtFunctionName ( text ) ; if ( atFunctionName != null ) { return parseAtFunction ( atFunctionName , text , type , arrayElementType , flags ) ; } else { text = cleanupAtFunctionEscapes ( text ) ; flags = flags | TextParser . FlagIgnoreAtFunctionEscape ; } } } if ( isRichTextContent ( flags ) ) { String parsedString = parseString ( text , flags ) ; if ( type == typeTable . arrayType ) { return array ( Collections . singleton ( ( Object ) parsedString ) , arrayElementType ) ; } else { return parsedString ; } } else { return parseValue ( text , type , arrayElementType , flags ) ; } }
protected Object parse ( String text , Type type , Type arrayElementType , int flags ) { if ( ! inCDATA ( flags ) ) { if ( ! ignoreBinding ( flags ) ) { BindingExpression result = parseBindingExpression ( text ) ; if ( result != null ) { return result ; } else { text = cleanupBindingEscapes ( text ) ; } } if ( ! ignoreAtFunction ( flags ) ) { String atFunctionName = getAtFunctionName ( text ) ; if ( atFunctionName != null ) { return parseAtFunction ( atFunctionName , text , type , arrayElementType , flags ) ; } else { text = cleanupAtFunctionEscapes ( text ) ; flags = flags | TextParser . FlagIgnoreAtFunctionEscape ; } } } if ( isRichTextContent ( flags ) ) { String parsedString = parseString ( text , flags ) ; if ( type == typeTable . arrayType ) { return array ( Collections . singleton ( ( Object ) parsedString ) , arrayElementType ) ; } else { return parsedString ; } } else { return parseValue ( text , type , arrayElementType , flags ) ; } }
protected Object parse ( String text , Type type , Type arrayElementType , int flags ) { if ( ! inCDATA ( flags ) ) { if ( ! ignoreBinding ( flags ) ) { BindingExpression result = parseBindingExpression ( text ) ; if ( result != null ) { return result ; } else { text = cleanupBindingEscapes ( text ) ; } } if ( ! ignoreAtFunction ( flags ) ) { String atFunctionName = getAtFunctionName ( text ) ; if ( atFunctionName != null ) { return parseAtFunction ( atFunctionName , text , type , arrayElementType , flags ) ; } else { text = cleanupAtFunctionEscapes ( text ) ; flags = flags | TextParser . FlagIgnoreAtFunctionEscape ; } } } if ( isRichTextContent ( flags ) ) { String parsedString = parseString ( text , flags ) ; if ( type == typeTable . arrayType ) { return array ( Collections . singleton ( ( Object ) parsedString ) , arrayElementType ) ; } else { return parsedString ; } } else { return parseValue ( text , type , arrayElementType , flags ) ; } }
public boolean sphereInFrustum ( Vector3 center , float radius ) { for ( int i = _NUM ; i < _NUM ; i ++ ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return _BOOL ; return _BOOL ; }
public boolean sphereInFrustum ( Vector3 center , float radius ) { for ( int i = _NUM ; i < _NUM ; i ++ ) if ( ( planes [ i ] . normal . x * center . x + planes [ i ] . normal . y * center . y + planes [ i ] . normal . z * center . z ) < ( - radius - planes [ i ] . d ) ) return _BOOL ; return _BOOL ; }
public void waitIfExclusiveModeEnabled ( ) { if ( database . getLobSession ( ) == this ) { return ; } while ( _BOOL ) { Session exclusive = database . getExclusiveSession ( ) ; if ( exclusive == null || exclusive == this ) { break ; } if ( Thread . holdsLock ( exclusive ) ) { break ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { } } }
public void waitIfExclusiveModeEnabled ( ) { if ( database . getLobSession ( ) == this ) { return ; } while ( _BOOL ) { Session exclusive = database . getExclusiveSession ( ) ; if ( exclusive == null || exclusive == this ) { break ; } if ( Thread . holdsLock ( exclusive ) ) { break ; } try { Thread . sleep ( _NUM ) ; } catch ( InterruptedException e ) { } } }
public String reportError ( XMLLocator location , String domain , String key , Object [ ] arguments , short severity , Exception exception ) throws XNIException { MessageFormatter messageFormatter = getMessageFormatter ( domain ) ; String message ; if ( messageFormatter != null ) { message = messageFormatter . formatMessage ( fLocale , key , arguments ) ; } else { StringBuffer str = new StringBuffer ( ) ; str . append ( domain ) ; str . append ( STRING ) ; str . append ( key ) ; int argCount = arguments != null ? arguments . length : _NUM ; if ( argCount > _NUM ) { str . append ( STRING ) ; for ( int i = _NUM ; i < argCount ; i ++ ) { str . append ( arguments [ i ] ) ; if ( i < argCount - _NUM ) { str . append ( STRING ) ; } } } message = str . toString ( ) ; } XMLParseException parseException = ( exception != null ) ? new XMLParseException ( location , message , exception ) : new XMLParseException ( location , message ) ; XMLErrorHandler errorHandler = fErrorHandler ; if ( errorHandler == null ) { if ( fDefaultErrorHandler == null ) { fDefaultErrorHandler = new DefaultErrorHandler ( ) ; } errorHandler = fDefaultErrorHandler ; } switch ( severity ) { case SEVERITY_WARNING : { errorHandler . warning ( domain , key , parseException ) ; break ; } case SEVERITY_ERROR : { errorHandler . error ( domain , key , parseException ) ; break ; } case SEVERITY_FATAL_ERROR : { errorHandler . fatalError ( domain , key , parseException ) ; if ( ! fContinueAfterFatalError ) { throw parseException ; } break ; } } return message ; }
private int parseContentType ( final byte [ ] b , final int off ) throws ParseException { contentTypeVal_ = PrimitivesParser . parseByte ( b , off ) ; if ( ContentType . deserialize ( contentTypeVal_ ) == null ) { throw new BadCiphertextException ( STRING ) ; } return _NUM ; }
private int parseContentType ( final byte [ ] b , final int off ) throws ParseException { contentTypeVal_ = PrimitivesParser . parseByte ( b , off ) ; if ( ContentType . deserialize ( contentTypeVal_ ) == null ) { throw new BadCiphertextException ( STRING ) ; } return _NUM ; }
private int parseContentType ( final byte [ ] b , final int off ) throws ParseException { contentTypeVal_ = PrimitivesParser . parseByte ( b , off ) ; if ( ContentType . deserialize ( contentTypeVal_ ) == null ) { throw new BadCiphertextException ( STRING ) ; } return _NUM ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ _NUM ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = _NUM ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ _NUM ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = _NUM ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ _NUM ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = _NUM ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ _NUM ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = _NUM ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
private static URL [ ] pathToURLs ( String path ) throws MalformedURLException { if ( path == null ) { return null ; } synchronized ( pathToURLsCache ) { Object [ ] v = ( Object [ ] ) pathToURLsCache . get ( path ) ; if ( v != null ) { return ( ( URL [ ] ) v [ _NUM ] ) ; } } StringTokenizer st = new StringTokenizer ( path ) ; URL [ ] urls = new URL [ st . countTokens ( ) ] ; for ( int i = _NUM ; st . hasMoreTokens ( ) ; i ++ ) { urls [ i ] = new URL ( st . nextToken ( ) ) ; } synchronized ( pathToURLsCache ) { pathToURLsCache . put ( path , new Object [ ] { urls , new SoftReference ( path ) } ) ; } return urls ; }
public boolean checkUidExists ( String uid ) throws DataAccessException { return getDeviceInfo ( uid ) != null ; }
public boolean checkUidExists ( String uid ) throws DataAccessException { return getDeviceInfo ( uid ) != null ; }
public void write ( byte [ ] b ) throws IOException { out . write ( b ) ; }
public EntityLoadInfo create ( Entity entity ) { return create ( entity , null ) ; }
public static String makeTagClassName ( String componentFamily , String rendererType ) { if ( componentFamily == null ) { return null ; } String tagClassName = componentFamily ; if ( rendererType != null ) { if ( ! componentFamily . equals ( rendererType ) ) { tagClassName = tagClassName + rendererType ; } } return tagClassName + STRING ; }
public synchronized void close ( ) throws IOException { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
public synchronized void close ( ) throws IOException { if ( in == null ) return ; in . close ( ) ; in = null ; buf = null ; }
void unweave ( int id ) throws PTAgentException { while ( _BOOL ) { ConfiguredAdvice [ ] oldWoven = woven . get ( ) ; boolean found = _BOOL ; for ( int i = _NUM ; i < oldWoven . length ; i ++ ) { ConfiguredAdvice e = oldWoven [ i ] ; if ( e . id == id ) { ConfiguredAdvice [ ] newWoven = new ConfiguredAdvice [ oldWoven . length - _NUM ] ; System . arraycopy ( oldWoven , _NUM , newWoven , _NUM , i ) ; System . arraycopy ( oldWoven , i + _NUM , newWoven , i , newWoven . length - i ) ; if ( woven . compareAndSet ( oldWoven , newWoven ) ) { return ; } else { found = _BOOL ; } } } if ( ! found ) { throw new PTAgentException ( STRING , id , this . id ) ; } } }
public static boolean filesExistOnDestButNotSrc ( Configuration conf , Path src , Path dest , Optional < PathFilter > filter ) throws IOException { Set < FileStatus > srcFileStatuses = getFileStatusesRecursive ( conf , src , filter ) ; Set < FileStatus > destFileStatuses = getFileStatusesRecursive ( conf , dest , filter ) ; Map < String , Long > srcFileSizes = null ; Map < String , Long > destFileSizes = null ; try { srcFileSizes = getRelPathToSizes ( src , srcFileStatuses ) ; destFileSizes = getRelPathToSizes ( dest , destFileStatuses ) ; } catch ( ArgumentException e ) { throw new IOException ( STRING , e ) ; } for ( String file : destFileSizes . keySet ( ) ) { if ( ! srcFileSizes . containsKey ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return _BOOL ; } } return _BOOL ; }
public static boolean filesExistOnDestButNotSrc ( Configuration conf , Path src , Path dest , Optional < PathFilter > filter ) throws IOException { Set < FileStatus > srcFileStatuses = getFileStatusesRecursive ( conf , src , filter ) ; Set < FileStatus > destFileStatuses = getFileStatusesRecursive ( conf , dest , filter ) ; Map < String , Long > srcFileSizes = null ; Map < String , Long > destFileSizes = null ; try { srcFileSizes = getRelPathToSizes ( src , srcFileStatuses ) ; destFileSizes = getRelPathToSizes ( dest , destFileStatuses ) ; } catch ( ArgumentException e ) { throw new IOException ( STRING , e ) ; } for ( String file : destFileSizes . keySet ( ) ) { if ( ! srcFileSizes . containsKey ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return _BOOL ; } } return _BOOL ; }
public static boolean filesExistOnDestButNotSrc ( Configuration conf , Path src , Path dest , Optional < PathFilter > filter ) throws IOException { Set < FileStatus > srcFileStatuses = getFileStatusesRecursive ( conf , src , filter ) ; Set < FileStatus > destFileStatuses = getFileStatusesRecursive ( conf , dest , filter ) ; Map < String , Long > srcFileSizes = null ; Map < String , Long > destFileSizes = null ; try { srcFileSizes = getRelPathToSizes ( src , srcFileStatuses ) ; destFileSizes = getRelPathToSizes ( dest , destFileStatuses ) ; } catch ( ArgumentException e ) { throw new IOException ( STRING , e ) ; } for ( String file : destFileSizes . keySet ( ) ) { if ( ! srcFileSizes . containsKey ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return _BOOL ; } } return _BOOL ; }
public static boolean filesExistOnDestButNotSrc ( Configuration conf , Path src , Path dest , Optional < PathFilter > filter ) throws IOException { Set < FileStatus > srcFileStatuses = getFileStatusesRecursive ( conf , src , filter ) ; Set < FileStatus > destFileStatuses = getFileStatusesRecursive ( conf , dest , filter ) ; Map < String , Long > srcFileSizes = null ; Map < String , Long > destFileSizes = null ; try { srcFileSizes = getRelPathToSizes ( src , srcFileStatuses ) ; destFileSizes = getRelPathToSizes ( dest , destFileStatuses ) ; } catch ( ArgumentException e ) { throw new IOException ( STRING , e ) ; } for ( String file : destFileSizes . keySet ( ) ) { if ( ! srcFileSizes . containsKey ( file ) ) { LOG . warn ( String . format ( STRING , file , dest , src ) ) ; return _BOOL ; } } return _BOOL ; }
public static String join ( CharSequence delimiter , Iterable tokens ) { StringBuilder sb = new StringBuilder ( ) ; boolean firstTime = _BOOL ; for ( Object token : tokens ) { if ( token == null || isEmpty ( token . toString ( ) ) ) { continue ; } if ( firstTime ) { firstTime = _BOOL ; } else { sb . append ( delimiter ) ; } sb . append ( token . toString ( ) ) ; } if ( firstTime ) { return null ; } return sb . toString ( ) ; }
public static String join ( CharSequence delimiter , Iterable tokens ) { StringBuilder sb = new StringBuilder ( ) ; boolean firstTime = _BOOL ; for ( Object token : tokens ) { if ( token == null || isEmpty ( token . toString ( ) ) ) { continue ; } if ( firstTime ) { firstTime = _BOOL ; } else { sb . append ( delimiter ) ; } sb . append ( token . toString ( ) ) ; } if ( firstTime ) { return null ; } return sb . toString ( ) ; }
public TrustManagerBuilder useDefault ( ) throws NoSuchAlgorithmException , KeyStoreException { TrustManagerFactory tmf = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; tmf . init ( ( KeyStore ) null ) ; add ( tmf . getTrustManagers ( ) ) ; return ( this ) ; }
public TrustManagerBuilder useDefault ( ) throws NoSuchAlgorithmException , KeyStoreException { TrustManagerFactory tmf = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; tmf . init ( ( KeyStore ) null ) ; add ( tmf . getTrustManagers ( ) ) ; return ( this ) ; }
public TrustManagerBuilder useDefault ( ) throws NoSuchAlgorithmException , KeyStoreException { TrustManagerFactory tmf = TrustManagerFactory . getInstance ( TrustManagerFactory . getDefaultAlgorithm ( ) ) ; tmf . init ( ( KeyStore ) null ) ; add ( tmf . getTrustManagers ( ) ) ; return ( this ) ; }
private void canEditCheck ( ) { canEdit = ! profile . isCommonProfile ( ) ; if ( ! canEdit ) { addButton . setEnabled ( _BOOL ) ; removeButton . setEnabled ( _BOOL ) ; } }
public static boolean isMimeTypeImage ( String mimeType ) { return mimeType != null && mimeType . startsWith ( STRING ) ; }
public static Number div ( Character left , Number right ) { return NumberNumberDiv . div ( Integer . valueOf ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return NumberNumberDiv . div ( Integer . valueOf ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return NumberNumberDiv . div ( Integer . valueOf ( left ) , right ) ; }
public static Number div ( Character left , Number right ) { return NumberNumberDiv . div ( Integer . valueOf ( left ) , right ) ; }
private static String toString ( double [ ] [ ] m , NumberFormat nf , List < String > variables ) { String result ; if ( nf == null ) { throw new NullPointerException ( STRING ) ; } if ( variables == null ) { variables = new ArrayList < > ( ) ; for ( int i = _NUM ; i < m [ _NUM ] . length ; i ++ ) { variables . add ( STRING + ( i + _NUM ) ) ; } } if ( m == null ) { result = nullMessage ( ) ; } else { TextTable textTable = new TextTable ( m . length + _NUM , m [ _NUM ] . length ) ; for ( int i = _NUM ; i < variables . size ( ) ; i ++ ) { textTable . setToken ( _NUM , i , variables . get ( i ) ) ; } for ( int i = _NUM ; i < m . length ; i ++ ) { for ( int j = _NUM ; j < m [ _NUM ] . length ; j ++ ) { textTable . setToken ( i + _NUM , j , m [ i ] [ j ] == _NUM ? STRING : nf . format ( m [ i ] [ j ] ) ) ; } } result = STRING + textTable . toString ( ) ; } return result ; }
private static String toString ( double [ ] [ ] m , NumberFormat nf , List < String > variables ) { String result ; if ( nf == null ) { throw new NullPointerException ( STRING ) ; } if ( variables == null ) { variables = new ArrayList < > ( ) ; for ( int i = _NUM ; i < m [ _NUM ] . length ; i ++ ) { variables . add ( STRING + ( i + _NUM ) ) ; } } if ( m == null ) { result = nullMessage ( ) ; } else { TextTable textTable = new TextTable ( m . length + _NUM , m [ _NUM ] . length ) ; for ( int i = _NUM ; i < variables . size ( ) ; i ++ ) { textTable . setToken ( _NUM , i , variables . get ( i ) ) ; } for ( int i = _NUM ; i < m . length ; i ++ ) { for ( int j = _NUM ; j < m [ _NUM ] . length ; j ++ ) { textTable . setToken ( i + _NUM , j , m [ i ] [ j ] == _NUM ? STRING : nf . format ( m [ i ] [ j ] ) ) ; } } result = STRING + textTable . toString ( ) ; } return result ; }
private static void s_uaColSumEqNe ( MatrixBlock in , MatrixBlock out , double [ ] bv , BinaryOperator bOp ) throws DMLRuntimeException { int agg0 = sumEqNe ( _NUM , bv , bOp ) ; out . allocateDenseBlock ( _BOOL ) ; Arrays . fill ( out . getDenseBlock ( ) , _NUM , out . getNumColumns ( ) , agg0 ) ; if ( agg0 != _NUM ) out . setNonZeros ( out . getNumColumns ( ) ) ; if ( in . isEmptyBlock ( _BOOL ) ) return ; SparseBlock sblock = in . getSparseBlock ( ) ; for ( int j = _NUM ; j < sblock . numRows ( ) ; j ++ ) if ( ! sblock . isEmpty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sumEqNe ( avals [ i ] , bv , bOp ) ; out . quickSetValue ( _NUM , aix [ i ] , cnt ) ; } } }
private static void s_uaColSumEqNe ( MatrixBlock in , MatrixBlock out , double [ ] bv , BinaryOperator bOp ) throws DMLRuntimeException { int agg0 = sumEqNe ( _NUM , bv , bOp ) ; out . allocateDenseBlock ( _BOOL ) ; Arrays . fill ( out . getDenseBlock ( ) , _NUM , out . getNumColumns ( ) , agg0 ) ; if ( agg0 != _NUM ) out . setNonZeros ( out . getNumColumns ( ) ) ; if ( in . isEmptyBlock ( _BOOL ) ) return ; SparseBlock sblock = in . getSparseBlock ( ) ; for ( int j = _NUM ; j < sblock . numRows ( ) ; j ++ ) if ( ! sblock . isEmpty ( j ) ) { int apos = sblock . pos ( j ) ; int alen = sblock . size ( j ) ; int [ ] aix = sblock . indexes ( j ) ; double [ ] avals = sblock . values ( j ) ; for ( int i = apos ; i < apos + alen ; i ++ ) { int cnt = sumEqNe ( avals [ i ] , bv , bOp ) ; out . quickSetValue ( _NUM , aix [ i ] , cnt ) ; } } }
public Week ( Date time ) { this ( time , TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; }
public Week ( Date time ) { this ( time , TimeZone . getDefault ( ) , Locale . getDefault ( ) ) ; }
public NondominatedPopulation run ( ) { isCanceled . set ( _BOOL ) ; return runSingleSeed ( _NUM , _NUM , properties . getInt ( STRING , _NUM ) ) ; }
public int decryptBlock ( byte [ ] in , int inOff , byte [ ] out , int outOff ) throws DataLengthException , IllegalStateException { if ( ( inOff + blockSize ) > in . length ) { throw new DataLengthException ( STRING ) ; } if ( ( outOff + blockSize ) > out . length ) { throw new DataLengthException ( STRING ) ; } cipher . processBlock ( cfbV , _NUM , cfbOutV , _NUM ) ; System . arraycopy ( cfbV , blockSize , cfbV , _NUM , cfbV . length - blockSize ) ; System . arraycopy ( in , inOff , cfbV , cfbV . length - blockSize , blockSize ) ; for ( int i = _NUM ; i < blockSize ; i ++ ) { out [ outOff + i ] = ( byte ) ( cfbOutV [ i ] ^ in [ inOff + i ] ) ; } return blockSize ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
@ Override public BigdataStatement next ( ) throws QueryEvaluationException { final BigdataStatement stmt = src . next ( ) ; { final BigdataValue s = stmt . getSubject ( ) ; if ( describedResources . contains ( s ) ) { record ( s , stmt ) ; } } { final BigdataValue o = stmt . getObject ( ) ; if ( describedResources . contains ( o ) ) { record ( o , stmt ) ; } } return stmt ; }
private void initializeScrollbars ( ) { verticalScrollbar . addAdjustmentListener ( listener ) ; add ( verticalScrollbar , BorderLayout . EAST ) ; horizontalScrollbar . addAdjustmentListener ( listener ) ; add ( horizontalScrollbar , BorderLayout . SOUTH ) ; }
private void initializeScrollbars ( ) { verticalScrollbar . addAdjustmentListener ( listener ) ; add ( verticalScrollbar , BorderLayout . EAST ) ; horizontalScrollbar . addAdjustmentListener ( listener ) ; add ( horizontalScrollbar , BorderLayout . SOUTH ) ; }
private byte [ ] fetchGuid ( ) { PreparedStatement stmt = null ; ResultSet rows = null ; String sqltext = SELECT_GUID ; byte [ ] data = null ; try { metrics . startTiming ( ) ; stmt = conn . prepareStatement ( sqltext ) ; rows = stmt . executeQuery ( ) ; if ( rows . next ( ) ) { data = rows . getBytes ( _NUM ) ; } rows . close ( ) ; rows = null ; stmt . close ( ) ; stmt = null ; metrics . recordGUIDS ( ) ; } catch ( SQLException e ) { if ( OracleLog . isLoggingEnabled ( ) ) log . severe ( e . toString ( ) ) ; } finally { for ( String message : SODAUtils . closeCursor ( stmt , rows ) ) { if ( OracleLog . isLoggingEnabled ( ) ) log . severe ( message ) ; } } return ( data ) ; }
public double exactArea ( ) { S2Point v0 = getVertex ( _NUM ) ; S2Point v1 = getVertex ( _NUM ) ; S2Point v2 = getVertex ( _NUM ) ; S2Point v3 = getVertex ( _NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public double exactArea ( ) { S2Point v0 = getVertex ( _NUM ) ; S2Point v1 = getVertex ( _NUM ) ; S2Point v2 = getVertex ( _NUM ) ; S2Point v3 = getVertex ( _NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public double exactArea ( ) { S2Point v0 = getVertex ( _NUM ) ; S2Point v1 = getVertex ( _NUM ) ; S2Point v2 = getVertex ( _NUM ) ; S2Point v3 = getVertex ( _NUM ) ; return S2 . area ( v0 , v1 , v2 ) + S2 . area ( v0 , v2 , v3 ) ; }
public Map < String , Tuple < Coord , Tuple < Double , Double > > > parseCustomerFile ( String inputFile ) { BufferedReader br = IOUtils . getBufferedReader ( inputFile ) ; Map < String , Tuple < Coord , Tuple < Double , Double > > > customerMap = new HashMap < String , Tuple < Coord , Tuple < Double , Double > > > ( ) ; try { br . readLine ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] array = line . split ( STRING ) ; String customer = array [ _NUM ] ; double longi = Double . parseDouble ( array [ _NUM ] ) ; double lati = Double . parseDouble ( array [ _NUM ] ) ; double distance = Double . parseDouble ( array [ _NUM ] ) ; double earliestStart = Double . parseDouble ( array [ _NUM ] ) ; double latestEnd = Double . parseDouble ( array [ _NUM ] ) ; Coord coord = new Coord ( longi , lati ) ; Tuple < Double , Double > timeWindow = new Tuple < Double , Double > ( earliestStart , latestEnd ) ; Tuple < Coord , Tuple < Double , Double > > entry = new Tuple < Coord , Tuple < Double , Double > > ( coord , timeWindow ) ; customerMap . put ( customer , entry ) ; } } catch ( IOException e ) { log . error ( STRING ) ; } finally { try { br . close ( ) ; } catch ( IOException e ) { log . info ( STRING ) ; } } return customerMap ; }
public Map < String , Tuple < Coord , Tuple < Double , Double > > > parseCustomerFile ( String inputFile ) { BufferedReader br = IOUtils . getBufferedReader ( inputFile ) ; Map < String , Tuple < Coord , Tuple < Double , Double > > > customerMap = new HashMap < String , Tuple < Coord , Tuple < Double , Double > > > ( ) ; try { br . readLine ( ) ; String line ; while ( ( line = br . readLine ( ) ) != null ) { String [ ] array = line . split ( STRING ) ; String customer = array [ _NUM ] ; double longi = Double . parseDouble ( array [ _NUM ] ) ; double lati = Double . parseDouble ( array [ _NUM ] ) ; double distance = Double . parseDouble ( array [ _NUM ] ) ; double earliestStart = Double . parseDouble ( array [ _NUM ] ) ; double latestEnd = Double . parseDouble ( array [ _NUM ] ) ; Coord coord = new Coord ( longi , lati ) ; Tuple < Double , Double > timeWindow = new Tuple < Double , Double > ( earliestStart , latestEnd ) ; Tuple < Coord , Tuple < Double , Double > > entry = new Tuple < Coord , Tuple < Double , Double > > ( coord , timeWindow ) ; customerMap . put ( customer , entry ) ; } } catch ( IOException e ) { log . error ( STRING ) ; } finally { try { br . close ( ) ; } catch ( IOException e ) { log . info ( STRING ) ; } } return customerMap ; }
private void createDelayMatrix ( TopologicalGraph graph , boolean directed ) { mTotalNodeNum = graph . getNumberOfNodes ( ) ; mDelayMatrix = new float [ mTotalNodeNum ] [ mTotalNodeNum ] ; for ( int row = _NUM ; row < mTotalNodeNum ; ++ row ) { for ( int col = _NUM ; col < mTotalNodeNum ; ++ col ) { mDelayMatrix [ row ] [ col ] = Float . MAX_VALUE ; } } Iterator < TopologicalLink > itr = graph . getLinkIterator ( ) ; TopologicalLink edge ; while ( itr . hasNext ( ) ) { edge = itr . next ( ) ; mDelayMatrix [ edge . getSrcNodeID ( ) ] [ edge . getDestNodeID ( ) ] = edge . getLinkDelay ( ) ; if ( ! directed ) { mDelayMatrix [ edge . getDestNodeID ( ) ] [ edge . getSrcNodeID ( ) ] = edge . getLinkDelay ( ) ; } } }
public LensTransformer ( Component component , MutableTransformer delegate ) { super ( delegate ) ; setComponent ( component ) ; component . addComponentListener ( new ComponentListenerImpl ( ) ) ; }
void readCNT ( ) throws IOException { int [ ] header = new int [ _NUM ] ; while ( _BOOL ) { String S = isr . readLine ( ) ; if ( S == null ) break ; parseString ( S , header , _NUM ) ; int n = header [ _NUM ] ; if ( n == - _NUM ) break ; for ( int i = _NUM ; i < n ; i ++ ) isr . readLine ( ) ; } }
private void injectDynamically ( ) { injectionRequestProcessor . injectMembers ( ) ; stopwatch . resetAndLog ( STRING ) ; initializer . injectAll ( errors ) ; stopwatch . resetAndLog ( STRING ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; for ( InjectorShell shell : shells ) { loadEagerSingletons ( shell . getInjector ( ) , stage , errors ) ; } stopwatch . resetAndLog ( STRING ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; }
private void injectDynamically ( ) { injectionRequestProcessor . injectMembers ( ) ; stopwatch . resetAndLog ( STRING ) ; initializer . injectAll ( errors ) ; stopwatch . resetAndLog ( STRING ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; for ( InjectorShell shell : shells ) { loadEagerSingletons ( shell . getInjector ( ) , stage , errors ) ; } stopwatch . resetAndLog ( STRING ) ; errors . throwCreationExceptionIfErrorsExist ( ) ; }
public void sendMessage ( String mac , MessageItem item , OnSendMessageListener listener ) { sendMessage ( mac , item , _BOOL , listener ) ; }
public void cleanupTestImages ( ) { try { File stressImagesDirectory = new File ( String . format ( STRING , Environment . getExternalStorageDirectory ( ) , CAMERA_STRESS_IMAGES_DIRECTORY ) ) ; File [ ] stressImages = stressImagesDirectory . listFiles ( ) ; for ( File f : stressImages ) { f . delete ( ) ; } } catch ( SecurityException e ) { Log . e ( TAG , STRING + e . toString ( ) ) ; } }
protected boolean supportsTransactions ( ) { return _BOOL ; }
protected boolean supportsTransactions ( ) { return _BOOL ; }
private void removeOldJar ( ) throws IOException { if ( outputFile . exists ( ) ) { if ( outputFile . isDirectory ( ) ) { if ( ! FileUtils . recursiveDelete ( outputFile ) ) { throw new IOException ( STRING + outputFile . getAbsolutePath ( ) + STRING ) ; } } else { if ( ! outputFile . delete ( ) ) { throw new IOException ( STRING + outputFile . getAbsolutePath ( ) + STRING ) ; } } } }
public ResultSet executeQuery ( String sql ) throws GenericDataSourceException , GenericEntityException { prepareStatement ( sql ) ; return executeQuery ( ) ; }
private static synchronized boolean checkFolderPermissions ( StringBuilder aStringBuilder , String aDirectory ) { File directory = new File ( aDirectory ) ; if ( ! directory . exists ( ) ) { directory . mkdirs ( ) ; } if ( ! directory . canRead ( ) ) { aStringBuilder . append ( STRING + directory + STRING + STRING ) ; return _BOOL ; } if ( ! directory . canWrite ( ) ) { aStringBuilder . append ( STRING + directory + STRING + STRING ) ; return _BOOL ; } return _BOOL ; }
public static ChatMessage createTextMessage ( ContactId remote , String msg , long timestamp , long timestampSent ) { String msgId = IdGenerator . generateMessageID ( ) ; return new ChatMessage ( msgId , remote , msg , MimeType . TEXT_MESSAGE , timestamp , timestampSent , null ) ; }
public static String escape ( String url ) throws UnsupportedEncodingException { return escape ( url , STRING ) ; }
public static String escape ( String url ) throws UnsupportedEncodingException { return escape ( url , STRING ) ; }
synchronized void remove ( NotificationManager manager ) { int last = cache . size ( ) - _NUM ; manager . cancel ( cache . get ( last ) ) ; cache . remove ( last ) ; }
protected String searchFor ( final String target , String start ) { return searchFor ( target , null , start ) ; }
protected String searchFor ( final String target , String start ) { return searchFor ( target , null , start ) ; }
public Builder untilDate ( Date date ) { untilDate = QUERY_DATE . format ( date ) ; return this ; }
public void sendDataChunks ( String msgId , String data , String mime , TypeMsrpChunk typeMsrpChunk ) throws NetworkException { byte [ ] bytes = data . getBytes ( UTF8 ) ; ByteArrayInputStream stream = new ByteArrayInputStream ( bytes ) ; mMsrpMgr . sendChunks ( stream , msgId , mime , bytes . length , typeMsrpChunk ) ; }
public void sendDataChunks ( String msgId , String data , String mime , TypeMsrpChunk typeMsrpChunk ) throws NetworkException { byte [ ] bytes = data . getBytes ( UTF8 ) ; ByteArrayInputStream stream = new ByteArrayInputStream ( bytes ) ; mMsrpMgr . sendChunks ( stream , msgId , mime , bytes . length , typeMsrpChunk ) ; }
public static String normalizeColumnValueForItsDataType ( String value , CarbonDimension dimension ) { try { Object parsedValue = null ; switch ( dimension . getDataType ( ) ) { case DECIMAL : return parseStringToBigDecimal ( value , dimension ) ; case INT : case LONG : parsedValue = normalizeIntAndLongValues ( value , dimension . getDataType ( ) ) ; break ; case DOUBLE : parsedValue = Double . parseDouble ( value ) ; break ; default : return value ; } if ( null != parsedValue ) { return value ; } return null ; } catch ( Exception e ) { return null ; } }
public void checkHallofFame ( ) { for ( Player p : playersLeaving ) { int gms = p . gamesPlayed + p . careerGamesPlayed ; int allConf = p . careerAllConference + ( p . wonAllConference ? _NUM : _NUM ) ; int allAmer = p . careerAllAmerican + ( p . wonAllAmerican ? _NUM : _NUM ) ; int poty = p . careerHeismans + ( p . wonHeisman ? _NUM : _NUM ) ; if ( gms / _NUM + _NUM * allConf + _NUM * allAmer + _NUM * poty > _NUM ) { ArrayList < String > careerStats = p . getCareerStatsList ( ) ; StringBuilder sb = new StringBuilder ( ) ; sb . append ( p . getPosNameYrOvr_Str ( ) + STRING ) ; for ( String s : careerStats ) { sb . append ( s + STRING ) ; } hallOfFame . add ( sb . toString ( ) ) ; } } }
public final boolean removeChild ( TextEdit child ) { if ( fChildren == null ) return _BOOL ; boolean result = fChildren . remove ( child ) ; if ( result ) { child . internalSetParent ( null ) ; if ( fChildren . isEmpty ( ) ) fChildren = null ; } return result ; }
protected void check ( ) { checkmark . removeAttribute ( SVGConstants . SVG_STYLE_ATTRIBUTE ) ; checked = _BOOL ; fireSwitchEvent ( new ChangeEvent ( SVGCheckbox . this ) ) ; }
protected void check ( ) { checkmark . removeAttribute ( SVGConstants . SVG_STYLE_ATTRIBUTE ) ; checked = _BOOL ; fireSwitchEvent ( new ChangeEvent ( SVGCheckbox . this ) ) ; }
public static String generateRandomString ( int length ) { String AB = STRING ; Random rnd = new Random ( ) ; StringBuilder sb = new StringBuilder ( length ) ; for ( int i = _NUM ; i < length ; i ++ ) sb . append ( AB . charAt ( rnd . nextInt ( AB . length ( ) ) ) ) ; return sb . toString ( ) ; }
public final Mono < T > reduce ( BiFunction < T , T , T > reducer ) { Objects . requireNonNull ( reducer , STRING ) ; return Mono . onAssembly ( new ParallelReduceFull < > ( this , reducer ) ) ; }